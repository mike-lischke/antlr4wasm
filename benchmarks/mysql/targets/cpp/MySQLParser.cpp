/*
 * Copyright (c) 2020, 2023, Oracle and/or its affiliates.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2.0,
 * as published by the Free Software Foundation.
 *
 * This program is also distributed with certain software (including
 * but not limited to OpenSSL) that is licensed under separate terms, as
 * designated in a particular file or component or in included license
 * documentation. The authors of MySQL hereby grant you an additional
 * permission to link the program and your derivative works with the
 * separately licensed software that they have included with MySQL.
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
 * the GNU General Public License, version 2.0, for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */

/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable no-useless-escape, no-lone-blocks */

/* cspell: disable */

// Generated from MySQLParser.g4 by ANTLR 4.13.0

#include "MySQLParserListener.h"
#include "MySQLParserVisitor.h"

#include "MySQLParser.h"

using namespace antlrcpp;
using namespace parsers;

using namespace antlr4;

namespace {

  struct MySQLParserStaticData final {
    MySQLParserStaticData(std::vector<std::string> ruleNames, std::vector<std::string> literalNames,
                          std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)),
        literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {
    }

    MySQLParserStaticData(const MySQLParserStaticData &) = delete;
    MySQLParserStaticData(MySQLParserStaticData &&) = delete;
    MySQLParserStaticData &operator=(const MySQLParserStaticData &) = delete;
    MySQLParserStaticData &operator=(MySQLParserStaticData &&) = delete;

    std::vector<antlr4::dfa::DFA> decisionToDFA;
    antlr4::atn::PredictionContextCache sharedContextCache;
    const std::vector<std::string> ruleNames;
    const std::vector<std::string> literalNames;
    const std::vector<std::string> symbolicNames;
    const antlr4::dfa::Vocabulary vocabulary;
    antlr4::atn::SerializedATNView serializedATN;
    std::unique_ptr<antlr4::atn::ATN> atn;
  };

  ::antlr4::internal::OnceFlag mysqlparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  static thread_local
#endif
    MySQLParserStaticData *mysqlparserParserStaticData = nullptr;

  void mysqlparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
    if (mysqlparserParserStaticData != nullptr) {
      return;
    }
#else
    assert(mysqlparserParserStaticData == nullptr);
#endif
    auto staticData = std::make_unique<MySQLParserStaticData>(
      std::vector<std::string>{ "query",
                                "simpleStatement",
                                "alterStatement",
                                "alterDatabase",
                                "alterDatabaseOption",
                                "alterEvent",
                                "alterLogfileGroup",
                                "alterLogfileGroupOptions",
                                "alterLogfileGroupOption",
                                "alterServer",
                                "alterTable",
                                "alterTableActions",
                                "alterCommandList",
                                "alterCommandsModifierList",
                                "standaloneAlterCommands",
                                "alterPartition",
                                "alterList",
                                "alterCommandsModifier",
                                "alterListItem",
                                "place",
                                "restrict",
                                "alterOrderList",
                                "alterAlgorithmOption",
                                "alterLockOption",
                                "indexLockAndAlgorithm",
                                "withValidation",
                                "removePartitioning",
                                "allOrPartitionNameList",
                                "alterTablespace",
                                "alterUndoTablespace",
                                "undoTableSpaceOptions",
                                "undoTableSpaceOption",
                                "alterTablespaceOptions",
                                "alterTablespaceOption",
                                "changeTablespaceOption",
                                "alterView",
                                "viewTail",
                                "viewQueryBlock",
                                "viewCheckOption",
                                "alterInstanceStatement",
                                "createStatement",
                                "createDatabase",
                                "createDatabaseOption",
                                "createTable",
                                "tableElementList",
                                "tableElement",
                                "duplicateAsQe",
                                "asCreateQueryExpression",
                                "queryExpressionOrParens",
                                "queryExpressionWithOptLockingClauses",
                                "createRoutine",
                                "createProcedure",
                                "createFunction",
                                "createUdf",
                                "routineCreateOption",
                                "routineAlterOptions",
                                "routineOption",
                                "createIndex",
                                "indexNameAndType",
                                "createIndexTarget",
                                "createLogfileGroup",
                                "logfileGroupOptions",
                                "logfileGroupOption",
                                "createServer",
                                "serverOptions",
                                "serverOption",
                                "createTablespace",
                                "createUndoTablespace",
                                "tsDataFileName",
                                "tsDataFile",
                                "tablespaceOptions",
                                "tablespaceOption",
                                "tsOptionInitialSize",
                                "tsOptionUndoRedoBufferSize",
                                "tsOptionAutoextendSize",
                                "tsOptionMaxSize",
                                "tsOptionExtentSize",
                                "tsOptionNodegroup",
                                "tsOptionEngine",
                                "tsOptionWait",
                                "tsOptionComment",
                                "tsOptionFileblockSize",
                                "tsOptionEncryption",
                                "tsOptionEngineAttribute",
                                "createView",
                                "viewReplaceOrAlgorithm",
                                "viewAlgorithm",
                                "viewSuid",
                                "createTrigger",
                                "triggerFollowsPrecedesClause",
                                "createEvent",
                                "createRole",
                                "createSpatialReference",
                                "srsAttribute",
                                "dropStatement",
                                "dropDatabase",
                                "dropEvent",
                                "dropFunction",
                                "dropProcedure",
                                "dropIndex",
                                "dropLogfileGroup",
                                "dropLogfileGroupOption",
                                "dropServer",
                                "dropTable",
                                "dropTableSpace",
                                "dropTrigger",
                                "dropView",
                                "dropRole",
                                "dropSpatialReference",
                                "dropUndoTablespace",
                                "renameTableStatement",
                                "renamePair",
                                "truncateTableStatement",
                                "importStatement",
                                "callStatement",
                                "deleteStatement",
                                "partitionDelete",
                                "deleteStatementOption",
                                "doStatement",
                                "handlerStatement",
                                "handlerReadOrScan",
                                "insertStatement",
                                "insertLockOption",
                                "insertFromConstructor",
                                "fields",
                                "insertValues",
                                "insertQueryExpression",
                                "valueList",
                                "values",
                                "valuesReference",
                                "insertUpdateList",
                                "loadStatement",
                                "dataOrXml",
                                "xmlRowsIdentifiedBy",
                                "loadDataFileTail",
                                "loadDataFileTargetList",
                                "fieldOrVariableList",
                                "replaceStatement",
                                "selectStatement",
                                "selectStatementWithInto",
                                "queryExpression",
                                "queryExpressionBody",
                                "queryExpressionParens",
                                "queryPrimary",
                                "querySpecification",
                                "subquery",
                                "querySpecOption",
                                "limitClause",
                                "simpleLimitClause",
                                "limitOptions",
                                "limitOption",
                                "intoClause",
                                "procedureAnalyseClause",
                                "havingClause",
                                "windowClause",
                                "windowDefinition",
                                "windowSpec",
                                "windowSpecDetails",
                                "windowFrameClause",
                                "windowFrameUnits",
                                "windowFrameExtent",
                                "windowFrameStart",
                                "windowFrameBetween",
                                "windowFrameBound",
                                "windowFrameExclusion",
                                "withClause",
                                "commonTableExpression",
                                "groupByClause",
                                "olapOption",
                                "orderClause",
                                "direction",
                                "fromClause",
                                "tableReferenceList",
                                "tableValueConstructor",
                                "explicitTable",
                                "rowValueExplicit",
                                "selectOption",
                                "lockingClauseList",
                                "lockingClause",
                                "lockStrengh",
                                "lockedRowAction",
                                "selectItemList",
                                "selectItem",
                                "selectAlias",
                                "whereClause",
                                "tableReference",
                                "escapedTableReference",
                                "joinedTable",
                                "naturalJoinType",
                                "innerJoinType",
                                "outerJoinType",
                                "tableFactor",
                                "singleTable",
                                "singleTableParens",
                                "derivedTable",
                                "tableReferenceListParens",
                                "tableFunction",
                                "columnsClause",
                                "jtColumn",
                                "onEmptyOrError",
                                "onEmptyOrErrorJsonTable",
                                "onEmpty",
                                "onError",
                                "jsonOnResponse",
                                "unionOption",
                                "tableAlias",
                                "indexHintList",
                                "indexHint",
                                "indexHintType",
                                "keyOrIndex",
                                "constraintKeyType",
                                "indexHintClause",
                                "indexList",
                                "indexListElement",
                                "updateStatement",
                                "transactionOrLockingStatement",
                                "transactionStatement",
                                "beginWork",
                                "startTransactionOptionList",
                                "savepointStatement",
                                "lockStatement",
                                "lockItem",
                                "lockOption",
                                "xaStatement",
                                "xaConvert",
                                "xid",
                                "replicationStatement",
                                "resetOption",
                                "sourceResetOptions",
                                "replicationLoad",
                                "changeReplicationSource",
                                "changeSource",
                                "sourceDefinitions",
                                "sourceDefinition",
                                "changeReplicationSourceAutoPosition",
                                "changeReplicationSourceHost",
                                "changeReplicationSourceBind",
                                "changeReplicationSourceUser",
                                "changeReplicationSourcePassword",
                                "changeReplicationSourcePort",
                                "changeReplicationSourceConnectRetry",
                                "changeReplicationSourceRetryCount",
                                "changeReplicationSourceDelay",
                                "changeReplicationSourceSSL",
                                "changeReplicationSourceSSLCA",
                                "changeReplicationSourceSSLCApath",
                                "changeReplicationSourceSSLCipher",
                                "changeReplicationSourceSSLCLR",
                                "changeReplicationSourceSSLCLRpath",
                                "changeReplicationSourceSSLKey",
                                "changeReplicationSourceSSLVerifyServerCert",
                                "changeReplicationSourceTLSVersion",
                                "changeReplicationSourceTLSCiphersuites",
                                "changeReplicationSourceSSLCert",
                                "changeReplicationSourcePublicKey",
                                "changeReplicationSourceGetSourcePublicKey",
                                "changeReplicationSourceHeartbeatPeriod",
                                "changeReplicationSourceCompressionAlgorithm",
                                "changeReplicationSourceZstdCompressionLevel",
                                "privilegeCheckDef",
                                "tablePrimaryKeyCheckDef",
                                "assignGtidsToAnonymousTransactionsDefinition",
                                "sourceTlsCiphersuitesDef",
                                "sourceFileDef",
                                "sourceLogFile",
                                "sourceLogPos",
                                "serverIdList",
                                "changeReplication",
                                "filterDefinition",
                                "filterDbList",
                                "filterTableList",
                                "filterStringList",
                                "filterWildDbTableString",
                                "filterDbPairList",
                                "startReplicaStatement",
                                "stopReplicaStatement",
                                "replicaUntil",
                                "userOption",
                                "passwordOption",
                                "defaultAuthOption",
                                "pluginDirOption",
                                "replicaThreadOptions",
                                "replicaThreadOption",
                                "groupReplication",
                                "groupReplicationStartOptions",
                                "groupReplicationStartOption",
                                "groupReplicationUser",
                                "groupReplicationPassword",
                                "groupReplicationPluginAuth",
                                "replica",
                                "preparedStatement",
                                "executeStatement",
                                "executeVarList",
                                "cloneStatement",
                                "dataDirSSL",
                                "ssl",
                                "accountManagementStatement",
                                "alterUserStatement",
                                "alterUserList",
                                "alterUser",
                                "oldAlterUser",
                                "userFunction",
                                "createUserStatement",
                                "createUserTail",
                                "userAttributes",
                                "defaultRoleClause",
                                "requireClause",
                                "connectOptions",
                                "accountLockPasswordExpireOptions",
                                "userAttribute",
                                "dropUserStatement",
                                "grantStatement",
                                "grantTargetList",
                                "grantOptions",
                                "exceptRoleList",
                                "withRoles",
                                "grantAs",
                                "versionedRequireClause",
                                "renameUserStatement",
                                "revokeStatement",
                                "aclType",
                                "roleOrPrivilegesList",
                                "roleOrPrivilege",
                                "grantIdentifier",
                                "requireList",
                                "requireListElement",
                                "grantOption",
                                "setRoleStatement",
                                "roleList",
                                "role",
                                "tableAdministrationStatement",
                                "histogram",
                                "checkOption",
                                "repairType",
                                "installUninstallStatement",
                                "setStatement",
                                "startOptionValueList",
                                "transactionCharacteristics",
                                "transactionAccessMode",
                                "isolationLevel",
                                "optionValueListContinued",
                                "optionValueNoOptionType",
                                "optionValue",
                                "setSystemVariable",
                                "startOptionValueListFollowingOptionType",
                                "optionValueFollowingOptionType",
                                "setExprOrDefault",
                                "showDatabasesStatement",
                                "showTablesStatement",
                                "showTriggersStatement",
                                "showEventsStatement",
                                "showTableStatusStatement",
                                "showOpenTablesStatement",
                                "showPluginsStatement",
                                "showEngineLogsStatement",
                                "showEngineMutexStatement",
                                "showEngineStatusStatement",
                                "showColumnsStatement",
                                "showBinaryLogsStatement",
                                "showReplicasStatement",
                                "showBinlogEventsStatement",
                                "showRelaylogEventsStatement",
                                "showKeysStatement",
                                "showEnginesStatement",
                                "showCountWarningsStatement",
                                "showCountErrorsStatement",
                                "showWarningsStatement",
                                "showErrorsStatement",
                                "showProfilesStatement",
                                "showProfileStatement",
                                "showStatusStatement",
                                "showProcessListStatement",
                                "showVariablesStatement",
                                "showCharacterSetStatement",
                                "showCollationStatement",
                                "showPrivilegesStatement",
                                "showGrantsStatement",
                                "showCreateDatabaseStatement",
                                "showCreateTableStatement",
                                "showCreateViewStatement",
                                "showMasterStatusStatement",
                                "showReplicaStatusStatement",
                                "showCreateProcedureStatement",
                                "showCreateFunctionStatement",
                                "showCreateTriggerStatement",
                                "showCreateProcedureStatusStatement",
                                "showCreateFunctionStatusStatement",
                                "showCreateProcedureCodeStatement",
                                "showCreateFunctionCodeStatement",
                                "showCreateEventStatement",
                                "showCreateUserStatement",
                                "showCommandType",
                                "engineOrAll",
                                "fromOrIn",
                                "inDb",
                                "profileDefinitions",
                                "profileDefinition",
                                "otherAdministrativeStatement",
                                "keyCacheListOrParts",
                                "keyCacheList",
                                "assignToKeycache",
                                "assignToKeycachePartition",
                                "cacheKeyList",
                                "keyUsageElement",
                                "keyUsageList",
                                "flushOption",
                                "logType",
                                "flushTables",
                                "flushTablesOptions",
                                "preloadTail",
                                "preloadList",
                                "preloadKeys",
                                "adminPartition",
                                "resourceGroupManagement",
                                "createResourceGroup",
                                "resourceGroupVcpuList",
                                "vcpuNumOrRange",
                                "resourceGroupPriority",
                                "resourceGroupEnableDisable",
                                "alterResourceGroup",
                                "setResourceGroup",
                                "threadIdList",
                                "dropResourceGroup",
                                "utilityStatement",
                                "describeStatement",
                                "explainStatement",
                                "explainableStatement",
                                "helpCommand",
                                "useCommand",
                                "restartServer",
                                "expr",
                                "boolPri",
                                "compOp",
                                "predicate",
                                "predicateOperations",
                                "bitExpr",
                                "simpleExpr",
                                "arrayCast",
                                "jsonOperator",
                                "sumExpr",
                                "groupingOperation",
                                "windowFunctionCall",
                                "windowingClause",
                                "leadLagInfo",
                                "stableInteger",
                                "paramOrVar",
                                "nullTreatment",
                                "jsonFunction",
                                "inSumExpr",
                                "identListArg",
                                "identList",
                                "fulltextOptions",
                                "runtimeFunctionCall",
                                "returningType",
                                "geometryFunction",
                                "timeFunctionParameters",
                                "fractionalPrecision",
                                "weightStringLevels",
                                "weightStringLevelListItem",
                                "dateTimeTtype",
                                "trimFunction",
                                "substringFunction",
                                "functionCall",
                                "udfExprList",
                                "udfExpr",
                                "userVariable",
                                "inExpressionUserVariableAssignment",
                                "rvalueSystemOrUserVariable",
                                "lvalueVariable",
                                "rvalueSystemVariable",
                                "whenExpression",
                                "thenExpression",
                                "elseExpression",
                                "castType",
                                "exprList",
                                "charset",
                                "notRule",
                                "not2Rule",
                                "interval",
                                "intervalTimeStamp",
                                "exprListWithParentheses",
                                "exprWithParentheses",
                                "simpleExprWithParentheses",
                                "orderList",
                                "orderExpression",
                                "groupList",
                                "groupingExpression",
                                "channel",
                                "compoundStatement",
                                "returnStatement",
                                "ifStatement",
                                "ifBody",
                                "thenStatement",
                                "compoundStatementList",
                                "caseStatement",
                                "elseStatement",
                                "labeledBlock",
                                "unlabeledBlock",
                                "label",
                                "beginEndBlock",
                                "labeledControl",
                                "unlabeledControl",
                                "loopBlock",
                                "whileDoBlock",
                                "repeatUntilBlock",
                                "spDeclarations",
                                "spDeclaration",
                                "variableDeclaration",
                                "conditionDeclaration",
                                "spCondition",
                                "sqlstate",
                                "handlerDeclaration",
                                "handlerCondition",
                                "cursorDeclaration",
                                "iterateStatement",
                                "leaveStatement",
                                "getDiagnosticsStatement",
                                "signalAllowedExpr",
                                "statementInformationItem",
                                "conditionInformationItem",
                                "signalInformationItemName",
                                "signalStatement",
                                "resignalStatement",
                                "signalInformationItem",
                                "cursorOpen",
                                "cursorClose",
                                "cursorFetch",
                                "schedule",
                                "columnDefinition",
                                "checkOrReferences",
                                "checkConstraint",
                                "constraintEnforcement",
                                "tableConstraintDef",
                                "constraintName",
                                "fieldDefinition",
                                "columnAttribute",
                                "columnFormat",
                                "storageMedia",
                                "now",
                                "nowOrSignedLiteral",
                                "gcolAttribute",
                                "references",
                                "deleteOption",
                                "keyList",
                                "keyPart",
                                "keyListWithExpression",
                                "keyPartOrExpression",
                                "indexType",
                                "indexOption",
                                "commonIndexOption",
                                "visibility",
                                "indexTypeClause",
                                "fulltextIndexOption",
                                "spatialIndexOption",
                                "dataTypeDefinition",
                                "dataType",
                                "nchar",
                                "realType",
                                "fieldLength",
                                "fieldOptions",
                                "charsetWithOptBinary",
                                "ascii",
                                "unicode",
                                "wsNumCodepoints",
                                "typeDatetimePrecision",
                                "functionDatetimePrecision",
                                "charsetName",
                                "collationName",
                                "createTableOptions",
                                "createTableOptionsEtc",
                                "createPartitioningEtc",
                                "createTableOptionsSpaceSeparated",
                                "createTableOption",
                                "ternaryOption",
                                "defaultCollation",
                                "defaultEncryption",
                                "defaultCharset",
                                "partitionClause",
                                "partitionTypeDef",
                                "subPartitions",
                                "partitionKeyAlgorithm",
                                "partitionDefinitions",
                                "partitionDefinition",
                                "partitionValuesIn",
                                "partitionOption",
                                "subpartitionDefinition",
                                "partitionValueItemListParen",
                                "partitionValueItem",
                                "definerClause",
                                "ifExists",
                                "ifNotExists",
                                "ignoreUnknownUser",
                                "procedureParameter",
                                "functionParameter",
                                "collate",
                                "typeWithOptCollate",
                                "schemaIdentifierPair",
                                "viewRefList",
                                "updateList",
                                "updateElement",
                                "charsetClause",
                                "fieldsClause",
                                "fieldTerm",
                                "linesClause",
                                "lineTerm",
                                "userList",
                                "createUserList",
                                "createUser",
                                "createUserWithMfa",
                                "identification",
                                "identifiedByPassword",
                                "identifiedByRandomPassword",
                                "identifiedWithPlugin",
                                "identifiedWithPluginAsAuth",
                                "identifiedWithPluginByPassword",
                                "identifiedWithPluginByRandomPassword",
                                "initialAuth",
                                "retainCurrentPassword",
                                "discardOldPassword",
                                "userRegistration",
                                "factor",
                                "replacePassword",
                                "userIdentifierOrText",
                                "user",
                                "likeClause",
                                "likeOrWhere",
                                "onlineOption",
                                "noWriteToBinLog",
                                "usePartition",
                                "fieldIdentifier",
                                "columnName",
                                "columnInternalRef",
                                "columnInternalRefList",
                                "columnRef",
                                "insertIdentifier",
                                "indexName",
                                "indexRef",
                                "tableWild",
                                "schemaName",
                                "schemaRef",
                                "procedureName",
                                "procedureRef",
                                "functionName",
                                "functionRef",
                                "triggerName",
                                "triggerRef",
                                "viewName",
                                "viewRef",
                                "tablespaceName",
                                "tablespaceRef",
                                "logfileGroupName",
                                "logfileGroupRef",
                                "eventName",
                                "eventRef",
                                "udfName",
                                "serverName",
                                "serverRef",
                                "engineRef",
                                "tableName",
                                "filterTableRef",
                                "tableRefWithWildcard",
                                "tableRef",
                                "tableRefList",
                                "tableAliasRefList",
                                "parameterName",
                                "labelIdentifier",
                                "labelRef",
                                "roleIdentifier",
                                "pluginRef",
                                "componentRef",
                                "resourceGroupRef",
                                "windowName",
                                "pureIdentifier",
                                "identifier",
                                "identifierList",
                                "identifierListWithParentheses",
                                "qualifiedIdentifier",
                                "simpleIdentifier",
                                "dotIdentifier",
                                "ulong_number",
                                "real_ulong_number",
                                "ulonglong_number",
                                "real_ulonglong_number",
                                "signedLiteral",
                                "signedLiteralOrNull",
                                "literal",
                                "literalOrNull",
                                "nullAsLiteral",
                                "stringList",
                                "textStringLiteral",
                                "textString",
                                "textStringHash",
                                "textLiteral",
                                "textStringNoLinebreak",
                                "textStringLiteralList",
                                "numLiteral",
                                "boolLiteral",
                                "nullLiteral",
                                "int64Literal",
                                "temporalLiteral",
                                "floatOptions",
                                "standardFloatOptions",
                                "precision",
                                "textOrIdentifier",
                                "lValueIdentifier",
                                "roleIdentifierOrText",
                                "sizeNumber",
                                "parentheses",
                                "equal",
                                "optionType",
                                "rvalueSystemVariableType",
                                "setVarIdentType",
                                "jsonAttribute",
                                "identifierKeyword",
                                "identifierKeywordsAmbiguous1RolesAndLabels",
                                "identifierKeywordsAmbiguous2Labels",
                                "labelKeyword",
                                "identifierKeywordsAmbiguous3Roles",
                                "identifierKeywordsUnambiguous",
                                "roleKeyword",
                                "lValueKeyword",
                                "identifierKeywordsAmbiguous4SystemVariables",
                                "roleOrIdentifierKeyword",
                                "roleOrLabelKeyword" },
      std::vector<std::string>{
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "'='", "':='", "'<=>'", "'>='",
        "'>'",  "'<='", "'<'",   "'!='", "'+'", "'-'",  "'*'",   "'/'",       "'%'", "'!'", "'~'",  "'<<'",  "'>>'",
        "'&&'", "'&'",  "'^'",   "'||'", "'|'", "'.'",  "','",   "';'",       "':'", "'('", "')'",  "'{'",   "'}'",
        "'_'",  "'->'", "'->>'", "'@'",  "",    "'@@'", "'\\N'", "'\\u003F'", "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "",      "",     "",    "",     "",      "",          "",    "",    "",     "",      "",
        "",     "",     "'<>'" },
      std::vector<std::string>{ "",
                                "ACCESSIBLE_SYMBOL",
                                "ACCOUNT_SYMBOL",
                                "ACTION_SYMBOL",
                                "ADD_SYMBOL",
                                "ADDDATE_SYMBOL",
                                "AFTER_SYMBOL",
                                "AGAINST_SYMBOL",
                                "AGGREGATE_SYMBOL",
                                "ALGORITHM_SYMBOL",
                                "ALL_SYMBOL",
                                "ALTER_SYMBOL",
                                "ALWAYS_SYMBOL",
                                "ANALYSE_SYMBOL",
                                "ANALYZE_SYMBOL",
                                "AND_SYMBOL",
                                "ANY_SYMBOL",
                                "AS_SYMBOL",
                                "ASC_SYMBOL",
                                "ASCII_SYMBOL",
                                "ASENSITIVE_SYMBOL",
                                "AT_SYMBOL",
                                "AUTHORS_SYMBOL",
                                "AUTOEXTEND_SIZE_SYMBOL",
                                "AUTO_INCREMENT_SYMBOL",
                                "AVG_ROW_LENGTH_SYMBOL",
                                "AVG_SYMBOL",
                                "BACKUP_SYMBOL",
                                "BEFORE_SYMBOL",
                                "BEGIN_SYMBOL",
                                "BETWEEN_SYMBOL",
                                "BIGINT_SYMBOL",
                                "BINARY_SYMBOL",
                                "BINLOG_SYMBOL",
                                "BIN_NUM_SYMBOL",
                                "BIT_AND_SYMBOL",
                                "BIT_OR_SYMBOL",
                                "BIT_SYMBOL",
                                "BIT_XOR_SYMBOL",
                                "BLOB_SYMBOL",
                                "BLOCK_SYMBOL",
                                "BOOLEAN_SYMBOL",
                                "BOOL_SYMBOL",
                                "BOTH_SYMBOL",
                                "BTREE_SYMBOL",
                                "BY_SYMBOL",
                                "BYTE_SYMBOL",
                                "CACHE_SYMBOL",
                                "CALL_SYMBOL",
                                "CASCADE_SYMBOL",
                                "CASCADED_SYMBOL",
                                "CASE_SYMBOL",
                                "CAST_SYMBOL",
                                "CATALOG_NAME_SYMBOL",
                                "CHAIN_SYMBOL",
                                "CHANGE_SYMBOL",
                                "CHANGED_SYMBOL",
                                "CHANNEL_SYMBOL",
                                "CHARSET_SYMBOL",
                                "CHARACTER_SYMBOL",
                                "CHAR_SYMBOL",
                                "CHECKSUM_SYMBOL",
                                "CHECK_SYMBOL",
                                "CIPHER_SYMBOL",
                                "CLASS_ORIGIN_SYMBOL",
                                "CLIENT_SYMBOL",
                                "CLOSE_SYMBOL",
                                "COALESCE_SYMBOL",
                                "CODE_SYMBOL",
                                "COLLATE_SYMBOL",
                                "COLLATION_SYMBOL",
                                "COLUMNS_SYMBOL",
                                "COLUMN_SYMBOL",
                                "COLUMN_NAME_SYMBOL",
                                "COLUMN_FORMAT_SYMBOL",
                                "COMMENT_SYMBOL",
                                "COMMITTED_SYMBOL",
                                "COMMIT_SYMBOL",
                                "COMPACT_SYMBOL",
                                "COMPLETION_SYMBOL",
                                "COMPRESSED_SYMBOL",
                                "COMPRESSION_SYMBOL",
                                "CONCURRENT_SYMBOL",
                                "CONDITION_SYMBOL",
                                "CONNECTION_SYMBOL",
                                "CONSISTENT_SYMBOL",
                                "CONSTRAINT_SYMBOL",
                                "CONSTRAINT_CATALOG_SYMBOL",
                                "CONSTRAINT_NAME_SYMBOL",
                                "CONSTRAINT_SCHEMA_SYMBOL",
                                "CONTAINS_SYMBOL",
                                "CONTEXT_SYMBOL",
                                "CONTINUE_SYMBOL",
                                "CONTRIBUTORS_SYMBOL",
                                "CONVERT_SYMBOL",
                                "COUNT_SYMBOL",
                                "CPU_SYMBOL",
                                "CREATE_SYMBOL",
                                "CROSS_SYMBOL",
                                "CUBE_SYMBOL",
                                "CURDATE_SYMBOL",
                                "CURRENT_SYMBOL",
                                "CURRENT_DATE_SYMBOL",
                                "CURRENT_TIME_SYMBOL",
                                "CURRENT_TIMESTAMP_SYMBOL",
                                "CURRENT_USER_SYMBOL",
                                "CURSOR_SYMBOL",
                                "CURSOR_NAME_SYMBOL",
                                "CURTIME_SYMBOL",
                                "DATABASE_SYMBOL",
                                "DATABASES_SYMBOL",
                                "DATAFILE_SYMBOL",
                                "DATA_SYMBOL",
                                "DATETIME_SYMBOL",
                                "DATE_ADD_SYMBOL",
                                "DATE_SUB_SYMBOL",
                                "DATE_SYMBOL",
                                "DAYOFMONTH_SYMBOL",
                                "DAY_HOUR_SYMBOL",
                                "DAY_MICROSECOND_SYMBOL",
                                "DAY_MINUTE_SYMBOL",
                                "DAY_SECOND_SYMBOL",
                                "DAY_SYMBOL",
                                "DEALLOCATE_SYMBOL",
                                "DEC_SYMBOL",
                                "DECIMAL_NUM_SYMBOL",
                                "DECIMAL_SYMBOL",
                                "DECLARE_SYMBOL",
                                "DEFAULT_SYMBOL",
                                "DEFAULT_AUTH_SYMBOL",
                                "DEFINER_SYMBOL",
                                "DELAYED_SYMBOL",
                                "DELAY_KEY_WRITE_SYMBOL",
                                "DELETE_SYMBOL",
                                "DESC_SYMBOL",
                                "DESCRIBE_SYMBOL",
                                "DES_KEY_FILE_SYMBOL",
                                "DETERMINISTIC_SYMBOL",
                                "DIAGNOSTICS_SYMBOL",
                                "DIRECTORY_SYMBOL",
                                "DISABLE_SYMBOL",
                                "DISCARD_SYMBOL",
                                "DISK_SYMBOL",
                                "DISTINCT_SYMBOL",
                                "DISTINCTROW_SYMBOL",
                                "DIV_SYMBOL",
                                "DOUBLE_SYMBOL",
                                "DO_SYMBOL",
                                "DROP_SYMBOL",
                                "DUAL_SYMBOL",
                                "DUMPFILE_SYMBOL",
                                "DUPLICATE_SYMBOL",
                                "DYNAMIC_SYMBOL",
                                "EACH_SYMBOL",
                                "ELSE_SYMBOL",
                                "ELSEIF_SYMBOL",
                                "ENABLE_SYMBOL",
                                "ENCLOSED_SYMBOL",
                                "ENCRYPTION_SYMBOL",
                                "END_SYMBOL",
                                "ENDS_SYMBOL",
                                "END_OF_INPUT_SYMBOL",
                                "ENGINES_SYMBOL",
                                "ENGINE_SYMBOL",
                                "ENUM_SYMBOL",
                                "ERROR_SYMBOL",
                                "ERRORS_SYMBOL",
                                "ESCAPED_SYMBOL",
                                "ESCAPE_SYMBOL",
                                "EVENTS_SYMBOL",
                                "EVENT_SYMBOL",
                                "EVERY_SYMBOL",
                                "EXCHANGE_SYMBOL",
                                "EXECUTE_SYMBOL",
                                "EXISTS_SYMBOL",
                                "EXIT_SYMBOL",
                                "EXPANSION_SYMBOL",
                                "EXPIRE_SYMBOL",
                                "EXPLAIN_SYMBOL",
                                "EXPORT_SYMBOL",
                                "EXTENDED_SYMBOL",
                                "EXTENT_SIZE_SYMBOL",
                                "EXTRACT_SYMBOL",
                                "FALSE_SYMBOL",
                                "FAST_SYMBOL",
                                "FAULTS_SYMBOL",
                                "FETCH_SYMBOL",
                                "FIELDS_SYMBOL",
                                "FILE_SYMBOL",
                                "FILE_BLOCK_SIZE_SYMBOL",
                                "FILTER_SYMBOL",
                                "FIRST_SYMBOL",
                                "FIXED_SYMBOL",
                                "FLOAT4_SYMBOL",
                                "FLOAT8_SYMBOL",
                                "FLOAT_SYMBOL",
                                "FLUSH_SYMBOL",
                                "FOLLOWS_SYMBOL",
                                "FORCE_SYMBOL",
                                "FOREIGN_SYMBOL",
                                "FOR_SYMBOL",
                                "FORMAT_SYMBOL",
                                "FOUND_SYMBOL",
                                "FROM_SYMBOL",
                                "FULL_SYMBOL",
                                "FULLTEXT_SYMBOL",
                                "FUNCTION_SYMBOL",
                                "GET_SYMBOL",
                                "GENERAL_SYMBOL",
                                "GENERATED_SYMBOL",
                                "GROUP_REPLICATION_SYMBOL",
                                "GEOMETRYCOLLECTION_SYMBOL",
                                "GEOMETRY_SYMBOL",
                                "GET_FORMAT_SYMBOL",
                                "GLOBAL_SYMBOL",
                                "GRANT_SYMBOL",
                                "GRANTS_SYMBOL",
                                "GROUP_SYMBOL",
                                "GROUP_CONCAT_SYMBOL",
                                "HANDLER_SYMBOL",
                                "HASH_SYMBOL",
                                "HAVING_SYMBOL",
                                "HELP_SYMBOL",
                                "HIGH_PRIORITY_SYMBOL",
                                "HOST_SYMBOL",
                                "HOSTS_SYMBOL",
                                "HOUR_MICROSECOND_SYMBOL",
                                "HOUR_MINUTE_SYMBOL",
                                "HOUR_SECOND_SYMBOL",
                                "HOUR_SYMBOL",
                                "IDENTIFIED_SYMBOL",
                                "IF_SYMBOL",
                                "IGNORE_SYMBOL",
                                "IGNORE_SERVER_IDS_SYMBOL",
                                "IMPORT_SYMBOL",
                                "INDEXES_SYMBOL",
                                "INDEX_SYMBOL",
                                "INFILE_SYMBOL",
                                "INITIAL_SIZE_SYMBOL",
                                "INNER_SYMBOL",
                                "INOUT_SYMBOL",
                                "INSENSITIVE_SYMBOL",
                                "INSERT_SYMBOL",
                                "INSERT_METHOD_SYMBOL",
                                "INSTANCE_SYMBOL",
                                "INSTALL_SYMBOL",
                                "INTEGER_SYMBOL",
                                "INTERVAL_SYMBOL",
                                "INTO_SYMBOL",
                                "INT_SYMBOL",
                                "INVOKER_SYMBOL",
                                "IN_SYMBOL",
                                "IO_AFTER_GTIDS_SYMBOL",
                                "IO_BEFORE_GTIDS_SYMBOL",
                                "IO_THREAD_SYMBOL",
                                "IO_SYMBOL",
                                "IPC_SYMBOL",
                                "IS_SYMBOL",
                                "ISOLATION_SYMBOL",
                                "ISSUER_SYMBOL",
                                "ITERATE_SYMBOL",
                                "JOIN_SYMBOL",
                                "JSON_SYMBOL",
                                "KEYS_SYMBOL",
                                "KEY_BLOCK_SIZE_SYMBOL",
                                "KEY_SYMBOL",
                                "KILL_SYMBOL",
                                "LANGUAGE_SYMBOL",
                                "LAST_SYMBOL",
                                "LEADING_SYMBOL",
                                "LEAVES_SYMBOL",
                                "LEAVE_SYMBOL",
                                "LEFT_SYMBOL",
                                "LESS_SYMBOL",
                                "LEVEL_SYMBOL",
                                "LIKE_SYMBOL",
                                "LIMIT_SYMBOL",
                                "LINEAR_SYMBOL",
                                "LINES_SYMBOL",
                                "LINESTRING_SYMBOL",
                                "LIST_SYMBOL",
                                "LOAD_SYMBOL",
                                "LOCALTIME_SYMBOL",
                                "LOCALTIMESTAMP_SYMBOL",
                                "LOCAL_SYMBOL",
                                "LOCATOR_SYMBOL",
                                "LOCKS_SYMBOL",
                                "LOCK_SYMBOL",
                                "LOGFILE_SYMBOL",
                                "LOGS_SYMBOL",
                                "LONGBLOB_SYMBOL",
                                "LONGTEXT_SYMBOL",
                                "LONG_NUM_SYMBOL",
                                "LONG_SYMBOL",
                                "LOOP_SYMBOL",
                                "LOW_PRIORITY_SYMBOL",
                                "MASTER_AUTO_POSITION_SYMBOL",
                                "MASTER_BIND_SYMBOL",
                                "MASTER_CONNECT_RETRY_SYMBOL",
                                "MASTER_DELAY_SYMBOL",
                                "MASTER_HOST_SYMBOL",
                                "MASTER_LOG_FILE_SYMBOL",
                                "MASTER_LOG_POS_SYMBOL",
                                "MASTER_PASSWORD_SYMBOL",
                                "MASTER_PORT_SYMBOL",
                                "MASTER_RETRY_COUNT_SYMBOL",
                                "MASTER_SERVER_ID_SYMBOL",
                                "MASTER_SSL_CAPATH_SYMBOL",
                                "MASTER_SSL_CA_SYMBOL",
                                "MASTER_SSL_CERT_SYMBOL",
                                "MASTER_SSL_CIPHER_SYMBOL",
                                "MASTER_SSL_CRL_SYMBOL",
                                "MASTER_SSL_CRLPATH_SYMBOL",
                                "MASTER_SSL_KEY_SYMBOL",
                                "MASTER_SSL_SYMBOL",
                                "MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL",
                                "MASTER_SYMBOL",
                                "MASTER_TLS_VERSION_SYMBOL",
                                "MASTER_USER_SYMBOL",
                                "MASTER_HEARTBEAT_PERIOD_SYMBOL",
                                "MATCH_SYMBOL",
                                "MAX_CONNECTIONS_PER_HOUR_SYMBOL",
                                "MAX_QUERIES_PER_HOUR_SYMBOL",
                                "MAX_ROWS_SYMBOL",
                                "MAX_SIZE_SYMBOL",
                                "MAX_STATEMENT_TIME_SYMBOL",
                                "MAX_SYMBOL",
                                "MAX_UPDATES_PER_HOUR_SYMBOL",
                                "MAX_USER_CONNECTIONS_SYMBOL",
                                "MAXVALUE_SYMBOL",
                                "MEDIUMBLOB_SYMBOL",
                                "MEDIUMINT_SYMBOL",
                                "MEDIUMTEXT_SYMBOL",
                                "MEDIUM_SYMBOL",
                                "MEMORY_SYMBOL",
                                "MERGE_SYMBOL",
                                "MESSAGE_TEXT_SYMBOL",
                                "MICROSECOND_SYMBOL",
                                "MID_SYMBOL",
                                "MIDDLEINT_SYMBOL",
                                "MIGRATE_SYMBOL",
                                "MINUTE_MICROSECOND_SYMBOL",
                                "MINUTE_SECOND_SYMBOL",
                                "MINUTE_SYMBOL",
                                "MIN_ROWS_SYMBOL",
                                "MIN_SYMBOL",
                                "MODE_SYMBOL",
                                "MODIFIES_SYMBOL",
                                "MODIFY_SYMBOL",
                                "MOD_SYMBOL",
                                "MONTH_SYMBOL",
                                "MULTILINESTRING_SYMBOL",
                                "MULTIPOINT_SYMBOL",
                                "MULTIPOLYGON_SYMBOL",
                                "MUTEX_SYMBOL",
                                "MYSQL_ERRNO_SYMBOL",
                                "NAMES_SYMBOL",
                                "NAME_SYMBOL",
                                "NATIONAL_SYMBOL",
                                "NATURAL_SYMBOL",
                                "NCHAR_STRING_SYMBOL",
                                "NCHAR_SYMBOL",
                                "NDB_SYMBOL",
                                "NDBCLUSTER_SYMBOL",
                                "NEG_SYMBOL",
                                "NEVER_SYMBOL",
                                "NEW_SYMBOL",
                                "NEXT_SYMBOL",
                                "NODEGROUP_SYMBOL",
                                "NONE_SYMBOL",
                                "NONBLOCKING_SYMBOL",
                                "NOT_SYMBOL",
                                "NOW_SYMBOL",
                                "NO_SYMBOL",
                                "NO_WAIT_SYMBOL",
                                "NO_WRITE_TO_BINLOG_SYMBOL",
                                "NULL_SYMBOL",
                                "NUMBER_SYMBOL",
                                "NUMERIC_SYMBOL",
                                "NVARCHAR_SYMBOL",
                                "OFFLINE_SYMBOL",
                                "OFFSET_SYMBOL",
                                "OLD_PASSWORD_SYMBOL",
                                "ON_SYMBOL",
                                "ONE_SYMBOL",
                                "ONLINE_SYMBOL",
                                "ONLY_SYMBOL",
                                "OPEN_SYMBOL",
                                "OPTIMIZE_SYMBOL",
                                "OPTIMIZER_COSTS_SYMBOL",
                                "OPTIONS_SYMBOL",
                                "OPTION_SYMBOL",
                                "OPTIONALLY_SYMBOL",
                                "ORDER_SYMBOL",
                                "OR_SYMBOL",
                                "OUTER_SYMBOL",
                                "OUTFILE_SYMBOL",
                                "OUT_SYMBOL",
                                "OWNER_SYMBOL",
                                "PACK_KEYS_SYMBOL",
                                "PAGE_SYMBOL",
                                "PARSER_SYMBOL",
                                "PARTIAL_SYMBOL",
                                "PARTITIONING_SYMBOL",
                                "PARTITIONS_SYMBOL",
                                "PARTITION_SYMBOL",
                                "PASSWORD_SYMBOL",
                                "PHASE_SYMBOL",
                                "PLUGINS_SYMBOL",
                                "PLUGIN_DIR_SYMBOL",
                                "PLUGIN_SYMBOL",
                                "POINT_SYMBOL",
                                "POLYGON_SYMBOL",
                                "PORT_SYMBOL",
                                "POSITION_SYMBOL",
                                "PRECEDES_SYMBOL",
                                "PRECISION_SYMBOL",
                                "PREPARE_SYMBOL",
                                "PRESERVE_SYMBOL",
                                "PREV_SYMBOL",
                                "PRIMARY_SYMBOL",
                                "PRIVILEGES_SYMBOL",
                                "PROCEDURE_SYMBOL",
                                "PROCESS_SYMBOL",
                                "PROCESSLIST_SYMBOL",
                                "PROFILE_SYMBOL",
                                "PROFILES_SYMBOL",
                                "PROXY_SYMBOL",
                                "PURGE_SYMBOL",
                                "QUARTER_SYMBOL",
                                "QUERY_SYMBOL",
                                "QUICK_SYMBOL",
                                "RANGE_SYMBOL",
                                "READS_SYMBOL",
                                "READ_ONLY_SYMBOL",
                                "READ_SYMBOL",
                                "READ_WRITE_SYMBOL",
                                "REAL_SYMBOL",
                                "REBUILD_SYMBOL",
                                "RECOVER_SYMBOL",
                                "REDOFILE_SYMBOL",
                                "REDO_BUFFER_SIZE_SYMBOL",
                                "REDUNDANT_SYMBOL",
                                "REFERENCES_SYMBOL",
                                "REGEXP_SYMBOL",
                                "RELAY_SYMBOL",
                                "RELAYLOG_SYMBOL",
                                "RELAY_LOG_FILE_SYMBOL",
                                "RELAY_LOG_POS_SYMBOL",
                                "RELAY_THREAD_SYMBOL",
                                "RELEASE_SYMBOL",
                                "RELOAD_SYMBOL",
                                "REMOVE_SYMBOL",
                                "RENAME_SYMBOL",
                                "REORGANIZE_SYMBOL",
                                "REPAIR_SYMBOL",
                                "REPEATABLE_SYMBOL",
                                "REPEAT_SYMBOL",
                                "REPLACE_SYMBOL",
                                "REPLICATION_SYMBOL",
                                "REPLICATE_DO_DB_SYMBOL",
                                "REPLICATE_IGNORE_DB_SYMBOL",
                                "REPLICATE_DO_TABLE_SYMBOL",
                                "REPLICATE_IGNORE_TABLE_SYMBOL",
                                "REPLICATE_WILD_DO_TABLE_SYMBOL",
                                "REPLICATE_WILD_IGNORE_TABLE_SYMBOL",
                                "REPLICATE_REWRITE_DB_SYMBOL",
                                "REQUIRE_SYMBOL",
                                "RESET_SYMBOL",
                                "RESIGNAL_SYMBOL",
                                "RESTORE_SYMBOL",
                                "RESTRICT_SYMBOL",
                                "RESUME_SYMBOL",
                                "RETURNED_SQLSTATE_SYMBOL",
                                "RETURNS_SYMBOL",
                                "RETURN_SYMBOL",
                                "REVERSE_SYMBOL",
                                "REVOKE_SYMBOL",
                                "RIGHT_SYMBOL",
                                "RLIKE_SYMBOL",
                                "ROLLBACK_SYMBOL",
                                "ROLLUP_SYMBOL",
                                "ROTATE_SYMBOL",
                                "ROUTINE_SYMBOL",
                                "ROWS_SYMBOL",
                                "ROW_COUNT_SYMBOL",
                                "ROW_FORMAT_SYMBOL",
                                "ROW_SYMBOL",
                                "RTREE_SYMBOL",
                                "SAVEPOINT_SYMBOL",
                                "SCHEDULE_SYMBOL",
                                "SCHEMA_SYMBOL",
                                "SCHEMA_NAME_SYMBOL",
                                "SCHEMAS_SYMBOL",
                                "SECOND_MICROSECOND_SYMBOL",
                                "SECOND_SYMBOL",
                                "SECURITY_SYMBOL",
                                "SELECT_SYMBOL",
                                "SENSITIVE_SYMBOL",
                                "SEPARATOR_SYMBOL",
                                "SERIALIZABLE_SYMBOL",
                                "SERIAL_SYMBOL",
                                "SESSION_SYMBOL",
                                "SERVER_SYMBOL",
                                "SERVER_OPTIONS_SYMBOL",
                                "SESSION_USER_SYMBOL",
                                "SET_SYMBOL",
                                "SET_VAR_SYMBOL",
                                "SHARE_SYMBOL",
                                "SHOW_SYMBOL",
                                "SHUTDOWN_SYMBOL",
                                "SIGNAL_SYMBOL",
                                "SIGNED_SYMBOL",
                                "SIMPLE_SYMBOL",
                                "SLAVE_SYMBOL",
                                "SLOW_SYMBOL",
                                "SMALLINT_SYMBOL",
                                "SNAPSHOT_SYMBOL",
                                "SOME_SYMBOL",
                                "SOCKET_SYMBOL",
                                "SONAME_SYMBOL",
                                "SOUNDS_SYMBOL",
                                "SOURCE_SYMBOL",
                                "SPATIAL_SYMBOL",
                                "SPECIFIC_SYMBOL",
                                "SQLEXCEPTION_SYMBOL",
                                "SQLSTATE_SYMBOL",
                                "SQLWARNING_SYMBOL",
                                "SQL_AFTER_GTIDS_SYMBOL",
                                "SQL_AFTER_MTS_GAPS_SYMBOL",
                                "SQL_BEFORE_GTIDS_SYMBOL",
                                "SQL_BIG_RESULT_SYMBOL",
                                "SQL_BUFFER_RESULT_SYMBOL",
                                "SQL_CACHE_SYMBOL",
                                "SQL_CALC_FOUND_ROWS_SYMBOL",
                                "SQL_NO_CACHE_SYMBOL",
                                "SQL_SMALL_RESULT_SYMBOL",
                                "SQL_SYMBOL",
                                "SQL_THREAD_SYMBOL",
                                "SSL_SYMBOL",
                                "STACKED_SYMBOL",
                                "STARTING_SYMBOL",
                                "STARTS_SYMBOL",
                                "START_SYMBOL",
                                "STATS_AUTO_RECALC_SYMBOL",
                                "STATS_PERSISTENT_SYMBOL",
                                "STATS_SAMPLE_PAGES_SYMBOL",
                                "STATUS_SYMBOL",
                                "STDDEV_SAMP_SYMBOL",
                                "STDDEV_SYMBOL",
                                "STDDEV_POP_SYMBOL",
                                "STD_SYMBOL",
                                "STOP_SYMBOL",
                                "STORAGE_SYMBOL",
                                "STORED_SYMBOL",
                                "STRAIGHT_JOIN_SYMBOL",
                                "STRING_SYMBOL",
                                "SUBCLASS_ORIGIN_SYMBOL",
                                "SUBDATE_SYMBOL",
                                "SUBJECT_SYMBOL",
                                "SUBPARTITIONS_SYMBOL",
                                "SUBPARTITION_SYMBOL",
                                "SUBSTR_SYMBOL",
                                "SUBSTRING_SYMBOL",
                                "SUM_SYMBOL",
                                "SUPER_SYMBOL",
                                "SUSPEND_SYMBOL",
                                "SWAPS_SYMBOL",
                                "SWITCHES_SYMBOL",
                                "SYSDATE_SYMBOL",
                                "SYSTEM_USER_SYMBOL",
                                "TABLES_SYMBOL",
                                "TABLESPACE_SYMBOL",
                                "TABLE_REF_PRIORITY_SYMBOL",
                                "TABLE_SYMBOL",
                                "TABLE_CHECKSUM_SYMBOL",
                                "TABLE_NAME_SYMBOL",
                                "TEMPORARY_SYMBOL",
                                "TEMPTABLE_SYMBOL",
                                "TERMINATED_SYMBOL",
                                "TEXT_SYMBOL",
                                "THAN_SYMBOL",
                                "THEN_SYMBOL",
                                "TIMESTAMP_SYMBOL",
                                "TIMESTAMP_ADD_SYMBOL",
                                "TIMESTAMP_DIFF_SYMBOL",
                                "TIME_SYMBOL",
                                "TINYBLOB_SYMBOL",
                                "TINYINT_SYMBOL",
                                "TINYTEXT_SYMBOL",
                                "TO_SYMBOL",
                                "TRAILING_SYMBOL",
                                "TRANSACTION_SYMBOL",
                                "TRIGGERS_SYMBOL",
                                "TRIGGER_SYMBOL",
                                "TRIM_SYMBOL",
                                "TRUE_SYMBOL",
                                "TRUNCATE_SYMBOL",
                                "TYPES_SYMBOL",
                                "TYPE_SYMBOL",
                                "UDF_RETURNS_SYMBOL",
                                "UNCOMMITTED_SYMBOL",
                                "UNDEFINED_SYMBOL",
                                "UNDOFILE_SYMBOL",
                                "UNDO_BUFFER_SIZE_SYMBOL",
                                "UNDO_SYMBOL",
                                "UNICODE_SYMBOL",
                                "UNINSTALL_SYMBOL",
                                "UNION_SYMBOL",
                                "UNIQUE_SYMBOL",
                                "UNKNOWN_SYMBOL",
                                "UNLOCK_SYMBOL",
                                "UNSIGNED_SYMBOL",
                                "UNTIL_SYMBOL",
                                "UPDATE_SYMBOL",
                                "UPGRADE_SYMBOL",
                                "USAGE_SYMBOL",
                                "USER_RESOURCES_SYMBOL",
                                "USER_SYMBOL",
                                "USE_FRM_SYMBOL",
                                "USE_SYMBOL",
                                "USING_SYMBOL",
                                "UTC_DATE_SYMBOL",
                                "UTC_TIMESTAMP_SYMBOL",
                                "UTC_TIME_SYMBOL",
                                "VALIDATION_SYMBOL",
                                "VALUES_SYMBOL",
                                "VALUE_SYMBOL",
                                "VARBINARY_SYMBOL",
                                "VARCHAR_SYMBOL",
                                "VARCHARACTER_SYMBOL",
                                "VARIABLES_SYMBOL",
                                "VARIANCE_SYMBOL",
                                "VARYING_SYMBOL",
                                "VAR_POP_SYMBOL",
                                "VAR_SAMP_SYMBOL",
                                "VIEW_SYMBOL",
                                "VIRTUAL_SYMBOL",
                                "WAIT_SYMBOL",
                                "WARNINGS_SYMBOL",
                                "WEEK_SYMBOL",
                                "WEIGHT_STRING_SYMBOL",
                                "WHEN_SYMBOL",
                                "WHERE_SYMBOL",
                                "WHILE_SYMBOL",
                                "WITH_SYMBOL",
                                "WITHOUT_SYMBOL",
                                "WORK_SYMBOL",
                                "WRAPPER_SYMBOL",
                                "WRITE_SYMBOL",
                                "X509_SYMBOL",
                                "XA_SYMBOL",
                                "XID_SYMBOL",
                                "XML_SYMBOL",
                                "XOR_SYMBOL",
                                "YEAR_MONTH_SYMBOL",
                                "YEAR_SYMBOL",
                                "ZEROFILL_SYMBOL",
                                "PERSIST_SYMBOL",
                                "ROLE_SYMBOL",
                                "ADMIN_SYMBOL",
                                "INVISIBLE_SYMBOL",
                                "VISIBLE_SYMBOL",
                                "EXCEPT_SYMBOL",
                                "COMPONENT_SYMBOL",
                                "RECURSIVE_SYMBOL",
                                "JSON_OBJECTAGG_SYMBOL",
                                "JSON_ARRAYAGG_SYMBOL",
                                "OF_SYMBOL",
                                "SKIP_SYMBOL",
                                "LOCKED_SYMBOL",
                                "NOWAIT_SYMBOL",
                                "GROUPING_SYMBOL",
                                "PERSIST_ONLY_SYMBOL",
                                "HISTOGRAM_SYMBOL",
                                "BUCKETS_SYMBOL",
                                "REMOTE_SYMBOL",
                                "CLONE_SYMBOL",
                                "CUME_DIST_SYMBOL",
                                "DENSE_RANK_SYMBOL",
                                "EXCLUDE_SYMBOL",
                                "FIRST_VALUE_SYMBOL",
                                "FOLLOWING_SYMBOL",
                                "GROUPS_SYMBOL",
                                "LAG_SYMBOL",
                                "LAST_VALUE_SYMBOL",
                                "LEAD_SYMBOL",
                                "NTH_VALUE_SYMBOL",
                                "NTILE_SYMBOL",
                                "NULLS_SYMBOL",
                                "OTHERS_SYMBOL",
                                "OVER_SYMBOL",
                                "PERCENT_RANK_SYMBOL",
                                "PRECEDING_SYMBOL",
                                "RANK_SYMBOL",
                                "RESPECT_SYMBOL",
                                "ROW_NUMBER_SYMBOL",
                                "TIES_SYMBOL",
                                "UNBOUNDED_SYMBOL",
                                "WINDOW_SYMBOL",
                                "EMPTY_SYMBOL",
                                "JSON_TABLE_SYMBOL",
                                "NESTED_SYMBOL",
                                "ORDINALITY_SYMBOL",
                                "PATH_SYMBOL",
                                "HISTORY_SYMBOL",
                                "REUSE_SYMBOL",
                                "SRID_SYMBOL",
                                "THREAD_PRIORITY_SYMBOL",
                                "RESOURCE_SYMBOL",
                                "SYSTEM_SYMBOL",
                                "VCPU_SYMBOL",
                                "MASTER_PUBLIC_KEY_PATH_SYMBOL",
                                "GET_MASTER_PUBLIC_KEY_SYMBOL",
                                "RESTART_SYMBOL",
                                "DEFINITION_SYMBOL",
                                "DESCRIPTION_SYMBOL",
                                "ORGANIZATION_SYMBOL",
                                "REFERENCE_SYMBOL",
                                "OPTIONAL_SYMBOL",
                                "SECONDARY_SYMBOL",
                                "SECONDARY_ENGINE_SYMBOL",
                                "SECONDARY_LOAD_SYMBOL",
                                "SECONDARY_UNLOAD_SYMBOL",
                                "ACTIVE_SYMBOL",
                                "INACTIVE_SYMBOL",
                                "LATERAL_SYMBOL",
                                "RETAIN_SYMBOL",
                                "OLD_SYMBOL",
                                "NETWORK_NAMESPACE_SYMBOL",
                                "ENFORCED_SYMBOL",
                                "ARRAY_SYMBOL",
                                "OJ_SYMBOL",
                                "MEMBER_SYMBOL",
                                "RANDOM_SYMBOL",
                                "MASTER_COMPRESSION_ALGORITHM_SYMBOL",
                                "MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL",
                                "PRIVILEGE_CHECKS_USER_SYMBOL",
                                "MASTER_TLS_CIPHERSUITES_SYMBOL",
                                "REQUIRE_ROW_FORMAT_SYMBOL",
                                "PASSWORD_LOCK_TIME_SYMBOL",
                                "FAILED_LOGIN_ATTEMPTS_SYMBOL",
                                "REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL",
                                "STREAM_SYMBOL",
                                "OFF_SYMBOL",
                                "NOT2_SYMBOL",
                                "CONCAT_PIPES_SYMBOL",
                                "INT_NUMBER",
                                "LONG_NUMBER",
                                "ULONGLONG_NUMBER",
                                "EQUAL_OPERATOR",
                                "ASSIGN_OPERATOR",
                                "NULL_SAFE_EQUAL_OPERATOR",
                                "GREATER_OR_EQUAL_OPERATOR",
                                "GREATER_THAN_OPERATOR",
                                "LESS_OR_EQUAL_OPERATOR",
                                "LESS_THAN_OPERATOR",
                                "NOT_EQUAL_OPERATOR",
                                "PLUS_OPERATOR",
                                "MINUS_OPERATOR",
                                "MULT_OPERATOR",
                                "DIV_OPERATOR",
                                "MOD_OPERATOR",
                                "LOGICAL_NOT_OPERATOR",
                                "BITWISE_NOT_OPERATOR",
                                "SHIFT_LEFT_OPERATOR",
                                "SHIFT_RIGHT_OPERATOR",
                                "LOGICAL_AND_OPERATOR",
                                "BITWISE_AND_OPERATOR",
                                "BITWISE_XOR_OPERATOR",
                                "LOGICAL_OR_OPERATOR",
                                "BITWISE_OR_OPERATOR",
                                "DOT_SYMBOL",
                                "COMMA_SYMBOL",
                                "SEMICOLON_SYMBOL",
                                "COLON_SYMBOL",
                                "OPEN_PAR_SYMBOL",
                                "CLOSE_PAR_SYMBOL",
                                "OPEN_CURLY_SYMBOL",
                                "CLOSE_CURLY_SYMBOL",
                                "UNDERLINE_SYMBOL",
                                "JSON_SEPARATOR_SYMBOL",
                                "JSON_UNQUOTED_SEPARATOR_SYMBOL",
                                "AT_SIGN_SYMBOL",
                                "AT_TEXT_SUFFIX",
                                "AT_AT_SIGN_SYMBOL",
                                "NULL2_SYMBOL",
                                "PARAM_MARKER",
                                "HEX_NUMBER",
                                "BIN_NUMBER",
                                "DECIMAL_NUMBER",
                                "FLOAT_NUMBER",
                                "TIMESTAMPADD_SYMBOL",
                                "TIMESTAMPDIFF_SYMBOL",
                                "RETURNING_SYMBOL",
                                "JSON_VALUE_SYMBOL",
                                "TLS_SYMBOL",
                                "ATTRIBUTE_SYMBOL",
                                "ENGINE_ATTRIBUTE_SYMBOL",
                                "SECONDARY_ENGINE_ATTRIBUTE_SYMBOL",
                                "SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL",
                                "ZONE_SYMBOL",
                                "GRAMMAR_SELECTOR_DERIVED_EXPR",
                                "REPLICA_SYMBOL",
                                "REPLICAS_SYMBOL",
                                "ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL",
                                "GET_SOURCE_PUBLIC_KEY_SYMBOL",
                                "SOURCE_AUTO_POSITION_SYMBOL",
                                "SOURCE_BIND_SYMBOL",
                                "SOURCE_COMPRESSION_ALGORITHM_SYMBOL",
                                "SOURCE_CONNECT_RETRY_SYMBOL",
                                "SOURCE_DELAY_SYMBOL",
                                "SOURCE_HEARTBEAT_PERIOD_SYMBOL",
                                "SOURCE_HOST_SYMBOL",
                                "SOURCE_LOG_FILE_SYMBOL",
                                "SOURCE_LOG_POS_SYMBOL",
                                "SOURCE_PASSWORD_SYMBOL",
                                "SOURCE_PORT_SYMBOL",
                                "SOURCE_PUBLIC_KEY_PATH_SYMBOL",
                                "SOURCE_RETRY_COUNT_SYMBOL",
                                "SOURCE_SSL_SYMBOL",
                                "SOURCE_SSL_CA_SYMBOL",
                                "SOURCE_SSL_CAPATH_SYMBOL",
                                "SOURCE_SSL_CERT_SYMBOL",
                                "SOURCE_SSL_CIPHER_SYMBOL",
                                "SOURCE_SSL_CRL_SYMBOL",
                                "SOURCE_SSL_CRLPATH_SYMBOL",
                                "SOURCE_SSL_KEY_SYMBOL",
                                "SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL",
                                "SOURCE_TLS_CIPHERSUITES_SYMBOL",
                                "SOURCE_TLS_VERSION_SYMBOL",
                                "SOURCE_USER_SYMBOL",
                                "SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL",
                                "ST_COLLECT_SYMBOL",
                                "KEYRING_SYMBOL",
                                "AUTHENTICATION_SYMBOL",
                                "FACTOR_SYMBOL",
                                "FINISH_SYMBOL",
                                "INITIATE_SYMBOL",
                                "REGISTRATION_SYMBOL",
                                "UNREGISTER_SYMBOL",
                                "INITIAL_SYMBOL",
                                "CHALLENGE_RESPONSE_SYMBOL",
                                "GTID_ONLY_SYMBOL",
                                "INTERSECT_SYMBOL",
                                "WHITESPACE",
                                "INVALID_INPUT",
                                "UNDERSCORE_CHARSET",
                                "IDENTIFIER",
                                "NCHAR_TEXT",
                                "BACK_TICK_QUOTED_ID",
                                "DOUBLE_QUOTED_TEXT",
                                "SINGLE_QUOTED_TEXT",
                                "VERSION_COMMENT_START",
                                "MYSQL_COMMENT_START",
                                "VERSION_COMMENT_END",
                                "BLOCK_COMMENT",
                                "INVALID_BLOCK_COMMENT",
                                "POUND_COMMENT",
                                "DASHDASH_COMMENT",
                                "NOT_EQUAL2_OPERATOR" });
    static const int32_t serializedATNSegment[] = {
      4,     1,    860,  9010, 2,    0,    7,    0,    2,    1,    7,    1,    2,    2,    7,    2,    2,    3,    7,
      3,     2,    4,    7,    4,    2,    5,    7,    5,    2,    6,    7,    6,    2,    7,    7,    7,    2,    8,
      7,     8,    2,    9,    7,    9,    2,    10,   7,    10,   2,    11,   7,    11,   2,    12,   7,    12,   2,
      13,    7,    13,   2,    14,   7,    14,   2,    15,   7,    15,   2,    16,   7,    16,   2,    17,   7,    17,
      2,     18,   7,    18,   2,    19,   7,    19,   2,    20,   7,    20,   2,    21,   7,    21,   2,    22,   7,
      22,    2,    23,   7,    23,   2,    24,   7,    24,   2,    25,   7,    25,   2,    26,   7,    26,   2,    27,
      7,     27,   2,    28,   7,    28,   2,    29,   7,    29,   2,    30,   7,    30,   2,    31,   7,    31,   2,
      32,    7,    32,   2,    33,   7,    33,   2,    34,   7,    34,   2,    35,   7,    35,   2,    36,   7,    36,
      2,     37,   7,    37,   2,    38,   7,    38,   2,    39,   7,    39,   2,    40,   7,    40,   2,    41,   7,
      41,    2,    42,   7,    42,   2,    43,   7,    43,   2,    44,   7,    44,   2,    45,   7,    45,   2,    46,
      7,     46,   2,    47,   7,    47,   2,    48,   7,    48,   2,    49,   7,    49,   2,    50,   7,    50,   2,
      51,    7,    51,   2,    52,   7,    52,   2,    53,   7,    53,   2,    54,   7,    54,   2,    55,   7,    55,
      2,     56,   7,    56,   2,    57,   7,    57,   2,    58,   7,    58,   2,    59,   7,    59,   2,    60,   7,
      60,    2,    61,   7,    61,   2,    62,   7,    62,   2,    63,   7,    63,   2,    64,   7,    64,   2,    65,
      7,     65,   2,    66,   7,    66,   2,    67,   7,    67,   2,    68,   7,    68,   2,    69,   7,    69,   2,
      70,    7,    70,   2,    71,   7,    71,   2,    72,   7,    72,   2,    73,   7,    73,   2,    74,   7,    74,
      2,     75,   7,    75,   2,    76,   7,    76,   2,    77,   7,    77,   2,    78,   7,    78,   2,    79,   7,
      79,    2,    80,   7,    80,   2,    81,   7,    81,   2,    82,   7,    82,   2,    83,   7,    83,   2,    84,
      7,     84,   2,    85,   7,    85,   2,    86,   7,    86,   2,    87,   7,    87,   2,    88,   7,    88,   2,
      89,    7,    89,   2,    90,   7,    90,   2,    91,   7,    91,   2,    92,   7,    92,   2,    93,   7,    93,
      2,     94,   7,    94,   2,    95,   7,    95,   2,    96,   7,    96,   2,    97,   7,    97,   2,    98,   7,
      98,    2,    99,   7,    99,   2,    100,  7,    100,  2,    101,  7,    101,  2,    102,  7,    102,  2,    103,
      7,     103,  2,    104,  7,    104,  2,    105,  7,    105,  2,    106,  7,    106,  2,    107,  7,    107,  2,
      108,   7,    108,  2,    109,  7,    109,  2,    110,  7,    110,  2,    111,  7,    111,  2,    112,  7,    112,
      2,     113,  7,    113,  2,    114,  7,    114,  2,    115,  7,    115,  2,    116,  7,    116,  2,    117,  7,
      117,   2,    118,  7,    118,  2,    119,  7,    119,  2,    120,  7,    120,  2,    121,  7,    121,  2,    122,
      7,     122,  2,    123,  7,    123,  2,    124,  7,    124,  2,    125,  7,    125,  2,    126,  7,    126,  2,
      127,   7,    127,  2,    128,  7,    128,  2,    129,  7,    129,  2,    130,  7,    130,  2,    131,  7,    131,
      2,     132,  7,    132,  2,    133,  7,    133,  2,    134,  7,    134,  2,    135,  7,    135,  2,    136,  7,
      136,   2,    137,  7,    137,  2,    138,  7,    138,  2,    139,  7,    139,  2,    140,  7,    140,  2,    141,
      7,     141,  2,    142,  7,    142,  2,    143,  7,    143,  2,    144,  7,    144,  2,    145,  7,    145,  2,
      146,   7,    146,  2,    147,  7,    147,  2,    148,  7,    148,  2,    149,  7,    149,  2,    150,  7,    150,
      2,     151,  7,    151,  2,    152,  7,    152,  2,    153,  7,    153,  2,    154,  7,    154,  2,    155,  7,
      155,   2,    156,  7,    156,  2,    157,  7,    157,  2,    158,  7,    158,  2,    159,  7,    159,  2,    160,
      7,     160,  2,    161,  7,    161,  2,    162,  7,    162,  2,    163,  7,    163,  2,    164,  7,    164,  2,
      165,   7,    165,  2,    166,  7,    166,  2,    167,  7,    167,  2,    168,  7,    168,  2,    169,  7,    169,
      2,     170,  7,    170,  2,    171,  7,    171,  2,    172,  7,    172,  2,    173,  7,    173,  2,    174,  7,
      174,   2,    175,  7,    175,  2,    176,  7,    176,  2,    177,  7,    177,  2,    178,  7,    178,  2,    179,
      7,     179,  2,    180,  7,    180,  2,    181,  7,    181,  2,    182,  7,    182,  2,    183,  7,    183,  2,
      184,   7,    184,  2,    185,  7,    185,  2,    186,  7,    186,  2,    187,  7,    187,  2,    188,  7,    188,
      2,     189,  7,    189,  2,    190,  7,    190,  2,    191,  7,    191,  2,    192,  7,    192,  2,    193,  7,
      193,   2,    194,  7,    194,  2,    195,  7,    195,  2,    196,  7,    196,  2,    197,  7,    197,  2,    198,
      7,     198,  2,    199,  7,    199,  2,    200,  7,    200,  2,    201,  7,    201,  2,    202,  7,    202,  2,
      203,   7,    203,  2,    204,  7,    204,  2,    205,  7,    205,  2,    206,  7,    206,  2,    207,  7,    207,
      2,     208,  7,    208,  2,    209,  7,    209,  2,    210,  7,    210,  2,    211,  7,    211,  2,    212,  7,
      212,   2,    213,  7,    213,  2,    214,  7,    214,  2,    215,  7,    215,  2,    216,  7,    216,  2,    217,
      7,     217,  2,    218,  7,    218,  2,    219,  7,    219,  2,    220,  7,    220,  2,    221,  7,    221,  2,
      222,   7,    222,  2,    223,  7,    223,  2,    224,  7,    224,  2,    225,  7,    225,  2,    226,  7,    226,
      2,     227,  7,    227,  2,    228,  7,    228,  2,    229,  7,    229,  2,    230,  7,    230,  2,    231,  7,
      231,   2,    232,  7,    232,  2,    233,  7,    233,  2,    234,  7,    234,  2,    235,  7,    235,  2,    236,
      7,     236,  2,    237,  7,    237,  2,    238,  7,    238,  2,    239,  7,    239,  2,    240,  7,    240,  2,
      241,   7,    241,  2,    242,  7,    242,  2,    243,  7,    243,  2,    244,  7,    244,  2,    245,  7,    245,
      2,     246,  7,    246,  2,    247,  7,    247,  2,    248,  7,    248,  2,    249,  7,    249,  2,    250,  7,
      250,   2,    251,  7,    251,  2,    252,  7,    252,  2,    253,  7,    253,  2,    254,  7,    254,  2,    255,
      7,     255,  2,    256,  7,    256,  2,    257,  7,    257,  2,    258,  7,    258,  2,    259,  7,    259,  2,
      260,   7,    260,  2,    261,  7,    261,  2,    262,  7,    262,  2,    263,  7,    263,  2,    264,  7,    264,
      2,     265,  7,    265,  2,    266,  7,    266,  2,    267,  7,    267,  2,    268,  7,    268,  2,    269,  7,
      269,   2,    270,  7,    270,  2,    271,  7,    271,  2,    272,  7,    272,  2,    273,  7,    273,  2,    274,
      7,     274,  2,    275,  7,    275,  2,    276,  7,    276,  2,    277,  7,    277,  2,    278,  7,    278,  2,
      279,   7,    279,  2,    280,  7,    280,  2,    281,  7,    281,  2,    282,  7,    282,  2,    283,  7,    283,
      2,     284,  7,    284,  2,    285,  7,    285,  2,    286,  7,    286,  2,    287,  7,    287,  2,    288,  7,
      288,   2,    289,  7,    289,  2,    290,  7,    290,  2,    291,  7,    291,  2,    292,  7,    292,  2,    293,
      7,     293,  2,    294,  7,    294,  2,    295,  7,    295,  2,    296,  7,    296,  2,    297,  7,    297,  2,
      298,   7,    298,  2,    299,  7,    299,  2,    300,  7,    300,  2,    301,  7,    301,  2,    302,  7,    302,
      2,     303,  7,    303,  2,    304,  7,    304,  2,    305,  7,    305,  2,    306,  7,    306,  2,    307,  7,
      307,   2,    308,  7,    308,  2,    309,  7,    309,  2,    310,  7,    310,  2,    311,  7,    311,  2,    312,
      7,     312,  2,    313,  7,    313,  2,    314,  7,    314,  2,    315,  7,    315,  2,    316,  7,    316,  2,
      317,   7,    317,  2,    318,  7,    318,  2,    319,  7,    319,  2,    320,  7,    320,  2,    321,  7,    321,
      2,     322,  7,    322,  2,    323,  7,    323,  2,    324,  7,    324,  2,    325,  7,    325,  2,    326,  7,
      326,   2,    327,  7,    327,  2,    328,  7,    328,  2,    329,  7,    329,  2,    330,  7,    330,  2,    331,
      7,     331,  2,    332,  7,    332,  2,    333,  7,    333,  2,    334,  7,    334,  2,    335,  7,    335,  2,
      336,   7,    336,  2,    337,  7,    337,  2,    338,  7,    338,  2,    339,  7,    339,  2,    340,  7,    340,
      2,     341,  7,    341,  2,    342,  7,    342,  2,    343,  7,    343,  2,    344,  7,    344,  2,    345,  7,
      345,   2,    346,  7,    346,  2,    347,  7,    347,  2,    348,  7,    348,  2,    349,  7,    349,  2,    350,
      7,     350,  2,    351,  7,    351,  2,    352,  7,    352,  2,    353,  7,    353,  2,    354,  7,    354,  2,
      355,   7,    355,  2,    356,  7,    356,  2,    357,  7,    357,  2,    358,  7,    358,  2,    359,  7,    359,
      2,     360,  7,    360,  2,    361,  7,    361,  2,    362,  7,    362,  2,    363,  7,    363,  2,    364,  7,
      364,   2,    365,  7,    365,  2,    366,  7,    366,  2,    367,  7,    367,  2,    368,  7,    368,  2,    369,
      7,     369,  2,    370,  7,    370,  2,    371,  7,    371,  2,    372,  7,    372,  2,    373,  7,    373,  2,
      374,   7,    374,  2,    375,  7,    375,  2,    376,  7,    376,  2,    377,  7,    377,  2,    378,  7,    378,
      2,     379,  7,    379,  2,    380,  7,    380,  2,    381,  7,    381,  2,    382,  7,    382,  2,    383,  7,
      383,   2,    384,  7,    384,  2,    385,  7,    385,  2,    386,  7,    386,  2,    387,  7,    387,  2,    388,
      7,     388,  2,    389,  7,    389,  2,    390,  7,    390,  2,    391,  7,    391,  2,    392,  7,    392,  2,
      393,   7,    393,  2,    394,  7,    394,  2,    395,  7,    395,  2,    396,  7,    396,  2,    397,  7,    397,
      2,     398,  7,    398,  2,    399,  7,    399,  2,    400,  7,    400,  2,    401,  7,    401,  2,    402,  7,
      402,   2,    403,  7,    403,  2,    404,  7,    404,  2,    405,  7,    405,  2,    406,  7,    406,  2,    407,
      7,     407,  2,    408,  7,    408,  2,    409,  7,    409,  2,    410,  7,    410,  2,    411,  7,    411,  2,
      412,   7,    412,  2,    413,  7,    413,  2,    414,  7,    414,  2,    415,  7,    415,  2,    416,  7,    416,
      2,     417,  7,    417,  2,    418,  7,    418,  2,    419,  7,    419,  2,    420,  7,    420,  2,    421,  7,
      421,   2,    422,  7,    422,  2,    423,  7,    423,  2,    424,  7,    424,  2,    425,  7,    425,  2,    426,
      7,     426,  2,    427,  7,    427,  2,    428,  7,    428,  2,    429,  7,    429,  2,    430,  7,    430,  2,
      431,   7,    431,  2,    432,  7,    432,  2,    433,  7,    433,  2,    434,  7,    434,  2,    435,  7,    435,
      2,     436,  7,    436,  2,    437,  7,    437,  2,    438,  7,    438,  2,    439,  7,    439,  2,    440,  7,
      440,   2,    441,  7,    441,  2,    442,  7,    442,  2,    443,  7,    443,  2,    444,  7,    444,  2,    445,
      7,     445,  2,    446,  7,    446,  2,    447,  7,    447,  2,    448,  7,    448,  2,    449,  7,    449,  2,
      450,   7,    450,  2,    451,  7,    451,  2,    452,  7,    452,  2,    453,  7,    453,  2,    454,  7,    454,
      2,     455,  7,    455,  2,    456,  7,    456,  2,    457,  7,    457,  2,    458,  7,    458,  2,    459,  7,
      459,   2,    460,  7,    460,  2,    461,  7,    461,  2,    462,  7,    462,  2,    463,  7,    463,  2,    464,
      7,     464,  2,    465,  7,    465,  2,    466,  7,    466,  2,    467,  7,    467,  2,    468,  7,    468,  2,
      469,   7,    469,  2,    470,  7,    470,  2,    471,  7,    471,  2,    472,  7,    472,  2,    473,  7,    473,
      2,     474,  7,    474,  2,    475,  7,    475,  2,    476,  7,    476,  2,    477,  7,    477,  2,    478,  7,
      478,   2,    479,  7,    479,  2,    480,  7,    480,  2,    481,  7,    481,  2,    482,  7,    482,  2,    483,
      7,     483,  2,    484,  7,    484,  2,    485,  7,    485,  2,    486,  7,    486,  2,    487,  7,    487,  2,
      488,   7,    488,  2,    489,  7,    489,  2,    490,  7,    490,  2,    491,  7,    491,  2,    492,  7,    492,
      2,     493,  7,    493,  2,    494,  7,    494,  2,    495,  7,    495,  2,    496,  7,    496,  2,    497,  7,
      497,   2,    498,  7,    498,  2,    499,  7,    499,  2,    500,  7,    500,  2,    501,  7,    501,  2,    502,
      7,     502,  2,    503,  7,    503,  2,    504,  7,    504,  2,    505,  7,    505,  2,    506,  7,    506,  2,
      507,   7,    507,  2,    508,  7,    508,  2,    509,  7,    509,  2,    510,  7,    510,  2,    511,  7,    511,
      2,     512,  7,    512,  2,    513,  7,    513,  2,    514,  7,    514,  2,    515,  7,    515,  2,    516,  7,
      516,   2,    517,  7,    517,  2,    518,  7,    518,  2,    519,  7,    519,  2,    520,  7,    520,  2,    521,
      7,     521,  2,    522,  7,    522,  2,    523,  7,    523,  2,    524,  7,    524,  2,    525,  7,    525,  2,
      526,   7,    526,  2,    527,  7,    527,  2,    528,  7,    528,  2,    529,  7,    529,  2,    530,  7,    530,
      2,     531,  7,    531,  2,    532,  7,    532,  2,    533,  7,    533,  2,    534,  7,    534,  2,    535,  7,
      535,   2,    536,  7,    536,  2,    537,  7,    537,  2,    538,  7,    538,  2,    539,  7,    539,  2,    540,
      7,     540,  2,    541,  7,    541,  2,    542,  7,    542,  2,    543,  7,    543,  2,    544,  7,    544,  2,
      545,   7,    545,  2,    546,  7,    546,  2,    547,  7,    547,  2,    548,  7,    548,  2,    549,  7,    549,
      2,     550,  7,    550,  2,    551,  7,    551,  2,    552,  7,    552,  2,    553,  7,    553,  2,    554,  7,
      554,   2,    555,  7,    555,  2,    556,  7,    556,  2,    557,  7,    557,  2,    558,  7,    558,  2,    559,
      7,     559,  2,    560,  7,    560,  2,    561,  7,    561,  2,    562,  7,    562,  2,    563,  7,    563,  2,
      564,   7,    564,  2,    565,  7,    565,  2,    566,  7,    566,  2,    567,  7,    567,  2,    568,  7,    568,
      2,     569,  7,    569,  2,    570,  7,    570,  2,    571,  7,    571,  2,    572,  7,    572,  2,    573,  7,
      573,   2,    574,  7,    574,  2,    575,  7,    575,  2,    576,  7,    576,  2,    577,  7,    577,  2,    578,
      7,     578,  2,    579,  7,    579,  2,    580,  7,    580,  2,    581,  7,    581,  2,    582,  7,    582,  2,
      583,   7,    583,  2,    584,  7,    584,  2,    585,  7,    585,  2,    586,  7,    586,  2,    587,  7,    587,
      2,     588,  7,    588,  2,    589,  7,    589,  2,    590,  7,    590,  2,    591,  7,    591,  2,    592,  7,
      592,   2,    593,  7,    593,  2,    594,  7,    594,  2,    595,  7,    595,  2,    596,  7,    596,  2,    597,
      7,     597,  2,    598,  7,    598,  2,    599,  7,    599,  2,    600,  7,    600,  2,    601,  7,    601,  2,
      602,   7,    602,  2,    603,  7,    603,  2,    604,  7,    604,  2,    605,  7,    605,  2,    606,  7,    606,
      2,     607,  7,    607,  2,    608,  7,    608,  2,    609,  7,    609,  2,    610,  7,    610,  2,    611,  7,
      611,   2,    612,  7,    612,  2,    613,  7,    613,  2,    614,  7,    614,  2,    615,  7,    615,  2,    616,
      7,     616,  2,    617,  7,    617,  2,    618,  7,    618,  2,    619,  7,    619,  2,    620,  7,    620,  2,
      621,   7,    621,  2,    622,  7,    622,  2,    623,  7,    623,  2,    624,  7,    624,  2,    625,  7,    625,
      2,     626,  7,    626,  2,    627,  7,    627,  2,    628,  7,    628,  2,    629,  7,    629,  2,    630,  7,
      630,   2,    631,  7,    631,  2,    632,  7,    632,  2,    633,  7,    633,  2,    634,  7,    634,  2,    635,
      7,     635,  2,    636,  7,    636,  2,    637,  7,    637,  2,    638,  7,    638,  2,    639,  7,    639,  2,
      640,   7,    640,  2,    641,  7,    641,  2,    642,  7,    642,  2,    643,  7,    643,  2,    644,  7,    644,
      2,     645,  7,    645,  2,    646,  7,    646,  2,    647,  7,    647,  2,    648,  7,    648,  2,    649,  7,
      649,   2,    650,  7,    650,  2,    651,  7,    651,  2,    652,  7,    652,  2,    653,  7,    653,  2,    654,
      7,     654,  2,    655,  7,    655,  2,    656,  7,    656,  2,    657,  7,    657,  2,    658,  7,    658,  2,
      659,   7,    659,  2,    660,  7,    660,  2,    661,  7,    661,  2,    662,  7,    662,  2,    663,  7,    663,
      2,     664,  7,    664,  2,    665,  7,    665,  2,    666,  7,    666,  2,    667,  7,    667,  2,    668,  7,
      668,   2,    669,  7,    669,  2,    670,  7,    670,  2,    671,  7,    671,  2,    672,  7,    672,  2,    673,
      7,     673,  2,    674,  7,    674,  2,    675,  7,    675,  2,    676,  7,    676,  2,    677,  7,    677,  2,
      678,   7,    678,  2,    679,  7,    679,  2,    680,  7,    680,  2,    681,  7,    681,  2,    682,  7,    682,
      2,     683,  7,    683,  2,    684,  7,    684,  2,    685,  7,    685,  2,    686,  7,    686,  2,    687,  7,
      687,   2,    688,  7,    688,  2,    689,  7,    689,  2,    690,  7,    690,  2,    691,  7,    691,  2,    692,
      7,     692,  2,    693,  7,    693,  2,    694,  7,    694,  2,    695,  7,    695,  2,    696,  7,    696,  2,
      697,   7,    697,  2,    698,  7,    698,  2,    699,  7,    699,  2,    700,  7,    700,  2,    701,  7,    701,
      2,     702,  7,    702,  2,    703,  7,    703,  2,    704,  7,    704,  2,    705,  7,    705,  2,    706,  7,
      706,   2,    707,  7,    707,  2,    708,  7,    708,  2,    709,  7,    709,  2,    710,  7,    710,  2,    711,
      7,     711,  2,    712,  7,    712,  2,    713,  7,    713,  2,    714,  7,    714,  2,    715,  7,    715,  2,
      716,   7,    716,  2,    717,  7,    717,  2,    718,  7,    718,  2,    719,  7,    719,  2,    720,  7,    720,
      2,     721,  7,    721,  2,    722,  7,    722,  2,    723,  7,    723,  1,    0,    1,    0,    3,    0,    1451,
      8,     0,    1,    0,    3,    0,    1454, 8,    0,    3,    0,    1456, 8,    0,    1,    0,    1,    0,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
      1,     1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    3,    1,    1533, 8,    1,    1,    2,
      1,     2,    1,    2,    1,    2,    1,    2,    1,    2,    3,    2,    1541, 8,    2,    1,    2,    1,    2,
      1,     2,    3,    2,    1546, 8,    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,    1,    2,
      1,     2,    1,    2,    3,    2,    1556, 8,    2,    1,    3,    1,    3,    1,    3,    4,    3,    1561, 8,
      3,     11,   3,    12,   3,    1562, 1,    4,    1,    4,    1,    4,    1,    4,    3,    4,    1569, 8,    4,
      1,     4,    3,    4,    1572, 8,    4,    1,    5,    3,    5,    1575, 8,    5,    1,    5,    1,    5,    1,
      5,     1,    5,    1,    5,    3,    5,    1582, 8,    5,    1,    5,    1,    5,    1,    5,    3,    5,    1587,
      8,     5,    1,    5,    3,    5,    1590, 8,    5,    1,    5,    1,    5,    1,    5,    3,    5,    1595, 8,
      5,     1,    5,    1,    5,    1,    5,    1,    5,    3,    5,    1601, 8,    5,    3,    5,    1603, 8,    5,
      1,     5,    1,    5,    3,    5,    1607, 8,    5,    1,    5,    1,    5,    3,    5,    1611, 8,    5,    1,
      6,     1,    6,    1,    6,    1,    6,    1,    6,    1,    6,    1,    6,    3,    6,    1620, 8,    6,    1,
      7,     1,    7,    3,    7,    1624, 8,    7,    1,    7,    5,    7,    1627, 8,    7,    10,   7,    12,   7,
      1630,  9,    7,    1,    8,    1,    8,    1,    8,    3,    8,    1635, 8,    8,    1,    9,    1,    9,    1,
      9,     1,    9,    1,    10,   3,    10,   1642, 8,    10,   1,    10,   1,    10,   1,    10,   3,    10,   1647,
      8,     10,   1,    11,   1,    11,   1,    11,   3,    11,   1652, 8,    11,   1,    11,   1,    11,   1,    11,
      1,     11,   1,    11,   3,    11,   1659, 8,    11,   1,    11,   3,    11,   1662, 8,    11,   1,    12,   1,
      12,    1,    12,   1,    12,   3,    12,   1668, 8,    12,   1,    12,   3,    12,   1671, 8,    12,   1,    13,
      1,     13,   1,    13,   5,    13,   1676, 8,    13,   10,   13,   12,   13,   1679, 9,    13,   1,    14,   1,
      14,    1,    14,   1,    14,   1,    14,   1,    14,   1,    14,   3,    14,   1688, 8,    14,   1,    15,   1,
      15,    1,    15,   3,    15,   1693, 8,    15,   1,    15,   1,    15,   1,    15,   3,    15,   1698, 8,    15,
      1,     15,   1,    15,   1,    15,   1,    15,   1,    15,   1,    15,   3,    15,   1706, 8,    15,   1,    15,
      1,     15,   1,    15,   1,    15,   3,    15,   1712, 8,    15,   1,    15,   1,    15,   3,    15,   1716, 8,
      15,    1,    15,   1,    15,   1,    15,   3,    15,   1721, 8,    15,   1,    15,   1,    15,   1,    15,   1,
      15,    1,    15,   5,    15,   1728, 8,    15,   10,   15,   12,   15,   1731, 9,    15,   1,    15,   1,    15,
      1,     15,   3,    15,   1736, 8,    15,   1,    15,   1,    15,   5,    15,   1740, 8,    15,   10,   15,   12,
      15,    1743, 9,    15,   1,    15,   1,    15,   1,    15,   3,    15,   1748, 8,    15,   1,    15,   1,    15,
      1,     15,   1,    15,   1,    15,   1,    15,   1,    15,   3,    15,   1757, 8,    15,   1,    15,   1,    15,
      1,     15,   1,    15,   3,    15,   1763, 8,    15,   1,    15,   1,    15,   1,    15,   1,    15,   1,    15,
      1,     15,   1,    15,   3,    15,   1772, 8,    15,   1,    15,   1,    15,   1,    15,   1,    15,   1,    15,
      1,     15,   1,    15,   1,    15,   1,    15,   1,    15,   3,    15,   1784, 8,    15,   1,    16,   1,    16,
      3,     16,   1788, 8,    16,   1,    16,   1,    16,   1,    16,   1,    16,   3,    16,   1794, 8,    16,   5,
      16,    1796, 8,    16,   10,   16,   12,   16,   1799, 9,    16,   1,    17,   1,    17,   1,    17,   3,    17,
      1804,  8,    17,   1,    18,   1,    18,   3,    18,   1808, 8,    18,   1,    18,   1,    18,   1,    18,   3,
      18,    1813, 8,    18,   1,    18,   3,    18,   1816, 8,    18,   1,    18,   1,    18,   1,    18,   1,    18,
      3,     18,   1822, 8,    18,   1,    18,   1,    18,   1,    18,   1,    18,   3,    18,   1828, 8,    18,   1,
      18,    1,    18,   1,    18,   1,    18,   3,    18,   1834, 8,    18,   1,    18,   1,    18,   3,    18,   1838,
      8,     18,   1,    18,   1,    18,   1,    18,   3,    18,   1843, 8,    18,   1,    18,   1,    18,   3,    18,
      1847,  8,    18,   1,    18,   1,    18,   3,    18,   1851, 8,    18,   1,    18,   1,    18,   1,    18,   1,
      18,    1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,
      1,     18,   3,    18,   1867, 8,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,
      3,     18,   1875, 8,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   3,    18,
      1883,  8,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   3,    18,   1890, 8,    18,   1,
      18,    1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,
      1,     18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,
      18,    1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   3,    18,   1917, 8,    18,   1,    18,   1,
      18,    1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,   1,    18,
      1,     18,   1,    18,   3,    18,   1932, 8,    18,   1,    18,   3,    18,   1935, 8,    18,   1,    18,   1,
      18,    1,    18,   1,    18,   3,    18,   1941, 8,    18,   1,    19,   1,    19,   1,    19,   3,    19,   1946,
      8,     19,   1,    20,   1,    20,   1,    21,   1,    21,   3,    21,   1952, 8,    21,   1,    21,   1,    21,
      1,     21,   3,    21,   1957, 8,    21,   5,    21,   1959, 8,    21,   10,   21,   12,   21,   1962, 9,    21,
      1,     22,   1,    22,   3,    22,   1966, 8,    22,   1,    22,   1,    22,   3,    22,   1970, 8,    22,   1,
      23,    1,    23,   3,    23,   1974, 8,    23,   1,    23,   1,    23,   3,    23,   1978, 8,    23,   1,    24,
      1,     24,   3,    24,   1982, 8,    24,   1,    24,   1,    24,   3,    24,   1986, 8,    24,   3,    24,   1988,
      8,     24,   1,    25,   1,    25,   1,    25,   1,    26,   1,    26,   1,    26,   1,    27,   1,    27,   3,
      27,    1998, 8,    27,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   3,    28,   2006,
      8,     28,   1,    28,   1,    28,   1,    28,   1,    28,   1,    28,   3,    28,   2013, 8,    28,   1,    29,
      1,     29,   1,    29,   1,    29,   1,    29,   1,    29,   3,    29,   2021, 8,    29,   1,    30,   1,    30,
      3,     30,   2025, 8,    30,   1,    30,   5,    30,   2028, 8,    30,   10,   30,   12,   30,   2031, 9,    30,
      1,     31,   1,    31,   1,    32,   1,    32,   3,    32,   2037, 8,    32,   1,    32,   5,    32,   2040, 8,
      32,    10,   32,   12,   32,   2043, 9,    32,   1,    33,   1,    33,   3,    33,   2047, 8,    33,   1,    33,
      1,     33,   1,    33,   1,    33,   1,    33,   1,    33,   1,    33,   1,    33,   3,    33,   2057, 8,    33,
      1,     34,   1,    34,   3,    34,   2061, 8,    34,   1,    34,   1,    34,   1,    34,   3,    34,   2066, 8,
      34,    1,    35,   3,    35,   2069, 8,    35,   1,    35,   3,    35,   2072, 8,    35,   1,    35,   3,    35,
      2075,  8,    35,   1,    35,   1,    35,   1,    35,   1,    35,   1,    36,   3,    36,   2082, 8,    36,   1,
      36,    1,    36,   1,    36,   1,    37,   1,    37,   3,    37,   2089, 8,    37,   1,    38,   1,    38,   3,
      38,    2093, 8,    38,   1,    38,   1,    38,   1,    38,   1,    39,   1,    39,   1,    39,   1,    39,   1,
      39,    1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,
      1,     39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   3,    39,   2118, 8,    39,   3,    39,
      2120,  8,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   1,    39,   3,    39,   2128, 8,
      39,    3,    39,   2130, 8,    39,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,
      40,    1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,   1,    40,
      1,     40,   1,    40,   3,    40,   2150, 8,    40,   1,    41,   1,    41,   3,    41,   2154, 8,    41,   1,
      41,    1,    41,   5,    41,   2158, 8,    41,   10,   41,   12,   41,   2161, 9,    41,   1,    42,   1,    42,
      1,     42,   1,    42,   3,    42,   2167, 8,    42,   1,    43,   3,    43,   2170, 8,    43,   1,    43,   1,
      43,    3,    43,   2174, 8,    43,   1,    43,   1,    43,   1,    43,   1,    43,   1,    43,   3,    43,   2181,
      8,     43,   1,    43,   3,    43,   2184, 8,    43,   1,    43,   1,    43,   1,    43,   1,    43,   1,    43,
      1,     43,   1,    43,   3,    43,   2193, 8,    43,   1,    44,   1,    44,   1,    44,   5,    44,   2198, 8,
      44,    10,   44,   12,   44,   2201, 9,    44,   1,    45,   1,    45,   3,    45,   2205, 8,    45,   1,    46,
      3,     46,   2208, 8,    46,   1,    46,   1,    46,   1,    47,   3,    47,   2213, 8,    47,   1,    47,   1,
      47,    1,    48,   1,    48,   1,    48,   3,    48,   2220, 8,    48,   1,    48,   3,    48,   2223, 8,    48,
      1,     49,   1,    49,   3,    49,   2227, 8,    49,   1,    50,   1,    50,   1,    50,   1,    50,   3,    50,
      2233,  8,    50,   1,    50,   3,    50,   2236, 8,    50,   1,    50,   1,    50,   1,    51,   3,    51,   2241,
      8,     51,   1,    51,   1,    51,   3,    51,   2245, 8,    51,   1,    51,   1,    51,   1,    51,   1,    51,
      1,     51,   5,    51,   2252, 8,    51,   10,   51,   12,   51,   2255, 9,    51,   3,    51,   2257, 8,    51,
      1,     51,   1,    51,   5,    51,   2261, 8,    51,   10,   51,   12,   51,   2264, 9,    51,   1,    51,   1,
      51,    1,    52,   3,    52,   2269, 8,    52,   1,    52,   1,    52,   3,    52,   2273, 8,    52,   1,    52,
      1,     52,   1,    52,   1,    52,   1,    52,   5,    52,   2280, 8,    52,   10,   52,   12,   52,   2283, 9,
      52,    3,    52,   2285, 8,    52,   1,    52,   1,    52,   1,    52,   1,    52,   5,    52,   2291, 8,    52,
      10,    52,   12,   52,   2294, 9,    52,   1,    52,   1,    52,   1,    53,   3,    53,   2299, 8,    53,   1,
      53,    1,    53,   3,    53,   2303, 8,    53,   1,    53,   1,    53,   1,    53,   1,    53,   1,    53,   1,
      53,    1,    54,   1,    54,   3,    54,   2313, 8,    54,   1,    54,   3,    54,   2316, 8,    54,   1,    55,
      4,     55,   2319, 8,    55,   11,   55,   12,   55,   2320, 1,    56,   1,    56,   1,    56,   1,    56,   1,
      56,    1,    56,   1,    56,   1,    56,   1,    56,   1,    56,   1,    56,   1,    56,   1,    56,   1,    56,
      1,     56,   1,    56,   1,    56,   3,    56,   2340, 8,    56,   1,    57,   3,    57,   2343, 8,    57,   1,
      57,    3,    57,   2346, 8,    57,   1,    57,   1,    57,   1,    57,   3,    57,   2351, 8,    57,   1,    57,
      1,     57,   5,    57,   2355, 8,    57,   10,   57,   12,   57,   2358, 9,    57,   1,    57,   1,    57,   1,
      57,    1,    57,   1,    57,   5,    57,   2365, 8,    57,   10,   57,   12,   57,   2368, 9,    57,   1,    57,
      1,     57,   1,    57,   1,    57,   1,    57,   5,    57,   2375, 8,    57,   10,   57,   12,   57,   2378, 9,
      57,    3,    57,   2380, 8,    57,   1,    57,   3,    57,   2383, 8,    57,   1,    58,   1,    58,   3,    58,
      2387,  8,    58,   1,    58,   1,    58,   1,    58,   1,    58,   1,    58,   1,    58,   3,    58,   2395, 8,
      58,    1,    59,   1,    59,   1,    59,   1,    59,   1,    60,   1,    60,   1,    60,   1,    60,   1,    60,
      1,     60,   1,    60,   3,    60,   2408, 8,    60,   1,    61,   1,    61,   3,    61,   2412, 8,    61,   1,
      61,    5,    61,   2415, 8,    61,   10,   61,   12,   61,   2418, 9,    61,   1,    62,   1,    62,   1,    62,
      1,     62,   1,    62,   1,    62,   3,    62,   2426, 8,    62,   1,    63,   1,    63,   1,    63,   1,    63,
      1,     63,   1,    63,   1,    63,   1,    63,   1,    64,   1,    64,   1,    64,   1,    64,   1,    64,   5,
      64,    2441, 8,    64,   10,   64,   12,   64,   2444, 9,    64,   1,    64,   1,    64,   1,    65,   1,    65,
      1,     65,   1,    65,   1,    65,   1,    65,   1,    65,   1,    65,   1,    65,   1,    65,   1,    65,   1,
      65,    1,    65,   1,    65,   3,    65,   2462, 8,    65,   1,    66,   1,    66,   1,    66,   1,    66,   1,
      66,    1,    66,   1,    66,   3,    66,   2471, 8,    66,   1,    66,   3,    66,   2474, 8,    66,   1,    67,
      1,     67,   1,    67,   1,    67,   1,    67,   1,    67,   3,    67,   2482, 8,    67,   1,    68,   1,    68,
      1,     68,   1,    68,   1,    68,   3,    68,   2489, 8,    68,   3,    68,   2491, 8,    68,   1,    69,   1,
      69,    1,    69,   1,    70,   1,    70,   3,    70,   2498, 8,    70,   1,    70,   5,    70,   2501, 8,    70,
      10,    70,   12,   70,   2504, 9,    70,   1,    71,   1,    71,   1,    71,   1,    71,   1,    71,   1,    71,
      1,     71,   1,    71,   1,    71,   1,    71,   1,    71,   3,    71,   2517, 8,    71,   1,    72,   1,    72,
      3,     72,   2521, 8,    72,   1,    72,   1,    72,   1,    73,   1,    73,   3,    73,   2527, 8,    73,   1,
      73,    1,    73,   1,    74,   1,    74,   3,    74,   2533, 8,    74,   1,    74,   1,    74,   1,    75,   1,
      75,    3,    75,   2539, 8,    75,   1,    75,   1,    75,   1,    76,   1,    76,   3,    76,   2545, 8,    76,
      1,     76,   1,    76,   1,    77,   1,    77,   3,    77,   2551, 8,    77,   1,    77,   1,    77,   1,    78,
      3,     78,   2556, 8,    78,   1,    78,   1,    78,   3,    78,   2560, 8,    78,   1,    78,   1,    78,   1,
      79,    1,    79,   1,    80,   1,    80,   3,    80,   2568, 8,    80,   1,    80,   1,    80,   1,    81,   1,
      81,    3,    81,   2574, 8,    81,   1,    81,   1,    81,   1,    82,   1,    82,   3,    82,   2580, 8,    82,
      1,     82,   1,    82,   1,    83,   1,    83,   3,    83,   2586, 8,    83,   1,    83,   1,    83,   1,    84,
      3,     84,   2591, 8,    84,   1,    84,   3,    84,   2594, 8,    84,   1,    84,   3,    84,   2597, 8,    84,
      1,     84,   1,    84,   1,    84,   1,    84,   1,    85,   1,    85,   1,    85,   3,    85,   2606, 8,    85,
      1,     85,   3,    85,   2609, 8,    85,   1,    86,   1,    86,   1,    86,   1,    86,   1,    87,   1,    87,
      1,     87,   1,    87,   1,    88,   3,    88,   2620, 8,    88,   1,    88,   1,    88,   3,    88,   2624, 8,
      88,    1,    88,   1,    88,   1,    88,   1,    88,   1,    88,   1,    88,   1,    88,   1,    88,   1,    88,
      3,     88,   2635, 8,    88,   1,    88,   1,    88,   1,    89,   1,    89,   1,    89,   1,    90,   3,    90,
      2643,  8,    90,   1,    90,   1,    90,   3,    90,   2647, 8,    90,   1,    90,   1,    90,   1,    90,   1,
      90,    1,    90,   1,    90,   1,    90,   3,    90,   2656, 8,    90,   1,    90,   3,    90,   2659, 8,    90,
      1,     90,   1,    90,   1,    90,   1,    90,   3,    90,   2665, 8,    90,   3,    90,   2667, 8,    90,   1,
      90,    1,    90,   3,    90,   2671, 8,    90,   1,    90,   1,    90,   1,    90,   1,    91,   1,    91,   3,
      91,    2678, 8,    91,   1,    91,   1,    91,   1,    92,   1,    92,   1,    92,   1,    92,   1,    92,   1,
      92,    1,    92,   5,    92,   2689, 8,    92,   10,   92,   12,   92,   2692, 9,    92,   1,    92,   1,    92,
      1,     92,   1,    92,   3,    92,   2698, 8,    92,   1,    92,   1,    92,   5,    92,   2702, 8,    92,   10,
      92,    12,   92,   2705, 9,    92,   3,    92,   2707, 8,    92,   1,    93,   1,    93,   1,    93,   1,    93,
      1,     93,   1,    93,   1,    93,   1,    93,   1,    93,   1,    93,   1,    93,   1,    93,   1,    93,   1,
      93,    1,    93,   3,    93,   2724, 8,    93,   1,    94,   1,    94,   1,    94,   1,    94,   1,    94,   1,
      94,    1,    94,   1,    94,   1,    94,   1,    94,   1,    94,   1,    94,   1,    94,   1,    94,   1,    94,
      1,     94,   1,    94,   3,    94,   2743, 8,    94,   1,    95,   1,    95,   3,    95,   2747, 8,    95,   1,
      95,    1,    95,   1,    96,   1,    96,   3,    96,   2753, 8,    96,   1,    96,   1,    96,   1,    97,   1,
      97,    3,    97,   2759, 8,    97,   1,    97,   1,    97,   1,    98,   1,    98,   3,    98,   2765, 8,    98,
      1,     98,   1,    98,   1,    99,   3,    99,   2770, 8,    99,   1,    99,   1,    99,   1,    99,   1,    99,
      1,     99,   3,    99,   2777, 8,    99,   1,    100,  1,    100,  1,    100,  1,    100,  1,    100,  3,    100,
      2784,  8,    100,  1,    100,  5,    100,  2787, 8,    100,  10,   100,  12,   100,  2790, 9,    100,  3,    100,
      2792,  8,    100,  1,    101,  1,    101,  3,    101,  2796, 8,    101,  1,    102,  1,    102,  3,    102,  2800,
      8,     102,  1,    102,  1,    102,  1,    103,  3,    103,  2805, 8,    103,  1,    103,  1,    103,  3,    103,
      2809,  8,    103,  1,    103,  1,    103,  3,    103,  2813, 8,    103,  1,    104,  1,    104,  1,    104,  1,
      104,   3,    104,  2819, 8,    104,  1,    104,  5,    104,  2822, 8,    104,  10,   104,  12,   104,  2825, 9,
      104,   3,    104,  2827, 8,    104,  1,    105,  1,    105,  3,    105,  2831, 8,    105,  1,    105,  1,    105,
      1,     106,  1,    106,  3,    106,  2837, 8,    106,  1,    106,  1,    106,  3,    106,  2841, 8,    106,  1,
      107,   1,    107,  3,    107,  2845, 8,    107,  1,    107,  1,    107,  1,    108,  1,    108,  1,    108,  1,
      108,   3,    108,  2853, 8,    108,  1,    108,  1,    108,  1,    109,  1,    109,  1,    109,  1,    109,  3,
      109,   2861, 8,    109,  1,    110,  1,    110,  1,    110,  1,    110,  1,    110,  5,    110,  2868, 8,    110,
      10,    110,  12,   110,  2871, 9,    110,  1,    111,  1,    111,  1,    111,  1,    111,  1,    112,  1,    112,
      3,     112,  2879, 8,    112,  1,    112,  1,    112,  1,    113,  1,    113,  1,    113,  1,    113,  1,    113,
      1,     114,  1,    114,  1,    114,  1,    114,  3,    114,  2892, 8,    114,  1,    114,  3,    114,  2895, 8,
      114,   1,    115,  3,    115,  2898, 8,    115,  1,    115,  1,    115,  5,    115,  2902, 8,    115,  10,   115,
      12,    115,  2905, 9,    115,  1,    115,  1,    115,  1,    115,  1,    115,  1,    115,  3,    115,  2912, 8,
      115,   1,    115,  1,    115,  1,    115,  3,    115,  2917, 8,    115,  1,    115,  3,    115,  2920, 8,    115,
      1,     115,  3,    115,  2923, 8,    115,  1,    115,  3,    115,  2926, 8,    115,  1,    115,  3,    115,  2929,
      8,     115,  3,    115,  2931, 8,    115,  1,    115,  1,    115,  1,    115,  1,    115,  3,    115,  2937, 8,
      115,   3,    115,  2939, 8,    115,  1,    116,  1,    116,  1,    116,  1,    116,  1,    116,  1,    117,  1,
      117,   1,    118,  1,    118,  1,    118,  1,    119,  1,    119,  1,    119,  1,    119,  3,    119,  2955, 8,
      119,   1,    119,  1,    119,  1,    119,  1,    119,  1,    119,  3,    119,  2962, 8,    119,  1,    119,  3,
      119,   2965, 8,    119,  3,    119,  2967, 8,    119,  3,    119,  2969, 8,    119,  1,    120,  1,    120,  1,
      120,   1,    120,  1,    120,  1,    120,  1,    120,  1,    120,  3,    120,  2979, 8,    120,  3,    120,  2981,
      8,     120,  1,    121,  1,    121,  3,    121,  2985, 8,    121,  1,    121,  3,    121,  2988, 8,    121,  1,
      121,   3,    121,  2991, 8,    121,  1,    121,  1,    121,  3,    121,  2995, 8,    121,  1,    121,  1,    121,
      1,     121,  3,    121,  3000, 8,    121,  1,    121,  1,    121,  1,    121,  1,    121,  3,    121,  3006, 8,
      121,   1,    121,  3,    121,  3009, 8,    121,  1,    121,  3,    121,  3012, 8,    121,  1,    122,  1,    122,
      1,     123,  1,    123,  3,    123,  3018, 8,    123,  1,    123,  3,    123,  3021, 8,    123,  1,    123,  1,
      123,   1,    124,  1,    124,  1,    124,  5,    124,  3028, 8,    124,  10,   124,  12,   124,  3031, 9,    124,
      1,     125,  1,    125,  1,    125,  1,    126,  1,    126,  1,    126,  1,    126,  3,    126,  3040, 8,    126,
      1,     126,  3,    126,  3043, 8,    126,  1,    126,  3,    126,  3046, 8,    126,  1,    127,  1,    127,  3,
      127,   3050, 8,    127,  1,    127,  1,    127,  1,    127,  1,    127,  3,    127,  3056, 8,    127,  1,    127,
      5,     127,  3059, 8,    127,  10,   127,  12,   127,  3062, 9,    127,  1,    128,  1,    128,  3,    128,  3066,
      8,     128,  1,    128,  1,    128,  1,    128,  3,    128,  3071, 8,    128,  5,    128,  3073, 8,    128,  10,
      128,   12,   128,  3076, 9,    128,  1,    129,  1,    129,  1,    129,  3,    129,  3081, 8,    129,  1,    130,
      1,     130,  1,    130,  1,    130,  1,    130,  1,    130,  1,    131,  1,    131,  1,    131,  3,    131,  3092,
      8,     131,  1,    131,  3,    131,  3095, 8,    131,  1,    131,  1,    131,  1,    131,  3,    131,  3100, 8,
      131,   1,    131,  1,    131,  1,    131,  1,    131,  3,    131,  3106, 8,    131,  1,    131,  3,    131,  3109,
      8,     131,  1,    131,  3,    131,  3112, 8,    131,  1,    131,  3,    131,  3115, 8,    131,  1,    131,  3,
      131,   3118, 8,    131,  1,    131,  1,    131,  1,    132,  1,    132,  1,    133,  1,    133,  1,    133,  1,
      133,   1,    133,  1,    134,  1,    134,  1,    134,  3,    134,  3132, 8,    134,  1,    134,  3,    134,  3135,
      8,     134,  1,    134,  1,    134,  3,    134,  3139, 8,    134,  1,    135,  1,    135,  3,    135,  3143, 8,
      135,   1,    135,  1,    135,  1,    136,  1,    136,  1,    136,  1,    136,  3,    136,  3151, 8,    136,  1,
      136,   1,    136,  1,    136,  1,    136,  1,    136,  1,    136,  3,    136,  3159, 8,    136,  5,    136,  3161,
      8,     136,  10,   136,  12,   136,  3164, 9,    136,  1,    137,  1,    137,  3,    137,  3168, 8,    137,  1,
      137,   3,    137,  3171, 8,    137,  1,    137,  1,    137,  3,    137,  3175, 8,    137,  1,    137,  1,    137,
      1,     137,  1,    137,  3,    137,  3181, 8,    137,  1,    138,  1,    138,  3,    138,  3185, 8,    138,  1,
      138,   3,    138,  3188, 8,    138,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,
      139,   3,    139,  3197, 8,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,    139,  1,
      139,   1,    139,  3,    139,  3207, 8,    139,  1,    140,  3,    140,  3210, 8,    140,  1,    140,  1,    140,
      3,     140,  3214, 8,    140,  1,    140,  3,    140,  3217, 8,    140,  1,    141,  1,    141,  3,    141,  3221,
      8,     141,  1,    141,  1,    141,  1,    141,  3,    141,  3226, 8,    141,  1,    141,  3,    141,  3229, 8,
      141,   1,    141,  5,    141,  3232, 8,    141,  10,   141,  12,   141,  3235, 9,    141,  1,    142,  1,    142,
      1,     142,  3,    142,  3240, 8,    142,  1,    142,  1,    142,  1,    143,  1,    143,  1,    143,  1,    143,
      1,     143,  3,    143,  3249, 8,    143,  1,    144,  1,    144,  5,    144,  3253, 8,    144,  10,   144,  12,
      144,   3256, 9,    144,  1,    144,  1,    144,  3,    144,  3260, 8,    144,  1,    144,  3,    144,  3263, 8,
      144,   1,    144,  3,    144,  3266, 8,    144,  1,    144,  3,    144,  3269, 8,    144,  1,    144,  3,    144,
      3272,  8,    144,  1,    144,  3,    144,  3275, 8,    144,  1,    145,  1,    145,  1,    146,  1,    146,  1,
      147,   1,    147,  1,    147,  1,    148,  1,    148,  1,    148,  1,    149,  1,    149,  1,    149,  3,    149,
      3290,  8,    149,  1,    150,  1,    150,  3,    150,  3294, 8,    150,  1,    151,  1,    151,  1,    151,  1,
      151,   3,    151,  3300, 8,    151,  1,    151,  3,    151,  3303, 8,    151,  1,    151,  3,    151,  3306, 8,
      151,   1,    151,  1,    151,  1,    151,  1,    151,  3,    151,  3312, 8,    151,  1,    151,  1,    151,  1,
      151,   3,    151,  3317, 8,    151,  5,    151,  3319, 8,    151,  10,   151,  12,   151,  3322, 9,    151,  3,
      151,   3324, 8,    151,  1,    152,  1,    152,  1,    152,  1,    152,  1,    152,  3,    152,  3331, 8,    152,
      3,     152,  3333, 8,    152,  1,    152,  1,    152,  1,    153,  1,    153,  1,    153,  1,    154,  1,    154,
      1,     154,  1,    154,  5,    154,  3344, 8,    154,  10,   154,  12,   154,  3347, 9,    154,  1,    155,  1,
      155,   1,    155,  1,    155,  1,    156,  1,    156,  1,    156,  1,    156,  1,    157,  3,    157,  3358, 8,
      157,   1,    157,  1,    157,  1,    157,  3,    157,  3363, 8,    157,  1,    157,  3,    157,  3366, 8,    157,
      1,     157,  3,    157,  3369, 8,    157,  1,    158,  1,    158,  1,    158,  3,    158,  3374, 8,    158,  1,
      159,   1,    159,  1,    160,  1,    160,  3,    160,  3380, 8,    160,  1,    161,  1,    161,  1,    161,  1,
      161,   1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,  1,    161,
      1,     161,  3,    161,  3396, 8,    161,  1,    162,  1,    162,  1,    162,  1,    162,  1,    162,  1,    163,
      1,     163,  1,    163,  1,    163,  1,    163,  1,    163,  1,    163,  1,    163,  1,    163,  1,    163,  1,
      163,   1,    163,  1,    163,  3,    163,  3416, 8,    163,  1,    164,  1,    164,  1,    164,  1,    164,  1,
      164,   1,    164,  1,    164,  3,    164,  3425, 8,    164,  1,    165,  1,    165,  3,    165,  3429, 8,    165,
      1,     165,  1,    165,  1,    165,  5,    165,  3434, 8,    165,  10,   165,  12,   165,  3437, 9,    165,  1,
      166,   1,    166,  3,    166,  3441, 8,    166,  1,    166,  1,    166,  1,    166,  1,    167,  1,    167,  1,
      167,   1,    167,  3,    167,  3450, 8,    167,  1,    168,  1,    168,  1,    168,  1,    169,  1,    169,  1,
      169,   1,    169,  1,    170,  1,    170,  1,    171,  1,    171,  1,    171,  3,    171,  3464, 8,    171,  1,
      172,   1,    172,  1,    172,  5,    172,  3469, 8,    172,  10,   172,  12,   172,  3472, 9,    172,  1,    173,
      1,     173,  1,    173,  1,    173,  5,    173,  3478, 8,    173,  10,   173,  12,   173,  3481, 9,    173,  1,
      174,   1,    174,  1,    174,  1,    175,  1,    175,  1,    175,  3,    175,  3489, 8,    175,  1,    175,  1,
      175,   1,    176,  1,    176,  3,    176,  3495, 8,    176,  1,    177,  4,    177,  3498, 8,    177,  11,   177,
      12,    177,  3499, 1,    178,  1,    178,  1,    178,  1,    178,  3,    178,  3506, 8,    178,  1,    178,  3,
      178,   3509, 8,    178,  1,    178,  1,    178,  1,    178,  1,    178,  3,    178,  3515, 8,    178,  1,    179,
      1,     179,  1,    180,  1,    180,  1,    180,  3,    180,  3522, 8,    180,  1,    181,  1,    181,  3,    181,
      3526,  8,    181,  1,    181,  1,    181,  5,    181,  3530, 8,    181,  10,   181,  12,   181,  3533, 9,    181,
      1,     182,  1,    182,  1,    182,  3,    182,  3538, 8,    182,  3,    182,  3540, 8,    182,  1,    183,  3,
      183,   3543, 8,    183,  1,    183,  1,    183,  3,    183,  3547, 8,    183,  1,    184,  1,    184,  1,    184,
      1,     185,  1,    185,  1,    185,  1,    185,  1,    185,  3,    185,  3557, 8,    185,  1,    185,  1,    185,
      1,     185,  3,    185,  3562, 8,    185,  1,    185,  5,    185,  3565, 8,    185,  10,   185,  12,   185,  3568,
      9,     185,  1,    186,  1,    186,  5,    186,  3572, 8,    186,  10,   186,  12,   186,  3575, 9,    186,  1,
      187,   1,    187,  1,    187,  1,    187,  1,    187,  1,    187,  3,    187,  3583, 8,    187,  1,    187,  1,
      187,   1,    187,  1,    187,  1,    187,  1,    187,  3,    187,  3591, 8,    187,  1,    187,  1,    187,  1,
      187,   3,    187,  3596, 8,    187,  1,    188,  1,    188,  3,    188,  3600, 8,    188,  1,    188,  1,    188,
      1,     188,  1,    188,  3,    188,  3606, 8,    188,  1,    188,  3,    188,  3609, 8,    188,  1,    189,  3,
      189,   3612, 8,    189,  1,    189,  1,    189,  3,    189,  3616, 8,    189,  1,    190,  1,    190,  3,    190,
      3620,  8,    190,  1,    190,  1,    190,  1,    191,  1,    191,  1,    191,  1,    191,  1,    191,  1,    191,
      3,     191,  3630, 8,    191,  1,    192,  1,    192,  3,    192,  3634, 8,    192,  1,    192,  3,    192,  3637,
      8,     192,  1,    192,  3,    192,  3640, 8,    192,  1,    193,  1,    193,  1,    193,  3,    193,  3645, 8,
      193,   1,    193,  1,    193,  1,    194,  1,    194,  3,    194,  3651, 8,    194,  1,    194,  3,    194,  3654,
      8,     194,  1,    194,  1,    194,  1,    194,  1,    194,  3,    194,  3660, 8,    194,  1,    194,  3,    194,
      3663,  8,    194,  3,    194,  3665, 8,    194,  1,    195,  1,    195,  1,    195,  3,    195,  3670, 8,    195,
      1,     195,  1,    195,  1,    196,  1,    196,  1,    196,  1,    196,  1,    196,  1,    196,  1,    196,  1,
      196,   3,    196,  3682, 8,    196,  1,    197,  1,    197,  1,    197,  1,    197,  1,    197,  5,    197,  3689,
      8,     197,  10,   197,  12,   197,  3692, 9,    197,  1,    197,  1,    197,  1,    198,  1,    198,  1,    198,
      1,     198,  1,    198,  1,    198,  1,    198,  1,    198,  3,    198,  3704, 8,    198,  1,    198,  3,    198,
      3707,  8,    198,  1,    198,  1,    198,  1,    198,  3,    198,  3712, 8,    198,  1,    198,  1,    198,  1,
      198,   1,    198,  1,    198,  3,    198,  3719, 8,    198,  1,    199,  1,    199,  3,    199,  3723, 8,    199,
      1,     199,  3,    199,  3726, 8,    199,  1,    200,  1,    200,  1,    200,  1,    200,  3,    200,  3732, 8,
      200,   1,    201,  1,    201,  1,    201,  1,    201,  1,    202,  1,    202,  1,    202,  1,    202,  1,    203,
      1,     203,  1,    203,  1,    203,  3,    203,  3746, 8,    203,  1,    204,  1,    204,  1,    205,  1,    205,
      1,     205,  3,    205,  3753, 8,    205,  1,    205,  1,    205,  1,    206,  1,    206,  1,    206,  5,    206,
      3760,  8,    206,  10,   206,  12,   206,  3763, 9,    206,  1,    207,  1,    207,  1,    207,  3,    207,  3768,
      8,     207,  1,    207,  1,    207,  1,    207,  1,    207,  1,    207,  1,    207,  1,    207,  3,    207,  3777,
      8,     207,  1,    207,  1,    207,  3,    207,  3781, 8,    207,  1,    207,  1,    207,  3,    207,  3785, 8,
      207,   1,    208,  1,    208,  1,    209,  1,    209,  1,    210,  1,    210,  1,    210,  1,    210,  3,    210,
      3795,  8,    210,  3,    210,  3797, 8,    210,  1,    211,  1,    211,  1,    211,  1,    211,  1,    211,  1,
      211,   3,    211,  3805, 8,    211,  1,    212,  1,    212,  1,    212,  5,    212,  3810, 8,    212,  10,   212,
      12,    212,  3813, 9,    212,  1,    213,  1,    213,  3,    213,  3817, 8,    213,  1,    214,  3,    214,  3820,
      8,     214,  1,    214,  1,    214,  3,    214,  3824, 8,    214,  1,    214,  3,    214,  3827, 8,    214,  1,
      214,   1,    214,  1,    214,  1,    214,  3,    214,  3833, 8,    214,  1,    214,  3,    214,  3836, 8,    214,
      1,     214,  3,    214,  3839, 8,    214,  1,    215,  1,    215,  1,    215,  1,    215,  3,    215,  3845, 8,
      215,   1,    216,  1,    216,  1,    216,  5,    216,  3850, 8,    216,  10,   216,  12,   216,  3853, 9,    216,
      1,     216,  1,    216,  3,    216,  3857, 8,    216,  1,    216,  1,    216,  3,    216,  3861, 8,    216,  1,
      216,   3,    216,  3864, 8,    216,  1,    216,  3,    216,  3867, 8,    216,  1,    216,  3,    216,  3870, 8,
      216,   3,    216,  3872, 8,    216,  1,    217,  1,    217,  3,    217,  3876, 8,    217,  1,    218,  1,    218,
      1,     218,  1,    218,  1,    218,  3,    218,  3883, 8,    218,  1,    219,  1,    219,  1,    219,  1,    219,
      3,     219,  3889, 8,    219,  1,    219,  1,    219,  3,    219,  3893, 8,    219,  1,    219,  1,    219,  1,
      219,   3,    219,  3898, 8,    219,  1,    219,  3,    219,  3901, 8,    219,  1,    219,  3,    219,  3904, 8,
      219,   1,    219,  3,    219,  3907, 8,    219,  3,    219,  3909, 8,    219,  1,    219,  1,    219,  1,    219,
      3,     219,  3914, 8,    219,  1,    220,  1,    220,  1,    220,  1,    220,  1,    220,  5,    220,  3921, 8,
      220,   10,   220,  12,   220,  3924, 9,    220,  1,    220,  1,    220,  1,    220,  1,    220,  1,    220,  1,
      220,   3,    220,  3932, 8,    220,  1,    221,  1,    221,  3,    221,  3936, 8,    221,  1,    221,  1,    221,
      1,     222,  1,    222,  3,    222,  3942, 8,    222,  1,    222,  3,    222,  3945, 8,    222,  1,    222,  3,
      222,   3948, 8,    222,  1,    223,  1,    223,  1,    223,  1,    223,  3,    223,  3954, 8,    223,  1,    223,
      1,     223,  1,    223,  1,    223,  1,    223,  3,    223,  3961, 8,    223,  3,    223,  3963, 8,    223,  1,
      223,   1,    223,  1,    223,  1,    223,  1,    223,  1,    223,  3,    223,  3971, 8,    223,  1,    223,  1,
      223,   1,    223,  1,    223,  3,    223,  3977, 8,    223,  3,    223,  3979, 8,    223,  1,    224,  1,    224,
      1,     224,  1,    225,  1,    225,  1,    225,  1,    225,  1,    225,  3,    225,  3989, 8,    225,  3,    225,
      3991,  8,    225,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  3,    226,
      4000,  8,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  5,    226,  4007, 8,    226,  10,
      226,   12,   226,  4010, 9,    226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  3,    226,  4017,
      8,     226,  1,    226,  1,    226,  1,    226,  1,    226,  1,    226,  3,    226,  4024, 8,    226,  1,    227,
      1,     227,  3,    227,  4028, 8,    227,  1,    227,  1,    227,  3,    227,  4032, 8,    227,  1,    227,  3,
      227,   4035, 8,    227,  3,    227,  4037, 8,    227,  1,    228,  1,    228,  1,    228,  1,    229,  1,    229,
      1,     229,  1,    229,  3,    229,  4046, 8,    229,  1,    229,  1,    229,  1,    229,  1,    230,  1,    230,
      1,     230,  1,    230,  3,    230,  4055, 8,    230,  1,    231,  1,    231,  1,    231,  1,    231,  1,    231,
      3,     231,  4062, 8,    231,  1,    232,  1,    232,  1,    232,  5,    232,  4067, 8,    232,  10,   232,  12,
      232,   4070, 9,    232,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,
      1,     233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,
      233,   1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  1,    233,  3,    233,  4200, 8,    233,  1,
      234,   1,    234,  1,    235,  1,    235,  1,    236,  1,    236,  1,    237,  1,    237,  1,    238,  1,    238,
      1,     239,  1,    239,  1,    240,  1,    240,  1,    241,  1,    241,  1,    242,  1,    242,  1,    243,  1,
      243,   1,    244,  1,    244,  1,    245,  1,    245,  1,    246,  1,    246,  1,    247,  1,    247,  1,    248,
      1,     248,  1,    249,  1,    249,  1,    250,  1,    250,  1,    251,  1,    251,  1,    252,  1,    252,  1,
      253,   1,    253,  1,    254,  1,    254,  1,    255,  1,    255,  1,    256,  1,    256,  1,    257,  1,    257,
      1,     258,  1,    258,  1,    259,  1,    259,  3,    259,  4254, 8,    259,  1,    260,  1,    260,  1,    261,
      1,     261,  1,    261,  3,    261,  4261, 8,    261,  1,    262,  1,    262,  3,    262,  4265, 8,    262,  1,
      263,   1,    263,  1,    263,  1,    263,  1,    263,  1,    263,  1,    263,  1,    263,  1,    263,  1,    263,
      1,     263,  1,    263,  1,    263,  1,    263,  3,    263,  4281, 8,    263,  1,    264,  1,    264,  1,    265,
      1,     265,  1,    266,  1,    266,  1,    266,  1,    266,  5,    266,  4291, 8,    266,  10,   266,  12,   266,
      4294,  9,    266,  3,    266,  4296, 8,    266,  1,    266,  1,    266,  1,    267,  1,    267,  1,    267,  1,
      267,   1,    267,  1,    267,  5,    267,  4306, 8,    267,  10,   267,  12,   267,  4309, 9,    267,  1,    267,
      3,     267,  4312, 8,    267,  1,    268,  1,    268,  1,    268,  1,    268,  3,    268,  4318, 8,    268,  1,
      268,   1,    268,  1,    268,  1,    268,  1,    268,  3,    268,  4325, 8,    268,  1,    268,  1,    268,  1,
      268,   1,    268,  1,    268,  3,    268,  4332, 8,    268,  1,    268,  1,    268,  1,    268,  1,    268,  1,
      268,   3,    268,  4339, 8,    268,  1,    268,  1,    268,  1,    268,  1,    268,  1,    268,  3,    268,  4346,
      8,     268,  1,    268,  1,    268,  1,    268,  1,    268,  1,    268,  3,    268,  4353, 8,    268,  1,    268,
      1,     268,  1,    268,  1,    268,  1,    268,  3,    268,  4360, 8,    268,  1,    268,  3,    268,  4363, 8,
      268,   1,    269,  1,    269,  1,    269,  5,    269,  4368, 8,    269,  10,   269,  12,   269,  4371, 9,    269,
      1,     270,  1,    270,  1,    270,  5,    270,  4376, 8,    270,  10,   270,  12,   270,  4379, 9,    270,  1,
      271,   1,    271,  1,    271,  5,    271,  4384, 8,    271,  10,   271,  12,   271,  4387, 9,    271,  1,    272,
      1,     272,  1,    273,  1,    273,  1,    273,  5,    273,  4394, 8,    273,  10,   273,  12,   273,  4397, 9,
      273,   1,    274,  1,    274,  1,    274,  3,    274,  4402, 8,    274,  1,    274,  1,    274,  3,    274,  4406,
      8,     274,  1,    274,  3,    274,  4409, 8,    274,  1,    274,  3,    274,  4412, 8,    274,  1,    274,  3,
      274,   4415, 8,    274,  1,    274,  3,    274,  4418, 8,    274,  1,    274,  3,    274,  4421, 8,    274,  1,
      275,   1,    275,  1,    275,  3,    275,  4426, 8,    275,  1,    275,  3,    275,  4429, 8,    275,  1,    276,
      1,     276,  1,    276,  1,    276,  1,    276,  3,    276,  4436, 8,    276,  1,    276,  1,    276,  5,    276,
      4440,  8,    276,  10,   276,  12,   276,  4443, 9,    276,  1,    277,  1,    277,  1,    277,  1,    277,  1,
      278,   1,    278,  1,    278,  1,    278,  1,    279,  1,    279,  1,    279,  1,    279,  1,    280,  1,    280,
      1,     280,  1,    280,  1,    281,  1,    281,  1,    281,  5,    281,  4464, 8,    281,  10,   281,  12,   281,
      4467,  9,    281,  1,    282,  1,    282,  1,    283,  1,    283,  3,    283,  4473, 8,    283,  1,    283,  3,
      283,   4476, 8,    283,  1,    283,  1,    283,  1,    284,  1,    284,  1,    284,  5,    284,  4483, 8,    284,
      10,    284,  12,   284,  4486, 9,    284,  1,    285,  1,    285,  1,    285,  3,    285,  4491, 8,    285,  1,
      286,   1,    286,  1,    286,  1,    286,  1,    287,  1,    287,  1,    287,  1,    287,  1,    288,  1,    288,
      1,     288,  1,    288,  1,    289,  1,    289,  1,    290,  1,    290,  1,    290,  1,    290,  1,    290,  3,
      290,   4512, 8,    290,  1,    290,  1,    290,  1,    290,  1,    290,  3,    290,  4518, 8,    290,  1,    291,
      1,     291,  1,    291,  1,    291,  3,    291,  4524, 8,    291,  1,    292,  1,    292,  1,    292,  5,    292,
      4529,  8,    292,  10,   292,  12,   292,  4532, 9,    292,  1,    293,  1,    293,  1,    293,  1,    293,  1,
      293,   3,    293,  4539, 8,    293,  1,    293,  1,    293,  1,    293,  1,    293,  3,    293,  4545, 8,    293,
      1,     293,  1,    293,  1,    293,  1,    293,  1,    293,  1,    293,  1,    293,  1,    293,  1,    293,  1,
      293,   3,    293,  4557, 8,    293,  3,    293,  4559, 8,    293,  1,    294,  1,    294,  1,    294,  1,    294,
      3,     294,  4565, 8,    294,  1,    294,  1,    294,  3,    294,  4569, 8,    294,  3,    294,  4571, 8,    294,
      1,     295,  1,    295,  3,    295,  4575, 8,    295,  1,    295,  1,    295,  1,    296,  1,    296,  1,    296,
      1,     296,  1,    296,  1,    296,  1,    296,  3,    296,  4586, 8,    296,  1,    297,  1,    297,  1,    297,
      3,     297,  4591, 8,    297,  1,    297,  1,    297,  1,    297,  1,    297,  3,    297,  4597, 8,    297,  1,
      297,   1,    297,  1,    297,  1,    297,  1,    297,  3,    297,  4604, 8,    297,  1,    297,  3,    297,  4607,
      8,     297,  1,    297,  3,    297,  4610, 8,    297,  1,    297,  1,    297,  1,    297,  1,    297,  3,    297,
      4616,  8,    297,  3,    297,  4618, 8,    297,  1,    297,  1,    297,  1,    297,  1,    297,  1,    297,  1,
      297,   3,    297,  4626, 8,    297,  1,    297,  3,    297,  4629, 8,    297,  3,    297,  4631, 8,    297,  3,
      297,   4633, 8,    297,  1,    298,  1,    298,  1,    298,  5,    298,  4638, 8,    298,  10,   298,  12,   298,
      4641,  9,    298,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,
      3,     299,  4651, 8,    299,  1,    299,  3,    299,  4654, 8,    299,  3,    299,  4656, 8,    299,  1,    299,
      1,     299,  3,    299,  4660, 8,    299,  1,    299,  1,    299,  1,    299,  3,    299,  4665, 8,    299,  3,
      299,   4667, 8,    299,  1,    299,  1,    299,  1,    299,  3,    299,  4672, 8,    299,  1,    299,  1,    299,
      1,     299,  1,    299,  3,    299,  4678, 8,    299,  1,    299,  3,    299,  4681, 8,    299,  3,    299,  4683,
      8,     299,  1,    299,  1,    299,  3,    299,  4687, 8,    299,  1,    299,  3,    299,  4690, 8,    299,  1,
      299,   1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  3,    299,  4699, 8,    299,  1,
      299,   1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  1,    299,  3,    299,  4708, 8,    299,  1,
      299,   1,    299,  1,    299,  1,    299,  3,    299,  4714, 8,    299,  3,    299,  4716, 8,    299,  3,    299,
      4718,  8,    299,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  3,    300,
      4727,  8,    300,  1,    300,  1,    300,  3,    300,  4731, 8,    300,  1,    300,  1,    300,  1,    300,  1,
      300,   3,    300,  4737, 8,    300,  1,    300,  3,    300,  4740, 8,    300,  3,    300,  4742, 8,    300,  1,
      300,   1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  1,    300,  3,    300,
      4753,  8,    300,  1,    300,  1,    300,  1,    300,  3,    300,  4758, 8,    300,  1,    300,  1,    300,  1,
      300,   3,    300,  4763, 8,    300,  1,    300,  1,    300,  1,    300,  1,    300,  3,    300,  4769, 8,    300,
      3,     300,  4771, 8,    300,  1,    300,  1,    300,  3,    300,  4775, 8,    300,  3,    300,  4777, 8,    300,
      1,     301,  1,    301,  1,    301,  1,    302,  1,    302,  1,    302,  3,    302,  4785, 8,    302,  1,    302,
      1,     302,  3,    302,  4789, 8,    302,  1,    302,  1,    302,  1,    303,  3,    303,  4794, 8,    303,  1,
      303,   3,    303,  4797, 8,    303,  1,    303,  5,    303,  4800, 8,    303,  10,   303,  12,   303,  4803, 9,
      303,   1,    303,  1,    303,  3,    303,  4807, 8,    303,  1,    304,  1,    304,  1,    304,  1,    304,  3,
      304,   4813, 8,    304,  1,    305,  1,    305,  1,    305,  1,    305,  1,    306,  1,    306,  1,    306,  3,
      306,   4822, 8,    306,  1,    307,  1,    307,  1,    307,  1,    307,  1,    307,  1,    307,  1,    307,  1,
      307,   1,    307,  4,    307,  4833, 8,    307,  11,   307,  12,   307,  4834, 1,    308,  1,    308,  1,    308,
      1,     308,  1,    308,  1,    308,  1,    308,  1,    308,  1,    308,  1,    308,  3,    308,  4847, 8,    308,
      1,     308,  1,    308,  1,    308,  3,    308,  4852, 8,    308,  1,    308,  1,    308,  1,    308,  1,    308,
      1,     308,  1,    308,  3,    308,  4860, 8,    308,  1,    308,  1,    308,  1,    308,  1,    308,  3,    308,
      4866,  8,    308,  3,    308,  4868, 8,    308,  1,    308,  1,    308,  1,    308,  1,    308,  1,    308,  3,
      308,   4875, 8,    308,  3,    308,  4877, 8,    308,  1,    309,  1,    309,  1,    309,  1,    309,  1,    309,
      3,     309,  4884, 8,    309,  1,    310,  1,    310,  1,    310,  3,    310,  4889, 8,    310,  1,    310,  1,
      310,   1,    311,  1,    311,  1,    311,  1,    311,  1,    311,  1,    311,  1,    311,  3,    311,  4900, 8,
      311,   1,    311,  1,    311,  1,    311,  3,    311,  4905, 8,    311,  3,    311,  4907, 8,    311,  1,    311,
      1,     311,  3,    311,  4911, 8,    311,  1,    311,  1,    311,  1,    311,  1,    311,  3,    311,  4917, 8,
      311,   1,    311,  3,    311,  4920, 8,    311,  1,    311,  3,    311,  4923, 8,    311,  1,    311,  1,    311,
      1,     311,  1,    311,  1,    311,  1,    311,  1,    311,  1,    311,  3,    311,  4933, 8,    311,  3,    311,
      4935,  8,    311,  1,    312,  1,    312,  1,    312,  1,    312,  3,    312,  4941, 8,    312,  1,    313,  1,
      313,   1,    313,  1,    313,  5,    313,  4947, 8,    313,  10,   313,  12,   313,  4950, 9,    313,  1,    314,
      1,     314,  1,    314,  1,    315,  1,    315,  1,    315,  1,    315,  1,    315,  3,    315,  4960, 8,    315,
      1,     315,  1,    315,  3,    315,  4964, 8,    315,  1,    316,  1,    316,  1,    316,  3,    316,  4969, 8,
      316,   1,    317,  1,    317,  1,    317,  1,    318,  1,    318,  1,    318,  1,    318,  1,    318,  1,    318,
      1,     318,  1,    318,  1,    318,  1,    318,  5,    318,  4984, 8,    318,  10,   318,  12,   318,  4987, 9,
      318,   1,    319,  1,    319,  1,    319,  3,    319,  4992, 8,    319,  1,    319,  1,    319,  1,    319,  1,
      319,   1,    319,  1,    319,  1,    319,  3,    319,  5001, 8,    319,  1,    319,  1,    319,  1,    319,  1,
      319,   1,    319,  1,    319,  3,    319,  5009, 8,    319,  1,    319,  1,    319,  3,    319,  5013, 8,    319,
      1,     319,  1,    319,  1,    319,  1,    319,  3,    319,  5019, 8,    319,  1,    319,  1,    319,  1,    319,
      1,     319,  1,    319,  1,    319,  1,    319,  1,    319,  3,    319,  5029, 8,    319,  1,    319,  1,    319,
      3,     319,  5033, 8,    319,  1,    320,  1,    320,  1,    321,  1,    321,  1,    321,  5,    321,  5040, 8,
      321,   10,   321,  12,   321,  5043, 9,    321,  1,    322,  1,    322,  3,    322,  5047, 8,    322,  1,    322,
      1,     322,  1,    322,  1,    322,  3,    322,  5053, 8,    322,  3,    322,  5055, 8,    322,  1,    322,  1,
      322,   3,    322,  5059, 8,    322,  1,    322,  1,    322,  1,    322,  1,    322,  1,    322,  1,    322,  1,
      322,   1,    322,  1,    322,  3,    322,  5070, 8,    322,  1,    322,  1,    322,  1,    322,  1,    322,  1,
      322,   3,    322,  5077, 8,    322,  1,    322,  1,    322,  1,    322,  1,    322,  3,    322,  5083, 8,    322,
      1,     322,  1,    322,  3,    322,  5087, 8,    322,  1,    323,  1,    323,  1,    323,  3,    323,  5092, 8,
      323,   1,    323,  1,    323,  1,    323,  3,    323,  5097, 8,    323,  1,    323,  1,    323,  1,    323,  1,
      323,   1,    323,  1,    323,  3,    323,  5105, 8,    323,  1,    324,  1,    324,  3,    324,  5109, 8,    324,
      1,     324,  5,    324,  5112, 8,    324,  10,   324,  12,   324,  5115, 9,    324,  1,    325,  1,    325,  1,
      325,   1,    325,  1,    325,  1,    325,  3,    325,  5123, 8,    325,  1,    326,  1,    326,  1,    326,  1,
      326,   1,    326,  1,    326,  1,    326,  1,    326,  1,    326,  1,    326,  1,    326,  3,    326,  5136, 8,
      326,   3,    326,  5138, 8,    326,  1,    327,  1,    327,  1,    327,  1,    327,  1,    327,  1,    327,  1,
      327,   1,    327,  1,    327,  1,    327,  1,    327,  1,    327,  3,    327,  5152, 8,    327,  1,    327,  1,
      327,   1,    327,  1,    327,  1,    327,  1,    327,  1,    327,  3,    327,  5161, 8,    327,  3,    327,  5163,
      8,     327,  1,    328,  1,    328,  1,    328,  5,    328,  5168, 8,    328,  10,   328,  12,   328,  5171, 9,
      328,   1,    329,  1,    329,  3,    329,  5175, 8,    329,  1,    330,  1,    330,  3,    330,  5179, 8,    330,
      1,     330,  1,    330,  1,    330,  3,    330,  5184, 8,    330,  1,    330,  1,    330,  1,    330,  1,    330,
      5,     330,  5190, 8,    330,  10,   330,  12,   330,  5193, 9,    330,  1,    330,  1,    330,  1,    330,  1,
      330,   3,    330,  5199, 8,    330,  1,    330,  1,    330,  3,    330,  5203, 8,    330,  1,    330,  1,    330,
      1,     330,  1,    330,  3,    330,  5209, 8,    330,  1,    330,  1,    330,  1,    330,  5,    330,  5214, 8,
      330,   10,   330,  12,   330,  5217, 9,    330,  3,    330,  5219, 8,    330,  1,    331,  1,    331,  1,    331,
      1,     331,  1,    331,  1,    331,  1,    331,  1,    331,  1,    331,  1,    331,  1,    331,  3,    331,  5232,
      8,     331,  1,    331,  1,    331,  1,    331,  1,    331,  3,    331,  5238, 8,    331,  1,    332,  1,    332,
      1,     332,  3,    332,  5243, 8,    332,  1,    333,  1,    333,  1,    334,  1,    334,  1,    334,  1,    334,
      1,     334,  1,    334,  1,    334,  1,    334,  1,    334,  1,    334,  1,    334,  1,    334,  1,    334,  1,
      334,   1,    334,  1,    334,  1,    334,  5,    334,  5264, 8,    334,  10,   334,  12,   334,  5267, 9,    334,
      3,     334,  5269, 8,    334,  1,    335,  1,    335,  1,    335,  1,    336,  1,    336,  1,    336,  1,    336,
      1,     336,  1,    336,  1,    336,  1,    336,  1,    336,  1,    336,  1,    336,  3,    336,  5285, 8,    336,
      1,     336,  1,    336,  1,    336,  3,    336,  5290, 8,    336,  1,    336,  3,    336,  5293, 8,    336,  1,
      336,   1,    336,  3,    336,  5297, 8,    336,  1,    336,  3,    336,  5300, 8,    336,  1,    336,  1,    336,
      1,     336,  1,    336,  1,    336,  1,    336,  3,    336,  5308, 8,    336,  1,    336,  1,    336,  1,    336,
      1,     336,  3,    336,  5314, 8,    336,  1,    336,  1,    336,  1,    336,  3,    336,  5319, 8,    336,  1,
      336,   3,    336,  5322, 8,    336,  3,    336,  5324, 8,    336,  1,    337,  1,    337,  3,    337,  5328, 8,
      337,   1,    337,  1,    337,  1,    337,  3,    337,  5333, 8,    337,  3,    337,  5335, 8,    337,  1,    338,
      1,     338,  1,    338,  1,    339,  1,    339,  1,    339,  1,    339,  1,    339,  1,    339,  1,    339,  3,
      339,   5347, 8,    339,  1,    340,  1,    340,  5,    340,  5351, 8,    340,  10,   340,  12,   340,  5354, 9,
      340,   1,    341,  1,    341,  1,    341,  1,    341,  1,    341,  1,    341,  1,    341,  1,    341,  1,    341,
      1,     341,  1,    341,  3,    341,  5367, 8,    341,  1,    341,  1,    341,  1,    341,  1,    341,  1,    341,
      1,     341,  1,    341,  1,    341,  1,    341,  1,    341,  3,    341,  5379, 8,    341,  1,    341,  1,    341,
      3,     341,  5383, 8,    341,  3,    341,  5385, 8,    341,  1,    342,  1,    342,  1,    342,  1,    342,  1,
      342,   1,    342,  3,    342,  5393, 8,    342,  1,    343,  1,    343,  3,    343,  5397, 8,    343,  1,    343,
      1,     343,  1,    344,  1,    344,  1,    344,  1,    344,  1,    344,  3,    344,  5406, 8,    344,  1,    345,
      1,     345,  1,    345,  1,    345,  1,    346,  1,    346,  1,    346,  1,    346,  1,    346,  1,    346,  1,
      346,   3,    346,  5419, 8,    346,  1,    347,  1,    347,  1,    347,  3,    347,  5424, 8,    347,  1,    348,
      1,     348,  3,    348,  5428, 8,    348,  1,    348,  1,    348,  3,    348,  5432, 8,    348,  1,    348,  3,
      348,   5435, 8,    348,  1,    349,  1,    349,  3,    349,  5439, 8,    349,  1,    349,  1,    349,  3,    349,
      5443,  8,    349,  1,    349,  3,    349,  5446, 8,    349,  1,    350,  1,    350,  1,    350,  3,    350,  5451,
      8,     350,  1,    350,  3,    350,  5454, 8,    350,  1,    351,  1,    351,  1,    351,  1,    351,  3,    351,
      5460,  8,    351,  1,    351,  3,    351,  5463, 8,    351,  1,    352,  1,    352,  1,    352,  1,    352,  3,
      352,   5469, 8,    352,  1,    352,  3,    352,  5472, 8,    352,  1,    353,  1,    353,  1,    353,  1,    354,
      1,     354,  1,    354,  1,    354,  1,    354,  1,    355,  1,    355,  1,    355,  1,    355,  1,    355,  1,
      356,   1,    356,  1,    356,  1,    356,  1,    356,  1,    357,  1,    357,  3,    357,  5494, 8,    357,  1,
      357,   1,    357,  1,    357,  1,    357,  3,    357,  5500, 8,    357,  1,    357,  3,    357,  5503, 8,    357,
      1,     358,  1,    358,  1,    358,  1,    358,  1,    359,  1,    359,  1,    359,  1,    359,  1,    359,  3,
      359,   5514, 8,    359,  1,    360,  1,    360,  1,    360,  1,    360,  1,    360,  3,    360,  5521, 8,    360,
      1,     360,  1,    360,  3,    360,  5525, 8,    360,  1,    360,  3,    360,  5528, 8,    360,  1,    360,  3,
      360,   5531, 8,    360,  1,    361,  1,    361,  1,    361,  1,    361,  1,    361,  3,    361,  5538, 8,    361,
      1,     361,  1,    361,  3,    361,  5542, 8,    361,  1,    361,  3,    361,  5545, 8,    361,  1,    361,  3,
      361,   5548, 8,    361,  1,    362,  1,    362,  3,    362,  5552, 8,    362,  1,    362,  1,    362,  1,    362,
      1,     362,  3,    362,  5558, 8,    362,  1,    362,  3,    362,  5561, 8,    362,  1,    363,  1,    363,  3,
      363,   5565, 8,    363,  1,    363,  1,    363,  1,    364,  1,    364,  1,    364,  1,    364,  1,    364,  1,
      364,   1,    364,  1,    365,  1,    365,  1,    365,  1,    365,  1,    365,  1,    365,  1,    365,  1,    366,
      1,     366,  1,    366,  3,    366,  5586, 8,    366,  1,    367,  1,    367,  1,    367,  3,    367,  5591, 8,
      367,   1,    368,  1,    368,  1,    368,  1,    369,  1,    369,  1,    369,  3,    369,  5599, 8,    369,  1,
      369,   1,    369,  1,    369,  3,    369,  5604, 8,    369,  1,    369,  3,    369,  5607, 8,    369,  1,    370,
      1,     370,  3,    370,  5611, 8,    370,  1,    370,  1,    370,  3,    370,  5615, 8,    370,  1,    371,  1,
      371,   3,    371,  5619, 8,    371,  1,    371,  1,    371,  1,    372,  1,    372,  3,    372,  5625, 8,    372,
      1,     372,  1,    372,  3,    372,  5629, 8,    372,  1,    373,  1,    373,  1,    373,  3,    373,  5634, 8,
      373,   1,    374,  1,    374,  1,    374,  3,    374,  5639, 8,    374,  1,    375,  1,    375,  1,    375,  1,
      376,   1,    376,  1,    376,  1,    376,  1,    376,  1,    376,  3,    376,  5650, 8,    376,  3,    376,  5652,
      8,     376,  1,    377,  1,    377,  1,    377,  1,    377,  3,    377,  5658, 8,    377,  1,    377,  1,    377,
      1,     378,  1,    378,  1,    378,  1,    378,  1,    378,  1,    379,  1,    379,  1,    379,  1,    379,  1,
      379,   1,    380,  1,    380,  1,    380,  1,    380,  1,    381,  1,    381,  1,    381,  1,    381,  3,    381,
      5680,  8,    381,  1,    382,  1,    382,  1,    382,  1,    382,  1,    382,  1,    383,  1,    383,  1,    383,
      1,     383,  1,    383,  1,    384,  1,    384,  1,    384,  1,    384,  1,    384,  1,    385,  1,    385,  1,
      385,   1,    385,  1,    385,  3,    385,  5702, 8,    385,  1,    386,  1,    386,  1,    386,  1,    386,  1,
      386,   3,    386,  5709, 8,    386,  1,    387,  1,    387,  1,    387,  1,    387,  1,    387,  1,    387,  1,
      388,   1,    388,  1,    388,  1,    388,  1,    388,  1,    388,  1,    389,  1,    389,  1,    389,  1,    389,
      1,     389,  1,    390,  1,    390,  1,    390,  1,    390,  1,    390,  1,    391,  1,    391,  1,    391,  3,
      391,   5736, 8,    391,  3,    391,  5738, 8,    391,  1,    392,  1,    392,  3,    392,  5742, 8,    392,  1,
      393,   1,    393,  1,    394,  1,    394,  1,    394,  1,    395,  1,    395,  1,    395,  5,    395,  5752, 8,
      395,   10,   395,  12,   395,  5755, 9,    395,  1,    396,  1,    396,  1,    396,  1,    396,  1,    396,  1,
      396,   1,    396,  3,    396,  5764, 8,    396,  1,    397,  1,    397,  1,    397,  1,    397,  1,    397,  1,
      397,   1,    397,  1,    397,  3,    397,  5774, 8,    397,  1,    397,  1,    397,  3,    397,  5778, 8,    397,
      1,     397,  1,    397,  1,    397,  1,    397,  5,    397,  5784, 8,    397,  10,   397,  12,   397,  5787, 9,
      397,   3,    397,  5789, 8,    397,  1,    397,  1,    397,  3,    397,  5793, 8,    397,  1,    397,  1,    397,
      1,     397,  1,    397,  1,    397,  1,    397,  1,    397,  3,    397,  5802, 8,    397,  1,    398,  1,    398,
      3,     398,  5806, 8,    398,  1,    399,  1,    399,  1,    399,  5,    399,  5811, 8,    399,  10,   399,  12,
      399,   5814, 9,    399,  1,    400,  1,    400,  3,    400,  5818, 8,    400,  1,    401,  1,    401,  1,    401,
      1,     401,  1,    401,  1,    401,  3,    401,  5826, 8,    401,  1,    402,  1,    402,  1,    402,  3,    402,
      5831,  8,    402,  1,    402,  1,    402,  1,    403,  1,    403,  3,    403,  5837, 8,    403,  1,    404,  1,
      404,   1,    404,  5,    404,  5842, 8,    404,  10,   404,  12,   404,  5845, 9,    404,  1,    405,  1,    405,
      3,     405,  5849, 8,    405,  1,    405,  1,    405,  1,    405,  1,    405,  3,    405,  5855, 8,    405,  1,
      405,   3,    405,  5858, 8,    405,  1,    406,  1,    406,  1,    407,  1,    407,  1,    407,  1,    407,  1,
      407,   1,    407,  3,    407,  5868, 8,    407,  3,    407,  5870, 8,    407,  1,    408,  1,    408,  1,    408,
      1,     408,  1,    408,  3,    408,  5877, 8,    408,  1,    409,  1,    409,  1,    409,  3,    409,  5882, 8,
      409,   1,    409,  1,    409,  3,    409,  5886, 8,    409,  1,    409,  3,    409,  5889, 8,    409,  1,    410,
      1,     410,  1,    410,  5,    410,  5894, 8,    410,  10,   410,  12,   410,  5897, 9,    410,  1,    411,  1,
      411,   3,    411,  5901, 8,    411,  1,    411,  1,    411,  3,    411,  5905, 8,    411,  1,    412,  1,    412,
      1,     412,  1,    412,  1,    412,  1,    413,  1,    413,  1,    413,  1,    413,  3,    413,  5916, 8,    413,
      1,     414,  1,    414,  1,    414,  1,    414,  1,    414,  1,    414,  3,    414,  5924, 8,    414,  1,    414,
      1,     414,  3,    414,  5928, 8,    414,  1,    414,  3,    414,  5931, 8,    414,  1,    414,  3,    414,  5934,
      8,     414,  1,    415,  1,    415,  3,    415,  5938, 8,    415,  1,    415,  1,    415,  3,    415,  5942, 8,
      415,   1,    415,  5,    415,  5945, 8,    415,  10,   415,  12,   415,  5948, 9,    415,  1,    416,  1,    416,
      1,     416,  3,    416,  5953, 8,    416,  1,    417,  1,    417,  3,    417,  5957, 8,    417,  1,    417,  1,
      417,   1,    418,  1,    418,  1,    419,  1,    419,  1,    419,  1,    419,  1,    419,  3,    419,  5968, 8,
      419,   1,    419,  3,    419,  5971, 8,    419,  1,    419,  3,    419,  5974, 8,    419,  1,    419,  3,    419,
      5977,  8,    419,  1,    420,  1,    420,  1,    420,  1,    420,  1,    420,  1,    420,  3,    420,  5985, 8,
      420,   1,    421,  1,    421,  3,    421,  5989, 8,    421,  1,    421,  5,    421,  5992, 8,    421,  10,   421,
      12,    421,  5995, 9,    421,  1,    422,  1,    422,  1,    422,  1,    422,  1,    422,  3,    422,  6002, 8,
      422,   1,    423,  1,    423,  1,    423,  1,    423,  1,    423,  1,    423,  3,    423,  6010, 8,    423,  1,
      424,   1,    424,  1,    424,  1,    424,  3,    424,  6016, 8,    424,  1,    425,  1,    425,  1,    425,  1,
      425,   1,    425,  1,    425,  1,    425,  1,    425,  1,    425,  1,    425,  1,    425,  1,    425,  3,    425,
      6030,  8,    425,  1,    425,  1,    425,  1,    426,  1,    426,  1,    426,  1,    426,  1,    426,  1,    426,
      1,     426,  1,    426,  3,    426,  6042, 8,    426,  1,    427,  1,    427,  1,    427,  1,    428,  1,    428,
      1,     428,  1,    429,  1,    429,  1,    430,  1,    430,  1,    430,  1,    430,  3,    430,  6056, 8,    430,
      1,     430,  3,    430,  6059, 8,    430,  1,    430,  1,    430,  3,    430,  6063, 8,    430,  1,    430,  1,
      430,   1,    430,  1,    430,  1,    430,  1,    430,  1,    430,  1,    430,  1,    430,  5,    430,  6074, 8,
      430,   10,   430,  12,   430,  6077, 9,    430,  1,    431,  1,    431,  1,    431,  1,    431,  1,    431,  1,
      431,   3,    431,  6085, 8,    431,  1,    431,  1,    431,  1,    431,  1,    431,  1,    431,  1,    431,  1,
      431,   1,    431,  1,    431,  1,    431,  5,    431,  6097, 8,    431,  10,   431,  12,   431,  6100, 9,    431,
      1,     432,  1,    432,  1,    433,  1,    433,  3,    433,  6106, 8,    433,  1,    433,  1,    433,  1,    433,
      1,     433,  3,    433,  6112, 8,    433,  1,    433,  1,    433,  1,    433,  1,    433,  3,    433,  6118, 8,
      433,   1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  3,    434,  6126, 8,    434,  1,
      434,   1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  1,    434,  3,    434,
      6137,  8,    434,  1,    434,  1,    434,  3,    434,  6141, 8,    434,  1,    435,  1,    435,  1,    435,  1,
      435,   1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,
      1,     435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,    435,  1,
      435,   1,    435,  1,    435,  1,    435,  1,    435,  5,    435,  6170, 8,    435,  10,   435,  12,   435,  6173,
      9,     435,  1,    436,  1,    436,  1,    436,  3,    436,  6178, 8,    436,  1,    436,  1,    436,  1,    436,
      1,     436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  3,    436,  6195, 8,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,
      436,   3,    436,  6202, 8,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  3,    436,  6216, 8,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  3,    436,  6227, 8,
      436,   1,    436,  1,    436,  1,    436,  3,    436,  6232, 8,    436,  1,    436,  1,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  3,    436,  6243, 8,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  3,    436,  6253, 8,    436,  1,
      436,   1,    436,  1,    436,  4,    436,  6258, 8,    436,  11,   436,  12,   436,  6259, 1,    436,  3,    436,
      6263,  8,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,
      1,     436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,
      436,   1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,  1,    436,
      1,     436,  1,    436,  1,    436,  1,    436,  1,    436,  3,    436,  6297, 8,    436,  1,    436,  1,    436,
      1,     436,  1,    436,  1,    436,  1,    436,  5,    436,  6305, 8,    436,  10,   436,  12,   436,  6308, 9,
      436,   1,    437,  1,    437,  1,    437,  1,    438,  1,    438,  1,    438,  1,    438,  3,    438,  6317, 8,
      438,   1,    439,  1,    439,  1,    439,  3,    439,  6322, 8,    439,  1,    439,  1,    439,  1,    439,  3,
      439,   6327, 8,    439,  1,    439,  1,    439,  1,    439,  1,    439,  1,    439,  3,    439,  6334, 8,    439,
      1,     439,  1,    439,  1,    439,  1,    439,  3,    439,  6340, 8,    439,  1,    439,  1,    439,  1,    439,
      3,     439,  6345, 8,    439,  1,    439,  1,    439,  1,    439,  3,    439,  6350, 8,    439,  1,    439,  1,
      439,   1,    439,  1,    439,  3,    439,  6356, 8,    439,  1,    439,  1,    439,  3,    439,  6360, 8,    439,
      1,     439,  1,    439,  1,    439,  3,    439,  6365, 8,    439,  1,    439,  1,    439,  1,    439,  3,    439,
      6370,  8,    439,  1,    439,  1,    439,  1,    439,  1,    439,  1,    439,  3,    439,  6377, 8,    439,  1,
      439,   1,    439,  1,    439,  1,    439,  1,    439,  1,    439,  3,    439,  6385, 8,    439,  1,    439,  1,
      439,   1,    439,  3,    439,  6390, 8,    439,  1,    439,  1,    439,  3,    439,  6394, 8,    439,  1,    439,
      1,     439,  3,    439,  6398, 8,    439,  1,    439,  1,    439,  3,    439,  6402, 8,    439,  3,    439,  6404,
      8,     439,  1,    440,  1,    440,  1,    440,  1,    440,  1,    440,  1,    441,  1,    441,  1,    441,  1,
      441,   1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  3,    441,  6422, 8,
      441,   1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  3,    441,  6430, 8,    441,  1,
      441,   1,    441,  3,    441,  6434, 8,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  3,
      441,   6441, 8,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,    441,  1,
      441,   1,    441,  1,    441,  3,    441,  6453, 8,    441,  1,    441,  3,    441,  6456, 8,    441,  1,    441,
      1,     441,  3,    441,  6460, 8,    441,  1,    442,  1,    442,  1,    442,  3,    442,  6465, 8,    442,  1,
      443,   1,    443,  1,    443,  1,    443,  1,    443,  3,    443,  6472, 8,    443,  1,    443,  1,    443,  3,
      443,   6476, 8,    443,  1,    444,  1,    444,  3,    444,  6480, 8,    444,  1,    445,  1,    445,  1,    445,
      1,     445,  3,    445,  6486, 8,    445,  1,    446,  1,    446,  1,    446,  1,    447,  1,    447,  1,    447,
      1,     447,  1,    447,  3,    447,  6496, 8,    447,  1,    447,  1,    447,  1,    447,  1,    447,  1,    447,
      1,     447,  1,    447,  3,    447,  6505, 8,    447,  3,    447,  6507, 8,    447,  1,    448,  3,    448,  6510,
      8,     448,  1,    448,  1,    448,  1,    449,  1,    449,  1,    449,  1,    449,  1,    449,  3,    449,  6519,
      8,     449,  1,    450,  1,    450,  1,    450,  5,    450,  6524, 8,    450,  10,   450,  12,   450,  6527, 9,
      450,   1,    451,  1,    451,  1,    451,  1,    451,  1,    451,  1,    451,  1,    451,  1,    451,  1,    451,
      1,     451,  3,    451,  6539, 8,    451,  1,    451,  1,    451,  1,    451,  3,    451,  6544, 8,    451,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6551, 8,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  3,    452,  6557, 8,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  4,    452,  6581, 8,    452,
      11,    452,  12,   452,  6582, 1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  3,    452,  6593, 8,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6625, 8,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6644, 8,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  3,    452,  6650, 8,    452,  1,    452,  1,    452,  3,    452,  6654, 8,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6681, 8,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  3,
      452,   6693, 8,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  3,    452,  6706, 8,    452,  1,    452,  1,    452,  3,    452,  6710,
      8,     452,  1,    452,  1,    452,  3,    452,  6714, 8,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  3,    452,  6742, 8,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6792, 8,    452,  1,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6802, 8,    452,
      1,     452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,    452,  1,
      452,   3,    452,  6814, 8,    452,  1,    452,  1,    452,  1,    452,  3,    452,  6819, 8,    452,  1,    453,
      1,     453,  1,    453,  1,    454,  1,    454,  1,    454,  3,    454,  6827, 8,    454,  1,    454,  1,    454,
      1,     454,  1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  1,
      454,   1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  1,    454,  3,    454,  6847, 8,    454,  1,
      455,   1,    455,  3,    455,  6851, 8,    455,  1,    455,  1,    455,  1,    456,  1,    456,  1,    457,  1,
      457,   1,    457,  1,    457,  1,    457,  1,    457,  1,    457,  1,    457,  5,    457,  6865, 8,    457,  10,
      457,   12,   457,  6868, 9,    457,  3,    457,  6870, 8,    457,  1,    458,  1,    458,  1,    458,  3,    458,
      6875,  8,    458,  1,    458,  3,    458,  6878, 8,    458,  1,    459,  1,    459,  1,    460,  1,    460,  1,
      460,   1,    460,  1,    460,  3,    460,  6887, 8,    460,  1,    460,  1,    460,  3,    460,  6891, 8,    460,
      1,     460,  1,    460,  1,    460,  1,    460,  3,    460,  6897, 8,    460,  1,    460,  1,    460,  1,    460,
      1,     460,  3,    460,  6903, 8,    460,  1,    460,  1,    460,  3,    460,  6907, 8,    460,  1,    460,  1,
      460,   1,    461,  1,    461,  1,    461,  1,    461,  1,    461,  1,    461,  1,    461,  3,    461,  6918, 8,
      461,   1,    461,  1,    461,  1,    461,  1,    461,  3,    461,  6924, 8,    461,  3,    461,  6926, 8,    461,
      1,     461,  1,    461,  1,    462,  1,    462,  1,    462,  3,    462,  6933, 8,    462,  1,    462,  1,    462,
      1,     462,  1,    462,  1,    462,  3,    462,  6940, 8,    462,  1,    462,  1,    462,  3,    462,  6944, 8,
      462,   1,    463,  1,    463,  1,    463,  5,    463,  6949, 8,    463,  10,   463,  12,   463,  6952, 9,    463,
      1,     464,  1,    464,  3,    464,  6956, 8,    464,  1,    465,  1,    465,  1,    465,  3,    465,  6961, 8,
      465,   1,    466,  1,    466,  1,    466,  1,    466,  1,    467,  1,    467,  1,    467,  3,    467,  6970, 8,
      467,   1,    467,  3,    467,  6973, 8,    467,  1,    468,  1,    468,  3,    468,  6977, 8,    468,  1,    468,
      1,     468,  1,    468,  3,    468,  6982, 8,    468,  3,    468,  6984, 8,    468,  1,    468,  1,    468,  3,
      468,   6988, 8,    468,  1,    469,  1,    469,  3,    469,  6992, 8,    469,  1,    470,  1,    470,  1,    470,
      1,     471,  1,    471,  1,    471,  1,    472,  1,    472,  1,    472,  1,    473,  1,    473,  3,    473,  7005,
      8,     473,  1,    473,  1,    473,  3,    473,  7009, 8,    473,  1,    473,  3,    473,  7012, 8,    473,  1,
      473,   1,    473,  3,    473,  7016, 8,    473,  1,    473,  1,    473,  3,    473,  7020, 8,    473,  1,    473,
      1,     473,  3,    473,  7024, 8,    473,  1,    473,  1,    473,  1,    473,  1,    473,  1,    473,  3,    473,
      7031,  8,    473,  1,    473,  1,    473,  3,    473,  7035, 8,    473,  1,    473,  1,    473,  3,    473,  7039,
      8,     473,  1,    473,  1,    473,  1,    473,  1,    473,  1,    473,  1,    473,  3,    473,  7047, 8,    473,
      1,     473,  1,    473,  3,    473,  7051, 8,    473,  1,    474,  1,    474,  1,    474,  5,    474,  7056, 8,
      474,   10,   474,  12,   474,  7059, 9,    474,  1,    475,  1,    475,  1,    475,  3,    475,  7064, 8,    475,
      1,     476,  1,    476,  1,    477,  1,    477,  1,    478,  1,    478,  3,    478,  7072, 8,    478,  1,    479,
      1,     479,  1,    480,  1,    480,  1,    480,  1,    480,  1,    481,  1,    481,  1,    481,  1,    481,  1,
      482,   1,    482,  1,    482,  1,    482,  1,    483,  1,    483,  1,    483,  5,    483,  7091, 8,    483,  10,
      483,   12,   483,  7094, 9,    483,  1,    484,  1,    484,  3,    484,  7098, 8,    484,  1,    485,  1,    485,
      1,     485,  5,    485,  7103, 8,    485,  10,   485,  12,   485,  7106, 9,    485,  1,    486,  1,    486,  1,
      487,   1,    487,  1,    487,  1,    487,  1,    488,  1,    488,  1,    488,  1,    488,  1,    488,  1,    488,
      1,     488,  1,    488,  1,    488,  1,    488,  1,    488,  1,    488,  1,    488,  3,    488,  7127, 8,    488,
      1,     489,  1,    489,  1,    489,  1,    490,  1,    490,  1,    490,  1,    490,  1,    490,  1,    491,  1,
      491,   1,    491,  1,    491,  1,    491,  1,    491,  3,    491,  7143, 8,    491,  1,    492,  1,    492,  1,
      492,   1,    493,  1,    493,  1,    493,  4,    493,  7151, 8,    493,  11,   493,  12,   493,  7152, 1,    494,
      1,     494,  3,    494,  7157, 8,    494,  1,    494,  1,    494,  1,    494,  4,    494,  7162, 8,    494,  11,
      494,   12,   494,  7163, 1,    494,  3,    494,  7167, 8,    494,  1,    494,  1,    494,  1,    494,  1,    495,
      1,     495,  1,    495,  1,    496,  1,    496,  1,    496,  3,    496,  7178, 8,    496,  1,    497,  1,    497,
      1,     498,  1,    498,  1,    498,  1,    499,  1,    499,  3,    499,  7187, 8,    499,  1,    499,  3,    499,
      7190,  8,    499,  1,    499,  1,    499,  1,    500,  1,    500,  1,    500,  3,    500,  7197, 8,    500,  1,
      501,   1,    501,  1,    501,  3,    501,  7202, 8,    501,  1,    502,  1,    502,  1,    502,  1,    502,  1,
      502,   1,    503,  1,    503,  1,    503,  1,    503,  1,    503,  1,    503,  1,    503,  1,    504,  1,    504,
      1,     504,  1,    504,  1,    504,  1,    504,  1,    504,  1,    505,  1,    505,  1,    505,  4,    505,  7226,
      8,     505,  11,   505,  12,   505,  7227, 1,    506,  1,    506,  1,    506,  1,    506,  3,    506,  7234, 8,
      506,   1,    507,  1,    507,  1,    507,  1,    507,  3,    507,  7240, 8,    507,  1,    507,  1,    507,  3,
      507,   7244, 8,    507,  1,    508,  1,    508,  1,    508,  1,    508,  1,    508,  1,    508,  1,    509,  1,
      509,   3,    509,  7254, 8,    509,  1,    510,  1,    510,  3,    510,  7258, 8,    510,  1,    510,  1,    510,
      1,     511,  1,    511,  1,    511,  1,    511,  1,    511,  1,    511,  1,    511,  5,    511,  7269, 8,    511,
      10,    511,  12,   511,  7272, 9,    511,  1,    511,  1,    511,  1,    512,  1,    512,  1,    512,  1,    512,
      1,     512,  1,    512,  1,    512,  3,    512,  7283, 8,    512,  1,    513,  1,    513,  1,    513,  1,    513,
      1,     513,  1,    513,  1,    514,  1,    514,  1,    514,  1,    515,  1,    515,  1,    515,  1,    516,  1,
      516,   3,    516,  7299, 8,    516,  1,    516,  1,    516,  1,    516,  1,    516,  5,    516,  7305, 8,    516,
      10,    516,  12,   516,  7308, 9,    516,  1,    516,  1,    516,  1,    516,  1,    516,  1,    516,  5,    516,
      7315,  8,    516,  10,   516,  12,   516,  7318, 9,    516,  3,    516,  7320, 8,    516,  1,    517,  1,    517,
      1,     517,  3,    517,  7325, 8,    517,  1,    518,  1,    518,  3,    518,  7329, 8,    518,  1,    518,  1,
      518,   1,    518,  1,    519,  1,    519,  3,    519,  7336, 8,    519,  1,    519,  1,    519,  1,    519,  3,
      519,   7341, 8,    519,  1,    520,  1,    520,  1,    521,  1,    521,  1,    521,  3,    521,  7348, 8,    521,
      1,     521,  1,    521,  1,    521,  1,    521,  5,    521,  7354, 8,    521,  10,   521,  12,   521,  7357, 9,
      521,   3,    521,  7359, 8,    521,  1,    522,  1,    522,  1,    522,  3,    522,  7364, 8,    522,  1,    522,
      1,     522,  1,    522,  1,    522,  5,    522,  7370, 8,    522,  10,   522,  12,   522,  7373, 9,    522,  3,
      522,   7375, 8,    522,  1,    523,  1,    523,  1,    523,  1,    523,  1,    524,  1,    524,  1,    524,  1,
      525,   1,    525,  1,    525,  1,    526,  1,    526,  3,    526,  7389, 8,    526,  1,    526,  3,    526,  7392,
      8,     526,  1,    526,  1,    526,  1,    526,  1,    526,  1,    527,  1,    527,  1,    527,  1,    527,  1,
      527,   1,    527,  1,    527,  3,    527,  7405, 8,    527,  1,    527,  1,    527,  3,    527,  7409, 8,    527,
      3,     527,  7411, 8,    527,  1,    528,  1,    528,  1,    528,  3,    528,  7416, 8,    528,  1,    529,  1,
      529,   1,    529,  3,    529,  7421, 8,    529,  1,    530,  1,    530,  1,    530,  1,    531,  3,    531,  7427,
      8,     531,  1,    531,  1,    531,  1,    532,  1,    532,  3,    532,  7433, 8,    532,  1,    532,  1,    532,
      5,     532,  7437, 8,    532,  10,   532,  12,   532,  7440, 9,    532,  1,    532,  1,    532,  3,    532,  7444,
      8,     532,  1,    532,  3,    532,  7447, 8,    532,  1,    532,  1,    532,  5,    532,  7451, 8,    532,  10,
      532,   12,   532,  7454, 9,    532,  1,    532,  1,    532,  3,    532,  7458, 8,    532,  1,    532,  3,    532,
      7461,  8,    532,  1,    532,  1,    532,  5,    532,  7465, 8,    532,  10,   532,  12,   532,  7468, 9,    532,
      1,     532,  3,    532,  7471, 8,    532,  1,    532,  1,    532,  1,    532,  1,    532,  3,    532,  7477, 8,
      532,   3,    532,  7479, 8,    532,  1,    532,  3,    532,  7482, 8,    532,  1,    532,  1,    532,  5,    532,
      7486,  8,    532,  10,   532,  12,   532,  7489, 9,    532,  1,    532,  1,    532,  1,    532,  3,    532,  7494,
      8,     532,  1,    532,  1,    532,  1,    532,  1,    532,  1,    532,  1,    532,  3,    532,  7502, 8,    532,
      3,     532,  7504, 8,    532,  3,    532,  7506, 8,    532,  1,    533,  1,    533,  3,    533,  7510, 8,    533,
      1,     534,  1,    534,  5,    534,  7514, 8,    534,  10,   534,  12,   534,  7517, 9,    534,  1,    534,  3,
      534,   7520, 8,    534,  1,    534,  1,    534,  3,    534,  7524, 8,    534,  1,    534,  1,    534,  1,    534,
      3,     534,  7529, 8,    534,  1,    534,  5,    534,  7532, 8,    534,  10,   534,  12,   534,  7535, 9,    534,
      3,     534,  7537, 8,    534,  1,    535,  3,    535,  7540, 8,    535,  1,    535,  1,    535,  1,    535,  1,
      535,   1,    535,  1,    535,  1,    535,  1,    535,  3,    535,  7550, 8,    535,  1,    535,  1,    535,  1,
      535,   1,    535,  3,    535,  7556, 8,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  3,
      535,   7563, 8,    535,  1,    535,  1,    535,  1,    535,  3,    535,  7568, 8,    535,  1,    535,  1,    535,
      1,     535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  3,
      535,   7581, 8,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  1,    535,  3,    535,  7589,
      8,     535,  1,    535,  1,    535,  1,    535,  1,    535,  3,    535,  7595, 8,    535,  1,    535,  1,    535,
      1,     535,  3,    535,  7600, 8,    535,  1,    536,  1,    536,  1,    537,  1,    537,  1,    538,  1,    538,
      1,     538,  1,    539,  1,    539,  3,    539,  7611, 8,    539,  1,    540,  1,    540,  3,    540,  7615, 8,
      540,   1,    540,  1,    540,  1,    540,  3,    540,  7620, 8,    540,  1,    540,  1,    540,  3,    540,  7624,
      8,     540,  1,    540,  3,    540,  7627, 8,    540,  1,    541,  1,    541,  1,    541,  3,    541,  7632, 8,
      541,   1,    541,  1,    541,  3,    541,  7636, 8,    541,  1,    541,  1,    541,  1,    541,  1,    541,  1,
      541,   1,    541,  3,    541,  7644, 8,    541,  1,    541,  1,    541,  1,    541,  1,    541,  1,    541,  1,
      541,   3,    541,  7652, 8,    541,  3,    541,  7654, 8,    541,  1,    542,  1,    542,  1,    542,  1,    542,
      1,     542,  1,    542,  1,    542,  3,    542,  7663, 8,    542,  1,    543,  1,    543,  1,    543,  1,    543,
      5,     543,  7669, 8,    543,  10,   543,  12,   543,  7672, 9,    543,  1,    543,  1,    543,  1,    544,  1,
      544,   3,    544,  7678, 8,    544,  1,    544,  3,    544,  7681, 8,    544,  1,    545,  1,    545,  1,    545,
      1,     545,  5,    545,  7687, 8,    545,  10,   545,  12,   545,  7690, 9,    545,  1,    545,  1,    545,  1,
      546,   1,    546,  1,    546,  1,    546,  3,    546,  7698, 8,    546,  3,    546,  7700, 8,    546,  1,    547,
      1,     547,  1,    548,  1,    548,  3,    548,  7706, 8,    548,  1,    549,  1,    549,  3,    549,  7710, 8,
      549,   1,    549,  1,    549,  1,    549,  1,    549,  1,    549,  1,    549,  1,    549,  3,    549,  7719, 8,
      549,   1,    549,  1,    549,  1,    549,  1,    549,  3,    549,  7725, 8,    549,  1,    549,  3,    549,  7728,
      8,     549,  1,    550,  1,    550,  1,    551,  1,    551,  1,    551,  1,    552,  1,    552,  1,    552,  1,
      552,   3,    552,  7739, 8,    552,  1,    553,  1,    553,  1,    554,  1,    554,  1,    554,  1,    555,  1,
      555,   3,    555,  7748, 8,    555,  1,    555,  3,    555,  7751, 8,    555,  1,    555,  1,    555,  1,    555,
      3,     555,  7756, 8,    555,  3,    555,  7758, 8,    555,  1,    555,  3,    555,  7761, 8,    555,  1,    555,
      3,     555,  7764, 8,    555,  1,    555,  1,    555,  3,    555,  7768, 8,    555,  1,    555,  3,    555,  7771,
      8,     555,  1,    555,  1,    555,  3,    555,  7775, 8,    555,  1,    555,  1,    555,  1,    555,  3,    555,
      7780,  8,    555,  1,    555,  3,    555,  7783, 8,    555,  1,    555,  1,    555,  3,    555,  7787, 8,    555,
      1,     555,  3,    555,  7790, 8,    555,  1,    555,  1,    555,  3,    555,  7794, 8,    555,  1,    555,  1,
      555,   1,    555,  3,    555,  7799, 8,    555,  1,    555,  1,    555,  3,    555,  7803, 8,    555,  1,    555,
      1,     555,  1,    555,  1,    555,  1,    555,  1,    555,  1,    555,  1,    555,  1,    555,  1,    555,  3,
      555,   7815, 8,    555,  1,    555,  1,    555,  3,    555,  7819, 8,    555,  1,    555,  1,    555,  1,    555,
      1,     555,  3,    555,  7825, 8,    555,  1,    555,  3,    555,  7828, 8,    555,  1,    555,  1,    555,  1,
      555,   3,    555,  7833, 8,    555,  1,    555,  1,    555,  3,    555,  7837, 8,    555,  1,    555,  1,    555,
      3,     555,  7841, 8,    555,  1,    555,  1,    555,  1,    555,  3,    555,  7846, 8,    555,  1,    555,  1,
      555,   1,    555,  1,    555,  1,    555,  1,    555,  1,    555,  3,    555,  7855, 8,    555,  1,    555,  3,
      555,   7858, 8,    555,  1,    555,  1,    555,  3,    555,  7862, 8,    555,  1,    555,  1,    555,  3,    555,
      7866,  8,    555,  1,    555,  3,    555,  7869, 8,    555,  1,    555,  1,    555,  3,    555,  7873, 8,    555,
      1,     555,  1,    555,  3,    555,  7877, 8,    555,  1,    555,  1,    555,  1,    555,  3,    555,  7882, 8,
      555,   1,    555,  1,    555,  1,    555,  3,    555,  7887, 8,    555,  1,    555,  1,    555,  1,    555,  3,
      555,   7892, 8,    555,  1,    556,  1,    556,  1,    556,  3,    556,  7897, 8,    556,  1,    557,  1,    557,
      1,     557,  3,    557,  7902, 8,    557,  3,    557,  7904, 8,    557,  1,    558,  1,    558,  1,    558,  3,
      558,   7909, 8,    558,  1,    558,  1,    558,  1,    559,  4,    559,  7914, 8,    559,  11,   559,  12,   559,
      7915,  1,    560,  1,    560,  1,    560,  1,    560,  1,    560,  1,    560,  3,    560,  7924, 8,    560,  1,
      560,   1,    560,  1,    560,  1,    560,  3,    560,  7930, 8,    560,  3,    560,  7932, 8,    560,  1,    561,
      1,     561,  3,    561,  7936, 8,    561,  1,    561,  1,    561,  3,    561,  7940, 8,    561,  1,    562,  1,
      562,   3,    562,  7944, 8,    562,  1,    562,  1,    562,  3,    562,  7948, 8,    562,  1,    563,  1,    563,
      1,     563,  1,    563,  1,    564,  1,    564,  1,    564,  1,    564,  1,    565,  1,    565,  1,    565,  1,
      565,   1,    565,  3,    565,  7963, 8,    565,  1,    566,  1,    566,  1,    566,  1,    566,  3,    566,  7969,
      8,     566,  1,    567,  1,    567,  1,    567,  1,    567,  1,    567,  3,    567,  7976, 8,    567,  1,    568,
      1,     568,  3,    568,  7980, 8,    568,  1,    568,  5,    568,  7983, 8,    568,  10,   568,  12,   568,  7986,
      9,     568,  1,    569,  1,    569,  3,    569,  7990, 8,    569,  1,    569,  3,    569,  7993, 8,    569,  1,
      570,   1,    570,  3,    570,  7997, 8,    570,  1,    570,  3,    570,  8000, 8,    570,  1,    571,  4,    571,
      8003,  8,    571,  11,   571,  12,   571,  8004, 1,    572,  1,    572,  3,    572,  8009, 8,    572,  1,    572,
      1,     572,  1,    572,  1,    572,  3,    572,  8015, 8,    572,  1,    572,  1,    572,  3,    572,  8019, 8,
      572,   1,    572,  1,    572,  3,    572,  8023, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8028,
      8,     572,  1,    572,  1,    572,  1,    572,  3,    572,  8033, 8,    572,  1,    572,  1,    572,  1,    572,
      3,     572,  8038, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8043, 8,    572,  1,    572,  1,
      572,   1,    572,  3,    572,  8048, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8053, 8,    572,
      1,     572,  1,    572,  1,    572,  3,    572,  8058, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,
      8063,  8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8068, 8,    572,  1,    572,  1,    572,  1,
      572,   3,    572,  8073, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8078, 8,    572,  1,    572,
      1,     572,  1,    572,  3,    572,  8083, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8088, 8,
      572,   1,    572,  1,    572,  1,    572,  1,    572,  1,    572,  1,    572,  1,    572,  1,    572,  3,    572,
      8098,  8,    572,  1,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8104, 8,    572,  1,    572,  1,
      572,   1,    572,  1,    572,  3,    572,  8110, 8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8115,
      8,     572,  1,    572,  1,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8122, 8,    572,  1,    572,
      1,     572,  1,    572,  3,    572,  8127, 8,    572,  1,    572,  1,    572,  1,    572,  1,    572,  1,    572,
      1,     572,  1,    572,  3,    572,  8136, 8,    572,  1,    572,  1,    572,  1,    572,  1,    572,  3,    572,
      8142,  8,    572,  1,    572,  1,    572,  1,    572,  3,    572,  8147, 8,    572,  1,    573,  1,    573,  3,
      573,   8151, 8,    573,  1,    574,  3,    574,  8154, 8,    574,  1,    574,  1,    574,  3,    574,  8158, 8,
      574,   1,    574,  1,    574,  1,    575,  3,    575,  8163, 8,    575,  1,    575,  1,    575,  3,    575,  8167,
      8,     575,  1,    575,  1,    575,  1,    576,  3,    576,  8172, 8,    576,  1,    576,  1,    576,  3,    576,
      8176,  8,    576,  1,    576,  1,    576,  1,    577,  1,    577,  1,    577,  1,    577,  1,    577,  3,    577,
      8185,  8,    577,  1,    577,  3,    577,  8188, 8,    577,  1,    577,  3,    577,  8191, 8,    577,  1,    578,
      3,     578,  8194, 8,    578,  1,    578,  1,    578,  3,    578,  8198, 8,    578,  1,    578,  1,    578,  3,
      578,   8202, 8,    578,  1,    578,  1,    578,  3,    578,  8206, 8,    578,  1,    578,  1,    578,  1,    578,
      1,     578,  1,    578,  1,    578,  1,    578,  1,    578,  1,    578,  1,    578,  1,    578,  1,    578,  1,
      578,   3,    578,  8221, 8,    578,  1,    578,  3,    578,  8224, 8,    578,  3,    578,  8226, 8,    578,  1,
      579,   1,    579,  1,    579,  3,    579,  8231, 8,    579,  1,    579,  1,    579,  1,    579,  1,    579,  1,
      579,   1,    579,  1,    579,  3,    579,  8240, 8,    579,  1,    579,  3,    579,  8243, 8,    579,  1,    579,
      1,     579,  3,    579,  8247, 8,    579,  1,    580,  1,    580,  1,    580,  1,    580,  1,    581,  1,    581,
      1,     581,  1,    581,  5,    581,  8257, 8,    581,  10,   581,  12,   581,  8260, 9,    581,  1,    581,  1,
      581,   1,    582,  1,    582,  1,    582,  1,    582,  1,    582,  1,    582,  1,    582,  3,    582,  8271, 8,
      582,   1,    582,  1,    582,  1,    582,  3,    582,  8276, 8,    582,  1,    582,  5,    582,  8279, 8,    582,
      10,    582,  12,   582,  8282, 9,    582,  1,    582,  1,    582,  1,    582,  1,    582,  5,    582,  8288, 8,
      582,   10,   582,  12,   582,  8291, 9,    582,  1,    582,  1,    582,  3,    582,  8295, 8,    582,  1,    583,
      1,     583,  1,    583,  1,    583,  1,    583,  5,    583,  8302, 8,    583,  10,   583,  12,   583,  8305, 9,
      583,   1,    583,  1,    583,  3,    583,  8309, 8,    583,  1,    584,  1,    584,  3,    584,  8313, 8,    584,
      1,     584,  1,    584,  3,    584,  8317, 8,    584,  1,    584,  1,    584,  3,    584,  8321, 8,    584,  1,
      584,   1,    584,  1,    584,  3,    584,  8326, 8,    584,  1,    584,  1,    584,  1,    584,  3,    584,  8331,
      8,     584,  1,    584,  1,    584,  1,    584,  1,    584,  3,    584,  8337, 8,    584,  1,    584,  1,    584,
      1,     584,  3,    584,  8342, 8,    584,  1,    584,  3,    584,  8345, 8,    584,  1,    585,  1,    585,  1,
      585,   5,    585,  8350, 8,    585,  10,   585,  12,   585,  8353, 9,    585,  1,    586,  1,    586,  1,    586,
      1,     586,  5,    586,  8359, 8,    586,  10,   586,  12,   586,  8362, 9,    586,  1,    586,  1,    586,  1,
      587,   1,    587,  3,    587,  8368, 8,    587,  1,    588,  1,    588,  1,    588,  1,    588,  1,    589,  1,
      589,   1,    589,  1,    590,  1,    590,  1,    590,  1,    590,  1,    591,  1,    591,  1,    591,  1,    591,
      1,     592,  3,    592,  8386, 8,    592,  1,    592,  1,    592,  1,    593,  1,    593,  1,    593,  1,    594,
      1,     594,  1,    594,  1,    595,  1,    595,  3,    595,  8398, 8,    595,  1,    596,  1,    596,  1,    596,
      1,     596,  1,    596,  1,    596,  1,    597,  1,    597,  1,    597,  5,    597,  8409, 8,    597,  10,   597,
      12,    597,  8412, 9,    597,  1,    598,  1,    598,  1,    598,  5,    598,  8417, 8,    598,  10,   598,  12,
      598,   8420, 9,    598,  1,    599,  1,    599,  1,    599,  1,    599,  3,    599,  8426, 8,    599,  1,    600,
      1,     600,  1,    600,  1,    601,  1,    601,  4,    601,  8433, 8,    601,  11,   601,  12,   601,  8434, 1,
      602,   1,    602,  1,    602,  1,    602,  3,    602,  8441, 8,    602,  1,    602,  1,    602,  1,    602,  1,
      602,   1,    602,  1,    602,  3,    602,  8449, 8,    602,  1,    603,  1,    603,  4,    603,  8453, 8,    603,
      11,    603,  12,   603,  8454, 1,    604,  1,    604,  1,    604,  1,    604,  1,    605,  1,    605,  1,    605,
      5,     605,  8464, 8,    605,  10,   605,  12,   605,  8467, 9,    605,  1,    606,  1,    606,  1,    606,  5,
      606,   8472, 8,    606,  10,   606,  12,   606,  8475, 9,    606,  1,    607,  1,    607,  1,    607,  3,    607,
      8480,  8,    607,  1,    607,  1,    607,  3,    607,  8484, 8,    607,  1,    607,  3,    607,  8487, 8,    607,
      1,     608,  1,    608,  1,    608,  1,    608,  3,    608,  8493, 8,    608,  1,    609,  1,    609,  1,    609,
      1,     609,  1,    609,  1,    609,  3,    609,  8501, 8,    609,  1,    610,  1,    610,  1,    610,  1,    610,
      1,     611,  1,    611,  1,    611,  1,    611,  1,    611,  1,    612,  1,    612,  1,    612,  1,    612,  1,
      613,   1,    613,  1,    613,  1,    613,  1,    613,  1,    613,  1,    614,  1,    614,  1,    614,  1,    614,
      1,     614,  1,    614,  1,    615,  1,    615,  1,    615,  1,    615,  1,    615,  1,    615,  1,    615,  1,
      616,   1,    616,  1,    616,  1,    616,  1,    616,  3,    616,  8540, 8,    616,  1,    617,  1,    617,  1,
      617,   1,    617,  1,    618,  1,    618,  1,    618,  1,    618,  1,    619,  1,    619,  1,    619,  1,    619,
      1,     619,  1,    619,  1,    619,  1,    619,  1,    619,  1,    619,  1,    619,  1,    619,  1,    619,  1,
      619,   1,    619,  3,    619,  8565, 8,    619,  1,    620,  1,    620,  1,    620,  1,    621,  1,    621,  1,
      621,   1,    622,  1,    622,  3,    622,  8575, 8,    622,  1,    623,  1,    623,  1,    623,  3,    623,  8580,
      8,     623,  3,    623,  8582, 8,    623,  1,    624,  1,    624,  1,    624,  1,    625,  1,    625,  3,    625,
      8589,  8,    625,  1,    626,  1,    626,  1,    627,  1,    627,  1,    628,  1,    628,  1,    628,  1,    629,
      1,     629,  1,    629,  3,    629,  8601, 8,    629,  3,    629,  8603, 8,    629,  1,    630,  1,    630,  1,
      631,   1,    631,  1,    632,  1,    632,  1,    632,  1,    632,  5,    632,  8613, 8,    632,  10,   632,  12,
      632,   8616, 9,    632,  1,    632,  1,    632,  1,    633,  1,    633,  1,    634,  1,    634,  3,    634,  8624,
      8,     634,  1,    635,  1,    635,  1,    636,  1,    636,  1,    637,  1,    637,  1,    637,  1,    637,  1,
      637,   3,    637,  8635, 8,    637,  1,    637,  1,    637,  1,    638,  1,    638,  1,    639,  1,    639,  1,
      640,   1,    640,  1,    641,  1,    641,  1,    642,  1,    642,  1,    643,  1,    643,  1,    644,  1,    644,
      1,     645,  1,    645,  1,    646,  1,    646,  3,    646,  8657, 8,    646,  1,    647,  1,    647,  3,    647,
      8661,  8,    647,  1,    648,  1,    648,  1,    649,  1,    649,  1,    650,  1,    650,  1,    651,  1,    651,
      1,     652,  1,    652,  1,    653,  1,    653,  1,    654,  1,    654,  1,    655,  1,    655,  1,    656,  1,
      656,   1,    657,  1,    657,  1,    658,  1,    658,  3,    658,  8685, 8,    658,  1,    659,  1,    659,  1,
      659,   1,    660,  1,    660,  1,    660,  1,    660,  1,    660,  1,    660,  3,    660,  8696, 8,    660,  3,
      660,   8698, 8,    660,  1,    661,  1,    661,  3,    661,  8702, 8,    661,  1,    662,  1,    662,  1,    662,
      5,     662,  8707, 8,    662,  10,   662,  12,   662,  8710, 9,    662,  1,    663,  1,    663,  1,    663,  5,
      663,   8715, 8,    663,  10,   663,  12,   663,  8718, 9,    663,  1,    664,  1,    664,  1,    665,  1,    665,
      3,     665,  8724, 8,    665,  1,    666,  1,    666,  1,    667,  1,    667,  3,    667,  8730, 8,    667,  1,
      668,   1,    668,  1,    669,  1,    669,  1,    670,  1,    670,  1,    671,  1,    671,  1,    672,  1,    672,
      1,     672,  3,    672,  8743, 8,    672,  1,    673,  1,    673,  3,    673,  8747, 8,    673,  1,    674,  1,
      674,   1,    674,  5,    674,  8752, 8,    674,  10,   674,  12,   674,  8755, 9,    674,  1,    675,  1,    675,
      1,     675,  1,    675,  1,    676,  1,    676,  3,    676,  8763, 8,    676,  1,    677,  1,    677,  1,    677,
      3,     677,  8768, 8,    677,  3,    677,  8770, 8,    677,  1,    678,  1,    678,  1,    678,  1,    679,  1,
      679,   1,    680,  1,    680,  1,    681,  1,    681,  1,    682,  1,    682,  1,    682,  1,    682,  1,    682,
      3,     682,  8786, 8,    682,  1,    683,  1,    683,  1,    683,  1,    683,  1,    683,  3,    683,  8793, 8,
      683,   1,    684,  1,    684,  1,    684,  3,    684,  8798, 8,    684,  1,    685,  1,    685,  1,    685,  1,
      685,   1,    685,  1,    685,  3,    685,  8806, 8,    685,  1,    685,  3,    685,  8809, 8,    685,  1,    686,
      1,     686,  1,    686,  3,    686,  8814, 8,    686,  1,    687,  1,    687,  1,    688,  1,    688,  1,    688,
      1,     688,  5,    688,  8822, 8,    688,  10,   688,  12,   688,  8825, 9,    688,  1,    688,  1,    688,  1,
      689,   1,    689,  1,    689,  3,    689,  8832, 8,    689,  1,    690,  1,    690,  1,    690,  3,    690,  8837,
      8,     690,  1,    691,  1,    691,  1,    691,  3,    691,  8842, 8,    691,  1,    692,  3,    692,  8845, 8,
      692,   1,    692,  1,    692,  3,    692,  8849, 8,    692,  1,    692,  5,    692,  8852, 8,    692,  10,   692,
      12,    692,  8855, 9,    692,  1,    693,  1,    693,  1,    694,  1,    694,  1,    694,  5,    694,  8862, 8,
      694,   10,   694,  12,   694,  8865, 9,    694,  1,    695,  1,    695,  1,    695,  3,    695,  8870, 8,    695,
      1,     696,  1,    696,  1,    697,  1,    697,  1,    698,  1,    698,  1,    699,  1,    699,  1,    699,  1,
      699,   1,    699,  1,    699,  3,    699,  8884, 8,    699,  1,    700,  1,    700,  3,    700,  8888, 8,    700,
      1,     701,  1,    701,  1,    702,  1,    702,  1,    702,  1,    702,  1,    702,  1,    702,  1,    703,  1,
      703,   3,    703,  8900, 8,    703,  1,    704,  1,    704,  3,    704,  8904, 8,    704,  1,    705,  1,    705,
      3,     705,  8908, 8,    705,  1,    706,  1,    706,  3,    706,  8912, 8,    706,  1,    707,  1,    707,  1,
      707,   1,    708,  1,    708,  1,    709,  1,    709,  1,    710,  1,    710,  1,    710,  1,    710,  1,    710,
      1,     710,  3,    710,  8927, 8,    710,  1,    711,  1,    711,  1,    711,  1,    712,  1,    712,  1,    713,
      1,     713,  1,    713,  1,    713,  1,    713,  1,    713,  1,    713,  3,    713,  8941, 8,    713,  1,    713,
      1,     713,  1,    713,  1,    713,  1,    713,  3,    713,  8948, 8,    713,  3,    713,  8950, 8,    713,  1,
      714,   1,    714,  1,    715,  1,    715,  1,    716,  1,    716,  1,    716,  1,    716,  1,    716,  1,    716,
      1,     716,  1,    716,  1,    716,  1,    716,  1,    716,  3,    716,  8967, 8,    716,  1,    716,  1,    716,
      1,     716,  3,    716,  8972, 8,    716,  3,    716,  8974, 8,    716,  1,    717,  1,    717,  1,    718,  1,
      718,   1,    718,  3,    718,  8981, 8,    718,  1,    719,  1,    719,  1,    719,  3,    719,  8986, 8,    719,
      1,     719,  1,    719,  1,    719,  3,    719,  8991, 8,    719,  3,    719,  8993, 8,    719,  1,    720,  1,
      720,   1,    720,  1,    720,  3,    720,  8999, 8,    720,  1,    721,  1,    721,  1,    722,  1,    722,  1,
      723,   1,    723,  1,    723,  3,    723,  9008, 8,    723,  1,    723,  0,    4,    860,  862,  870,  872,  724,
      0,     2,    4,    6,    8,    10,   12,   14,   16,   18,   20,   22,   24,   26,   28,   30,   32,   34,   36,
      38,    40,   42,   44,   46,   48,   50,   52,   54,   56,   58,   60,   62,   64,   66,   68,   70,   72,   74,
      76,    78,   80,   82,   84,   86,   88,   90,   92,   94,   96,   98,   100,  102,  104,  106,  108,  110,  112,
      114,   116,  118,  120,  122,  124,  126,  128,  130,  132,  134,  136,  138,  140,  142,  144,  146,  148,  150,
      152,   154,  156,  158,  160,  162,  164,  166,  168,  170,  172,  174,  176,  178,  180,  182,  184,  186,  188,
      190,   192,  194,  196,  198,  200,  202,  204,  206,  208,  210,  212,  214,  216,  218,  220,  222,  224,  226,
      228,   230,  232,  234,  236,  238,  240,  242,  244,  246,  248,  250,  252,  254,  256,  258,  260,  262,  264,
      266,   268,  270,  272,  274,  276,  278,  280,  282,  284,  286,  288,  290,  292,  294,  296,  298,  300,  302,
      304,   306,  308,  310,  312,  314,  316,  318,  320,  322,  324,  326,  328,  330,  332,  334,  336,  338,  340,
      342,   344,  346,  348,  350,  352,  354,  356,  358,  360,  362,  364,  366,  368,  370,  372,  374,  376,  378,
      380,   382,  384,  386,  388,  390,  392,  394,  396,  398,  400,  402,  404,  406,  408,  410,  412,  414,  416,
      418,   420,  422,  424,  426,  428,  430,  432,  434,  436,  438,  440,  442,  444,  446,  448,  450,  452,  454,
      456,   458,  460,  462,  464,  466,  468,  470,  472,  474,  476,  478,  480,  482,  484,  486,  488,  490,  492,
      494,   496,  498,  500,  502,  504,  506,  508,  510,  512,  514,  516,  518,  520,  522,  524,  526,  528,  530,
      532,   534,  536,  538,  540,  542,  544,  546,  548,  550,  552,  554,  556,  558,  560,  562,  564,  566,  568,
      570,   572,  574,  576,  578,  580,  582,  584,  586,  588,  590,  592,  594,  596,  598,  600,  602,  604,  606,
      608,   610,  612,  614,  616,  618,  620,  622,  624,  626,  628,  630,  632,  634,  636,  638,  640,  642,  644,
      646,   648,  650,  652,  654,  656,  658,  660,  662,  664,  666,  668,  670,  672,  674,  676,  678,  680,  682,
      684,   686,  688,  690,  692,  694,  696,  698,  700,  702,  704,  706,  708,  710,  712,  714,  716,  718,  720,
      722,   724,  726,  728,  730,  732,  734,  736,  738,  740,  742,  744,  746,  748,  750,  752,  754,  756,  758,
      760,   762,  764,  766,  768,  770,  772,  774,  776,  778,  780,  782,  784,  786,  788,  790,  792,  794,  796,
      798,   800,  802,  804,  806,  808,  810,  812,  814,  816,  818,  820,  822,  824,  826,  828,  830,  832,  834,
      836,   838,  840,  842,  844,  846,  848,  850,  852,  854,  856,  858,  860,  862,  864,  866,  868,  870,  872,
      874,   876,  878,  880,  882,  884,  886,  888,  890,  892,  894,  896,  898,  900,  902,  904,  906,  908,  910,
      912,   914,  916,  918,  920,  922,  924,  926,  928,  930,  932,  934,  936,  938,  940,  942,  944,  946,  948,
      950,   952,  954,  956,  958,  960,  962,  964,  966,  968,  970,  972,  974,  976,  978,  980,  982,  984,  986,
      988,   990,  992,  994,  996,  998,  1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024,
      1026,  1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042, 1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062,
      1064,  1066, 1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090, 1092, 1094, 1096, 1098, 1100,
      1102,  1104, 1106, 1108, 1110, 1112, 1114, 1116, 1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138,
      1140,  1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158, 1160, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176,
      1178,  1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214,
      1216,  1218, 1220, 1222, 1224, 1226, 1228, 1230, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252,
      1254,  1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290,
      1292,  1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, 1328,
      1330,  1332, 1334, 1336, 1338, 1340, 1342, 1344, 1346, 1348, 1350, 1352, 1354, 1356, 1358, 1360, 1362, 1364, 1366,
      1368,  1370, 1372, 1374, 1376, 1378, 1380, 1382, 1384, 1386, 1388, 1390, 1392, 1394, 1396, 1398, 1400, 1402, 1404,
      1406,  1408, 1410, 1412, 1414, 1416, 1418, 1420, 1422, 1424, 1426, 1428, 1430, 1432, 1434, 1436, 1438, 1440, 1442,
      1444,  1446, 0,    170,  1,    0,    722,  723,  2,    0,    17,   17,   590,  590,  2,    0,    49,   49,   471,
      471,   1,    0,    645,  646,  2,    0,    4,    4,    148,  148,  1,    0,    724,  725,  2,    0,    50,   50,
      284,   284,  2,    0,    140,  140,  156,  156,  2,    0,    232,  232,  458,  458,  4,    0,    126,  126,  249,
      249,   437,  437,  556,  556,  2,    0,    130,  130,  250,  250,  2,    0,    441,  441,  604,  604,  2,    0,
      374,   374,  638,  638,  3,    0,    335,  335,  578,  578,  602,  602,  2,    0,    6,    6,    28,   28,   3,
      0,     133,  133,  242,  242,  614,  614,  2,    0,    197,  197,  415,  415,  2,    0,    571,  571,  574,  574,
      3,     0,    232,  232,  295,  295,  431,  431,  2,    0,    191,  191,  367,  367,  4,    0,    191,  191,  268,
      268,   367,  367,  419,  419,  2,    0,    750,  750,  753,  756,  3,    0,    131,  131,  223,  223,  295,  295,
      1,     0,    626,  627,  2,    0,    82,   82,   295,  295,  2,    0,    112,  112,  653,  653,  2,    0,    278,
      278,   484,  484,  2,    0,    131,  131,  295,  295,  2,    0,    663,  663,  844,  844,  7,    0,    10,   10,
      143,   143,  223,  223,  531,  532,  534,  534,  536,  536,  555,  555,  2,    0,    381,  381,  773,  773,  2,
      0,     747,  749,  787,  787,  3,    0,    432,  432,  484,  484,  683,  683,  2,    0,    18,   18,   134,  134,
      2,     0,    508,  508,  614,  614,  2,    0,    272,  272,  478,  478,  2,    0,    98,   98,   239,  239,  2,
      0,     10,   10,   143,  143,  2,    0,    198,  198,  232,  232,  2,    0,    236,  236,  265,  265,  2,    0,
      386,   386,  649,  649,  3,    0,    244,  244,  571,  571,  574,  574,  2,    0,    29,   29,   543,  543,  2,
      0,     261,  261,  472,  472,  2,    0,    32,   32,   316,  316,  2,    0,    296,  296,  807,  807,  2,    0,
      300,   300,  813,  813,  2,    0,    297,  297,  808,  808,  2,    0,    318,  318,  831,  831,  2,    0,    303,
      303,   816,  816,  2,    0,    304,  304,  817,  817,  2,    0,    298,  298,  810,  810,  2,    0,    305,  305,
      819,   819,  2,    0,    299,  299,  811,  811,  2,    0,    314,  314,  820,  820,  2,    0,    308,  308,  821,
      821,   2,    0,    307,  307,  822,  822,  2,    0,    310,  310,  824,  824,  2,    0,    311,  311,  825,  825,
      2,     0,    312,  312,  826,  826,  2,    0,    313,  313,  827,  827,  2,    0,    315,  315,  828,  828,  2,
      0,     317,  317,  830,  830,  2,    0,    738,  738,  829,  829,  2,    0,    309,  309,  823,  823,  2,    0,
      712,   712,  818,  818,  2,    0,    713,  713,  806,  806,  2,    0,    319,  319,  812,  812,  2,    0,    735,
      735,   809,  809,  2,    0,    736,  736,  832,  832,  2,    0,    383,  383,  743,  744,  2,    0,    301,  301,
      814,   814,  2,    0,    302,  302,  815,  815,  2,    0,    528,  528,  530,  530,  2,    0,    449,  449,  538,
      538,   2,    0,    514,  514,  803,  803,  2,    0,    123,  123,  148,  148,  3,    0,    369,  369,  539,  539,
      650,   650,  2,    0,    287,  287,  611,  611,  2,    0,    128,  128,  719,  719,  3,    0,    206,  206,  422,
      422,   574,  574,  4,    0,    242,  242,  443,  443,  497,  497,  614,  614,  13,   0,    133,  133,  148,  148,
      170,   170,  173,  173,  188,  188,  236,  236,  423,  423,  427,  427,  451,  451,  510,  510,  565,  565,  594,
      594,   616,  616,  4,    0,    483,  483,  572,  572,  618,  618,  636,  636,  2,    0,    97,   97,   148,  148,
      2,     0,    128,  128,  369,  369,  2,    0,    180,  180,  431,  431,  5,    0,    56,   56,   180,  180,  184,
      184,   333,  333,  431,  431,  3,    0,    180,  180,  431,  431,  619,  619,  2,    0,    76,   76,   601,  601,
      2,     0,    203,  203,  251,  251,  2,    0,    235,  236,  263,  263,  6,    0,    10,   10,   96,   96,   256,
      256,   334,  334,  522,  522,  567,  567,  2,    0,    84,   84,   430,  430,  4,    0,    225,  225,  421,  421,
      547,   547,  617,  617,  5,    0,    32,   32,   163,  163,  165,  165,  208,  208,  515,  515,  2,    0,    618,
      618,   710,  710,  2,    0,    134,  135,  178,  178,  3,    0,    183,  183,  596,  596,  610,  610,  2,    0,
      15,    15,   767,  767,  2,    0,    394,  394,  770,  770,  2,    0,    10,   10,   16,   16,   2,    0,    750,
      750,   752,  757,  3,    0,    145,  145,  349,  349,  760,  762,  1,    0,    758,  759,  1,    0,    765,  766,
      2,     0,    758,  759,  764,  764,  2,    0,    35,   36,   38,   38,   2,    0,    326,  326,  345,  345,  5,
      0,     548,  548,  551,  551,  564,  564,  632,  632,  635,  635,  4,    0,    678,  679,  692,  692,  694,  694,
      696,   696,  2,    0,    684,  684,  686,  686,  2,    0,    681,  681,  685,  685,  2,    0,    191,  191,  268,
      268,   2,    0,    232,  232,  695,  695,  2,    0,    5,    5,    558,  558,  1,    0,    114,  115,  1,    0,
      792,   793,  4,    0,    113,  113,  116,  116,  583,  583,  586,  586,  4,    0,    211,  211,  279,  279,  351,
      353,   411,  412,  2,    0,    371,  371,  745,  745,  2,    0,    745,  745,  763,  763,  5,    0,    118,  121,
      226,   228,  341,  342,  494,  494,  655,  655,  9,    0,    122,  122,  229,  229,  337,  337,  343,  343,  350,
      350,   429,  429,  495,  495,  640,  640,  656,  656,  3,    0,    92,   92,   175,  175,  605,  605,  2,    0,
      101,   101,  540,  540,  2,    0,    377,  377,  485,  485,  10,   0,    53,   53,   64,   64,   73,   73,   87,
      89,    107,  107,  336,  336,  355,  355,  492,  492,  557,  557,  576,  576,  2,    0,    554,  554,  637,  637,
      3,     0,    128,  128,  152,  152,  192,  192,  3,    0,    128,  128,  142,  142,  334,  334,  3,    0,    204,
      204,   402,  402,  513,  513,  3,    0,    44,   44,   220,  220,  488,  488,  1,    0,    661,  662,  2,    0,
      599,   599,  621,  621,  5,    0,    31,   31,   249,  249,  331,  331,  516,  516,  588,  588,  4,    0,    126,
      126,   192,  192,  195,  195,  378,  378,  1,    0,    41,   42,   2,    0,    290,  290,  330,  330,  4,    0,
      211,   212,  279,  279,  351,  353,  411,  412,  3,    0,    512,  512,  612,  612,  657,  657,  1,    0,    544,
      546,   2,    0,    61,   61,   575,  575,  6,    0,    78,   78,   80,   80,   128,  128,  152,  152,  192,  192,
      442,   442,  3,    0,    191,  191,  268,  268,  373,  373,  2,    0,    142,  142,  334,  334,  2,    0,    280,
      280,   432,  432,  2,    0,    323,  323,  344,  344,  2,    0,    112,  112,  236,  236,  3,    0,    240,  240,
      251,   251,  397,  397,  2,    0,    541,  541,  579,  579,  2,    0,    380,  380,  385,  385,  2,    0,    284,
      284,   375,  375,  2,    0,    848,  848,  850,  850,  3,    0,    747,  749,  788,  788,  790,  791,  2,    0,
      747,   749,  788,  788,  2,    0,    747,  749,  790,  791,  1,    0,    788,  789,  2,    0,    183,  183,  596,
      596,   2,    0,    376,  376,  786,  786,  1,    0,    747,  749,  1,    0,    750,  751,  5,    0,    214,  214,
      284,   284,  502,  502,  658,  658,  673,  673,  3,    0,    173,  173,  510,  510,  714,  714,  32,   0,    19,
      19,    29,   29,   46,   47,   58,   58,   61,   61,   75,   75,   77,   77,   90,   90,   123,  123,  147,  147,
      159,   159,  196,  197,  219,  219,  222,  222,  234,  234,  245,  245,  267,  267,  373,  373,  415,  415,  417,
      417,   455,  455,  468,  468,  480,  480,  489,  489,  512,  512,  514,  514,  543,  543,  552,  552,  597,  597,
      606,   607,  651,  651,  677,  677,  9,    0,    170,  170,  188,  188,  369,  369,  423,  423,  427,  427,  451,
      451,   459,  459,  565,  565,  709,  709,  166,  0,    2,    3,    5,    9,    12,   12,   16,   16,   21,   21,
      23,    27,   33,   33,   37,   37,   40,   42,   44,   44,   50,   50,   53,   54,   56,   57,   63,   68,   70,
      71,    73,   74,   76,   76,   78,   82,   84,   85,   87,   89,   91,   91,   96,   96,   101,  101,  107,  107,
      111,   113,  116,  116,  122,  122,  129,  130,  132,  132,  138,  142,  150,  152,  156,  156,  158,  158,  160,
      160,   162,  166,  168,  169,  171,  172,  176,  177,  179,  181,  184,  185,  189,  192,  201,  202,  204,  204,
      208,   208,  210,  213,  216,  216,  220,  220,  224,  225,  229,  230,  233,  233,  235,  235,  238,  238,  243,
      244,   250,  250,  255,  256,  258,  259,  262,  262,  264,  264,  268,  268,  270,  270,  273,  274,  279,  280,
      286,   286,  288,  289,  296,  296,  298,  305,  307,  314,  316,  319,  321,  324,  327,  328,  333,  337,  340,
      340,   343,  344,  346,  346,  348,  348,  350,  358,  361,  361,  363,  363,  365,  368,  374,  374,  377,  377,
      379,   379,  381,  381,  384,  384,  386,  387,  390,  390,  398,  404,  406,  413,  418,  419,  421,  421,  424,
      426,   429,  431,  434,  434,  438,  439,  441,  442,  445,  449,  452,  452,  454,  454,  456,  456,  460,  466,
      470,   470,  472,  474,  476,  476,  481,  483,  485,  486,  488,  488,  490,  490,  492,  492,  495,  496,  500,
      501,   503,  503,  508,  508,  513,  513,  515,  515,  517,  517,  519,  522,  528,  530,  532,  532,  535,  535,
      538,   538,  540,  540,  542,  542,  544,  547,  553,  553,  556,  561,  566,  568,  571,  572,  575,  578,  580,
      581,   583,  583,  586,  586,  592,  593,  598,  599,  601,  604,  610,  610,  613,  613,  615,  615,  617,  619,
      625,   625,  627,  627,  631,  631,  636,  636,  638,  641,  646,  648,  650,  650,  652,  653,  656,  656,  659,
      662,   664,  664,  669,  671,  674,  675,  680,  680,  682,  682,  689,  690,  693,  693,  695,  695,  697,  698,
      702,   708,  711,  713,  715,  725,  727,  730,  732,  732,  735,  738,  792,  797,  799,  801,  803,  843,  4,
      0,     583,  583,  586,  586,  731,  731,  733,  744,  54,   0,    2,    2,    12,   12,   19,   19,   27,   27,
      29,    29,   46,   47,   58,   58,   61,   61,   66,   66,   75,   75,   77,   77,   90,   90,   123,  123,  147,
      147,   159,  159,  196,  197,  201,  201,  210,  210,  219,  219,  222,  222,  224,  224,  245,  245,  267,  267,
      373,   373,  387,  387,  390,  390,  398,  398,  401,  401,  405,  405,  413,  413,  415,  415,  417,  417,  452,
      452,   455,  455,  468,  468,  470,  470,  480,  480,  489,  489,  496,  496,  503,  503,  512,  512,  514,  514,
      519,   520,  543,  543,  552,  552,  597,  597,  606,  607,  615,  615,  648,  648,  651,  651,  659,  659,  661,
      662,   677,  677,  720,  723,  158,  0,    3,    3,    5,    9,    16,   16,   21,   21,   23,   26,   33,   33,
      37,    37,   40,   42,   44,   44,   50,   50,   53,   54,   56,   57,   63,   65,   67,   68,   70,   71,   73,
      74,    76,   76,   78,   82,   84,   85,   87,   89,   91,   91,   96,   96,   101,  101,  107,  107,  111,  113,
      116,   116,  122,  122,  129,  130,  132,  132,  138,  142,  150,  152,  156,  156,  158,  158,  160,  160,  162,
      166,   168,  169,  171,  171,  176,  176,  179,  181,  184,  185,  189,  192,  202,  202,  204,  204,  208,  208,
      211,   214,  216,  216,  220,  220,  225,  225,  229,  230,  233,  233,  235,  235,  238,  238,  243,  244,  250,
      250,   255,  256,  258,  259,  262,  262,  264,  264,  268,  268,  270,  270,  273,  274,  279,  280,  284,  284,
      286,   286,  288,  289,  296,  296,  298,  305,  307,  314,  316,  319,  321,  324,  327,  328,  333,  337,  340,
      340,   343,  344,  346,  346,  348,  348,  350,  358,  361,  361,  363,  363,  365,  368,  374,  374,  377,  377,
      379,   379,  381,  381,  384,  384,  399,  400,  402,  404,  406,  412,  418,  419,  421,  421,  424,  426,  429,
      431,   434,  434,  438,  439,  441,  442,  445,  449,  454,  454,  456,  456,  460,  466,  472,  474,  476,  476,
      481,   483,  485,  486,  488,  488,  490,  490,  492,  492,  495,  495,  500,  502,  508,  508,  513,  513,  515,
      515,   517,  517,  521,  522,  528,  530,  532,  532,  535,  535,  538,  538,  540,  540,  542,  542,  544,  547,
      553,   553,  556,  561,  565,  568,  571,  572,  575,  578,  580,  581,  583,  583,  586,  586,  592,  593,  598,
      604,   610,  610,  613,  613,  617,  619,  627,  627,  631,  631,  636,  636,  638,  641,  647,  647,  650,  650,
      652,   653,  656,  656,  664,  664,  669,  671,  674,  676,  680,  680,  682,  682,  689,  690,  693,  693,  695,
      695,   697,  698,  702,  708,  711,  712,  716,  717,  719,  719,  724,  725,  727,  728,  792,  793,  798,  798,
      10074, 0,    1455, 1,    0,    0,    0,    2,    1532, 1,    0,    0,    0,    4,    1534, 1,    0,    0,    0,
      6,     1557, 1,    0,    0,    0,    8,    1571, 1,    0,    0,    0,    10,   1574, 1,    0,    0,    0,    12,
      1612,  1,    0,    0,    0,    14,   1621, 1,    0,    0,    0,    16,   1634, 1,    0,    0,    0,    18,   1636,
      1,     0,    0,    0,    20,   1641, 1,    0,    0,    0,    22,   1661, 1,    0,    0,    0,    24,   1670, 1,
      0,     0,    0,    26,   1672, 1,    0,    0,    0,    28,   1687, 1,    0,    0,    0,    30,   1783, 1,    0,
      0,     0,    32,   1787, 1,    0,    0,    0,    34,   1803, 1,    0,    0,    0,    36,   1940, 1,    0,    0,
      0,     38,   1945, 1,    0,    0,    0,    40,   1947, 1,    0,    0,    0,    42,   1949, 1,    0,    0,    0,
      44,    1963, 1,    0,    0,    0,    46,   1971, 1,    0,    0,    0,    48,   1987, 1,    0,    0,    0,    50,
      1989,  1,    0,    0,    0,    52,   1992, 1,    0,    0,    0,    54,   1997, 1,    0,    0,    0,    56,   1999,
      1,     0,    0,    0,    58,   2014, 1,    0,    0,    0,    60,   2022, 1,    0,    0,    0,    62,   2032, 1,
      0,     0,    0,    64,   2034, 1,    0,    0,    0,    66,   2056, 1,    0,    0,    0,    68,   2065, 1,    0,
      0,     0,    70,   2068, 1,    0,    0,    0,    72,   2081, 1,    0,    0,    0,    74,   2086, 1,    0,    0,
      0,     76,   2090, 1,    0,    0,    0,    78,   2129, 1,    0,    0,    0,    80,   2131, 1,    0,    0,    0,
      82,    2151, 1,    0,    0,    0,    84,   2166, 1,    0,    0,    0,    86,   2169, 1,    0,    0,    0,    88,
      2194,  1,    0,    0,    0,    90,   2204, 1,    0,    0,    0,    92,   2207, 1,    0,    0,    0,    94,   2212,
      1,     0,    0,    0,    96,   2222, 1,    0,    0,    0,    98,   2224, 1,    0,    0,    0,    100,  2228, 1,
      0,     0,    0,    102,  2240, 1,    0,    0,    0,    104,  2268, 1,    0,    0,    0,    106,  2298, 1,    0,
      0,     0,    108,  2315, 1,    0,    0,    0,    110,  2318, 1,    0,    0,    0,    112,  2339, 1,    0,    0,
      0,     114,  2342, 1,    0,    0,    0,    116,  2394, 1,    0,    0,    0,    118,  2396, 1,    0,    0,    0,
      120,   2400, 1,    0,    0,    0,    122,  2409, 1,    0,    0,    0,    124,  2425, 1,    0,    0,    0,    126,
      2427,  1,    0,    0,    0,    128,  2435, 1,    0,    0,    0,    130,  2461, 1,    0,    0,    0,    132,  2463,
      1,     0,    0,    0,    134,  2475, 1,    0,    0,    0,    136,  2490, 1,    0,    0,    0,    138,  2492, 1,
      0,     0,    0,    140,  2495, 1,    0,    0,    0,    142,  2516, 1,    0,    0,    0,    144,  2518, 1,    0,
      0,     0,    146,  2524, 1,    0,    0,    0,    148,  2530, 1,    0,    0,    0,    150,  2536, 1,    0,    0,
      0,     152,  2542, 1,    0,    0,    0,    154,  2548, 1,    0,    0,    0,    156,  2555, 1,    0,    0,    0,
      158,   2563, 1,    0,    0,    0,    160,  2565, 1,    0,    0,    0,    162,  2571, 1,    0,    0,    0,    164,
      2577,  1,    0,    0,    0,    166,  2583, 1,    0,    0,    0,    168,  2590, 1,    0,    0,    0,    170,  2608,
      1,     0,    0,    0,    172,  2610, 1,    0,    0,    0,    174,  2614, 1,    0,    0,    0,    176,  2619, 1,
      0,     0,    0,    178,  2638, 1,    0,    0,    0,    180,  2642, 1,    0,    0,    0,    182,  2675, 1,    0,
      0,     0,    184,  2706, 1,    0,    0,    0,    186,  2723, 1,    0,    0,    0,    188,  2725, 1,    0,    0,
      0,     190,  2744, 1,    0,    0,    0,    192,  2750, 1,    0,    0,    0,    194,  2756, 1,    0,    0,    0,
      196,   2762, 1,    0,    0,    0,    198,  2769, 1,    0,    0,    0,    200,  2778, 1,    0,    0,    0,    202,
      2795,  1,    0,    0,    0,    204,  2797, 1,    0,    0,    0,    206,  2804, 1,    0,    0,    0,    208,  2814,
      1,     0,    0,    0,    210,  2828, 1,    0,    0,    0,    212,  2834, 1,    0,    0,    0,    214,  2842, 1,
      0,     0,    0,    216,  2848, 1,    0,    0,    0,    218,  2856, 1,    0,    0,    0,    220,  2862, 1,    0,
      0,     0,    222,  2872, 1,    0,    0,    0,    224,  2876, 1,    0,    0,    0,    226,  2882, 1,    0,    0,
      0,     228,  2887, 1,    0,    0,    0,    230,  2897, 1,    0,    0,    0,    232,  2940, 1,    0,    0,    0,
      234,   2945, 1,    0,    0,    0,    236,  2947, 1,    0,    0,    0,    238,  2950, 1,    0,    0,    0,    240,
      2980,  1,    0,    0,    0,    242,  2982, 1,    0,    0,    0,    244,  3013, 1,    0,    0,    0,    246,  3020,
      1,     0,    0,    0,    248,  3024, 1,    0,    0,    0,    250,  3032, 1,    0,    0,    0,    252,  3045, 1,
      0,     0,    0,    254,  3047, 1,    0,    0,    0,    256,  3065, 1,    0,    0,    0,    258,  3077, 1,    0,
      0,     0,    260,  3082, 1,    0,    0,    0,    262,  3088, 1,    0,    0,    0,    264,  3121, 1,    0,    0,
      0,     266,  3123, 1,    0,    0,    0,    268,  3131, 1,    0,    0,    0,    270,  3140, 1,    0,    0,    0,
      272,   3150, 1,    0,    0,    0,    274,  3165, 1,    0,    0,    0,    276,  3187, 1,    0,    0,    0,    278,
      3206,  1,    0,    0,    0,    280,  3209, 1,    0,    0,    0,    282,  3220, 1,    0,    0,    0,    284,  3236,
      1,     0,    0,    0,    286,  3248, 1,    0,    0,    0,    288,  3250, 1,    0,    0,    0,    290,  3276, 1,
      0,     0,    0,    292,  3278, 1,    0,    0,    0,    294,  3280, 1,    0,    0,    0,    296,  3283, 1,    0,
      0,     0,    298,  3286, 1,    0,    0,    0,    300,  3293, 1,    0,    0,    0,    302,  3295, 1,    0,    0,
      0,     304,  3325, 1,    0,    0,    0,    306,  3336, 1,    0,    0,    0,    308,  3339, 1,    0,    0,    0,
      310,   3348, 1,    0,    0,    0,    312,  3352, 1,    0,    0,    0,    314,  3357, 1,    0,    0,    0,    316,
      3370,  1,    0,    0,    0,    318,  3375, 1,    0,    0,    0,    320,  3379, 1,    0,    0,    0,    322,  3395,
      1,     0,    0,    0,    324,  3397, 1,    0,    0,    0,    326,  3415, 1,    0,    0,    0,    328,  3417, 1,
      0,     0,    0,    330,  3426, 1,    0,    0,    0,    332,  3438, 1,    0,    0,    0,    334,  3445, 1,    0,
      0,     0,    336,  3451, 1,    0,    0,    0,    338,  3454, 1,    0,    0,    0,    340,  3458, 1,    0,    0,
      0,     342,  3460, 1,    0,    0,    0,    344,  3465, 1,    0,    0,    0,    346,  3473, 1,    0,    0,    0,
      348,   3482, 1,    0,    0,    0,    350,  3485, 1,    0,    0,    0,    352,  3494, 1,    0,    0,    0,    354,
      3497,  1,    0,    0,    0,    356,  3514, 1,    0,    0,    0,    358,  3516, 1,    0,    0,    0,    360,  3521,
      1,     0,    0,    0,    362,  3525, 1,    0,    0,    0,    364,  3539, 1,    0,    0,    0,    366,  3542, 1,
      0,     0,    0,    368,  3548, 1,    0,    0,    0,    370,  3561, 1,    0,    0,    0,    372,  3569, 1,    0,
      0,     0,    374,  3595, 1,    0,    0,    0,    376,  3608, 1,    0,    0,    0,    378,  3615, 1,    0,    0,
      0,     380,  3617, 1,    0,    0,    0,    382,  3629, 1,    0,    0,    0,    384,  3631, 1,    0,    0,    0,
      386,   3641, 1,    0,    0,    0,    388,  3664, 1,    0,    0,    0,    390,  3666, 1,    0,    0,    0,    392,
      3673,  1,    0,    0,    0,    394,  3683, 1,    0,    0,    0,    396,  3718, 1,    0,    0,    0,    398,  3725,
      1,     0,    0,    0,    400,  3731, 1,    0,    0,    0,    402,  3733, 1,    0,    0,    0,    404,  3737, 1,
      0,     0,    0,    406,  3745, 1,    0,    0,    0,    408,  3747, 1,    0,    0,    0,    410,  3752, 1,    0,
      0,     0,    412,  3756, 1,    0,    0,    0,    414,  3784, 1,    0,    0,    0,    416,  3786, 1,    0,    0,
      0,     418,  3788, 1,    0,    0,    0,    420,  3796, 1,    0,    0,    0,    422,  3798, 1,    0,    0,    0,
      424,   3806, 1,    0,    0,    0,    426,  3816, 1,    0,    0,    0,    428,  3819, 1,    0,    0,    0,    430,
      3844,  1,    0,    0,    0,    432,  3871, 1,    0,    0,    0,    434,  3873, 1,    0,    0,    0,    436,  3882,
      1,     0,    0,    0,    438,  3913, 1,    0,    0,    0,    440,  3931, 1,    0,    0,    0,    442,  3933, 1,
      0,     0,    0,    444,  3947, 1,    0,    0,    0,    446,  3949, 1,    0,    0,    0,    448,  3980, 1,    0,
      0,     0,    450,  3983, 1,    0,    0,    0,    452,  4023, 1,    0,    0,    0,    454,  4036, 1,    0,    0,
      0,     456,  4038, 1,    0,    0,    0,    458,  4041, 1,    0,    0,    0,    460,  4054, 1,    0,    0,    0,
      462,   4056, 1,    0,    0,    0,    464,  4063, 1,    0,    0,    0,    466,  4199, 1,    0,    0,    0,    468,
      4201,  1,    0,    0,    0,    470,  4203, 1,    0,    0,    0,    472,  4205, 1,    0,    0,    0,    474,  4207,
      1,     0,    0,    0,    476,  4209, 1,    0,    0,    0,    478,  4211, 1,    0,    0,    0,    480,  4213, 1,
      0,     0,    0,    482,  4215, 1,    0,    0,    0,    484,  4217, 1,    0,    0,    0,    486,  4219, 1,    0,
      0,     0,    488,  4221, 1,    0,    0,    0,    490,  4223, 1,    0,    0,    0,    492,  4225, 1,    0,    0,
      0,     494,  4227, 1,    0,    0,    0,    496,  4229, 1,    0,    0,    0,    498,  4231, 1,    0,    0,    0,
      500,   4233, 1,    0,    0,    0,    502,  4235, 1,    0,    0,    0,    504,  4237, 1,    0,    0,    0,    506,
      4239,  1,    0,    0,    0,    508,  4241, 1,    0,    0,    0,    510,  4243, 1,    0,    0,    0,    512,  4245,
      1,     0,    0,    0,    514,  4247, 1,    0,    0,    0,    516,  4249, 1,    0,    0,    0,    518,  4253, 1,
      0,     0,    0,    520,  4255, 1,    0,    0,    0,    522,  4260, 1,    0,    0,    0,    524,  4264, 1,    0,
      0,     0,    526,  4280, 1,    0,    0,    0,    528,  4282, 1,    0,    0,    0,    530,  4284, 1,    0,    0,
      0,     532,  4286, 1,    0,    0,    0,    534,  4299, 1,    0,    0,    0,    536,  4362, 1,    0,    0,    0,
      538,   4364, 1,    0,    0,    0,    540,  4372, 1,    0,    0,    0,    542,  4380, 1,    0,    0,    0,    544,
      4388,  1,    0,    0,    0,    546,  4390, 1,    0,    0,    0,    548,  4398, 1,    0,    0,    0,    550,  4422,
      1,     0,    0,    0,    552,  4435, 1,    0,    0,    0,    554,  4444, 1,    0,    0,    0,    556,  4448, 1,
      0,     0,    0,    558,  4452, 1,    0,    0,    0,    560,  4456, 1,    0,    0,    0,    562,  4460, 1,    0,
      0,     0,    564,  4468, 1,    0,    0,    0,    566,  4475, 1,    0,    0,    0,    568,  4479, 1,    0,    0,
      0,     570,  4490, 1,    0,    0,    0,    572,  4492, 1,    0,    0,    0,    574,  4496, 1,    0,    0,    0,
      576,   4500, 1,    0,    0,    0,    578,  4504, 1,    0,    0,    0,    580,  4517, 1,    0,    0,    0,    582,
      4519,  1,    0,    0,    0,    584,  4525, 1,    0,    0,    0,    586,  4533, 1,    0,    0,    0,    588,  4570,
      1,     0,    0,    0,    590,  4572, 1,    0,    0,    0,    592,  4585, 1,    0,    0,    0,    594,  4587, 1,
      0,     0,    0,    596,  4634, 1,    0,    0,    0,    598,  4717, 1,    0,    0,    0,    600,  4776, 1,    0,
      0,     0,    602,  4778, 1,    0,    0,    0,    604,  4781, 1,    0,    0,    0,    606,  4793, 1,    0,    0,
      0,     608,  4812, 1,    0,    0,    0,    610,  4814, 1,    0,    0,    0,    612,  4818, 1,    0,    0,    0,
      614,   4823, 1,    0,    0,    0,    616,  4876, 1,    0,    0,    0,    618,  4883, 1,    0,    0,    0,    620,
      4885,  1,    0,    0,    0,    622,  4892, 1,    0,    0,    0,    624,  4940, 1,    0,    0,    0,    626,  4942,
      1,     0,    0,    0,    628,  4951, 1,    0,    0,    0,    630,  4954, 1,    0,    0,    0,    632,  4965, 1,
      0,     0,    0,    634,  4970, 1,    0,    0,    0,    636,  4973, 1,    0,    0,    0,    638,  4988, 1,    0,
      0,     0,    640,  5034, 1,    0,    0,    0,    642,  5036, 1,    0,    0,    0,    644,  5086, 1,    0,    0,
      0,     646,  5104, 1,    0,    0,    0,    648,  5106, 1,    0,    0,    0,    650,  5122, 1,    0,    0,    0,
      652,   5137, 1,    0,    0,    0,    654,  5162, 1,    0,    0,    0,    656,  5164, 1,    0,    0,    0,    658,
      5172,  1,    0,    0,    0,    660,  5218, 1,    0,    0,    0,    662,  5237, 1,    0,    0,    0,    664,  5242,
      1,     0,    0,    0,    666,  5244, 1,    0,    0,    0,    668,  5268, 1,    0,    0,    0,    670,  5270, 1,
      0,     0,    0,    672,  5323, 1,    0,    0,    0,    674,  5334, 1,    0,    0,    0,    676,  5336, 1,    0,
      0,     0,    678,  5339, 1,    0,    0,    0,    680,  5352, 1,    0,    0,    0,    682,  5384, 1,    0,    0,
      0,     684,  5392, 1,    0,    0,    0,    686,  5394, 1,    0,    0,    0,    688,  5405, 1,    0,    0,    0,
      690,   5407, 1,    0,    0,    0,    692,  5418, 1,    0,    0,    0,    694,  5420, 1,    0,    0,    0,    696,
      5425,  1,    0,    0,    0,    698,  5436, 1,    0,    0,    0,    700,  5447, 1,    0,    0,    0,    702,  5455,
      1,     0,    0,    0,    704,  5464, 1,    0,    0,    0,    706,  5473, 1,    0,    0,    0,    708,  5476, 1,
      0,     0,    0,    710,  5481, 1,    0,    0,    0,    712,  5486, 1,    0,    0,    0,    714,  5491, 1,    0,
      0,     0,    716,  5504, 1,    0,    0,    0,    718,  5508, 1,    0,    0,    0,    720,  5515, 1,    0,    0,
      0,     722,  5532, 1,    0,    0,    0,    724,  5549, 1,    0,    0,    0,    726,  5562, 1,    0,    0,    0,
      728,   5568, 1,    0,    0,    0,    730,  5575, 1,    0,    0,    0,    732,  5582, 1,    0,    0,    0,    734,
      5587,  1,    0,    0,    0,    736,  5592, 1,    0,    0,    0,    738,  5595, 1,    0,    0,    0,    740,  5608,
      1,     0,    0,    0,    742,  5616, 1,    0,    0,    0,    744,  5622, 1,    0,    0,    0,    746,  5630, 1,
      0,     0,    0,    748,  5635, 1,    0,    0,    0,    750,  5640, 1,    0,    0,    0,    752,  5643, 1,    0,
      0,     0,    754,  5653, 1,    0,    0,    0,    756,  5661, 1,    0,    0,    0,    758,  5666, 1,    0,    0,
      0,     760,  5671, 1,    0,    0,    0,    762,  5675, 1,    0,    0,    0,    764,  5681, 1,    0,    0,    0,
      766,   5686, 1,    0,    0,    0,    768,  5691, 1,    0,    0,    0,    770,  5696, 1,    0,    0,    0,    772,
      5703,  1,    0,    0,    0,    774,  5710, 1,    0,    0,    0,    776,  5716, 1,    0,    0,    0,    778,  5722,
      1,     0,    0,    0,    780,  5727, 1,    0,    0,    0,    782,  5737, 1,    0,    0,    0,    784,  5741, 1,
      0,     0,    0,    786,  5743, 1,    0,    0,    0,    788,  5745, 1,    0,    0,    0,    790,  5748, 1,    0,
      0,     0,    792,  5763, 1,    0,    0,    0,    794,  5801, 1,    0,    0,    0,    796,  5805, 1,    0,    0,
      0,     798,  5807, 1,    0,    0,    0,    800,  5815, 1,    0,    0,    0,    802,  5819, 1,    0,    0,    0,
      804,   5827, 1,    0,    0,    0,    806,  5836, 1,    0,    0,    0,    808,  5838, 1,    0,    0,    0,    810,
      5857,  1,    0,    0,    0,    812,  5859, 1,    0,    0,    0,    814,  5861, 1,    0,    0,    0,    816,  5876,
      1,     0,    0,    0,    818,  5888, 1,    0,    0,    0,    820,  5890, 1,    0,    0,    0,    822,  5898, 1,
      0,     0,    0,    824,  5906, 1,    0,    0,    0,    826,  5915, 1,    0,    0,    0,    828,  5917, 1,    0,
      0,     0,    830,  5935, 1,    0,    0,    0,    832,  5949, 1,    0,    0,    0,    834,  5954, 1,    0,    0,
      0,     836,  5960, 1,    0,    0,    0,    838,  5962, 1,    0,    0,    0,    840,  5978, 1,    0,    0,    0,
      842,   5986, 1,    0,    0,    0,    844,  5996, 1,    0,    0,    0,    846,  6009, 1,    0,    0,    0,    848,
      6011,  1,    0,    0,    0,    850,  6017, 1,    0,    0,    0,    852,  6041, 1,    0,    0,    0,    854,  6043,
      1,     0,    0,    0,    856,  6046, 1,    0,    0,    0,    858,  6049, 1,    0,    0,    0,    860,  6062, 1,
      0,     0,    0,    862,  6078, 1,    0,    0,    0,    864,  6101, 1,    0,    0,    0,    866,  6103, 1,    0,
      0,     0,    868,  6140, 1,    0,    0,    0,    870,  6142, 1,    0,    0,    0,    872,  6296, 1,    0,    0,
      0,     874,  6309, 1,    0,    0,    0,    876,  6316, 1,    0,    0,    0,    878,  6403, 1,    0,    0,    0,
      880,   6405, 1,    0,    0,    0,    882,  6459, 1,    0,    0,    0,    884,  6461, 1,    0,    0,    0,    886,
      6466,  1,    0,    0,    0,    888,  6479, 1,    0,    0,    0,    890,  6485, 1,    0,    0,    0,    892,  6487,
      1,     0,    0,    0,    894,  6506, 1,    0,    0,    0,    896,  6509, 1,    0,    0,    0,    898,  6518, 1,
      0,     0,    0,    900,  6520, 1,    0,    0,    0,    902,  6543, 1,    0,    0,    0,    904,  6818, 1,    0,
      0,     0,    906,  6820, 1,    0,    0,    0,    908,  6846, 1,    0,    0,    0,    910,  6848, 1,    0,    0,
      0,     912,  6854, 1,    0,    0,    0,    914,  6856, 1,    0,    0,    0,    916,  6871, 1,    0,    0,    0,
      918,   6879, 1,    0,    0,    0,    920,  6881, 1,    0,    0,    0,    922,  6910, 1,    0,    0,    0,    924,
      6943,  1,    0,    0,    0,    926,  6945, 1,    0,    0,    0,    928,  6953, 1,    0,    0,    0,    930,  6960,
      1,     0,    0,    0,    932,  6962, 1,    0,    0,    0,    934,  6972, 1,    0,    0,    0,    936,  6987, 1,
      0,     0,    0,    938,  6989, 1,    0,    0,    0,    940,  6993, 1,    0,    0,    0,    942,  6996, 1,    0,
      0,     0,    944,  6999, 1,    0,    0,    0,    946,  7050, 1,    0,    0,    0,    948,  7052, 1,    0,    0,
      0,     950,  7063, 1,    0,    0,    0,    952,  7065, 1,    0,    0,    0,    954,  7067, 1,    0,    0,    0,
      956,   7071, 1,    0,    0,    0,    958,  7073, 1,    0,    0,    0,    960,  7075, 1,    0,    0,    0,    962,
      7079,  1,    0,    0,    0,    964,  7083, 1,    0,    0,    0,    966,  7087, 1,    0,    0,    0,    968,  7095,
      1,     0,    0,    0,    970,  7099, 1,    0,    0,    0,    972,  7107, 1,    0,    0,    0,    974,  7109, 1,
      0,     0,    0,    976,  7126, 1,    0,    0,    0,    978,  7128, 1,    0,    0,    0,    980,  7131, 1,    0,
      0,     0,    982,  7136, 1,    0,    0,    0,    984,  7144, 1,    0,    0,    0,    986,  7150, 1,    0,    0,
      0,     988,  7154, 1,    0,    0,    0,    990,  7171, 1,    0,    0,    0,    992,  7174, 1,    0,    0,    0,
      994,   7179, 1,    0,    0,    0,    996,  7181, 1,    0,    0,    0,    998,  7184, 1,    0,    0,    0,    1000,
      7193,  1,    0,    0,    0,    1002, 7201, 1,    0,    0,    0,    1004, 7203, 1,    0,    0,    0,    1006, 7208,
      1,     0,    0,    0,    1008, 7215, 1,    0,    0,    0,    1010, 7225, 1,    0,    0,    0,    1012, 7233, 1,
      0,     0,    0,    1014, 7235, 1,    0,    0,    0,    1016, 7245, 1,    0,    0,    0,    1018, 7253, 1,    0,
      0,     0,    1020, 7255, 1,    0,    0,    0,    1022, 7261, 1,    0,    0,    0,    1024, 7282, 1,    0,    0,
      0,     1026, 7284, 1,    0,    0,    0,    1028, 7290, 1,    0,    0,    0,    1030, 7293, 1,    0,    0,    0,
      1032,  7296, 1,    0,    0,    0,    1034, 7324, 1,    0,    0,    0,    1036, 7328, 1,    0,    0,    0,    1038,
      7335,  1,    0,    0,    0,    1040, 7342, 1,    0,    0,    0,    1042, 7344, 1,    0,    0,    0,    1044, 7360,
      1,     0,    0,    0,    1046, 7376, 1,    0,    0,    0,    1048, 7380, 1,    0,    0,    0,    1050, 7383, 1,
      0,     0,    0,    1052, 7386, 1,    0,    0,    0,    1054, 7410, 1,    0,    0,    0,    1056, 7412, 1,    0,
      0,     0,    1058, 7420, 1,    0,    0,    0,    1060, 7422, 1,    0,    0,    0,    1062, 7426, 1,    0,    0,
      0,     1064, 7505, 1,    0,    0,    0,    1066, 7507, 1,    0,    0,    0,    1068, 7511, 1,    0,    0,    0,
      1070,  7599, 1,    0,    0,    0,    1072, 7601, 1,    0,    0,    0,    1074, 7603, 1,    0,    0,    0,    1076,
      7605,  1,    0,    0,    0,    1078, 7610, 1,    0,    0,    0,    1080, 7626, 1,    0,    0,    0,    1082, 7628,
      1,     0,    0,    0,    1084, 7662, 1,    0,    0,    0,    1086, 7664, 1,    0,    0,    0,    1088, 7675, 1,
      0,     0,    0,    1090, 7682, 1,    0,    0,    0,    1092, 7699, 1,    0,    0,    0,    1094, 7701, 1,    0,
      0,     0,    1096, 7705, 1,    0,    0,    0,    1098, 7727, 1,    0,    0,    0,    1100, 7729, 1,    0,    0,
      0,     1102, 7731, 1,    0,    0,    0,    1104, 7738, 1,    0,    0,    0,    1106, 7740, 1,    0,    0,    0,
      1108,  7742, 1,    0,    0,    0,    1110, 7891, 1,    0,    0,    0,    1112, 7896, 1,    0,    0,    0,    1114,
      7903,  1,    0,    0,    0,    1116, 7905, 1,    0,    0,    0,    1118, 7913, 1,    0,    0,    0,    1120, 7931,
      1,     0,    0,    0,    1122, 7939, 1,    0,    0,    0,    1124, 7947, 1,    0,    0,    0,    1126, 7949, 1,
      0,     0,    0,    1128, 7953, 1,    0,    0,    0,    1130, 7962, 1,    0,    0,    0,    1132, 7968, 1,    0,
      0,     0,    1134, 7975, 1,    0,    0,    0,    1136, 7977, 1,    0,    0,    0,    1138, 7992, 1,    0,    0,
      0,     1140, 7999, 1,    0,    0,    0,    1142, 8002, 1,    0,    0,    0,    1144, 8146, 1,    0,    0,    0,
      1146,  8150, 1,    0,    0,    0,    1148, 8153, 1,    0,    0,    0,    1150, 8162, 1,    0,    0,    0,    1152,
      8171,  1,    0,    0,    0,    1154, 8179, 1,    0,    0,    0,    1156, 8225, 1,    0,    0,    0,    1158, 8227,
      1,     0,    0,    0,    1160, 8248, 1,    0,    0,    0,    1162, 8252, 1,    0,    0,    0,    1164, 8263, 1,
      0,     0,    0,    1166, 8308, 1,    0,    0,    0,    1168, 8344, 1,    0,    0,    0,    1170, 8346, 1,    0,
      0,     0,    1172, 8354, 1,    0,    0,    0,    1174, 8367, 1,    0,    0,    0,    1176, 8369, 1,    0,    0,
      0,     1178, 8373, 1,    0,    0,    0,    1180, 8376, 1,    0,    0,    0,    1182, 8380, 1,    0,    0,    0,
      1184,  8385, 1,    0,    0,    0,    1186, 8389, 1,    0,    0,    0,    1188, 8392, 1,    0,    0,    0,    1190,
      8395,  1,    0,    0,    0,    1192, 8399, 1,    0,    0,    0,    1194, 8405, 1,    0,    0,    0,    1196, 8413,
      1,     0,    0,    0,    1198, 8421, 1,    0,    0,    0,    1200, 8427, 1,    0,    0,    0,    1202, 8430, 1,
      0,     0,    0,    1204, 8448, 1,    0,    0,    0,    1206, 8450, 1,    0,    0,    0,    1208, 8456, 1,    0,
      0,     0,    1210, 8460, 1,    0,    0,    0,    1212, 8468, 1,    0,    0,    0,    1214, 8476, 1,    0,    0,
      0,     1216, 8488, 1,    0,    0,    0,    1218, 8500, 1,    0,    0,    0,    1220, 8502, 1,    0,    0,    0,
      1222,  8506, 1,    0,    0,    0,    1224, 8511, 1,    0,    0,    0,    1226, 8515, 1,    0,    0,    0,    1228,
      8521,  1,    0,    0,    0,    1230, 8527, 1,    0,    0,    0,    1232, 8534, 1,    0,    0,    0,    1234, 8541,
      1,     0,    0,    0,    1236, 8545, 1,    0,    0,    0,    1238, 8564, 1,    0,    0,    0,    1240, 8566, 1,
      0,     0,    0,    1242, 8569, 1,    0,    0,    0,    1244, 8572, 1,    0,    0,    0,    1246, 8581, 1,    0,
      0,     0,    1248, 8583, 1,    0,    0,    0,    1250, 8588, 1,    0,    0,    0,    1252, 8590, 1,    0,    0,
      0,     1254, 8592, 1,    0,    0,    0,    1256, 8594, 1,    0,    0,    0,    1258, 8602, 1,    0,    0,    0,
      1260,  8604, 1,    0,    0,    0,    1262, 8606, 1,    0,    0,    0,    1264, 8608, 1,    0,    0,    0,    1266,
      8619,  1,    0,    0,    0,    1268, 8623, 1,    0,    0,    0,    1270, 8625, 1,    0,    0,    0,    1272, 8627,
      1,     0,    0,    0,    1274, 8629, 1,    0,    0,    0,    1276, 8638, 1,    0,    0,    0,    1278, 8640, 1,
      0,     0,    0,    1280, 8642, 1,    0,    0,    0,    1282, 8644, 1,    0,    0,    0,    1284, 8646, 1,    0,
      0,     0,    1286, 8648, 1,    0,    0,    0,    1288, 8650, 1,    0,    0,    0,    1290, 8652, 1,    0,    0,
      0,     1292, 8656, 1,    0,    0,    0,    1294, 8660, 1,    0,    0,    0,    1296, 8662, 1,    0,    0,    0,
      1298,  8664, 1,    0,    0,    0,    1300, 8666, 1,    0,    0,    0,    1302, 8668, 1,    0,    0,    0,    1304,
      8670,  1,    0,    0,    0,    1306, 8672, 1,    0,    0,    0,    1308, 8674, 1,    0,    0,    0,    1310, 8676,
      1,     0,    0,    0,    1312, 8678, 1,    0,    0,    0,    1314, 8680, 1,    0,    0,    0,    1316, 8684, 1,
      0,     0,    0,    1318, 8686, 1,    0,    0,    0,    1320, 8689, 1,    0,    0,    0,    1322, 8701, 1,    0,
      0,     0,    1324, 8703, 1,    0,    0,    0,    1326, 8711, 1,    0,    0,    0,    1328, 8719, 1,    0,    0,
      0,     1330, 8723, 1,    0,    0,    0,    1332, 8725, 1,    0,    0,    0,    1334, 8729, 1,    0,    0,    0,
      1336,  8731, 1,    0,    0,    0,    1338, 8733, 1,    0,    0,    0,    1340, 8735, 1,    0,    0,    0,    1342,
      8737,  1,    0,    0,    0,    1344, 8742, 1,    0,    0,    0,    1346, 8746, 1,    0,    0,    0,    1348, 8748,
      1,     0,    0,    0,    1350, 8756, 1,    0,    0,    0,    1352, 8760, 1,    0,    0,    0,    1354, 8764, 1,
      0,     0,    0,    1356, 8771, 1,    0,    0,    0,    1358, 8774, 1,    0,    0,    0,    1360, 8776, 1,    0,
      0,     0,    1362, 8778, 1,    0,    0,    0,    1364, 8785, 1,    0,    0,    0,    1366, 8792, 1,    0,    0,
      0,     1368, 8797, 1,    0,    0,    0,    1370, 8808, 1,    0,    0,    0,    1372, 8813, 1,    0,    0,    0,
      1374,  8815, 1,    0,    0,    0,    1376, 8817, 1,    0,    0,    0,    1378, 8831, 1,    0,    0,    0,    1380,
      8836,  1,    0,    0,    0,    1382, 8841, 1,    0,    0,    0,    1384, 8848, 1,    0,    0,    0,    1386, 8856,
      1,     0,    0,    0,    1388, 8858, 1,    0,    0,    0,    1390, 8869, 1,    0,    0,    0,    1392, 8871, 1,
      0,     0,    0,    1394, 8873, 1,    0,    0,    0,    1396, 8875, 1,    0,    0,    0,    1398, 8883, 1,    0,
      0,     0,    1400, 8887, 1,    0,    0,    0,    1402, 8889, 1,    0,    0,    0,    1404, 8891, 1,    0,    0,
      0,     1406, 8899, 1,    0,    0,    0,    1408, 8903, 1,    0,    0,    0,    1410, 8907, 1,    0,    0,    0,
      1412,  8911, 1,    0,    0,    0,    1414, 8913, 1,    0,    0,    0,    1416, 8916, 1,    0,    0,    0,    1418,
      8918,  1,    0,    0,    0,    1420, 8926, 1,    0,    0,    0,    1422, 8928, 1,    0,    0,    0,    1424, 8931,
      1,     0,    0,    0,    1426, 8949, 1,    0,    0,    0,    1428, 8951, 1,    0,    0,    0,    1430, 8953, 1,
      0,     0,    0,    1432, 8973, 1,    0,    0,    0,    1434, 8975, 1,    0,    0,    0,    1436, 8980, 1,    0,
      0,     0,    1438, 8992, 1,    0,    0,    0,    1440, 8998, 1,    0,    0,    0,    1442, 9000, 1,    0,    0,
      0,     1444, 9002, 1,    0,    0,    0,    1446, 9007, 1,    0,    0,    0,    1448, 1451, 3,    2,    1,    0,
      1449,  1451, 3,    434,  217,  0,    1450, 1448, 1,    0,    0,    0,    1450, 1449, 1,    0,    0,    0,    1451,
      1453,  1,    0,    0,    0,    1452, 1454, 5,    774,  0,    0,    1453, 1452, 1,    0,    0,    0,    1453, 1454,
      1,     0,    0,    0,    1454, 1456, 1,    0,    0,    0,    1455, 1450, 1,    0,    0,    0,    1455, 1456, 1,
      0,     0,    0,    1456, 1457, 1,    0,    0,    0,    1457, 1458, 5,    0,    0,    1,    1458, 1,    1,    0,
      0,     0,    1459, 1533, 3,    4,    2,    0,    1460, 1533, 3,    80,   40,   0,    1461, 1533, 3,    188,  94,
      0,     1462, 1533, 3,    220,  110,  0,    1463, 1533, 3,    224,  112,  0,    1464, 1533, 3,    226,  113,  0,
      1465,  1533, 3,    228,  114,  0,    1466, 1533, 3,    230,  115,  0,    1467, 1533, 3,    236,  118,  0,    1468,
      1533,  3,    238,  119,  0,    1469, 1533, 3,    242,  121,  0,    1470, 1533, 3,    262,  131,  0,    1471, 1533,
      3,     274,  137,  0,    1472, 1533, 3,    276,  138,  0,    1473, 1533, 3,    428,  214,  0,    1474, 1533, 3,
      430,   215,  0,    1475, 1533, 3,    452,  226,  0,    1476, 1533, 3,    580,  290,  0,    1477, 1533, 3,    586,
      293,   0,    1478, 1533, 3,    592,  296,  0,    1479, 1533, 3,    660,  330,  0,    1480, 1533, 3,    668,  334,
      0,     1481, 1533, 3,    670,  335,  0,    1482, 1533, 3,    694,  347,  0,    1483, 1533, 3,    696,  348,  0,
      1484,  1533, 3,    698,  349,  0,    1485, 1533, 3,    700,  350,  0,    1486, 1533, 3,    702,  351,  0,    1487,
      1533,  3,    704,  352,  0,    1488, 1533, 3,    706,  353,  0,    1489, 1533, 3,    708,  354,  0,    1490, 1533,
      3,     710,  355,  0,    1491, 1533, 3,    712,  356,  0,    1492, 1533, 3,    714,  357,  0,    1493, 1533, 3,
      716,   358,  0,    1494, 1533, 3,    718,  359,  0,    1495, 1533, 3,    720,  360,  0,    1496, 1533, 3,    722,
      361,   0,    1497, 1533, 3,    724,  362,  0,    1498, 1533, 3,    726,  363,  0,    1499, 1533, 3,    728,  364,
      0,     1500, 1533, 3,    730,  365,  0,    1501, 1533, 3,    732,  366,  0,    1502, 1533, 3,    734,  367,  0,
      1503,  1533, 3,    736,  368,  0,    1504, 1533, 3,    738,  369,  0,    1505, 1533, 3,    740,  370,  0,    1506,
      1533,  3,    742,  371,  0,    1507, 1533, 3,    744,  372,  0,    1508, 1533, 3,    746,  373,  0,    1509, 1533,
      3,     748,  374,  0,    1510, 1533, 3,    750,  375,  0,    1511, 1533, 3,    752,  376,  0,    1512, 1533, 3,
      754,   377,  0,    1513, 1533, 3,    756,  378,  0,    1514, 1533, 3,    758,  379,  0,    1515, 1533, 3,    760,
      380,   0,    1516, 1533, 3,    762,  381,  0,    1517, 1533, 3,    764,  382,  0,    1518, 1533, 3,    766,  383,
      0,     1519, 1533, 3,    768,  384,  0,    1520, 1533, 3,    770,  385,  0,    1521, 1533, 3,    772,  386,  0,
      1522,  1533, 3,    774,  387,  0,    1523, 1533, 3,    776,  388,  0,    1524, 1533, 3,    778,  389,  0,    1525,
      1533,  3,    780,  390,  0,    1526, 1533, 3,    826,  413,  0,    1527, 1533, 3,    794,  397,  0,    1528, 1533,
      3,     846,  423,  0,    1529, 1533, 3,    1032, 516,  0,    1530, 1533, 3,    1042, 521,  0,    1531, 1533, 3,
      1044,  522,  0,    1532, 1459, 1,    0,    0,    0,    1532, 1460, 1,    0,    0,    0,    1532, 1461, 1,    0,
      0,     0,    1532, 1462, 1,    0,    0,    0,    1532, 1463, 1,    0,    0,    0,    1532, 1464, 1,    0,    0,
      0,     1532, 1465, 1,    0,    0,    0,    1532, 1466, 1,    0,    0,    0,    1532, 1467, 1,    0,    0,    0,
      1532,  1468, 1,    0,    0,    0,    1532, 1469, 1,    0,    0,    0,    1532, 1470, 1,    0,    0,    0,    1532,
      1471,  1,    0,    0,    0,    1532, 1472, 1,    0,    0,    0,    1532, 1473, 1,    0,    0,    0,    1532, 1474,
      1,     0,    0,    0,    1532, 1475, 1,    0,    0,    0,    1532, 1476, 1,    0,    0,    0,    1532, 1477, 1,
      0,     0,    0,    1532, 1478, 1,    0,    0,    0,    1532, 1479, 1,    0,    0,    0,    1532, 1480, 1,    0,
      0,     0,    1532, 1481, 1,    0,    0,    0,    1532, 1482, 1,    0,    0,    0,    1532, 1483, 1,    0,    0,
      0,     1532, 1484, 1,    0,    0,    0,    1532, 1485, 1,    0,    0,    0,    1532, 1486, 1,    0,    0,    0,
      1532,  1487, 1,    0,    0,    0,    1532, 1488, 1,    0,    0,    0,    1532, 1489, 1,    0,    0,    0,    1532,
      1490,  1,    0,    0,    0,    1532, 1491, 1,    0,    0,    0,    1532, 1492, 1,    0,    0,    0,    1532, 1493,
      1,     0,    0,    0,    1532, 1494, 1,    0,    0,    0,    1532, 1495, 1,    0,    0,    0,    1532, 1496, 1,
      0,     0,    0,    1532, 1497, 1,    0,    0,    0,    1532, 1498, 1,    0,    0,    0,    1532, 1499, 1,    0,
      0,     0,    1532, 1500, 1,    0,    0,    0,    1532, 1501, 1,    0,    0,    0,    1532, 1502, 1,    0,    0,
      0,     1532, 1503, 1,    0,    0,    0,    1532, 1504, 1,    0,    0,    0,    1532, 1505, 1,    0,    0,    0,
      1532,  1506, 1,    0,    0,    0,    1532, 1507, 1,    0,    0,    0,    1532, 1508, 1,    0,    0,    0,    1532,
      1509,  1,    0,    0,    0,    1532, 1510, 1,    0,    0,    0,    1532, 1511, 1,    0,    0,    0,    1532, 1512,
      1,     0,    0,    0,    1532, 1513, 1,    0,    0,    0,    1532, 1514, 1,    0,    0,    0,    1532, 1515, 1,
      0,     0,    0,    1532, 1516, 1,    0,    0,    0,    1532, 1517, 1,    0,    0,    0,    1532, 1518, 1,    0,
      0,     0,    1532, 1519, 1,    0,    0,    0,    1532, 1520, 1,    0,    0,    0,    1532, 1521, 1,    0,    0,
      0,     1532, 1522, 1,    0,    0,    0,    1532, 1523, 1,    0,    0,    0,    1532, 1524, 1,    0,    0,    0,
      1532,  1525, 1,    0,    0,    0,    1532, 1526, 1,    0,    0,    0,    1532, 1527, 1,    0,    0,    0,    1532,
      1528,  1,    0,    0,    0,    1532, 1529, 1,    0,    0,    0,    1532, 1530, 1,    0,    0,    0,    1532, 1531,
      1,     0,    0,    0,    1533, 3,    1,    0,    0,    0,    1534, 1555, 5,    11,   0,    0,    1535, 1556, 3,
      20,    10,   0,    1536, 1556, 3,    6,    3,    0,    1537, 1538, 5,    422,  0,    0,    1538, 1540, 3,    1282,
      641,   0,    1539, 1541, 3,    110,  55,   0,    1540, 1539, 1,    0,    0,    0,    1540, 1541, 1,    0,    0,
      0,     1541, 1556, 1,    0,    0,    0,    1542, 1543, 5,    206,  0,    0,    1543, 1545, 3,    1286, 643,  0,
      1544,  1546, 3,    110,  55,   0,    1545, 1544, 1,    0,    0,    0,    1545, 1546, 1,    0,    0,    0,    1546,
      1556,  1,    0,    0,    0,    1547, 1556, 3,    70,   35,   0,    1548, 1556, 3,    10,   5,    0,    1549, 1556,
      3,     56,   28,   0,    1550, 1551, 4,    2,    0,    0,    1551, 1556, 3,    58,   29,   0,    1552, 1556, 3,
      12,    6,    0,    1553, 1556, 3,    18,   9,    0,    1554, 1556, 3,    78,   39,   0,    1555, 1535, 1,    0,
      0,     0,    1555, 1536, 1,    0,    0,    0,    1555, 1537, 1,    0,    0,    0,    1555, 1542, 1,    0,    0,
      0,     1555, 1547, 1,    0,    0,    0,    1555, 1548, 1,    0,    0,    0,    1555, 1549, 1,    0,    0,    0,
      1555,  1550, 1,    0,    0,    0,    1555, 1552, 1,    0,    0,    0,    1555, 1553, 1,    0,    0,    0,    1555,
      1554,  1,    0,    0,    0,    1556, 5,    1,    0,    0,    0,    1557, 1558, 5,    109,  0,    0,    1558, 1560,
      3,     1278, 639,  0,    1559, 1561, 3,    8,    4,    0,    1560, 1559, 1,    0,    0,    0,    1561, 1562, 1,
      0,     0,    0,    1562, 1560, 1,    0,    0,    0,    1562, 1563, 1,    0,    0,    0,    1563, 7,    1,    0,
      0,     0,    1564, 1572, 3,    84,   42,   0,    1565, 1566, 5,    435,  0,    0,    1566, 1568, 5,    386,  0,
      0,     1567, 1569, 5,    750,  0,    0,    1568, 1567, 1,    0,    0,    0,    1568, 1569, 1,    0,    0,    0,
      1569,  1570, 1,    0,    0,    0,    1570, 1572, 3,    1146, 573,  0,    1571, 1564, 1,    0,    0,    0,    1571,
      1565,  1,    0,    0,    0,    1572, 9,    1,    0,    0,    0,    1573, 1575, 3,    1176, 588,  0,    1574, 1573,
      1,     0,    0,    0,    1574, 1575, 1,    0,    0,    0,    1575, 1576, 1,    0,    0,    0,    1576, 1577, 5,
      170,   0,    0,    1577, 1581, 3,    1306, 653,  0,    1578, 1579, 5,    383,  0,    0,    1579, 1580, 5,    490,
      0,     0,    1580, 1582, 3,    1054, 527,  0,    1581, 1578, 1,    0,    0,    0,    1581, 1582, 1,    0,    0,
      0,     1582, 1589, 1,    0,    0,    0,    1583, 1584, 5,    383,  0,    0,    1584, 1586, 5,    79,   0,    0,
      1585,  1587, 5,    371,  0,    0,    1586, 1585, 1,    0,    0,    0,    1586, 1587, 1,    0,    0,    0,    1587,
      1588,  1,    0,    0,    0,    1588, 1590, 5,    418,  0,    0,    1589, 1583, 1,    0,    0,    0,    1589, 1590,
      1,     0,    0,    0,    1590, 1594, 1,    0,    0,    0,    1591, 1592, 5,    453,  0,    0,    1592, 1593, 5,
      590,   0,    0,    1593, 1595, 3,    1346, 673,  0,    1594, 1591, 1,    0,    0,    0,    1594, 1595, 1,    0,
      0,     0,    1595, 1602, 1,    0,    0,    0,    1596, 1603, 5,    156,  0,    0,    1597, 1600, 5,    140,  0,
      0,     1598, 1599, 5,    383,  0,    0,    1599, 1601, 3,    578,  289,  0,    1600, 1598, 1,    0,    0,    0,
      1600,  1601, 1,    0,    0,    0,    1601, 1603, 1,    0,    0,    0,    1602, 1596, 1,    0,    0,    0,    1602,
      1597,  1,    0,    0,    0,    1602, 1603, 1,    0,    0,    0,    1603, 1606, 1,    0,    0,    0,    1604, 1605,
      5,     75,   0,    0,    1605, 1607, 3,    1384, 692,  0,    1606, 1604, 1,    0,    0,    0,    1606, 1607, 1,
      0,     0,    0,    1607, 1610, 1,    0,    0,    0,    1608, 1609, 5,    147,  0,    0,    1609, 1611, 3,    976,
      488,   0,    1610, 1608, 1,    0,    0,    0,    1610, 1611, 1,    0,    0,    0,    1611, 11,   1,    0,    0,
      0,     1612, 1613, 5,    288,  0,    0,    1613, 1614, 5,    217,  0,    0,    1614, 1615, 3,    1302, 651,  0,
      1615,  1616, 5,    4,    0,    0,    1616, 1617, 5,    603,  0,    0,    1617, 1619, 3,    1384, 692,  0,    1618,
      1620,  3,    14,   7,    0,    1619, 1618, 1,    0,    0,    0,    1619, 1620, 1,    0,    0,    0,    1620, 13,
      1,     0,    0,    0,    1621, 1628, 3,    16,   8,    0,    1622, 1624, 5,    773,  0,    0,    1623, 1622, 1,
      0,     0,    0,    1623, 1624, 1,    0,    0,    0,    1624, 1625, 1,    0,    0,    0,    1625, 1627, 3,    16,
      8,     0,    1626, 1623, 1,    0,    0,    0,    1627, 1630, 1,    0,    0,    0,    1628, 1626, 1,    0,    0,
      0,     1628, 1629, 1,    0,    0,    0,    1629, 15,   1,    0,    0,    0,    1630, 1628, 1,    0,    0,    0,
      1631,  1635, 3,    144,  72,   0,    1632, 1635, 3,    156,  78,   0,    1633, 1635, 3,    158,  79,   0,    1634,
      1631,  1,    0,    0,    0,    1634, 1632, 1,    0,    0,    0,    1634, 1633, 1,    0,    0,    0,    1635, 17,
      1,     0,    0,    0,    1636, 1637, 5,    503,  0,    0,    1637, 1638, 3,    1312, 656,  0,    1638, 1639, 3,
      128,   64,   0,    1639, 19,   1,    0,    0,    0,    1640, 1642, 3,    1252, 626,  0,    1641, 1640, 1,    0,
      0,     0,    1641, 1642, 1,    0,    0,    0,    1642, 1643, 1,    0,    0,    0,    1643, 1644, 5,    574,  0,
      0,     1644, 1646, 3,    1322, 661,  0,    1645, 1647, 3,    22,   11,   0,    1646, 1645, 1,    0,    0,    0,
      1646,  1647, 1,    0,    0,    0,    1647, 21,   1,    0,    0,    0,    1648, 1651, 3,    24,   12,   0,    1649,
      1652,  3,    1154, 577,  0,    1650, 1652, 3,    52,   26,   0,    1651, 1649, 1,    0,    0,    0,    1651, 1650,
      1,     0,    0,    0,    1651, 1652, 1,    0,    0,    0,    1652, 1662, 1,    0,    0,    0,    1653, 1662, 3,
      1154,  577,  0,    1654, 1662, 3,    52,   26,   0,    1655, 1656, 3,    26,   13,   0,    1656, 1657, 5,    773,
      0,     0,    1657, 1659, 1,    0,    0,    0,    1658, 1655, 1,    0,    0,    0,    1658, 1659, 1,    0,    0,
      0,     1659, 1660, 1,    0,    0,    0,    1660, 1662, 3,    28,   14,   0,    1661, 1648, 1,    0,    0,    0,
      1661,  1653, 1,    0,    0,    0,    1661, 1654, 1,    0,    0,    0,    1661, 1658, 1,    0,    0,    0,    1662,
      23,    1,    0,    0,    0,    1663, 1671, 3,    26,   13,   0,    1664, 1665, 3,    26,   13,   0,    1665, 1666,
      5,     773,  0,    0,    1666, 1668, 1,    0,    0,    0,    1667, 1664, 1,    0,    0,    0,    1667, 1668, 1,
      0,     0,    0,    1668, 1669, 1,    0,    0,    0,    1669, 1671, 3,    32,   16,   0,    1670, 1663, 1,    0,
      0,     0,    1670, 1667, 1,    0,    0,    0,    1671, 25,   1,    0,    0,    0,    1672, 1677, 3,    34,   17,
      0,     1673, 1674, 5,    773,  0,    0,    1674, 1676, 3,    34,   17,   0,    1675, 1673, 1,    0,    0,    0,
      1676,  1679, 1,    0,    0,    0,    1677, 1675, 1,    0,    0,    0,    1677, 1678, 1,    0,    0,    0,    1678,
      27,    1,    0,    0,    0,    1679, 1677, 1,    0,    0,    0,    1680, 1681, 5,    141,  0,    0,    1681, 1688,
      5,     572,  0,    0,    1682, 1683, 5,    234,  0,    0,    1683, 1688, 5,    572,  0,    0,    1684, 1688, 3,
      30,    15,   0,    1685, 1686, 4,    14,   1,    0,    1686, 1688, 7,    0,    0,    0,    1687, 1680, 1,    0,
      0,     0,    1687, 1682, 1,    0,    0,    0,    1687, 1684, 1,    0,    0,    0,    1687, 1685, 1,    0,    0,
      0,     1688, 29,   1,    0,    0,    0,    1689, 1690, 5,    4,    0,    0,    1690, 1692, 5,    405,  0,    0,
      1691,  1693, 3,    1254, 627,  0,    1692, 1691, 1,    0,    0,    0,    1692, 1693, 1,    0,    0,    0,    1693,
      1697,  1,    0,    0,    0,    1694, 1698, 3,    1162, 581,  0,    1695, 1696, 5,    404,  0,    0,    1696, 1698,
      3,     1360, 680,  0,    1697, 1694, 1,    0,    0,    0,    1697, 1695, 1,    0,    0,    0,    1698, 1784, 1,
      0,     0,    0,    1699, 1700, 5,    148,  0,    0,    1700, 1701, 5,    405,  0,    0,    1701, 1784, 3,    1348,
      674,   0,    1702, 1703, 5,    438,  0,    0,    1703, 1705, 5,    405,  0,    0,    1704, 1706, 3,    1254, 627,
      0,     1705, 1704, 1,    0,    0,    0,    1705, 1706, 1,    0,    0,    0,    1706, 1707, 1,    0,    0,    0,
      1707,  1784, 3,    54,   27,   0,    1708, 1709, 5,    388,  0,    0,    1709, 1711, 5,    405,  0,    0,    1710,
      1712,  3,    1254, 627,  0,    1711, 1710, 1,    0,    0,    0,    1711, 1712, 1,    0,    0,    0,    1712, 1713,
      1,     0,    0,    0,    1713, 1715, 3,    54,   27,   0,    1714, 1716, 3,    1254, 627,  0,    1715, 1714, 1,
      0,     0,    0,    1715, 1716, 1,    0,    0,    0,    1716, 1784, 1,    0,    0,    0,    1717, 1718, 5,    14,
      0,     0,    1718, 1720, 5,    405,  0,    0,    1719, 1721, 3,    1254, 627,  0,    1720, 1719, 1,    0,    0,
      0,     1720, 1721, 1,    0,    0,    0,    1721, 1722, 1,    0,    0,    0,    1722, 1784, 3,    54,   27,   0,
      1723,  1724, 5,    62,   0,    0,    1724, 1725, 5,    405,  0,    0,    1725, 1729, 3,    54,   27,   0,    1726,
      1728,  3,    664,  332,  0,    1727, 1726, 1,    0,    0,    0,    1728, 1731, 1,    0,    0,    0,    1729, 1727,
      1,     0,    0,    0,    1729, 1730, 1,    0,    0,    0,    1730, 1784, 1,    0,    0,    0,    1731, 1729, 1,
      0,     0,    0,    1732, 1733, 5,    455,  0,    0,    1733, 1735, 5,    405,  0,    0,    1734, 1736, 3,    1254,
      627,   0,    1735, 1734, 1,    0,    0,    0,    1735, 1736, 1,    0,    0,    0,    1736, 1737, 1,    0,    0,
      0,     1737, 1741, 3,    54,   27,   0,    1738, 1740, 3,    666,  333,  0,    1739, 1738, 1,    0,    0,    0,
      1740,  1743, 1,    0,    0,    0,    1741, 1739, 1,    0,    0,    0,    1741, 1742, 1,    0,    0,    0,    1742,
      1784,  1,    0,    0,    0,    1743, 1741, 1,    0,    0,    0,    1744, 1745, 5,    67,   0,    0,    1745, 1747,
      5,     405,  0,    0,    1746, 1748, 3,    1254, 627,  0,    1747, 1746, 1,    0,    0,    0,    1747, 1748, 1,
      0,     0,    0,    1748, 1749, 1,    0,    0,    0,    1749, 1784, 3,    1360, 680,  0,    1750, 1751, 5,    597,
      0,     0,    1751, 1752, 5,    405,  0,    0,    1752, 1784, 3,    54,   27,   0,    1753, 1754, 5,    454,  0,
      0,     1754, 1756, 5,    405,  0,    0,    1755, 1757, 3,    1254, 627,  0,    1756, 1755, 1,    0,    0,    0,
      1756,  1757, 1,    0,    0,    0,    1757, 1762, 1,    0,    0,    0,    1758, 1759, 3,    1348, 674,  0,    1759,
      1760,  5,    248,  0,    0,    1760, 1761, 3,    1162, 581,  0,    1761, 1763, 1,    0,    0,    0,    1762, 1758,
      1,     0,    0,    0,    1762, 1763, 1,    0,    0,    0,    1763, 1784, 1,    0,    0,    0,    1764, 1765, 5,
      172,   0,    0,    1765, 1766, 5,    405,  0,    0,    1766, 1767, 3,    1346, 673,  0,    1767, 1768, 5,    645,
      0,     0,    1768, 1769, 5,    574,  0,    0,    1769, 1771, 3,    1322, 661,  0,    1770, 1772, 3,    50,   25,
      0,     1771, 1770, 1,    0,    0,    0,    1771, 1772, 1,    0,    0,    0,    1772, 1784, 1,    0,    0,    0,
      1773,  1774, 5,    141,  0,    0,    1774, 1775, 5,    405,  0,    0,    1775, 1776, 3,    54,   27,   0,    1776,
      1777,  5,    572,  0,    0,    1777, 1784, 1,    0,    0,    0,    1778, 1779, 5,    234,  0,    0,    1779, 1780,
      5,     405,  0,    0,    1780, 1781, 3,    54,   27,   0,    1781, 1782, 5,    572,  0,    0,    1782, 1784, 1,
      0,     0,    0,    1783, 1689, 1,    0,    0,    0,    1783, 1699, 1,    0,    0,    0,    1783, 1702, 1,    0,
      0,     0,    1783, 1708, 1,    0,    0,    0,    1783, 1717, 1,    0,    0,    0,    1783, 1723, 1,    0,    0,
      0,     1783, 1732, 1,    0,    0,    0,    1783, 1744, 1,    0,    0,    0,    1783, 1750, 1,    0,    0,    0,
      1783,  1753, 1,    0,    0,    0,    1783, 1764, 1,    0,    0,    0,    1783, 1773, 1,    0,    0,    0,    1783,
      1778,  1,    0,    0,    0,    1784, 31,   1,    0,    0,    0,    1785, 1788, 3,    36,   18,   0,    1786, 1788,
      3,     1142, 571,  0,    1787, 1785, 1,    0,    0,    0,    1787, 1786, 1,    0,    0,    0,    1788, 1797, 1,
      0,     0,    0,    1789, 1793, 5,    773,  0,    0,    1790, 1794, 3,    36,   18,   0,    1791, 1794, 3,    34,
      17,    0,    1792, 1794, 3,    1142, 571,  0,    1793, 1790, 1,    0,    0,    0,    1793, 1791, 1,    0,    0,
      0,     1793, 1792, 1,    0,    0,    0,    1794, 1796, 1,    0,    0,    0,    1795, 1789, 1,    0,    0,    0,
      1796,  1799, 1,    0,    0,    0,    1797, 1795, 1,    0,    0,    0,    1797, 1798, 1,    0,    0,    0,    1798,
      33,    1,    0,    0,    0,    1799, 1797, 1,    0,    0,    0,    1800, 1804, 3,    44,   22,   0,    1801, 1804,
      3,     46,   23,   0,    1802, 1804, 3,    50,   25,   0,    1803, 1800, 1,    0,    0,    0,    1803, 1801, 1,
      0,     0,    0,    1803, 1802, 1,    0,    0,    0,    1804, 35,   1,    0,    0,    0,    1805, 1807, 5,    4,
      0,     0,    1806, 1808, 5,    72,   0,    0,    1807, 1806, 1,    0,    0,    0,    1807, 1808, 1,    0,    0,
      0,     1808, 1821, 1,    0,    0,    0,    1809, 1810, 3,    1346, 673,  0,    1810, 1812, 3,    1068, 534,  0,
      1811,  1813, 3,    1058, 529,  0,    1812, 1811, 1,    0,    0,    0,    1812, 1813, 1,    0,    0,    0,    1813,
      1815,  1,    0,    0,    0,    1814, 1816, 3,    38,   19,   0,    1815, 1814, 1,    0,    0,    0,    1815, 1816,
      1,     0,    0,    0,    1816, 1822, 1,    0,    0,    0,    1817, 1818, 5,    776,  0,    0,    1818, 1819, 3,
      88,    44,   0,    1819, 1820, 5,    777,  0,    0,    1820, 1822, 1,    0,    0,    0,    1821, 1809, 1,    0,
      0,     0,    1821, 1817, 1,    0,    0,    0,    1822, 1941, 1,    0,    0,    0,    1823, 1824, 5,    4,    0,
      0,     1824, 1941, 3,    1064, 532,  0,    1825, 1827, 5,    55,   0,    0,    1826, 1828, 5,    72,   0,    0,
      1827,  1826, 1,    0,    0,    0,    1827, 1828, 1,    0,    0,    0,    1828, 1829, 1,    0,    0,    0,    1829,
      1830,  3,    1262, 631,  0,    1830, 1831, 3,    1346, 673,  0,    1831, 1833, 3,    1068, 534,  0,    1832, 1834,
      3,     38,   19,   0,    1833, 1832, 1,    0,    0,    0,    1833, 1834, 1,    0,    0,    0,    1834, 1941, 1,
      0,     0,    0,    1835, 1837, 5,    348,  0,    0,    1836, 1838, 5,    72,   0,    0,    1837, 1836, 1,    0,
      0,     0,    1837, 1838, 1,    0,    0,    0,    1838, 1839, 1,    0,    0,    0,    1839, 1840, 3,    1262, 631,
      0,     1840, 1842, 3,    1068, 534,  0,    1841, 1843, 3,    38,   19,   0,    1842, 1841, 1,    0,    0,    0,
      1842,  1843, 1,    0,    0,    0,    1843, 1941, 1,    0,    0,    0,    1844, 1866, 5,    148,  0,    0,    1845,
      1847,  5,    72,   0,    0,    1846, 1845, 1,    0,    0,    0,    1846, 1847, 1,    0,    0,    0,    1847, 1848,
      1,     0,    0,    0,    1848, 1850, 3,    1262, 631,  0,    1849, 1851, 3,    40,   20,   0,    1850, 1849, 1,
      0,     0,    0,    1850, 1851, 1,    0,    0,    0,    1851, 1867, 1,    0,    0,    0,    1852, 1853, 5,    199,
      0,     0,    1853, 1854, 5,    265,  0,    0,    1854, 1867, 3,    1262, 631,  0,    1855, 1856, 5,    420,  0,
      0,     1856, 1867, 5,    265,  0,    0,    1857, 1858, 3,    418,  209,  0,    1858, 1859, 3,    1272, 636,  0,
      1859,  1867, 1,    0,    0,    0,    1860, 1861, 4,    18,   2,    0,    1861, 1862, 5,    62,   0,    0,    1862,
      1867,  3,    1346, 673,  0,    1863, 1864, 4,    18,   3,    0,    1864, 1865, 5,    86,   0,    0,    1865, 1867,
      3,     1346, 673,  0,    1866, 1846, 1,    0,    0,    0,    1866, 1852, 1,    0,    0,    0,    1866, 1855, 1,
      0,     0,    0,    1866, 1857, 1,    0,    0,    0,    1866, 1860, 1,    0,    0,    0,    1866, 1863, 1,    0,
      0,     0,    1867, 1941, 1,    0,    0,    0,    1868, 1869, 5,    140,  0,    0,    1869, 1941, 5,    263,  0,
      0,     1870, 1871, 5,    156,  0,    0,    1871, 1941, 5,    263,  0,    0,    1872, 1874, 5,    11,   0,    0,
      1873,  1875, 5,    72,   0,    0,    1874, 1873, 1,    0,    0,    0,    1874, 1875, 1,    0,    0,    0,    1875,
      1876,  1,    0,    0,    0,    1876, 1889, 3,    1262, 631,  0,    1877, 1878, 5,    506,  0,    0,    1878, 1882,
      5,     128,  0,    0,    1879, 1880, 4,    18,   4,    0,    1880, 1883, 3,    962,  481,  0,    1881, 1883, 3,
      1368,  684,  0,    1882, 1879, 1,    0,    0,    0,    1882, 1881, 1,    0,    0,    0,    1883, 1890, 1,    0,
      0,     0,    1884, 1885, 5,    148,  0,    0,    1885, 1890, 5,    128,  0,    0,    1886, 1887, 4,    18,   5,
      0,     1887, 1888, 5,    506,  0,    0,    1888, 1890, 3,    1100, 550,  0,    1889, 1877, 1,    0,    0,    0,
      1889,  1884, 1,    0,    0,    0,    1889, 1886, 1,    0,    0,    0,    1890, 1941, 1,    0,    0,    0,    1891,
      1892,  5,    11,   0,    0,    1892, 1893, 5,    236,  0,    0,    1893, 1894, 3,    1272, 636,  0,    1894, 1895,
      3,     1100, 550,  0,    1895, 1941, 1,    0,    0,    0,    1896, 1897, 4,    18,   6,    0,    1897, 1898, 5,
      11,    0,    0,    1898, 1899, 5,    62,   0,    0,    1899, 1900, 3,    1346, 673,  0,    1900, 1901, 3,    1062,
      531,   0,    1901, 1941, 1,    0,    0,    0,    1902, 1903, 4,    18,   7,    0,    1903, 1904, 5,    11,   0,
      0,     1904, 1905, 5,    86,   0,    0,    1905, 1906, 3,    1346, 673,  0,    1906, 1907, 3,    1062, 531,  0,
      1907,  1941, 1,    0,    0,    0,    1908, 1909, 5,    453,  0,    0,    1909, 1910, 5,    72,   0,    0,    1910,
      1911,  3,    1262, 631,  0,    1911, 1912, 5,    590,  0,    0,    1912, 1913, 3,    1346, 673,  0,    1913, 1941,
      1,     0,    0,    0,    1914, 1916, 5,    453,  0,    0,    1915, 1917, 7,    1,    0,    0,    1916, 1915, 1,
      0,     0,    0,    1916, 1917, 1,    0,    0,    0,    1917, 1918, 1,    0,    0,    0,    1918, 1941, 3,    1316,
      658,   0,    1919, 1920, 5,    453,  0,    0,    1920, 1921, 3,    418,  209,  0,    1921, 1922, 3,    1272, 636,
      0,     1922, 1923, 5,    590,  0,    0,    1923, 1924, 3,    1270, 635,  0,    1924, 1941, 1,    0,    0,    0,
      1925,  1926, 5,    94,   0,    0,    1926, 1927, 5,    590,  0,    0,    1927, 1931, 3,    950,  475,  0,    1928,
      1929,  4,    18,   8,    0,    1929, 1932, 5,    128,  0,    0,    1930, 1932, 3,    1132, 566,  0,    1931, 1928,
      1,     0,    0,    0,    1931, 1930, 1,    0,    0,    0,    1932, 1934, 1,    0,    0,    0,    1933, 1935, 3,
      1188,  594,  0,    1934, 1933, 1,    0,    0,    0,    1934, 1935, 1,    0,    0,    0,    1935, 1941, 1,    0,
      0,     0,    1936, 1941, 5,    198,  0,    0,    1937, 1938, 5,    393,  0,    0,    1938, 1939, 5,    45,   0,
      0,     1939, 1941, 3,    42,   21,   0,    1940, 1805, 1,    0,    0,    0,    1940, 1823, 1,    0,    0,    0,
      1940,  1825, 1,    0,    0,    0,    1940, 1835, 1,    0,    0,    0,    1940, 1844, 1,    0,    0,    0,    1940,
      1868,  1,    0,    0,    0,    1940, 1870, 1,    0,    0,    0,    1940, 1872, 1,    0,    0,    0,    1940, 1891,
      1,     0,    0,    0,    1940, 1896, 1,    0,    0,    0,    1940, 1902, 1,    0,    0,    0,    1940, 1908, 1,
      0,     0,    0,    1940, 1914, 1,    0,    0,    0,    1940, 1919, 1,    0,    0,    0,    1940, 1925, 1,    0,
      0,     0,    1940, 1936, 1,    0,    0,    0,    1940, 1937, 1,    0,    0,    0,    1941, 37,   1,    0,    0,
      0,     1942, 1943, 5,    6,    0,    0,    1943, 1946, 3,    1346, 673,  0,    1944, 1946, 5,    191,  0,    0,
      1945,  1942, 1,    0,    0,    0,    1945, 1944, 1,    0,    0,    0,    1946, 39,   1,    0,    0,    0,    1947,
      1948,  7,    2,    0,    0,    1948, 41,   1,    0,    0,    0,    1949, 1951, 3,    1346, 673,  0,    1950, 1952,
      3,     340,  170,  0,    1951, 1950, 1,    0,    0,    0,    1951, 1952, 1,    0,    0,    0,    1952, 1960, 1,
      0,     0,    0,    1953, 1954, 5,    773,  0,    0,    1954, 1956, 3,    1346, 673,  0,    1955, 1957, 3,    340,
      170,   0,    1956, 1955, 1,    0,    0,    0,    1956, 1957, 1,    0,    0,    0,    1957, 1959, 1,    0,    0,
      0,     1958, 1953, 1,    0,    0,    0,    1959, 1962, 1,    0,    0,    0,    1960, 1958, 1,    0,    0,    0,
      1960,  1961, 1,    0,    0,    0,    1961, 43,   1,    0,    0,    0,    1962, 1960, 1,    0,    0,    0,    1963,
      1965,  5,    9,    0,    0,    1964, 1966, 5,    750,  0,    0,    1965, 1964, 1,    0,    0,    0,    1965, 1966,
      1,     0,    0,    0,    1966, 1969, 1,    0,    0,    0,    1967, 1970, 5,    128,  0,    0,    1968, 1970, 3,
      1346,  673,  0,    1969, 1967, 1,    0,    0,    0,    1969, 1968, 1,    0,    0,    0,    1970, 45,   1,    0,
      0,     0,    1971, 1973, 5,    287,  0,    0,    1972, 1974, 5,    750,  0,    0,    1973, 1972, 1,    0,    0,
      0,     1973, 1974, 1,    0,    0,    0,    1974, 1977, 1,    0,    0,    0,    1975, 1978, 5,    128,  0,    0,
      1976,  1978, 3,    1346, 673,  0,    1977, 1975, 1,    0,    0,    0,    1977, 1976, 1,    0,    0,    0,    1978,
      47,    1,    0,    0,    0,    1979, 1981, 3,    44,   22,   0,    1980, 1982, 3,    46,   23,   0,    1981, 1980,
      1,     0,    0,    0,    1981, 1982, 1,    0,    0,    0,    1982, 1988, 1,    0,    0,    0,    1983, 1985, 3,
      46,    23,   0,    1984, 1986, 3,    44,   22,   0,    1985, 1984, 1,    0,    0,    0,    1985, 1986, 1,    0,
      0,     0,    1986, 1988, 1,    0,    0,    0,    1987, 1979, 1,    0,    0,    0,    1987, 1983, 1,    0,    0,
      0,     1988, 49,   1,    0,    0,    0,    1989, 1990, 7,    3,    0,    0,    1990, 1991, 5,    625,  0,    0,
      1991,  51,   1,    0,    0,    0,    1992, 1993, 5,    452,  0,    0,    1993, 1994, 5,    403,  0,    0,    1994,
      53,    1,    0,    0,    0,    1995, 1998, 5,    10,   0,    0,    1996, 1998, 3,    1348, 674,  0,    1997, 1995,
      1,     0,    0,    0,    1997, 1996, 1,    0,    0,    0,    1998, 55,   1,    0,    0,    0,    1999, 2000, 5,
      572,   0,    0,    2000, 2012, 3,    1298, 649,  0,    2001, 2002, 7,    4,    0,    0,    2002, 2003, 5,    111,
      0,     0,    2003, 2005, 3,    1384, 692,  0,    2004, 2006, 3,    64,   32,   0,    2005, 2004, 1,    0,    0,
      0,     2005, 2006, 1,    0,    0,    0,    2006, 2013, 1,    0,    0,    0,    2007, 2008, 5,    453,  0,    0,
      2008,  2009, 5,    590,  0,    0,    2009, 2013, 3,    1346, 673,  0,    2010, 2011, 4,    28,   9,    0,    2011,
      2013,  3,    64,   32,   0,    2012, 2001, 1,    0,    0,    0,    2012, 2007, 1,    0,    0,    0,    2012, 2010,
      1,     0,    0,    0,    2013, 57,   1,    0,    0,    0,    2014, 2015, 5,    605,  0,    0,    2015, 2016, 5,
      572,   0,    0,    2016, 2017, 3,    1298, 649,  0,    2017, 2018, 5,    506,  0,    0,    2018, 2020, 7,    5,
      0,     0,    2019, 2021, 3,    60,   30,   0,    2020, 2019, 1,    0,    0,    0,    2020, 2021, 1,    0,    0,
      0,     2021, 59,   1,    0,    0,    0,    2022, 2029, 3,    62,   31,   0,    2023, 2025, 5,    773,  0,    0,
      2024,  2023, 1,    0,    0,    0,    2024, 2025, 1,    0,    0,    0,    2025, 2026, 1,    0,    0,    0,    2026,
      2028,  3,    62,   31,   0,    2027, 2024, 1,    0,    0,    0,    2028, 2031, 1,    0,    0,    0,    2029, 2027,
      1,     0,    0,    0,    2029, 2030, 1,    0,    0,    0,    2030, 61,   1,    0,    0,    0,    2031, 2029, 1,
      0,     0,    0,    2032, 2033, 3,    156,  78,   0,    2033, 63,   1,    0,    0,    0,    2034, 2041, 3,    66,
      33,    0,    2035, 2037, 5,    773,  0,    0,    2036, 2035, 1,    0,    0,    0,    2036, 2037, 1,    0,    0,
      0,     2037, 2038, 1,    0,    0,    0,    2038, 2040, 3,    66,   33,   0,    2039, 2036, 1,    0,    0,    0,
      2040,  2043, 1,    0,    0,    0,    2041, 2039, 1,    0,    0,    0,    2041, 2042, 1,    0,    0,    0,    2042,
      65,    1,    0,    0,    0,    2043, 2041, 1,    0,    0,    0,    2044, 2046, 5,    238,  0,    0,    2045, 2047,
      5,     750,  0,    0,    2046, 2045, 1,    0,    0,    0,    2046, 2047, 1,    0,    0,    0,    2047, 2048, 1,
      0,     0,    0,    2048, 2057, 3,    1412, 706,  0,    2049, 2057, 3,    148,  74,   0,    2050, 2057, 3,    150,
      75,    0,    2051, 2057, 3,    156,  78,   0,    2052, 2057, 3,    158,  79,   0,    2053, 2057, 3,    164,  82,
      0,     2054, 2055, 4,    33,   10,   0,    2055, 2057, 3,    166,  83,   0,    2056, 2044, 1,    0,    0,    0,
      2056,  2049, 1,    0,    0,    0,    2056, 2050, 1,    0,    0,    0,    2056, 2051, 1,    0,    0,    0,    2056,
      2052,  1,    0,    0,    0,    2056, 2053, 1,    0,    0,    0,    2056, 2054, 1,    0,    0,    0,    2057, 67,
      1,     0,    0,    0,    2058, 2060, 5,    238,  0,    0,    2059, 2061, 5,    750,  0,    0,    2060, 2059, 1,
      0,     0,    0,    2060, 2061, 1,    0,    0,    0,    2061, 2062, 1,    0,    0,    0,    2062, 2066, 3,    1412,
      706,   0,    2063, 2066, 3,    148,  74,   0,    2064, 2066, 3,    150,  75,   0,    2065, 2058, 1,    0,    0,
      0,     2065, 2063, 1,    0,    0,    0,    2065, 2064, 1,    0,    0,    0,    2066, 69,   1,    0,    0,    0,
      2067,  2069, 3,    172,  86,   0,    2068, 2067, 1,    0,    0,    0,    2068, 2069, 1,    0,    0,    0,    2069,
      2071,  1,    0,    0,    0,    2070, 2072, 3,    1176, 588,  0,    2071, 2070, 1,    0,    0,    0,    2071, 2072,
      1,     0,    0,    0,    2072, 2074, 1,    0,    0,    0,    2073, 2075, 3,    174,  87,   0,    2074, 2073, 1,
      0,     0,    0,    2074, 2075, 1,    0,    0,    0,    2075, 2076, 1,    0,    0,    0,    2076, 2077, 5,    636,
      0,     0,    2077, 2078, 3,    1294, 647,  0,    2078, 2079, 3,    72,   36,   0,    2079, 71,   1,    0,    0,
      0,     2080, 2082, 3,    1264, 632,  0,    2081, 2080, 1,    0,    0,    0,    2081, 2082, 1,    0,    0,    0,
      2082,  2083, 1,    0,    0,    0,    2083, 2084, 5,    17,   0,    0,    2084, 2085, 3,    74,   37,   0,    2085,
      73,    1,    0,    0,    0,    2086, 2088, 3,    98,   49,   0,    2087, 2089, 3,    76,   38,   0,    2088, 2087,
      1,     0,    0,    0,    2088, 2089, 1,    0,    0,    0,    2089, 75,   1,    0,    0,    0,    2090, 2092, 5,
      645,   0,    0,    2091, 2093, 7,    6,    0,    0,    2092, 2091, 1,    0,    0,    0,    2092, 2093, 1,    0,
      0,     0,    2093, 2094, 1,    0,    0,    0,    2094, 2095, 5,    62,   0,    0,    2095, 2096, 5,    391,  0,
      0,     2096, 77,   1,    0,    0,    0,    2097, 2098, 5,    244,  0,    0,    2098, 2099, 5,    482,  0,    0,
      2099,  2100, 3,    1406, 703,  0,    2100, 2101, 5,    316,  0,    0,    2101, 2102, 5,    265,  0,    0,    2102,
      2130,  1,    0,    0,    0,    2103, 2127, 4,    39,   11,   0,    2104, 2105, 5,    451,  0,    0,    2105, 2119,
      5,     796,  0,    0,    2106, 2107, 5,    373,  0,    0,    2107, 2108, 5,    480,  0,    0,    2108, 2109, 5,
      383,   0,    0,    2109, 2120, 5,    165,  0,    0,    2110, 2111, 5,    200,  0,    0,    2111, 2112, 5,    57,
      0,     0,    2112, 2117, 3,    1346, 673,  0,    2113, 2114, 5,    373,  0,    0,    2114, 2115, 5,    480,  0,
      0,     2115, 2116, 5,    383,  0,    0,    2116, 2118, 5,    165,  0,    0,    2117, 2113, 1,    0,    0,    0,
      2117,  2118, 1,    0,    0,    0,    2118, 2120, 1,    0,    0,    0,    2119, 2106, 1,    0,    0,    0,    2119,
      2110,  1,    0,    0,    0,    2120, 2128, 1,    0,    0,    0,    2121, 2122, 7,    7,    0,    0,    2122, 2123,
      3,     1346, 673,  0,    2123, 2124, 3,    1346, 673,  0,    2124, 2128, 1,    0,    0,    0,    2125, 2126, 5,
      451,   0,    0,    2126, 2128, 5,    834,  0,    0,    2127, 2104, 1,    0,    0,    0,    2127, 2121, 1,    0,
      0,     0,    2127, 2125, 1,    0,    0,    0,    2128, 2130, 1,    0,    0,    0,    2129, 2097, 1,    0,    0,
      0,     2129, 2103, 1,    0,    0,    0,    2130, 79,   1,    0,    0,    0,    2131, 2149, 5,    97,   0,    0,
      2132,  2150, 3,    82,   41,   0,    2133, 2150, 3,    86,   43,   0,    2134, 2150, 3,    104,  52,   0,    2135,
      2150,  3,    102,  51,   0,    2136, 2150, 3,    106,  53,   0,    2137, 2150, 3,    120,  60,   0,    2138, 2150,
      3,     168,  84,   0,    2139, 2150, 3,    176,  88,   0,    2140, 2150, 3,    114,  57,   0,    2141, 2150, 3,
      126,   63,   0,    2142, 2150, 3,    132,  66,   0,    2143, 2150, 3,    180,  90,   0,    2144, 2150, 3,    182,
      91,    0,    2145, 2146, 4,    40,   12,   0,    2146, 2150, 3,    184,  92,   0,    2147, 2148, 4,    40,   13,
      0,     2148, 2150, 3,    134,  67,   0,    2149, 2132, 1,    0,    0,    0,    2149, 2133, 1,    0,    0,    0,
      2149,  2134, 1,    0,    0,    0,    2149, 2135, 1,    0,    0,    0,    2149, 2136, 1,    0,    0,    0,    2149,
      2137,  1,    0,    0,    0,    2149, 2138, 1,    0,    0,    0,    2149, 2139, 1,    0,    0,    0,    2149, 2140,
      1,     0,    0,    0,    2149, 2141, 1,    0,    0,    0,    2149, 2142, 1,    0,    0,    0,    2149, 2143, 1,
      0,     0,    0,    2149, 2144, 1,    0,    0,    0,    2149, 2145, 1,    0,    0,    0,    2149, 2147, 1,    0,
      0,     0,    2150, 81,   1,    0,    0,    0,    2151, 2153, 5,    109,  0,    0,    2152, 2154, 3,    1180, 590,
      0,     2153, 2152, 1,    0,    0,    0,    2153, 2154, 1,    0,    0,    0,    2154, 2155, 1,    0,    0,    0,
      2155,  2159, 3,    1276, 638,  0,    2156, 2158, 3,    84,   42,   0,    2157, 2156, 1,    0,    0,    0,    2158,
      2161,  1,    0,    0,    0,    2159, 2157, 1,    0,    0,    0,    2159, 2160, 1,    0,    0,    0,    2160, 83,
      1,     0,    0,    0,    2161, 2159, 1,    0,    0,    0,    2162, 2167, 3,    1152, 576,  0,    2163, 2167, 3,
      1148,  574,  0,    2164, 2165, 4,    42,   14,   0,    2165, 2167, 3,    1150, 575,  0,    2166, 2162, 1,    0,
      0,     0,    2166, 2163, 1,    0,    0,    0,    2166, 2164, 1,    0,    0,    0,    2167, 85,   1,    0,    0,
      0,     2168, 2170, 5,    577,  0,    0,    2169, 2168, 1,    0,    0,    0,    2169, 2170, 1,    0,    0,    0,
      2170,  2171, 1,    0,    0,    0,    2171, 2173, 5,    574,  0,    0,    2172, 2174, 3,    1180, 590,  0,    2173,
      2172,  1,    0,    0,    0,    2173, 2174, 1,    0,    0,    0,    2174, 2175, 1,    0,    0,    0,    2175, 2192,
      3,     1316, 658,  0,    2176, 2177, 5,    776,  0,    0,    2177, 2178, 3,    88,   44,   0,    2178, 2179, 5,
      777,   0,    0,    2179, 2181, 1,    0,    0,    0,    2180, 2176, 1,    0,    0,    0,    2180, 2181, 1,    0,
      0,     0,    2181, 2183, 1,    0,    0,    0,    2182, 2184, 3,    1138, 569,  0,    2183, 2182, 1,    0,    0,
      0,     2183, 2184, 1,    0,    0,    0,    2184, 2193, 1,    0,    0,    0,    2185, 2186, 5,    275,  0,    0,
      2186,  2193, 3,    1322, 661,  0,    2187, 2188, 5,    776,  0,    0,    2188, 2189, 5,    275,  0,    0,    2189,
      2190,  3,    1322, 661,  0,    2190, 2191, 5,    777,  0,    0,    2191, 2193, 1,    0,    0,    0,    2192, 2180,
      1,     0,    0,    0,    2192, 2185, 1,    0,    0,    0,    2192, 2187, 1,    0,    0,    0,    2193, 87,   1,
      0,     0,    0,    2194, 2199, 3,    90,   45,   0,    2195, 2196, 5,    773,  0,    0,    2196, 2198, 3,    90,
      45,    0,    2197, 2195, 1,    0,    0,    0,    2198, 2201, 1,    0,    0,    0,    2199, 2197, 1,    0,    0,
      0,     2199, 2200, 1,    0,    0,    0,    2200, 89,   1,    0,    0,    0,    2201, 2199, 1,    0,    0,    0,
      2202,  2205, 3,    1056, 528,  0,    2203, 2205, 3,    1064, 532,  0,    2204, 2202, 1,    0,    0,    0,    2204,
      2203,  1,    0,    0,    0,    2205, 91,   1,    0,    0,    0,    2206, 2208, 7,    8,    0,    0,    2207, 2206,
      1,     0,    0,    0,    2207, 2208, 1,    0,    0,    0,    2208, 2209, 1,    0,    0,    0,    2209, 2210, 3,
      94,    47,   0,    2210, 93,   1,    0,    0,    0,    2211, 2213, 5,    17,   0,    0,    2212, 2211, 1,    0,
      0,     0,    2212, 2213, 1,    0,    0,    0,    2213, 2214, 1,    0,    0,    0,    2214, 2215, 3,    98,   49,
      0,     2215, 95,   1,    0,    0,    0,    2216, 2219, 3,    280,  140,  0,    2217, 2218, 4,    48,   15,   0,
      2218,  2220, 3,    354,  177,  0,    2219, 2217, 1,    0,    0,    0,    2219, 2220, 1,    0,    0,    0,    2220,
      2223,  1,    0,    0,    0,    2221, 2223, 3,    284,  142,  0,    2222, 2216, 1,    0,    0,    0,    2222, 2221,
      1,     0,    0,    0,    2223, 97,   1,    0,    0,    0,    2224, 2226, 3,    280,  140,  0,    2225, 2227, 3,
      354,   177,  0,    2226, 2225, 1,    0,    0,    0,    2226, 2227, 1,    0,    0,    0,    2227, 99,   1,    0,
      0,     0,    2228, 2232, 5,    97,   0,    0,    2229, 2233, 3,    102,  51,   0,    2230, 2233, 3,    104,  52,
      0,     2231, 2233, 3,    106,  53,   0,    2232, 2229, 1,    0,    0,    0,    2232, 2230, 1,    0,    0,    0,
      2232,  2231, 1,    0,    0,    0,    2233, 2235, 1,    0,    0,    0,    2234, 2236, 5,    774,  0,    0,    2235,
      2234,  1,    0,    0,    0,    2235, 2236, 1,    0,    0,    0,    2236, 2237, 1,    0,    0,    0,    2237, 2238,
      5,     0,    0,    1,    2238, 101,  1,    0,    0,    0,    2239, 2241, 3,    1176, 588,  0,    2240, 2239, 1,
      0,     0,    0,    2240, 2241, 1,    0,    0,    0,    2241, 2242, 1,    0,    0,    0,    2242, 2244, 5,    422,
      0,     0,    2243, 2245, 3,    1180, 590,  0,    2244, 2243, 1,    0,    0,    0,    2244, 2245, 1,    0,    0,
      0,     2245, 2246, 1,    0,    0,    0,    2246, 2247, 3,    1280, 640,  0,    2247, 2256, 5,    776,  0,    0,
      2248,  2253, 3,    1184, 592,  0,    2249, 2250, 5,    773,  0,    0,    2250, 2252, 3,    1184, 592,  0,    2251,
      2249,  1,    0,    0,    0,    2252, 2255, 1,    0,    0,    0,    2253, 2251, 1,    0,    0,    0,    2253, 2254,
      1,     0,    0,    0,    2254, 2257, 1,    0,    0,    0,    2255, 2253, 1,    0,    0,    0,    2256, 2248, 1,
      0,     0,    0,    2256, 2257, 1,    0,    0,    0,    2257, 2258, 1,    0,    0,    0,    2258, 2262, 5,    777,
      0,     0,    2259, 2261, 3,    108,  54,   0,    2260, 2259, 1,    0,    0,    0,    2261, 2264, 1,    0,    0,
      0,     2262, 2260, 1,    0,    0,    0,    2262, 2263, 1,    0,    0,    0,    2263, 2265, 1,    0,    0,    0,
      2264,  2262, 1,    0,    0,    0,    2265, 2266, 3,    976,  488,  0,    2266, 103,  1,    0,    0,    0,    2267,
      2269,  3,    1176, 588,  0,    2268, 2267, 1,    0,    0,    0,    2268, 2269, 1,    0,    0,    0,    2269, 2270,
      1,     0,    0,    0,    2270, 2272, 5,    206,  0,    0,    2271, 2273, 3,    1180, 590,  0,    2272, 2271, 1,
      0,     0,    0,    2272, 2273, 1,    0,    0,    0,    2273, 2274, 1,    0,    0,    0,    2274, 2275, 3,    1284,
      642,   0,    2275, 2284, 5,    776,  0,    0,    2276, 2281, 3,    1186, 593,  0,    2277, 2278, 5,    773,  0,
      0,     2278, 2280, 3,    1186, 593,  0,    2279, 2277, 1,    0,    0,    0,    2280, 2283, 1,    0,    0,    0,
      2281,  2279, 1,    0,    0,    0,    2281, 2282, 1,    0,    0,    0,    2282, 2285, 1,    0,    0,    0,    2283,
      2281,  1,    0,    0,    0,    2284, 2276, 1,    0,    0,    0,    2284, 2285, 1,    0,    0,    0,    2285, 2286,
      1,     0,    0,    0,    2286, 2287, 5,    777,  0,    0,    2287, 2288, 5,    474,  0,    0,    2288, 2292, 3,
      1190,  595,  0,    2289, 2291, 3,    108,  54,   0,    2290, 2289, 1,    0,    0,    0,    2291, 2294, 1,    0,
      0,     0,    2292, 2290, 1,    0,    0,    0,    2292, 2293, 1,    0,    0,    0,    2293, 2295, 1,    0,    0,
      0,     2294, 2292, 1,    0,    0,    0,    2295, 2296, 3,    976,  488,  0,    2296, 105,  1,    0,    0,    0,
      2297,  2299, 5,    8,    0,    0,    2298, 2297, 1,    0,    0,    0,    2298, 2299, 1,    0,    0,    0,    2299,
      2300,  1,    0,    0,    0,    2300, 2302, 5,    206,  0,    0,    2301, 2303, 3,    1180, 590,  0,    2302, 2301,
      1,     0,    0,    0,    2302, 2303, 1,    0,    0,    0,    2303, 2304, 1,    0,    0,    0,    2304, 2305, 3,
      1308,  654,  0,    2305, 2306, 5,    474,  0,    0,    2306, 2307, 7,    9,    0,    0,    2307, 2308, 5,    520,
      0,     0,    2308, 2309, 3,    1384, 692,  0,    2309, 107,  1,    0,    0,    0,    2310, 2316, 3,    112,  56,
      0,     2311, 2313, 5,    371,  0,    0,    2312, 2311, 1,    0,    0,    0,    2312, 2313, 1,    0,    0,    0,
      2313,  2314, 1,    0,    0,    0,    2314, 2316, 5,    137,  0,    0,    2315, 2310, 1,    0,    0,    0,    2315,
      2312,  1,    0,    0,    0,    2316, 109,  1,    0,    0,    0,    2317, 2319, 3,    108,  54,   0,    2318, 2317,
      1,     0,    0,    0,    2319, 2320, 1,    0,    0,    0,    2320, 2318, 1,    0,    0,    0,    2320, 2321, 1,
      0,     0,    0,    2321, 111,  1,    0,    0,    0,    2322, 2323, 5,    75,   0,    0,    2323, 2340, 3,    1384,
      692,   0,    2324, 2325, 5,    267,  0,    0,    2325, 2340, 5,    537,  0,    0,    2326, 2327, 5,    373,  0,
      0,     2327, 2340, 5,    537,  0,    0,    2328, 2329, 5,    90,   0,    0,    2329, 2340, 5,    537,  0,    0,
      2330,  2331, 5,    433,  0,    0,    2331, 2332, 5,    537,  0,    0,    2332, 2340, 5,    112,  0,    0,    2333,
      2334,  5,    347,  0,    0,    2334, 2335, 5,    537,  0,    0,    2335, 2340, 5,    112,  0,    0,    2336, 2337,
      5,     537,  0,    0,    2337, 2338, 5,    496,  0,    0,    2338, 2340, 7,    10,   0,    0,    2339, 2322, 1,
      0,     0,    0,    2339, 2324, 1,    0,    0,    0,    2339, 2326, 1,    0,    0,    0,    2339, 2328, 1,    0,
      0,     0,    2339, 2330, 1,    0,    0,    0,    2339, 2333, 1,    0,    0,    0,    2339, 2336, 1,    0,    0,
      0,     2340, 113,  1,    0,    0,    0,    2341, 2343, 3,    1252, 626,  0,    2342, 2341, 1,    0,    0,    0,
      2342,  2343, 1,    0,    0,    0,    2343, 2379, 1,    0,    0,    0,    2344, 2346, 5,    609,  0,    0,    2345,
      2344,  1,    0,    0,    0,    2345, 2346, 1,    0,    0,    0,    2346, 2347, 1,    0,    0,    0,    2347, 2348,
      5,     236,  0,    0,    2348, 2350, 3,    1270, 635,  0,    2349, 2351, 3,    1102, 551,  0,    2350, 2349, 1,
      0,     0,    0,    2350, 2351, 1,    0,    0,    0,    2351, 2352, 1,    0,    0,    0,    2352, 2356, 3,    118,
      59,    0,    2353, 2355, 3,    1096, 548,  0,    2354, 2353, 1,    0,    0,    0,    2355, 2358, 1,    0,    0,
      0,     2356, 2354, 1,    0,    0,    0,    2356, 2357, 1,    0,    0,    0,    2357, 2380, 1,    0,    0,    0,
      2358,  2356, 1,    0,    0,    0,    2359, 2360, 5,    205,  0,    0,    2360, 2361, 5,    236,  0,    0,    2361,
      2362,  3,    1270, 635,  0,    2362, 2366, 3,    118,  59,   0,    2363, 2365, 3,    1104, 552,  0,    2364, 2363,
      1,     0,    0,    0,    2365, 2368, 1,    0,    0,    0,    2366, 2364, 1,    0,    0,    0,    2366, 2367, 1,
      0,     0,    0,    2367, 2380, 1,    0,    0,    0,    2368, 2366, 1,    0,    0,    0,    2369, 2370, 5,    523,
      0,     0,    2370, 2371, 5,    236,  0,    0,    2371, 2372, 3,    1270, 635,  0,    2372, 2376, 3,    118,  59,
      0,     2373, 2375, 3,    1106, 553,  0,    2374, 2373, 1,    0,    0,    0,    2375, 2378, 1,    0,    0,    0,
      2376,  2374, 1,    0,    0,    0,    2376, 2377, 1,    0,    0,    0,    2377, 2380, 1,    0,    0,    0,    2378,
      2376,  1,    0,    0,    0,    2379, 2345, 1,    0,    0,    0,    2379, 2359, 1,    0,    0,    0,    2379, 2369,
      1,     0,    0,    0,    2380, 2382, 1,    0,    0,    0,    2381, 2383, 3,    48,   24,   0,    2382, 2381, 1,
      0,     0,    0,    2382, 2383, 1,    0,    0,    0,    2383, 115,  1,    0,    0,    0,    2384, 2395, 3,    1270,
      635,   0,    2385, 2387, 3,    1270, 635,  0,    2386, 2385, 1,    0,    0,    0,    2386, 2387, 1,    0,    0,
      0,     2387, 2388, 1,    0,    0,    0,    2388, 2389, 5,    621,  0,    0,    2389, 2395, 3,    1094, 547,  0,
      2390,  2391, 3,    1270, 635,  0,    2391, 2392, 5,    599,  0,    0,    2392, 2393, 3,    1094, 547,  0,    2393,
      2395,  1,    0,    0,    0,    2394, 2384, 1,    0,    0,    0,    2394, 2386, 1,    0,    0,    0,    2394, 2390,
      1,     0,    0,    0,    2395, 117,  1,    0,    0,    0,    2396, 2397, 5,    383,  0,    0,    2397, 2398, 3,
      1322,  661,  0,    2398, 2399, 3,    1090, 545,  0,    2399, 119,  1,    0,    0,    0,    2400, 2401, 5,    288,
      0,     0,    2401, 2402, 5,    217,  0,    0,    2402, 2403, 3,    1300, 650,  0,    2403, 2404, 5,    4,    0,
      0,     2404, 2405, 5,    603,  0,    0,    2405, 2407, 3,    1384, 692,  0,    2406, 2408, 3,    122,  61,   0,
      2407,  2406, 1,    0,    0,    0,    2407, 2408, 1,    0,    0,    0,    2408, 121,  1,    0,    0,    0,    2409,
      2416,  3,    124,  62,   0,    2410, 2412, 5,    773,  0,    0,    2411, 2410, 1,    0,    0,    0,    2411, 2412,
      1,     0,    0,    0,    2412, 2413, 1,    0,    0,    0,    2413, 2415, 3,    124,  62,   0,    2414, 2411, 1,
      0,     0,    0,    2415, 2418, 1,    0,    0,    0,    2416, 2414, 1,    0,    0,    0,    2416, 2417, 1,    0,
      0,     0,    2417, 123,  1,    0,    0,    0,    2418, 2416, 1,    0,    0,    0,    2419, 2426, 3,    144,  72,
      0,     2420, 2426, 3,    146,  73,   0,    2421, 2426, 3,    154,  77,   0,    2422, 2426, 3,    156,  78,   0,
      2423,  2426, 3,    158,  79,   0,    2424, 2426, 3,    160,  80,   0,    2425, 2419, 1,    0,    0,    0,    2425,
      2420,  1,    0,    0,    0,    2425, 2421, 1,    0,    0,    0,    2425, 2422, 1,    0,    0,    0,    2425, 2423,
      1,     0,    0,    0,    2425, 2424, 1,    0,    0,    0,    2426, 125,  1,    0,    0,    0,    2427, 2428, 5,
      503,   0,    0,    2428, 2429, 3,    1310, 655,  0,    2429, 2430, 5,    199,  0,    0,    2430, 2431, 5,    112,
      0,     0,    2431, 2432, 5,    648,  0,    0,    2432, 2433, 3,    1406, 703,  0,    2433, 2434, 3,    128,  64,
      0,     2434, 127,  1,    0,    0,    0,    2435, 2436, 5,    390,  0,    0,    2436, 2437, 5,    776,  0,    0,
      2437,  2442, 3,    130,  65,   0,    2438, 2439, 5,    773,  0,    0,    2439, 2441, 3,    130,  65,   0,    2440,
      2438,  1,    0,    0,    0,    2441, 2444, 1,    0,    0,    0,    2442, 2440, 1,    0,    0,    0,    2442, 2443,
      1,     0,    0,    0,    2443, 2445, 1,    0,    0,    0,    2444, 2442, 1,    0,    0,    0,    2445, 2446, 5,
      777,   0,    0,    2446, 129,  1,    0,    0,    0,    2447, 2448, 5,    224,  0,    0,    2448, 2462, 3,    1384,
      692,   0,    2449, 2450, 5,    109,  0,    0,    2450, 2462, 3,    1384, 692,  0,    2451, 2452, 5,    618,  0,
      0,     2452, 2462, 3,    1384, 692,  0,    2453, 2454, 5,    406,  0,    0,    2454, 2462, 3,    1384, 692,  0,
      2455,  2456, 5,    519,  0,    0,    2456, 2462, 3,    1384, 692,  0,    2457, 2458, 5,    398,  0,    0,    2458,
      2462,  3,    1384, 692,  0,    2459, 2460, 5,    413,  0,    0,    2460, 2462, 3,    1358, 679,  0,    2461, 2447,
      1,     0,    0,    0,    2461, 2449, 1,    0,    0,    0,    2461, 2451, 1,    0,    0,    0,    2461, 2453, 1,
      0,     0,    0,    2461, 2455, 1,    0,    0,    0,    2461, 2457, 1,    0,    0,    0,    2461, 2459, 1,    0,
      0,     0,    2462, 131,  1,    0,    0,    0,    2463, 2464, 5,    572,  0,    0,    2464, 2465, 3,    1296, 648,
      0,     2465, 2470, 3,    136,  68,   0,    2466, 2467, 5,    620,  0,    0,    2467, 2468, 5,    288,  0,    0,
      2468,  2469, 5,    217,  0,    0,    2469, 2471, 3,    1302, 651,  0,    2470, 2466, 1,    0,    0,    0,    2470,
      2471,  1,    0,    0,    0,    2471, 2473, 1,    0,    0,    0,    2472, 2474, 3,    140,  70,   0,    2473, 2472,
      1,     0,    0,    0,    2473, 2474, 1,    0,    0,    0,    2474, 133,  1,    0,    0,    0,    2475, 2476, 5,
      605,   0,    0,    2476, 2477, 5,    572,  0,    0,    2477, 2478, 3,    1296, 648,  0,    2478, 2479, 5,    4,
      0,     0,    2479, 2481, 3,    138,  69,   0,    2480, 2482, 3,    60,   30,   0,    2481, 2480, 1,    0,    0,
      0,     2481, 2482, 1,    0,    0,    0,    2482, 135,  1,    0,    0,    0,    2483, 2484, 5,    4,    0,    0,
      2484,  2491, 3,    138,  69,   0,    2485, 2488, 4,    68,   16,   0,    2486, 2487, 5,    4,    0,    0,    2487,
      2489,  3,    138,  69,   0,    2488, 2486, 1,    0,    0,    0,    2488, 2489, 1,    0,    0,    0,    2489, 2491,
      1,     0,    0,    0,    2490, 2483, 1,    0,    0,    0,    2490, 2485, 1,    0,    0,    0,    2491, 137,  1,
      0,     0,    0,    2492, 2493, 5,    111,  0,    0,    2493, 2494, 3,    1384, 692,  0,    2494, 139,  1,    0,
      0,     0,    2495, 2502, 3,    142,  71,   0,    2496, 2498, 5,    773,  0,    0,    2497, 2496, 1,    0,    0,
      0,     2497, 2498, 1,    0,    0,    0,    2498, 2499, 1,    0,    0,    0,    2499, 2501, 3,    142,  71,   0,
      2500,  2497, 1,    0,    0,    0,    2501, 2504, 1,    0,    0,    0,    2502, 2500, 1,    0,    0,    0,    2502,
      2503,  1,    0,    0,    0,    2503, 141,  1,    0,    0,    0,    2504, 2502, 1,    0,    0,    0,    2505, 2517,
      3,     144,  72,   0,    2506, 2517, 3,    148,  74,   0,    2507, 2517, 3,    150,  75,   0,    2508, 2517, 3,
      152,   76,   0,    2509, 2517, 3,    154,  77,   0,    2510, 2517, 3,    156,  78,   0,    2511, 2517, 3,    158,
      79,    0,    2512, 2517, 3,    160,  80,   0,    2513, 2517, 3,    162,  81,   0,    2514, 2515, 4,    71,   17,
      0,     2515, 2517, 3,    164,  82,   0,    2516, 2505, 1,    0,    0,    0,    2516, 2506, 1,    0,    0,    0,
      2516,  2507, 1,    0,    0,    0,    2516, 2508, 1,    0,    0,    0,    2516, 2509, 1,    0,    0,    0,    2516,
      2510,  1,    0,    0,    0,    2516, 2511, 1,    0,    0,    0,    2516, 2512, 1,    0,    0,    0,    2516, 2513,
      1,     0,    0,    0,    2516, 2514, 1,    0,    0,    0,    2517, 143,  1,    0,    0,    0,    2518, 2520, 5,
      238,   0,    0,    2519, 2521, 5,    750,  0,    0,    2520, 2519, 1,    0,    0,    0,    2520, 2521, 1,    0,
      0,     0,    2521, 2522, 1,    0,    0,    0,    2522, 2523, 3,    1412, 706,  0,    2523, 145,  1,    0,    0,
      0,     2524, 2526, 7,    11,   0,    0,    2525, 2527, 5,    750,  0,    0,    2526, 2525, 1,    0,    0,    0,
      2526,  2527, 1,    0,    0,    0,    2527, 2528, 1,    0,    0,    0,    2528, 2529, 3,    1412, 706,  0,    2529,
      147,   1,    0,    0,    0,    2530, 2532, 5,    23,   0,    0,    2531, 2533, 5,    750,  0,    0,    2532, 2531,
      1,     0,    0,    0,    2532, 2533, 1,    0,    0,    0,    2533, 2534, 1,    0,    0,    0,    2534, 2535, 3,
      1412,  706,  0,    2535, 149,  1,    0,    0,    0,    2536, 2538, 5,    324,  0,    0,    2537, 2539, 5,    750,
      0,     0,    2538, 2537, 1,    0,    0,    0,    2538, 2539, 1,    0,    0,    0,    2539, 2540, 1,    0,    0,
      0,     2540, 2541, 3,    1412, 706,  0,    2541, 151,  1,    0,    0,    0,    2542, 2544, 5,    181,  0,    0,
      2543,  2545, 5,    750,  0,    0,    2544, 2543, 1,    0,    0,    0,    2544, 2545, 1,    0,    0,    0,    2545,
      2546,  1,    0,    0,    0,    2546, 2547, 3,    1412, 706,  0,    2547, 153,  1,    0,    0,    0,    2548, 2550,
      5,     368,  0,    0,    2549, 2551, 5,    750,  0,    0,    2550, 2549, 1,    0,    0,    0,    2550, 2551, 1,
      0,     0,    0,    2551, 2552, 1,    0,    0,    0,    2552, 2553, 3,    1360, 680,  0,    2553, 155,  1,    0,
      0,     0,    2554, 2556, 5,    553,  0,    0,    2555, 2554, 1,    0,    0,    0,    2555, 2556, 1,    0,    0,
      0,     2556, 2557, 1,    0,    0,    0,    2557, 2559, 5,    163,  0,    0,    2558, 2560, 5,    750,  0,    0,
      2559,  2558, 1,    0,    0,    0,    2559, 2560, 1,    0,    0,    0,    2560, 2561, 1,    0,    0,    0,    2561,
      2562,  3,    1314, 657,  0,    2562, 157,  1,    0,    0,    0,    2563, 2564, 7,    12,   0,    0,    2564, 159,
      1,     0,    0,    0,    2565, 2567, 5,    75,   0,    0,    2566, 2568, 5,    750,  0,    0,    2567, 2566, 1,
      0,     0,    0,    2567, 2568, 1,    0,    0,    0,    2568, 2569, 1,    0,    0,    0,    2569, 2570, 3,    1384,
      692,   0,    2570, 161,  1,    0,    0,    0,    2571, 2573, 5,    189,  0,    0,    2572, 2574, 5,    750,  0,
      0,     2573, 2572, 1,    0,    0,    0,    2573, 2574, 1,    0,    0,    0,    2574, 2575, 1,    0,    0,    0,
      2575,  2576, 3,    1412, 706,  0,    2576, 163,  1,    0,    0,    0,    2577, 2579, 5,    158,  0,    0,    2578,
      2580,  5,    750,  0,    0,    2579, 2578, 1,    0,    0,    0,    2579, 2580, 1,    0,    0,    0,    2580, 2581,
      1,     0,    0,    0,    2581, 2582, 3,    1378, 689,  0,    2582, 165,  1,    0,    0,    0,    2583, 2585, 5,
      163,   0,    0,    2584, 2586, 5,    750,  0,    0,    2585, 2584, 1,    0,    0,    0,    2585, 2586, 1,    0,
      0,     0,    2586, 2587, 1,    0,    0,    0,    2587, 2588, 3,    1424, 712,  0,    2588, 167,  1,    0,    0,
      0,     2589, 2591, 3,    170,  85,   0,    2590, 2589, 1,    0,    0,    0,    2590, 2591, 1,    0,    0,    0,
      2591,  2593, 1,    0,    0,    0,    2592, 2594, 3,    1176, 588,  0,    2593, 2592, 1,    0,    0,    0,    2593,
      2594,  1,    0,    0,    0,    2594, 2596, 1,    0,    0,    0,    2595, 2597, 3,    174,  87,   0,    2596, 2595,
      1,     0,    0,    0,    2596, 2597, 1,    0,    0,    0,    2597, 2598, 1,    0,    0,    0,    2598, 2599, 5,
      636,   0,    0,    2599, 2600, 3,    1292, 646,  0,    2600, 2601, 3,    72,   36,   0,    2601, 169,  1,    0,
      0,     0,    2602, 2603, 5,    394,  0,    0,    2603, 2605, 5,    458,  0,    0,    2604, 2606, 3,    172,  86,
      0,     2605, 2604, 1,    0,    0,    0,    2605, 2606, 1,    0,    0,    0,    2606, 2609, 1,    0,    0,    0,
      2607,  2609, 3,    172,  86,   0,    2608, 2602, 1,    0,    0,    0,    2608, 2607, 1,    0,    0,    0,    2609,
      171,   1,    0,    0,    0,    2610, 2611, 5,    9,    0,    0,    2611, 2612, 5,    750,  0,    0,    2612, 2613,
      7,     13,   0,    0,    2613, 173,  1,    0,    0,    0,    2614, 2615, 5,    537,  0,    0,    2615, 2616, 5,
      496,   0,    0,    2616, 2617, 7,    10,   0,    0,    2617, 175,  1,    0,    0,    0,    2618, 2620, 3,    1176,
      588,   0,    2619, 2618, 1,    0,    0,    0,    2619, 2620, 1,    0,    0,    0,    2620, 2621, 1,    0,    0,
      0,     2621, 2623, 5,    594,  0,    0,    2622, 2624, 3,    1180, 590,  0,    2623, 2622, 1,    0,    0,    0,
      2623,  2624, 1,    0,    0,    0,    2624, 2625, 1,    0,    0,    0,    2625, 2626, 3,    1288, 644,  0,    2626,
      2627,  7,    14,   0,    0,    2627, 2628, 7,    15,   0,    0,    2628, 2629, 5,    383,  0,    0,    2629, 2630,
      3,     1322, 661,  0,    2630, 2631, 5,    200,  0,    0,    2631, 2632, 5,    153,  0,    0,    2632, 2634, 5,
      487,   0,    0,    2633, 2635, 3,    178,  89,   0,    2634, 2633, 1,    0,    0,    0,    2634, 2635, 1,    0,
      0,     0,    2635, 2636, 1,    0,    0,    0,    2636, 2637, 3,    976,  488,  0,    2637, 177,  1,    0,    0,
      0,     2638, 2639, 7,    16,   0,    0,    2639, 2640, 3,    1406, 703,  0,    2640, 179,  1,    0,    0,    0,
      2641,  2643, 3,    1176, 588,  0,    2642, 2641, 1,    0,    0,    0,    2642, 2643, 1,    0,    0,    0,    2643,
      2644,  1,    0,    0,    0,    2644, 2646, 5,    170,  0,    0,    2645, 2647, 3,    1180, 590,  0,    2646, 2645,
      1,     0,    0,    0,    2646, 2647, 1,    0,    0,    0,    2647, 2648, 1,    0,    0,    0,    2648, 2649, 3,
      1304,  652,  0,    2649, 2650, 5,    383,  0,    0,    2650, 2651, 5,    490,  0,    0,    2651, 2658, 3,    1054,
      527,   0,    2652, 2653, 5,    383,  0,    0,    2653, 2655, 5,    79,   0,    0,    2654, 2656, 5,    371,  0,
      0,     2655, 2654, 1,    0,    0,    0,    2655, 2656, 1,    0,    0,    0,    2656, 2657, 1,    0,    0,    0,
      2657,  2659, 5,    418,  0,    0,    2658, 2652, 1,    0,    0,    0,    2658, 2659, 1,    0,    0,    0,    2659,
      2666,  1,    0,    0,    0,    2660, 2667, 5,    156,  0,    0,    2661, 2664, 5,    140,  0,    0,    2662, 2663,
      5,     383,  0,    0,    2663, 2665, 3,    578,  289,  0,    2664, 2662, 1,    0,    0,    0,    2664, 2665, 1,
      0,     0,    0,    2665, 2667, 1,    0,    0,    0,    2666, 2660, 1,    0,    0,    0,    2666, 2661, 1,    0,
      0,     0,    2666, 2667, 1,    0,    0,    0,    2667, 2670, 1,    0,    0,    0,    2668, 2669, 5,    75,   0,
      0,     2669, 2671, 3,    1384, 692,  0,    2670, 2668, 1,    0,    0,    0,    2670, 2671, 1,    0,    0,    0,
      2671,  2672, 1,    0,    0,    0,    2672, 2673, 5,    147,  0,    0,    2673, 2674, 3,    976,  488,  0,    2674,
      181,   1,    0,    0,    0,    2675, 2677, 5,    659,  0,    0,    2676, 2678, 3,    1180, 590,  0,    2677, 2676,
      1,     0,    0,    0,    2677, 2678, 1,    0,    0,    0,    2678, 2679, 1,    0,    0,    0,    2679, 2680, 3,
      656,   328,  0,    2680, 183,  1,    0,    0,    0,    2681, 2682, 5,    394,  0,    0,    2682, 2683, 5,    458,
      0,     0,    2683, 2684, 5,    523,  0,    0,    2684, 2685, 5,    718,  0,    0,    2685, 2686, 5,    710,  0,
      0,     2686, 2690, 3,    1364, 682,  0,    2687, 2689, 3,    186,  93,   0,    2688, 2687, 1,    0,    0,    0,
      2689,  2692, 1,    0,    0,    0,    2690, 2688, 1,    0,    0,    0,    2690, 2691, 1,    0,    0,    0,    2691,
      2707,  1,    0,    0,    0,    2692, 2690, 1,    0,    0,    0,    2693, 2694, 5,    523,  0,    0,    2694, 2695,
      5,     718,  0,    0,    2695, 2697, 5,    710,  0,    0,    2696, 2698, 3,    1180, 590,  0,    2697, 2696, 1,
      0,     0,    0,    2697, 2698, 1,    0,    0,    0,    2698, 2699, 1,    0,    0,    0,    2699, 2703, 3,    1364,
      682,   0,    2700, 2702, 3,    186,  93,   0,    2701, 2700, 1,    0,    0,    0,    2702, 2705, 1,    0,    0,
      0,     2703, 2701, 1,    0,    0,    0,    2703, 2704, 1,    0,    0,    0,    2704, 2707, 1,    0,    0,    0,
      2705,  2703, 1,    0,    0,    0,    2706, 2681, 1,    0,    0,    0,    2706, 2693, 1,    0,    0,    0,    2707,
      185,   1,    0,    0,    0,    2708, 2709, 5,    357,  0,    0,    2709, 2710, 5,    580,  0,    0,    2710, 2724,
      3,     1386, 693,  0,    2711, 2712, 5,    715,  0,    0,    2712, 2713, 5,    580,  0,    0,    2713, 2724, 3,
      1386,  693,  0,    2714, 2715, 5,    717,  0,    0,    2715, 2716, 3,    1386, 693,  0,    2716, 2717, 5,    230,
      0,     0,    2717, 2718, 5,    45,   0,    0,    2718, 2719, 3,    1364, 682,  0,    2719, 2724, 1,    0,    0,
      0,     2720, 2721, 5,    716,  0,    0,    2721, 2722, 5,    580,  0,    0,    2722, 2724, 3,    1386, 693,  0,
      2723,  2708, 1,    0,    0,    0,    2723, 2711, 1,    0,    0,    0,    2723, 2714, 1,    0,    0,    0,    2723,
      2720,  1,    0,    0,    0,    2724, 187,  1,    0,    0,    0,    2725, 2742, 5,    148,  0,    0,    2726, 2743,
      3,     190,  95,   0,    2727, 2743, 3,    192,  96,   0,    2728, 2743, 3,    194,  97,   0,    2729, 2743, 3,
      196,   98,   0,    2730, 2743, 3,    198,  99,   0,    2731, 2743, 3,    200,  100,  0,    2732, 2743, 3,    204,
      102,   0,    2733, 2743, 3,    206,  103,  0,    2734, 2743, 3,    208,  104,  0,    2735, 2743, 3,    210,  105,
      0,     2736, 2743, 3,    212,  106,  0,    2737, 2743, 3,    214,  107,  0,    2738, 2739, 4,    94,   18,   0,
      2739,  2743, 3,    216,  108,  0,    2740, 2741, 4,    94,   19,   0,    2741, 2743, 3,    218,  109,  0,    2742,
      2726,  1,    0,    0,    0,    2742, 2727, 1,    0,    0,    0,    2742, 2728, 1,    0,    0,    0,    2742, 2729,
      1,     0,    0,    0,    2742, 2730, 1,    0,    0,    0,    2742, 2731, 1,    0,    0,    0,    2742, 2732, 1,
      0,     0,    0,    2742, 2733, 1,    0,    0,    0,    2742, 2734, 1,    0,    0,    0,    2742, 2735, 1,    0,
      0,     0,    2742, 2736, 1,    0,    0,    0,    2742, 2737, 1,    0,    0,    0,    2742, 2738, 1,    0,    0,
      0,     2742, 2740, 1,    0,    0,    0,    2743, 189,  1,    0,    0,    0,    2744, 2746, 5,    109,  0,    0,
      2745,  2747, 3,    1178, 589,  0,    2746, 2745, 1,    0,    0,    0,    2746, 2747, 1,    0,    0,    0,    2747,
      2748,  1,    0,    0,    0,    2748, 2749, 3,    1278, 639,  0,    2749, 191,  1,    0,    0,    0,    2750, 2752,
      5,     170,  0,    0,    2751, 2753, 3,    1178, 589,  0,    2752, 2751, 1,    0,    0,    0,    2752, 2753, 1,
      0,     0,    0,    2753, 2754, 1,    0,    0,    0,    2754, 2755, 3,    1306, 653,  0,    2755, 193,  1,    0,
      0,     0,    2756, 2758, 5,    206,  0,    0,    2757, 2759, 3,    1178, 589,  0,    2758, 2757, 1,    0,    0,
      0,     2758, 2759, 1,    0,    0,    0,    2759, 2760, 1,    0,    0,    0,    2760, 2761, 3,    1286, 643,  0,
      2761,  195,  1,    0,    0,    0,    2762, 2764, 5,    422,  0,    0,    2763, 2765, 3,    1178, 589,  0,    2764,
      2763,  1,    0,    0,    0,    2764, 2765, 1,    0,    0,    0,    2765, 2766, 1,    0,    0,    0,    2766, 2767,
      3,     1282, 641,  0,    2767, 197,  1,    0,    0,    0,    2768, 2770, 3,    1252, 626,  0,    2769, 2768, 1,
      0,     0,    0,    2769, 2770, 1,    0,    0,    0,    2770, 2771, 1,    0,    0,    0,    2771, 2772, 5,    236,
      0,     0,    2772, 2773, 3,    1272, 636,  0,    2773, 2774, 5,    383,  0,    0,    2774, 2776, 3,    1322, 661,
      0,     2775, 2777, 3,    48,   24,   0,    2776, 2775, 1,    0,    0,    0,    2776, 2777, 1,    0,    0,    0,
      2777,  199,  1,    0,    0,    0,    2778, 2779, 5,    288,  0,    0,    2779, 2780, 5,    217,  0,    0,    2780,
      2791,  3,    1302, 651,  0,    2781, 2788, 3,    202,  101,  0,    2782, 2784, 5,    773,  0,    0,    2783, 2782,
      1,     0,    0,    0,    2783, 2784, 1,    0,    0,    0,    2784, 2785, 1,    0,    0,    0,    2785, 2787, 3,
      202,   101,  0,    2786, 2783, 1,    0,    0,    0,    2787, 2790, 1,    0,    0,    0,    2788, 2786, 1,    0,
      0,     0,    2788, 2789, 1,    0,    0,    0,    2789, 2792, 1,    0,    0,    0,    2790, 2788, 1,    0,    0,
      0,     2791, 2781, 1,    0,    0,    0,    2791, 2792, 1,    0,    0,    0,    2792, 201,  1,    0,    0,    0,
      2793,  2796, 3,    158,  79,   0,    2794, 2796, 3,    156,  78,   0,    2795, 2793, 1,    0,    0,    0,    2795,
      2794,  1,    0,    0,    0,    2796, 203,  1,    0,    0,    0,    2797, 2799, 5,    503,  0,    0,    2798, 2800,
      3,     1178, 589,  0,    2799, 2798, 1,    0,    0,    0,    2799, 2800, 1,    0,    0,    0,    2800, 2801, 1,
      0,     0,    0,    2801, 2802, 3,    1312, 656,  0,    2802, 205,  1,    0,    0,    0,    2803, 2805, 5,    577,
      0,     0,    2804, 2803, 1,    0,    0,    0,    2804, 2805, 1,    0,    0,    0,    2805, 2806, 1,    0,    0,
      0,     2806, 2808, 7,    17,   0,    0,    2807, 2809, 3,    1178, 589,  0,    2808, 2807, 1,    0,    0,    0,
      2808,  2809, 1,    0,    0,    0,    2809, 2810, 1,    0,    0,    0,    2810, 2812, 3,    1324, 662,  0,    2811,
      2813,  7,    2,    0,    0,    2812, 2811, 1,    0,    0,    0,    2812, 2813, 1,    0,    0,    0,    2813, 207,
      1,     0,    0,    0,    2814, 2815, 5,    572,  0,    0,    2815, 2826, 3,    1298, 649,  0,    2816, 2823, 3,
      202,   101,  0,    2817, 2819, 5,    773,  0,    0,    2818, 2817, 1,    0,    0,    0,    2818, 2819, 1,    0,
      0,     0,    2819, 2820, 1,    0,    0,    0,    2820, 2822, 3,    202,  101,  0,    2821, 2818, 1,    0,    0,
      0,     2822, 2825, 1,    0,    0,    0,    2823, 2821, 1,    0,    0,    0,    2823, 2824, 1,    0,    0,    0,
      2824,  2827, 1,    0,    0,    0,    2825, 2823, 1,    0,    0,    0,    2826, 2816, 1,    0,    0,    0,    2826,
      2827,  1,    0,    0,    0,    2827, 209,  1,    0,    0,    0,    2828, 2830, 5,    594,  0,    0,    2829, 2831,
      3,     1178, 589,  0,    2830, 2829, 1,    0,    0,    0,    2830, 2831, 1,    0,    0,    0,    2831, 2832, 1,
      0,     0,    0,    2832, 2833, 3,    1290, 645,  0,    2833, 211,  1,    0,    0,    0,    2834, 2836, 5,    636,
      0,     0,    2835, 2837, 3,    1178, 589,  0,    2836, 2835, 1,    0,    0,    0,    2836, 2837, 1,    0,    0,
      0,     2837, 2838, 1,    0,    0,    0,    2838, 2840, 3,    1194, 597,  0,    2839, 2841, 7,    2,    0,    0,
      2840,  2839, 1,    0,    0,    0,    2840, 2841, 1,    0,    0,    0,    2841, 213,  1,    0,    0,    0,    2842,
      2844,  5,    659,  0,    0,    2843, 2845, 3,    1178, 589,  0,    2844, 2843, 1,    0,    0,    0,    2844, 2845,
      1,     0,    0,    0,    2845, 2846, 1,    0,    0,    0,    2846, 2847, 3,    656,  328,  0,    2847, 215,  1,
      0,     0,    0,    2848, 2849, 5,    523,  0,    0,    2849, 2850, 5,    718,  0,    0,    2850, 2852, 5,    710,
      0,     0,    2851, 2853, 3,    1178, 589,  0,    2852, 2851, 1,    0,    0,    0,    2852, 2853, 1,    0,    0,
      0,     2853, 2854, 1,    0,    0,    0,    2854, 2855, 3,    1364, 682,  0,    2855, 217,  1,    0,    0,    0,
      2856,  2857, 5,    605,  0,    0,    2857, 2858, 5,    572,  0,    0,    2858, 2860, 3,    1298, 649,  0,    2859,
      2861,  3,    60,   30,   0,    2860, 2859, 1,    0,    0,    0,    2860, 2861, 1,    0,    0,    0,    2861, 219,
      1,     0,    0,    0,    2862, 2863, 5,    453,  0,    0,    2863, 2864, 7,    17,   0,    0,    2864, 2869, 3,
      222,   111,  0,    2865, 2866, 5,    773,  0,    0,    2866, 2868, 3,    222,  111,  0,    2867, 2865, 1,    0,
      0,     0,    2868, 2871, 1,    0,    0,    0,    2869, 2867, 1,    0,    0,    0,    2869, 2870, 1,    0,    0,
      0,     2870, 221,  1,    0,    0,    0,    2871, 2869, 1,    0,    0,    0,    2872, 2873, 3,    1322, 661,  0,
      2873,  2874, 5,    590,  0,    0,    2874, 2875, 3,    1316, 658,  0,    2875, 223,  1,    0,    0,    0,    2876,
      2878,  5,    597,  0,    0,    2877, 2879, 5,    574,  0,    0,    2878, 2877, 1,    0,    0,    0,    2878, 2879,
      1,     0,    0,    0,    2879, 2880, 1,    0,    0,    0,    2880, 2881, 3,    1322, 661,  0,    2881, 225,  1,
      0,     0,    0,    2882, 2883, 5,    234,  0,    0,    2883, 2884, 5,    574,  0,    0,    2884, 2885, 5,    203,
      0,     0,    2885, 2886, 3,    1388, 694,  0,    2886, 227,  1,    0,    0,    0,    2887, 2888, 5,    48,   0,
      0,     2888, 2894, 3,    1282, 641,  0,    2889, 2891, 5,    776,  0,    0,    2890, 2892, 3,    948,  474,  0,
      2891,  2890, 1,    0,    0,    0,    2891, 2892, 1,    0,    0,    0,    2892, 2893, 1,    0,    0,    0,    2893,
      2895,  5,    777,  0,    0,    2894, 2889, 1,    0,    0,    0,    2894, 2895, 1,    0,    0,    0,    2895, 229,
      1,     0,    0,    0,    2896, 2898, 3,    330,  165,  0,    2897, 2896, 1,    0,    0,    0,    2897, 2898, 1,
      0,     0,    0,    2898, 2899, 1,    0,    0,    0,    2899, 2903, 5,    133,  0,    0,    2900, 2902, 3,    234,
      117,   0,    2901, 2900, 1,    0,    0,    0,    2902, 2905, 1,    0,    0,    0,    2903, 2901, 1,    0,    0,
      0,     2903, 2904, 1,    0,    0,    0,    2904, 2938, 1,    0,    0,    0,    2905, 2903, 1,    0,    0,    0,
      2906,  2930, 5,    203,  0,    0,    2907, 2908, 3,    1326, 663,  0,    2908, 2909, 5,    621,  0,    0,    2909,
      2911,  3,    344,  172,  0,    2910, 2912, 3,    368,  184,  0,    2911, 2910, 1,    0,    0,    0,    2911, 2912,
      1,     0,    0,    0,    2912, 2931, 1,    0,    0,    0,    2913, 2916, 3,    1322, 661,  0,    2914, 2915, 4,
      115,   20,   0,    2915, 2917, 3,    410,  205,  0,    2916, 2914, 1,    0,    0,    0,    2916, 2917, 1,    0,
      0,     0,    2917, 2919, 1,    0,    0,    0,    2918, 2920, 3,    232,  116,  0,    2919, 2918, 1,    0,    0,
      0,     2919, 2920, 1,    0,    0,    0,    2920, 2922, 1,    0,    0,    0,    2921, 2923, 3,    368,  184,  0,
      2922,  2921, 1,    0,    0,    0,    2922, 2923, 1,    0,    0,    0,    2923, 2925, 1,    0,    0,    0,    2924,
      2926,  3,    338,  169,  0,    2925, 2924, 1,    0,    0,    0,    2925, 2926, 1,    0,    0,    0,    2926, 2928,
      1,     0,    0,    0,    2927, 2929, 3,    296,  148,  0,    2928, 2927, 1,    0,    0,    0,    2928, 2929, 1,
      0,     0,    0,    2929, 2931, 1,    0,    0,    0,    2930, 2907, 1,    0,    0,    0,    2930, 2913, 1,    0,
      0,     0,    2931, 2939, 1,    0,    0,    0,    2932, 2933, 3,    1326, 663,  0,    2933, 2934, 5,    203,  0,
      0,     2934, 2936, 3,    344,  172,  0,    2935, 2937, 3,    368,  184,  0,    2936, 2935, 1,    0,    0,    0,
      2936,  2937, 1,    0,    0,    0,    2937, 2939, 1,    0,    0,    0,    2938, 2906, 1,    0,    0,    0,    2938,
      2932,  1,    0,    0,    0,    2939, 231,  1,    0,    0,    0,    2940, 2941, 5,    405,  0,    0,    2941, 2942,
      5,     776,  0,    0,    2942, 2943, 3,    1348, 674,  0,    2943, 2944, 5,    777,  0,    0,    2944, 233,  1,
      0,     0,    0,    2945, 2946, 7,    18,   0,    0,    2946, 235,  1,    0,    0,    0,    2947, 2948, 5,    147,
      0,     0,    2948, 2949, 3,    362,  181,  0,    2949, 237,  1,    0,    0,    0,    2950, 2968, 5,    219,  0,
      0,     2951, 2952, 3,    1322, 661,  0,    2952, 2954, 5,    387,  0,    0,    2953, 2955, 3,    410,  205,  0,
      2954,  2953, 1,    0,    0,    0,    2954, 2955, 1,    0,    0,    0,    2955, 2969, 1,    0,    0,    0,    2956,
      2966,  3,    1346, 673,  0,    2957, 2967, 5,    66,   0,    0,    2958, 2959, 5,    435,  0,    0,    2959, 2961,
      3,     240,  120,  0,    2960, 2962, 3,    368,  184,  0,    2961, 2960, 1,    0,    0,    0,    2961, 2962, 1,
      0,     0,    0,    2962, 2964, 1,    0,    0,    0,    2963, 2965, 3,    294,  147,  0,    2964, 2963, 1,    0,
      0,     0,    2964, 2965, 1,    0,    0,    0,    2965, 2967, 1,    0,    0,    0,    2966, 2957, 1,    0,    0,
      0,     2966, 2958, 1,    0,    0,    0,    2967, 2969, 1,    0,    0,    0,    2968, 2951, 1,    0,    0,    0,
      2968,  2956, 1,    0,    0,    0,    2969, 239,  1,    0,    0,    0,    2970, 2981, 7,    19,   0,    0,    2971,
      2978,  3,    1346, 673,  0,    2972, 2979, 7,    20,   0,    0,    2973, 2974, 7,    21,   0,    0,    2974, 2975,
      5,     776,  0,    0,    2975, 2976, 3,    256,  128,  0,    2976, 2977, 5,    777,  0,    0,    2977, 2979, 1,
      0,     0,    0,    2978, 2972, 1,    0,    0,    0,    2978, 2973, 1,    0,    0,    0,    2979, 2981, 1,    0,
      0,     0,    2980, 2970, 1,    0,    0,    0,    2980, 2971, 1,    0,    0,    0,    2981, 241,  1,    0,    0,
      0,     2982, 2984, 5,    242,  0,    0,    2983, 2985, 3,    244,  122,  0,    2984, 2983, 1,    0,    0,    0,
      2984,  2985, 1,    0,    0,    0,    2985, 2987, 1,    0,    0,    0,    2986, 2988, 5,    232,  0,    0,    2987,
      2986,  1,    0,    0,    0,    2987, 2988, 1,    0,    0,    0,    2988, 2990, 1,    0,    0,    0,    2989, 2991,
      5,     248,  0,    0,    2990, 2989, 1,    0,    0,    0,    2990, 2991, 1,    0,    0,    0,    2991, 2992, 1,
      0,     0,    0,    2992, 2994, 3,    1322, 661,  0,    2993, 2995, 3,    1256, 628,  0,    2994, 2993, 1,    0,
      0,     0,    2994, 2995, 1,    0,    0,    0,    2995, 3008, 1,    0,    0,    0,    2996, 2999, 3,    246,  123,
      0,     2997, 2998, 4,    121,  21,   0,    2998, 3000, 3,    258,  129,  0,    2999, 2997, 1,    0,    0,    0,
      2999,  3000, 1,    0,    0,    0,    3000, 3009, 1,    0,    0,    0,    3001, 3002, 5,    506,  0,    0,    3002,
      3005,  3,    1196, 598,  0,    3003, 3004, 4,    121,  22,   0,    3004, 3006, 3,    258,  129,  0,    3005, 3003,
      1,     0,    0,    0,    3005, 3006, 1,    0,    0,    0,    3006, 3009, 1,    0,    0,    0,    3007, 3009, 3,
      252,   126,  0,    3008, 2996, 1,    0,    0,    0,    3008, 3001, 1,    0,    0,    0,    3008, 3007, 1,    0,
      0,     0,    3009, 3011, 1,    0,    0,    0,    3010, 3012, 3,    260,  130,  0,    3011, 3010, 1,    0,    0,
      0,     3011, 3012, 1,    0,    0,    0,    3012, 243,  1,    0,    0,    0,    3013, 3014, 7,    22,   0,    0,
      3014,  245,  1,    0,    0,    0,    3015, 3017, 5,    776,  0,    0,    3016, 3018, 3,    248,  124,  0,    3017,
      3016,  1,    0,    0,    0,    3017, 3018, 1,    0,    0,    0,    3018, 3019, 1,    0,    0,    0,    3019, 3021,
      5,     777,  0,    0,    3020, 3015, 1,    0,    0,    0,    3020, 3021, 1,    0,    0,    0,    3021, 3022, 1,
      0,     0,    0,    3022, 3023, 3,    250,  125,  0,    3023, 247,  1,    0,    0,    0,    3024, 3029, 3,    1268,
      634,   0,    3025, 3026, 5,    773,  0,    0,    3026, 3028, 3,    1268, 634,  0,    3027, 3025, 1,    0,    0,
      0,     3028, 3031, 1,    0,    0,    0,    3029, 3027, 1,    0,    0,    0,    3029, 3030, 1,    0,    0,    0,
      3030,  249,  1,    0,    0,    0,    3031, 3029, 1,    0,    0,    0,    3032, 3033, 7,    23,   0,    0,    3033,
      3034,  3,    254,  127,  0,    3034, 251,  1,    0,    0,    0,    3035, 3046, 3,    280,  140,  0,    3036, 3046,
      3,     284,  142,  0,    3037, 3039, 5,    776,  0,    0,    3038, 3040, 3,    248,  124,  0,    3039, 3038, 1,
      0,     0,    0,    3039, 3040, 1,    0,    0,    0,    3040, 3041, 1,    0,    0,    0,    3041, 3043, 5,    777,
      0,     0,    3042, 3037, 1,    0,    0,    0,    3042, 3043, 1,    0,    0,    0,    3043, 3044, 1,    0,    0,
      0,     3044, 3046, 3,    98,   49,   0,    3045, 3035, 1,    0,    0,    0,    3045, 3036, 1,    0,    0,    0,
      3045,  3042, 1,    0,    0,    0,    3046, 253,  1,    0,    0,    0,    3047, 3049, 5,    776,  0,    0,    3048,
      3050,  3,    256,  128,  0,    3049, 3048, 1,    0,    0,    0,    3049, 3050, 1,    0,    0,    0,    3050, 3051,
      1,     0,    0,    0,    3051, 3060, 5,    777,  0,    0,    3052, 3053, 5,    773,  0,    0,    3053, 3055, 5,
      776,   0,    0,    3054, 3056, 3,    256,  128,  0,    3055, 3054, 1,    0,    0,    0,    3055, 3056, 1,    0,
      0,     0,    3056, 3057, 1,    0,    0,    0,    3057, 3059, 5,    777,  0,    0,    3058, 3052, 1,    0,    0,
      0,     3059, 3062, 1,    0,    0,    0,    3060, 3058, 1,    0,    0,    0,    3060, 3061, 1,    0,    0,    0,
      3061,  255,  1,    0,    0,    0,    3062, 3060, 1,    0,    0,    0,    3063, 3066, 3,    860,  430,  0,    3064,
      3066,  5,    128,  0,    0,    3065, 3063, 1,    0,    0,    0,    3065, 3064, 1,    0,    0,    0,    3066, 3074,
      1,     0,    0,    0,    3067, 3070, 5,    773,  0,    0,    3068, 3071, 3,    860,  430,  0,    3069, 3071, 5,
      128,   0,    0,    3070, 3068, 1,    0,    0,    0,    3070, 3069, 1,    0,    0,    0,    3071, 3073, 1,    0,
      0,     0,    3072, 3067, 1,    0,    0,    0,    3073, 3076, 1,    0,    0,    0,    3074, 3072, 1,    0,    0,
      0,     3074, 3075, 1,    0,    0,    0,    3075, 257,  1,    0,    0,    0,    3076, 3074, 1,    0,    0,    0,
      3077,  3078, 5,    17,   0,    0,    3078, 3080, 3,    1346, 673,  0,    3079, 3081, 3,    1264, 632,  0,    3080,
      3079,  1,    0,    0,    0,    3080, 3081, 1,    0,    0,    0,    3081, 259,  1,    0,    0,    0,    3082, 3083,
      5,     383,  0,    0,    3083, 3084, 5,    151,  0,    0,    3084, 3085, 5,    265,  0,    0,    3085, 3086, 5,
      614,   0,    0,    3086, 3087, 3,    1196, 598,  0,    3087, 261,  1,    0,    0,    0,    3088, 3089, 5,    281,
      0,     0,    3089, 3091, 3,    264,  132,  0,    3090, 3092, 7,    24,   0,    0,    3091, 3090, 1,    0,    0,
      0,     3091, 3092, 1,    0,    0,    0,    3092, 3094, 1,    0,    0,    0,    3093, 3095, 5,    284,  0,    0,
      3094,  3093, 1,    0,    0,    0,    3094, 3095, 1,    0,    0,    0,    3095, 3096, 1,    0,    0,    0,    3096,
      3097,  5,    237,  0,    0,    3097, 3099, 3,    1384, 692,  0,    3098, 3100, 7,    8,    0,    0,    3099, 3098,
      1,     0,    0,    0,    3099, 3100, 1,    0,    0,    0,    3100, 3101, 1,    0,    0,    0,    3101, 3102, 5,
      248,   0,    0,    3102, 3103, 5,    574,  0,    0,    3103, 3105, 3,    1322, 661,  0,    3104, 3106, 3,    1256,
      628,   0,    3105, 3104, 1,    0,    0,    0,    3105, 3106, 1,    0,    0,    0,    3106, 3108, 1,    0,    0,
      0,     3107, 3109, 3,    1200, 600,  0,    3108, 3107, 1,    0,    0,    0,    3108, 3109, 1,    0,    0,    0,
      3109,  3111, 1,    0,    0,    0,    3110, 3112, 3,    266,  133,  0,    3111, 3110, 1,    0,    0,    0,    3111,
      3112,  1,    0,    0,    0,    3112, 3114, 1,    0,    0,    0,    3113, 3115, 3,    1202, 601,  0,    3114, 3113,
      1,     0,    0,    0,    3114, 3115, 1,    0,    0,    0,    3115, 3117, 1,    0,    0,    0,    3116, 3118, 3,
      1206,  603,  0,    3117, 3116, 1,    0,    0,    0,    3117, 3118, 1,    0,    0,    0,    3118, 3119, 1,    0,
      0,     0,    3119, 3120, 3,    268,  134,  0,    3120, 263,  1,    0,    0,    0,    3121, 3122, 7,    25,   0,
      0,     3122, 265,  1,    0,    0,    0,    3123, 3124, 5,    484,  0,    0,    3124, 3125, 5,    230,  0,    0,
      3125,  3126, 5,    45,   0,    0,    3126, 3127, 3,    1380, 690,  0,    3127, 267,  1,    0,    0,    0,    3128,
      3129,  5,    232,  0,    0,    3129, 3130, 5,    747,  0,    0,    3130, 3132, 7,    26,   0,    0,    3131, 3128,
      1,     0,    0,    0,    3131, 3132, 1,    0,    0,    0,    3132, 3134, 1,    0,    0,    0,    3133, 3135, 3,
      270,   135,  0,    3134, 3133, 1,    0,    0,    0,    3134, 3135, 1,    0,    0,    0,    3135, 3138, 1,    0,
      0,     0,    3136, 3137, 5,    506,  0,    0,    3137, 3139, 3,    1196, 598,  0,    3138, 3136, 1,    0,    0,
      0,     3138, 3139, 1,    0,    0,    0,    3139, 269,  1,    0,    0,    0,    3140, 3142, 5,    776,  0,    0,
      3141,  3143, 3,    272,  136,  0,    3142, 3141, 1,    0,    0,    0,    3142, 3143, 1,    0,    0,    0,    3143,
      3144,  1,    0,    0,    0,    3144, 3145, 5,    777,  0,    0,    3145, 271,  1,    0,    0,    0,    3146, 3151,
      3,     1266, 633,  0,    3147, 3148, 5,    783,  0,    0,    3148, 3151, 3,    1406, 703,  0,    3149, 3151, 5,
      785,   0,    0,    3150, 3146, 1,    0,    0,    0,    3150, 3147, 1,    0,    0,    0,    3150, 3149, 1,    0,
      0,     0,    3151, 3162, 1,    0,    0,    0,    3152, 3158, 5,    773,  0,    0,    3153, 3159, 3,    1266, 633,
      0,     3154, 3155, 5,    783,  0,    0,    3155, 3159, 3,    1406, 703,  0,    3156, 3159, 5,    784,  0,    0,
      3157,  3159, 5,    785,  0,    0,    3158, 3153, 1,    0,    0,    0,    3158, 3154, 1,    0,    0,    0,    3158,
      3156,  1,    0,    0,    0,    3158, 3157, 1,    0,    0,    0,    3159, 3161, 1,    0,    0,    0,    3160, 3152,
      1,     0,    0,    0,    3161, 3164, 1,    0,    0,    0,    3162, 3160, 1,    0,    0,    0,    3162, 3163, 1,
      0,     0,    0,    3163, 273,  1,    0,    0,    0,    3164, 3162, 1,    0,    0,    0,    3165, 3167, 5,    458,
      0,     0,    3166, 3168, 7,    27,   0,    0,    3167, 3166, 1,    0,    0,    0,    3167, 3168, 1,    0,    0,
      0,     3168, 3170, 1,    0,    0,    0,    3169, 3171, 5,    248,  0,    0,    3170, 3169, 1,    0,    0,    0,
      3170,  3171, 1,    0,    0,    0,    3171, 3172, 1,    0,    0,    0,    3172, 3174, 3,    1322, 661,  0,    3173,
      3175,  3,    1256, 628,  0,    3174, 3173, 1,    0,    0,    0,    3174, 3175, 1,    0,    0,    0,    3175, 3180,
      1,     0,    0,    0,    3176, 3181, 3,    246,  123,  0,    3177, 3178, 5,    506,  0,    0,    3178, 3181, 3,
      1196,  598,  0,    3179, 3181, 3,    252,  126,  0,    3180, 3176, 1,    0,    0,    0,    3180, 3177, 1,    0,
      0,     0,    3180, 3179, 1,    0,    0,    0,    3181, 275,  1,    0,    0,    0,    3182, 3184, 3,    280,  140,
      0,     3183, 3185, 3,    354,  177,  0,    3184, 3183, 1,    0,    0,    0,    3184, 3185, 1,    0,    0,    0,
      3185,  3188, 1,    0,    0,    0,    3186, 3188, 3,    278,  139,  0,    3187, 3182, 1,    0,    0,    0,    3187,
      3186,  1,    0,    0,    0,    3188, 277,  1,    0,    0,    0,    3189, 3190, 5,    776,  0,    0,    3190, 3191,
      3,     278,  139,  0,    3191, 3192, 5,    777,  0,    0,    3192, 3207, 1,    0,    0,    0,    3193, 3194, 3,
      280,   140,  0,    3194, 3196, 3,    302,  151,  0,    3195, 3197, 3,    354,  177,  0,    3196, 3195, 1,    0,
      0,     0,    3196, 3197, 1,    0,    0,    0,    3197, 3207, 1,    0,    0,    0,    3198, 3199, 3,    280,  140,
      0,     3199, 3200, 3,    354,  177,  0,    3200, 3201, 3,    302,  151,  0,    3201, 3207, 1,    0,    0,    0,
      3202,  3203, 4,    139,  23,   0,    3203, 3204, 3,    284,  142,  0,    3204, 3205, 3,    302,  151,  0,    3205,
      3207,  1,    0,    0,    0,    3206, 3189, 1,    0,    0,    0,    3206, 3193, 1,    0,    0,    0,    3206, 3198,
      1,     0,    0,    0,    3206, 3202, 1,    0,    0,    0,    3207, 279,  1,    0,    0,    0,    3208, 3210, 3,
      330,   165,  0,    3209, 3208, 1,    0,    0,    0,    3209, 3210, 1,    0,    0,    0,    3210, 3211, 1,    0,
      0,     0,    3211, 3213, 3,    282,  141,  0,    3212, 3214, 3,    338,  169,  0,    3213, 3212, 1,    0,    0,
      0,     3213, 3214, 1,    0,    0,    0,    3214, 3216, 1,    0,    0,    0,    3215, 3217, 3,    294,  147,  0,
      3216,  3215, 1,    0,    0,    0,    3216, 3217, 1,    0,    0,    0,    3217, 281,  1,    0,    0,    0,    3218,
      3221,  3,    286,  143,  0,    3219, 3221, 3,    284,  142,  0,    3220, 3218, 1,    0,    0,    0,    3220, 3219,
      1,     0,    0,    0,    3221, 3233, 1,    0,    0,    0,    3222, 3226, 5,    608,  0,    0,    3223, 3224, 4,
      141,   24,   0,    3224, 3226, 7,    28,   0,    0,    3225, 3222, 1,    0,    0,    0,    3225, 3223, 1,    0,
      0,     0,    3226, 3228, 1,    0,    0,    0,    3227, 3229, 3,    408,  204,  0,    3228, 3227, 1,    0,    0,
      0,     3228, 3229, 1,    0,    0,    0,    3229, 3230, 1,    0,    0,    0,    3230, 3232, 3,    282,  141,  0,
      3231,  3225, 1,    0,    0,    0,    3232, 3235, 1,    0,    0,    0,    3233, 3231, 1,    0,    0,    0,    3233,
      3234,  1,    0,    0,    0,    3234, 283,  1,    0,    0,    0,    3235, 3233, 1,    0,    0,    0,    3236, 3239,
      5,     776,  0,    0,    3237, 3240, 3,    284,  142,  0,    3238, 3240, 3,    98,   49,   0,    3239, 3237, 1,
      0,     0,    0,    3239, 3238, 1,    0,    0,    0,    3240, 3241, 1,    0,    0,    0,    3241, 3242, 5,    777,
      0,     0,    3242, 285,  1,    0,    0,    0,    3243, 3249, 3,    288,  144,  0,    3244, 3245, 4,    143,  25,
      0,     3245, 3249, 3,    346,  173,  0,    3246, 3247, 4,    143,  26,   0,    3247, 3249, 3,    348,  174,  0,
      3248,  3243, 1,    0,    0,    0,    3248, 3244, 1,    0,    0,    0,    3248, 3246, 1,    0,    0,    0,    3249,
      287,   1,    0,    0,    0,    3250, 3254, 5,    497,  0,    0,    3251, 3253, 3,    352,  176,  0,    3252, 3251,
      1,     0,    0,    0,    3253, 3256, 1,    0,    0,    0,    3254, 3252, 1,    0,    0,    0,    3254, 3255, 1,
      0,     0,    0,    3255, 3257, 1,    0,    0,    0,    3256, 3254, 1,    0,    0,    0,    3257, 3259, 3,    362,
      181,   0,    3258, 3260, 3,    302,  151,  0,    3259, 3258, 1,    0,    0,    0,    3259, 3260, 1,    0,    0,
      0,     3260, 3262, 1,    0,    0,    0,    3261, 3263, 3,    342,  171,  0,    3262, 3261, 1,    0,    0,    0,
      3262,  3263, 1,    0,    0,    0,    3263, 3265, 1,    0,    0,    0,    3264, 3266, 3,    368,  184,  0,    3265,
      3264,  1,    0,    0,    0,    3265, 3266, 1,    0,    0,    0,    3266, 3268, 1,    0,    0,    0,    3267, 3269,
      3,     334,  167,  0,    3268, 3267, 1,    0,    0,    0,    3268, 3269, 1,    0,    0,    0,    3269, 3271, 1,
      0,     0,    0,    3270, 3272, 3,    306,  153,  0,    3271, 3270, 1,    0,    0,    0,    3271, 3272, 1,    0,
      0,     0,    3272, 3274, 1,    0,    0,    0,    3273, 3275, 3,    308,  154,  0,    3274, 3273, 1,    0,    0,
      0,     3274, 3275, 1,    0,    0,    0,    3275, 289,  1,    0,    0,    0,    3276, 3277, 3,    284,  142,  0,
      3277,  291,  1,    0,    0,    0,    3278, 3279, 7,    29,   0,    0,    3279, 293,  1,    0,    0,    0,    3280,
      3281,  5,    276,  0,    0,    3281, 3282, 3,    298,  149,  0,    3282, 295,  1,    0,    0,    0,    3283, 3284,
      5,     276,  0,    0,    3284, 3285, 3,    300,  150,  0,    3285, 297,  1,    0,    0,    0,    3286, 3289, 3,
      300,   150,  0,    3287, 3288, 7,    30,   0,    0,    3288, 3290, 3,    300,  150,  0,    3289, 3287, 1,    0,
      0,     0,    3289, 3290, 1,    0,    0,    0,    3290, 299,  1,    0,    0,    0,    3291, 3294, 3,    1346, 673,
      0,     3292, 3294, 7,    31,   0,    0,    3293, 3291, 1,    0,    0,    0,    3293, 3292, 1,    0,    0,    0,
      3294,  301,  1,    0,    0,    0,    3295, 3323, 5,    248,  0,    0,    3296, 3297, 5,    396,  0,    0,    3297,
      3299,  3,    1378, 689,  0,    3298, 3300, 3,    1200, 600,  0,    3299, 3298, 1,    0,    0,    0,    3299, 3300,
      1,     0,    0,    0,    3300, 3302, 1,    0,    0,    0,    3301, 3303, 3,    1202, 601,  0,    3302, 3301, 1,
      0,     0,    0,    3302, 3303, 1,    0,    0,    0,    3303, 3305, 1,    0,    0,    0,    3304, 3306, 3,    1206,
      603,   0,    3305, 3304, 1,    0,    0,    0,    3305, 3306, 1,    0,    0,    0,    3306, 3324, 1,    0,    0,
      0,     3307, 3308, 5,    150,  0,    0,    3308, 3324, 3,    1378, 689,  0,    3309, 3312, 3,    1406, 703,  0,
      3310,  3312, 3,    930,  465,  0,    3311, 3309, 1,    0,    0,    0,    3311, 3310, 1,    0,    0,    0,    3312,
      3320,  1,    0,    0,    0,    3313, 3316, 5,    773,  0,    0,    3314, 3317, 3,    1406, 703,  0,    3315, 3317,
      3,     930,  465,  0,    3316, 3314, 1,    0,    0,    0,    3316, 3315, 1,    0,    0,    0,    3317, 3319, 1,
      0,     0,    0,    3318, 3313, 1,    0,    0,    0,    3319, 3322, 1,    0,    0,    0,    3320, 3318, 1,    0,
      0,     0,    3320, 3321, 1,    0,    0,    0,    3321, 3324, 1,    0,    0,    0,    3322, 3320, 1,    0,    0,
      0,     3323, 3296, 1,    0,    0,    0,    3323, 3307, 1,    0,    0,    0,    3323, 3311, 1,    0,    0,    0,
      3324,  303,  1,    0,    0,    0,    3325, 3326, 5,    422,  0,    0,    3326, 3332, 5,    776,  0,    0,    3327,
      3330,  5,    747,  0,    0,    3328, 3329, 5,    773,  0,    0,    3329, 3331, 5,    747,  0,    0,    3330, 3328,
      1,     0,    0,    0,    3330, 3331, 1,    0,    0,    0,    3331, 3333, 1,    0,    0,    0,    3332, 3327, 1,
      0,     0,    0,    3332, 3333, 1,    0,    0,    0,    3333, 3334, 1,    0,    0,    0,    3334, 3335, 5,    777,
      0,     0,    3335, 305,  1,    0,    0,    0,    3336, 3337, 5,    221,  0,    0,    3337, 3338, 3,    860,  430,
      0,     3338, 307,  1,    0,    0,    0,    3339, 3340, 5,    699,  0,    0,    3340, 3345, 3,    310,  155,  0,
      3341,  3342, 5,    773,  0,    0,    3342, 3344, 3,    310,  155,  0,    3343, 3341, 1,    0,    0,    0,    3344,
      3347,  1,    0,    0,    0,    3345, 3343, 1,    0,    0,    0,    3345, 3346, 1,    0,    0,    0,    3346, 309,
      1,     0,    0,    0,    3347, 3345, 1,    0,    0,    0,    3348, 3349, 3,    1342, 671,  0,    3349, 3350, 5,
      17,    0,    0,    3350, 3351, 3,    312,  156,  0,    3351, 311,  1,    0,    0,    0,    3352, 3353, 5,    776,
      0,     0,    3353, 3354, 3,    314,  157,  0,    3354, 3355, 5,    777,  0,    0,    3355, 313,  1,    0,    0,
      0,     3356, 3358, 3,    1342, 671,  0,    3357, 3356, 1,    0,    0,    0,    3357, 3358, 1,    0,    0,    0,
      3358,  3362, 1,    0,    0,    0,    3359, 3360, 5,    405,  0,    0,    3360, 3361, 5,    45,   0,    0,    3361,
      3363,  3,    966,  483,  0,    3362, 3359, 1,    0,    0,    0,    3362, 3363, 1,    0,    0,    0,    3363, 3365,
      1,     0,    0,    0,    3364, 3366, 3,    338,  169,  0,    3365, 3364, 1,    0,    0,    0,    3365, 3366, 1,
      0,     0,    0,    3366, 3368, 1,    0,    0,    0,    3367, 3369, 3,    316,  158,  0,    3368, 3367, 1,    0,
      0,     0,    3368, 3369, 1,    0,    0,    0,    3369, 315,  1,    0,    0,    0,    3370, 3371, 3,    318,  159,
      0,     3371, 3373, 3,    320,  160,  0,    3372, 3374, 3,    328,  164,  0,    3373, 3372, 1,    0,    0,    0,
      3373,  3374, 1,    0,    0,    0,    3374, 317,  1,    0,    0,    0,    3375, 3376, 7,    32,   0,    0,    3376,
      319,   1,    0,    0,    0,    3377, 3380, 3,    322,  161,  0,    3378, 3380, 3,    324,  162,  0,    3379, 3377,
      1,     0,    0,    0,    3379, 3378, 1,    0,    0,    0,    3380, 321,  1,    0,    0,    0,    3381, 3382, 5,
      698,   0,    0,    3382, 3396, 5,    693,  0,    0,    3383, 3384, 3,    1362, 681,  0,    3384, 3385, 5,    693,
      0,     0,    3385, 3396, 1,    0,    0,    0,    3386, 3387, 5,    787,  0,    0,    3387, 3396, 5,    693,  0,
      0,     3388, 3389, 5,    247,  0,    0,    3389, 3390, 3,    860,  430,  0,    3390, 3391, 3,    956,  478,  0,
      3391,  3392, 5,    693,  0,    0,    3392, 3396, 1,    0,    0,    0,    3393, 3394, 5,    101,  0,    0,    3394,
      3396,  5,    487,  0,    0,    3395, 3381, 1,    0,    0,    0,    3395, 3383, 1,    0,    0,    0,    3395, 3386,
      1,     0,    0,    0,    3395, 3388, 1,    0,    0,    0,    3395, 3393, 1,    0,    0,    0,    3396, 323,  1,
      0,     0,    0,    3397, 3398, 5,    30,   0,    0,    3398, 3399, 3,    326,  163,  0,    3399, 3400, 5,    15,
      0,     0,    3400, 3401, 3,    326,  163,  0,    3401, 325,  1,    0,    0,    0,    3402, 3416, 3,    322,  161,
      0,     3403, 3404, 5,    698,  0,    0,    3404, 3416, 5,    682,  0,    0,    3405, 3406, 3,    1362, 681,  0,
      3406,  3407, 5,    682,  0,    0,    3407, 3416, 1,    0,    0,    0,    3408, 3409, 5,    787,  0,    0,    3409,
      3416,  5,    682,  0,    0,    3410, 3411, 5,    247,  0,    0,    3411, 3412, 3,    860,  430,  0,    3412, 3413,
      3,     956,  478,  0,    3413, 3414, 5,    682,  0,    0,    3414, 3416, 1,    0,    0,    0,    3415, 3402, 1,
      0,     0,    0,    3415, 3403, 1,    0,    0,    0,    3415, 3405, 1,    0,    0,    0,    3415, 3408, 1,    0,
      0,     0,    3415, 3410, 1,    0,    0,    0,    3416, 327,  1,    0,    0,    0,    3417, 3424, 5,    680,  0,
      0,     3418, 3419, 5,    101,  0,    0,    3419, 3425, 5,    487,  0,    0,    3420, 3425, 5,    217,  0,    0,
      3421,  3425, 5,    697,  0,    0,    3422, 3423, 5,    373,  0,    0,    3423, 3425, 5,    690,  0,    0,    3424,
      3418,  1,    0,    0,    0,    3424, 3420, 1,    0,    0,    0,    3424, 3421, 1,    0,    0,    0,    3424, 3422,
      1,     0,    0,    0,    3425, 329,  1,    0,    0,    0,    3426, 3428, 5,    645,  0,    0,    3427, 3429, 5,
      665,   0,    0,    3428, 3427, 1,    0,    0,    0,    3428, 3429, 1,    0,    0,    0,    3429, 3430, 1,    0,
      0,     0,    3430, 3435, 3,    332,  166,  0,    3431, 3432, 5,    773,  0,    0,    3432, 3434, 3,    332,  166,
      0,     3433, 3431, 1,    0,    0,    0,    3434, 3437, 1,    0,    0,    0,    3435, 3433, 1,    0,    0,    0,
      3435,  3436, 1,    0,    0,    0,    3436, 331,  1,    0,    0,    0,    3437, 3435, 1,    0,    0,    0,    3438,
      3440,  3,    1346, 673,  0,    3439, 3441, 3,    1264, 632,  0,    3440, 3439, 1,    0,    0,    0,    3440, 3441,
      1,     0,    0,    0,    3441, 3442, 1,    0,    0,    0,    3442, 3443, 5,    17,   0,    0,    3443, 3444, 3,
      290,   145,  0,    3444, 333,  1,    0,    0,    0,    3445, 3446, 5,    217,  0,    0,    3446, 3447, 5,    45,
      0,     0,    3447, 3449, 3,    966,  483,  0,    3448, 3450, 3,    336,  168,  0,    3449, 3448, 1,    0,    0,
      0,     3449, 3450, 1,    0,    0,    0,    3450, 335,  1,    0,    0,    0,    3451, 3452, 5,    645,  0,    0,
      3452,  3453, 5,    481,  0,    0,    3453, 337,  1,    0,    0,    0,    3454, 3455, 5,    393,  0,    0,    3455,
      3456,  5,    45,   0,    0,    3456, 3457, 3,    966,  483,  0,    3457, 339,  1,    0,    0,    0,    3458, 3459,
      7,     33,   0,    0,    3459, 341,  1,    0,    0,    0,    3460, 3463, 5,    203,  0,    0,    3461, 3464, 5,
      149,   0,    0,    3462, 3464, 3,    344,  172,  0,    3463, 3461, 1,    0,    0,    0,    3463, 3462, 1,    0,
      0,     0,    3464, 343,  1,    0,    0,    0,    3465, 3470, 3,    370,  185,  0,    3466, 3467, 5,    773,  0,
      0,     3467, 3469, 3,    370,  185,  0,    3468, 3466, 1,    0,    0,    0,    3469, 3472, 1,    0,    0,    0,
      3470,  3468, 1,    0,    0,    0,    3470, 3471, 1,    0,    0,    0,    3471, 345,  1,    0,    0,    0,    3472,
      3470,  1,    0,    0,    0,    3473, 3474, 5,    626,  0,    0,    3474, 3479, 3,    350,  175,  0,    3475, 3476,
      5,     773,  0,    0,    3476, 3478, 3,    350,  175,  0,    3477, 3475, 1,    0,    0,    0,    3478, 3481, 1,
      0,     0,    0,    3479, 3477, 1,    0,    0,    0,    3479, 3480, 1,    0,    0,    0,    3480, 347,  1,    0,
      0,     0,    3481, 3479, 1,    0,    0,    0,    3482, 3483, 5,    574,  0,    0,    3483, 3484, 3,    1322, 661,
      0,     3484, 349,  1,    0,    0,    0,    3485, 3486, 5,    487,  0,    0,    3486, 3488, 5,    776,  0,    0,
      3487,  3489, 3,    256,  128,  0,    3488, 3487, 1,    0,    0,    0,    3488, 3489, 1,    0,    0,    0,    3489,
      3490,  1,    0,    0,    0,    3490, 3491, 5,    777,  0,    0,    3491, 351,  1,    0,    0,    0,    3492, 3495,
      3,     292,  146,  0,    3493, 3495, 5,    535,  0,    0,    3494, 3492, 1,    0,    0,    0,    3494, 3493, 1,
      0,     0,    0,    3495, 353,  1,    0,    0,    0,    3496, 3498, 3,    356,  178,  0,    3497, 3496, 1,    0,
      0,     0,    3498, 3499, 1,    0,    0,    0,    3499, 3497, 1,    0,    0,    0,    3499, 3500, 1,    0,    0,
      0,     3500, 355,  1,    0,    0,    0,    3501, 3502, 5,    200,  0,    0,    3502, 3505, 3,    358,  179,  0,
      3503,  3504, 5,    668,  0,    0,    3504, 3506, 3,    1326, 663,  0,    3505, 3503, 1,    0,    0,    0,    3505,
      3506,  1,    0,    0,    0,    3506, 3508, 1,    0,    0,    0,    3507, 3509, 3,    360,  180,  0,    3508, 3507,
      1,     0,    0,    0,    3508, 3509, 1,    0,    0,    0,    3509, 3515, 1,    0,    0,    0,    3510, 3511, 5,
      287,   0,    0,    3511, 3512, 5,    251,  0,    0,    3512, 3513, 5,    508,  0,    0,    3513, 3515, 5,    346,
      0,     0,    3514, 3501, 1,    0,    0,    0,    3514, 3510, 1,    0,    0,    0,    3515, 357,  1,    0,    0,
      0,     3516, 3517, 7,    34,   0,    0,    3517, 359,  1,    0,    0,    0,    3518, 3519, 5,    669,  0,    0,
      3519,  3522, 5,    670,  0,    0,    3520, 3522, 5,    671,  0,    0,    3521, 3518, 1,    0,    0,    0,    3521,
      3520,  1,    0,    0,    0,    3522, 361,  1,    0,    0,    0,    3523, 3526, 3,    364,  182,  0,    3524, 3526,
      5,     760,  0,    0,    3525, 3523, 1,    0,    0,    0,    3525, 3524, 1,    0,    0,    0,    3526, 3531, 1,
      0,     0,    0,    3527, 3528, 5,    773,  0,    0,    3528, 3530, 3,    364,  182,  0,    3529, 3527, 1,    0,
      0,     0,    3530, 3533, 1,    0,    0,    0,    3531, 3529, 1,    0,    0,    0,    3531, 3532, 1,    0,    0,
      0,     3532, 363,  1,    0,    0,    0,    3533, 3531, 1,    0,    0,    0,    3534, 3540, 3,    1274, 637,  0,
      3535,  3537, 3,    860,  430,  0,    3536, 3538, 3,    366,  183,  0,    3537, 3536, 1,    0,    0,    0,    3537,
      3538,  1,    0,    0,    0,    3538, 3540, 1,    0,    0,    0,    3539, 3534, 1,    0,    0,    0,    3539, 3535,
      1,     0,    0,    0,    3540, 365,  1,    0,    0,    0,    3541, 3543, 5,    17,   0,    0,    3542, 3541, 1,
      0,     0,    0,    3542, 3543, 1,    0,    0,    0,    3543, 3546, 1,    0,    0,    0,    3544, 3547, 3,    1346,
      673,   0,    3545, 3547, 3,    1378, 689,  0,    3546, 3544, 1,    0,    0,    0,    3546, 3545, 1,    0,    0,
      0,     3547, 367,  1,    0,    0,    0,    3548, 3549, 5,    643,  0,    0,    3549, 3550, 3,    860,  430,  0,
      3550,  369,  1,    0,    0,    0,    3551, 3562, 3,    382,  191,  0,    3552, 3556, 5,    778,  0,    0,    3553,
      3554,  4,    185,  27,   0,    3554, 3557, 3,    1346, 673,  0,    3555, 3557, 5,    732,  0,    0,    3556, 3553,
      1,     0,    0,    0,    3556, 3555, 1,    0,    0,    0,    3557, 3558, 1,    0,    0,    0,    3558, 3559, 3,
      372,   186,  0,    3559, 3560, 5,    779,  0,    0,    3560, 3562, 1,    0,    0,    0,    3561, 3551, 1,    0,
      0,     0,    3561, 3552, 1,    0,    0,    0,    3562, 3566, 1,    0,    0,    0,    3563, 3565, 3,    374,  187,
      0,     3564, 3563, 1,    0,    0,    0,    3565, 3568, 1,    0,    0,    0,    3566, 3564, 1,    0,    0,    0,
      3566,  3567, 1,    0,    0,    0,    3567, 371,  1,    0,    0,    0,    3568, 3566, 1,    0,    0,    0,    3569,
      3573,  3,    382,  191,  0,    3570, 3572, 3,    374,  187,  0,    3571, 3570, 1,    0,    0,    0,    3572, 3575,
      1,     0,    0,    0,    3573, 3571, 1,    0,    0,    0,    3573, 3574, 1,    0,    0,    0,    3574, 373,  1,
      0,     0,    0,    3575, 3573, 1,    0,    0,    0,    3576, 3577, 3,    378,  189,  0,    3577, 3582, 3,    370,
      185,   0,    3578, 3579, 5,    383,  0,    0,    3579, 3583, 3,    860,  430,  0,    3580, 3581, 5,    621,  0,
      0,     3581, 3583, 3,    1350, 675,  0,    3582, 3578, 1,    0,    0,    0,    3582, 3580, 1,    0,    0,    0,
      3582,  3583, 1,    0,    0,    0,    3583, 3596, 1,    0,    0,    0,    3584, 3585, 3,    380,  190,  0,    3585,
      3590,  3,    370,  185,  0,    3586, 3587, 5,    383,  0,    0,    3587, 3591, 3,    860,  430,  0,    3588, 3589,
      5,     621,  0,    0,    3589, 3591, 3,    1350, 675,  0,    3590, 3586, 1,    0,    0,    0,    3590, 3588, 1,
      0,     0,    0,    3591, 3596, 1,    0,    0,    0,    3592, 3593, 3,    376,  188,  0,    3593, 3594, 3,    382,
      191,   0,    3594, 3596, 1,    0,    0,    0,    3595, 3576, 1,    0,    0,    0,    3595, 3584, 1,    0,    0,
      0,     3595, 3592, 1,    0,    0,    0,    3596, 375,  1,    0,    0,    0,    3597, 3599, 5,    359,  0,    0,
      3598,  3600, 5,    239,  0,    0,    3599, 3598, 1,    0,    0,    0,    3599, 3600, 1,    0,    0,    0,    3600,
      3601,  1,    0,    0,    0,    3601, 3609, 5,    261,  0,    0,    3602, 3603, 5,    359,  0,    0,    3603, 3605,
      7,     35,   0,    0,    3604, 3606, 5,    395,  0,    0,    3605, 3604, 1,    0,    0,    0,    3605, 3606, 1,
      0,     0,    0,    3606, 3607, 1,    0,    0,    0,    3607, 3609, 5,    261,  0,    0,    3608, 3597, 1,    0,
      0,     0,    3608, 3602, 1,    0,    0,    0,    3609, 377,  1,    0,    0,    0,    3610, 3612, 7,    36,   0,
      0,     3611, 3610, 1,    0,    0,    0,    3611, 3612, 1,    0,    0,    0,    3612, 3613, 1,    0,    0,    0,
      3613,  3616, 5,    261,  0,    0,    3614, 3616, 5,    555,  0,    0,    3615, 3611, 1,    0,    0,    0,    3615,
      3614,  1,    0,    0,    0,    3616, 379,  1,    0,    0,    0,    3617, 3619, 7,    35,   0,    0,    3618, 3620,
      5,     395,  0,    0,    3619, 3618, 1,    0,    0,    0,    3619, 3620, 1,    0,    0,    0,    3620, 3621, 1,
      0,     0,    0,    3621, 3622, 5,    261,  0,    0,    3622, 381,  1,    0,    0,    0,    3623, 3630, 3,    384,
      192,   0,    3624, 3630, 3,    386,  193,  0,    3625, 3630, 3,    388,  194,  0,    3626, 3630, 3,    390,  195,
      0,     3627, 3628, 4,    191,  28,   0,    3628, 3630, 3,    392,  196,  0,    3629, 3623, 1,    0,    0,    0,
      3629,  3624, 1,    0,    0,    0,    3629, 3625, 1,    0,    0,    0,    3629, 3626, 1,    0,    0,    0,    3629,
      3627,  1,    0,    0,    0,    3630, 383,  1,    0,    0,    0,    3631, 3633, 3,    1322, 661,  0,    3632, 3634,
      3,     1256, 628,  0,    3633, 3632, 1,    0,    0,    0,    3633, 3634, 1,    0,    0,    0,    3634, 3636, 1,
      0,     0,    0,    3635, 3637, 3,    410,  205,  0,    3636, 3635, 1,    0,    0,    0,    3636, 3637, 1,    0,
      0,     0,    3637, 3639, 1,    0,    0,    0,    3638, 3640, 3,    412,  206,  0,    3639, 3638, 1,    0,    0,
      0,     3639, 3640, 1,    0,    0,    0,    3640, 385,  1,    0,    0,    0,    3641, 3644, 5,    776,  0,    0,
      3642,  3645, 3,    384,  192,  0,    3643, 3645, 3,    386,  193,  0,    3644, 3642, 1,    0,    0,    0,    3644,
      3643,  1,    0,    0,    0,    3645, 3646, 1,    0,    0,    0,    3646, 3647, 5,    777,  0,    0,    3647, 387,
      1,     0,    0,    0,    3648, 3650, 3,    290,  145,  0,    3649, 3651, 3,    410,  205,  0,    3650, 3649, 1,
      0,     0,    0,    3650, 3651, 1,    0,    0,    0,    3651, 3653, 1,    0,    0,    0,    3652, 3654, 3,    1264,
      632,   0,    3653, 3652, 1,    0,    0,    0,    3653, 3654, 1,    0,    0,    0,    3654, 3665, 1,    0,    0,
      0,     3655, 3656, 4,    194,  29,   0,    3656, 3657, 5,    726,  0,    0,    3657, 3659, 3,    290,  145,  0,
      3658,  3660, 3,    410,  205,  0,    3659, 3658, 1,    0,    0,    0,    3659, 3660, 1,    0,    0,    0,    3660,
      3662,  1,    0,    0,    0,    3661, 3663, 3,    1264, 632,  0,    3662, 3661, 1,    0,    0,    0,    3662, 3663,
      1,     0,    0,    0,    3663, 3665, 1,    0,    0,    0,    3664, 3648, 1,    0,    0,    0,    3664, 3655, 1,
      0,     0,    0,    3665, 389,  1,    0,    0,    0,    3666, 3669, 5,    776,  0,    0,    3667, 3670, 3,    344,
      172,   0,    3668, 3670, 3,    390,  195,  0,    3669, 3667, 1,    0,    0,    0,    3669, 3668, 1,    0,    0,
      0,     3670, 3671, 1,    0,    0,    0,    3671, 3672, 5,    777,  0,    0,    3672, 391,  1,    0,    0,    0,
      3673,  3674, 5,    701,  0,    0,    3674, 3675, 5,    776,  0,    0,    3675, 3676, 3,    860,  430,  0,    3676,
      3677,  5,    773,  0,    0,    3677, 3678, 3,    1378, 689,  0,    3678, 3679, 3,    394,  197,  0,    3679, 3681,
      5,     777,  0,    0,    3680, 3682, 3,    410,  205,  0,    3681, 3680, 1,    0,    0,    0,    3681, 3682, 1,
      0,     0,    0,    3682, 393,  1,    0,    0,    0,    3683, 3684, 5,    71,   0,    0,    3684, 3685, 5,    776,
      0,     0,    3685, 3690, 3,    396,  198,  0,    3686, 3687, 5,    773,  0,    0,    3687, 3689, 3,    396,  198,
      0,     3688, 3686, 1,    0,    0,    0,    3689, 3692, 1,    0,    0,    0,    3690, 3688, 1,    0,    0,    0,
      3690,  3691, 1,    0,    0,    0,    3691, 3693, 1,    0,    0,    0,    3692, 3690, 1,    0,    0,    0,    3693,
      3694,  5,    777,  0,    0,    3694, 395,  1,    0,    0,    0,    3695, 3696, 3,    1346, 673,  0,    3696, 3697,
      5,     200,  0,    0,    3697, 3698, 5,    703,  0,    0,    3698, 3719, 1,    0,    0,    0,    3699, 3700, 3,
      1346,  673,  0,    3700, 3703, 3,    1110, 555,  0,    3701, 3702, 4,    198,  30,   0,    3702, 3704, 3,    1188,
      594,   0,    3703, 3701, 1,    0,    0,    0,    3703, 3704, 1,    0,    0,    0,    3704, 3706, 1,    0,    0,
      0,     3705, 3707, 5,    174,  0,    0,    3706, 3705, 1,    0,    0,    0,    3706, 3707, 1,    0,    0,    0,
      3707,  3708, 1,    0,    0,    0,    3708, 3709, 5,    704,  0,    0,    3709, 3711, 3,    1378, 689,  0,    3710,
      3712,  3,    400,  200,  0,    3711, 3710, 1,    0,    0,    0,    3711, 3712, 1,    0,    0,    0,    3712, 3719,
      1,     0,    0,    0,    3713, 3714, 5,    702,  0,    0,    3714, 3715, 5,    704,  0,    0,    3715, 3716, 3,
      1378,  689,  0,    3716, 3717, 3,    394,  197,  0,    3717, 3719, 1,    0,    0,    0,    3718, 3695, 1,    0,
      0,     0,    3718, 3699, 1,    0,    0,    0,    3718, 3713, 1,    0,    0,    0,    3719, 397,  1,    0,    0,
      0,     3720, 3722, 3,    402,  201,  0,    3721, 3723, 3,    404,  202,  0,    3722, 3721, 1,    0,    0,    0,
      3722,  3723, 1,    0,    0,    0,    3723, 3726, 1,    0,    0,    0,    3724, 3726, 3,    404,  202,  0,    3725,
      3720,  1,    0,    0,    0,    3725, 3724, 1,    0,    0,    0,    3726, 399,  1,    0,    0,    0,    3727, 3732,
      3,     398,  199,  0,    3728, 3729, 3,    404,  202,  0,    3729, 3730, 3,    402,  201,  0,    3730, 3732, 1,
      0,     0,    0,    3731, 3727, 1,    0,    0,    0,    3731, 3728, 1,    0,    0,    0,    3732, 401,  1,    0,
      0,     0,    3733, 3734, 3,    406,  203,  0,    3734, 3735, 5,    383,  0,    0,    3735, 3736, 5,    700,  0,
      0,     3736, 403,  1,    0,    0,    0,    3737, 3738, 3,    406,  203,  0,    3738, 3739, 5,    383,  0,    0,
      3739,  3740, 5,    165,  0,    0,    3740, 405,  1,    0,    0,    0,    3741, 3746, 5,    165,  0,    0,    3742,
      3746,  5,    376,  0,    0,    3743, 3744, 5,    128,  0,    0,    3744, 3746, 3,    1378, 689,  0,    3745, 3741,
      1,     0,    0,    0,    3745, 3742, 1,    0,    0,    0,    3745, 3743, 1,    0,    0,    0,    3746, 407,  1,
      0,     0,    0,    3747, 3748, 7,    37,   0,    0,    3748, 409,  1,    0,    0,    0,    3749, 3753, 5,    17,
      0,     0,    3750, 3751, 4,    205,  31,   0,    3751, 3753, 5,    750,  0,    0,    3752, 3749, 1,    0,    0,
      0,     3752, 3750, 1,    0,    0,    0,    3752, 3753, 1,    0,    0,    0,    3753, 3754, 1,    0,    0,    0,
      3754,  3755, 3,    1346, 673,  0,    3755, 411,  1,    0,    0,    0,    3756, 3761, 3,    414,  207,  0,    3757,
      3758,  5,    773,  0,    0,    3758, 3760, 3,    414,  207,  0,    3759, 3757, 1,    0,    0,    0,    3760, 3763,
      1,     0,    0,    0,    3761, 3759, 1,    0,    0,    0,    3761, 3762, 1,    0,    0,    0,    3762, 413,  1,
      0,     0,    0,    3763, 3761, 1,    0,    0,    0,    3764, 3765, 3,    416,  208,  0,    3765, 3767, 3,    418,
      209,   0,    3766, 3768, 3,    422,  211,  0,    3767, 3766, 1,    0,    0,    0,    3767, 3768, 1,    0,    0,
      0,     3768, 3769, 1,    0,    0,    0,    3769, 3770, 5,    776,  0,    0,    3770, 3771, 3,    424,  212,  0,
      3771,  3772, 5,    777,  0,    0,    3772, 3785, 1,    0,    0,    0,    3773, 3774, 5,    620,  0,    0,    3774,
      3776,  3,    418,  209,  0,    3775, 3777, 3,    422,  211,  0,    3776, 3775, 1,    0,    0,    0,    3776, 3777,
      1,     0,    0,    0,    3777, 3778, 1,    0,    0,    0,    3778, 3780, 5,    776,  0,    0,    3779, 3781, 3,
      424,   212,  0,    3780, 3779, 1,    0,    0,    0,    3780, 3781, 1,    0,    0,    0,    3781, 3782, 1,    0,
      0,     0,    3782, 3783, 5,    777,  0,    0,    3783, 3785, 1,    0,    0,    0,    3784, 3764, 1,    0,    0,
      0,     3784, 3773, 1,    0,    0,    0,    3785, 415,  1,    0,    0,    0,    3786, 3787, 7,    38,   0,    0,
      3787,  417,  1,    0,    0,    0,    3788, 3789, 7,    39,   0,    0,    3789, 419,  1,    0,    0,    0,    3790,
      3791,  5,    420,  0,    0,    3791, 3797, 5,    265,  0,    0,    3792, 3794, 5,    609,  0,    0,    3793, 3795,
      3,     418,  209,  0,    3794, 3793, 1,    0,    0,    0,    3794, 3795, 1,    0,    0,    0,    3795, 3797, 1,
      0,     0,    0,    3796, 3790, 1,    0,    0,    0,    3796, 3792, 1,    0,    0,    0,    3797, 421,  1,    0,
      0,     0,    3798, 3804, 5,    200,  0,    0,    3799, 3805, 5,    261,  0,    0,    3800, 3801, 5,    393,  0,
      0,     3801, 3805, 5,    45,   0,    0,    3802, 3803, 5,    217,  0,    0,    3803, 3805, 5,    45,   0,    0,
      3804,  3799, 1,    0,    0,    0,    3804, 3800, 1,    0,    0,    0,    3804, 3802, 1,    0,    0,    0,    3805,
      423,   1,    0,    0,    0,    3806, 3811, 3,    426,  213,  0,    3807, 3808, 5,    773,  0,    0,    3808, 3810,
      3,     426,  213,  0,    3809, 3807, 1,    0,    0,    0,    3810, 3813, 1,    0,    0,    0,    3811, 3809, 1,
      0,     0,    0,    3811, 3812, 1,    0,    0,    0,    3812, 425,  1,    0,    0,    0,    3813, 3811, 1,    0,
      0,     0,    3814, 3817, 3,    1346, 673,  0,    3815, 3817, 5,    420,  0,    0,    3816, 3814, 1,    0,    0,
      0,     3816, 3815, 1,    0,    0,    0,    3817, 427,  1,    0,    0,    0,    3818, 3820, 3,    330,  165,  0,
      3819,  3818, 1,    0,    0,    0,    3819, 3820, 1,    0,    0,    0,    3820, 3821, 1,    0,    0,    0,    3821,
      3823,  5,    614,  0,    0,    3822, 3824, 5,    295,  0,    0,    3823, 3822, 1,    0,    0,    0,    3823, 3824,
      1,     0,    0,    0,    3824, 3826, 1,    0,    0,    0,    3825, 3827, 5,    232,  0,    0,    3826, 3825, 1,
      0,     0,    0,    3826, 3827, 1,    0,    0,    0,    3827, 3828, 1,    0,    0,    0,    3828, 3829, 3,    344,
      172,   0,    3829, 3830, 5,    506,  0,    0,    3830, 3832, 3,    1196, 598,  0,    3831, 3833, 3,    368,  184,
      0,     3832, 3831, 1,    0,    0,    0,    3832, 3833, 1,    0,    0,    0,    3833, 3835, 1,    0,    0,    0,
      3834,  3836, 3,    338,  169,  0,    3835, 3834, 1,    0,    0,    0,    3835, 3836, 1,    0,    0,    0,    3836,
      3838,  1,    0,    0,    0,    3837, 3839, 3,    296,  148,  0,    3838, 3837, 1,    0,    0,    0,    3838, 3839,
      1,     0,    0,    0,    3839, 429,  1,    0,    0,    0,    3840, 3845, 3,    432,  216,  0,    3841, 3845, 3,
      438,   219,  0,    3842, 3845, 3,    440,  220,  0,    3843, 3845, 3,    446,  223,  0,    3844, 3840, 1,    0,
      0,     0,    3844, 3841, 1,    0,    0,    0,    3844, 3842, 1,    0,    0,    0,    3844, 3843, 1,    0,    0,
      0,     3845, 431,  1,    0,    0,    0,    3846, 3847, 5,    543,  0,    0,    3847, 3851, 5,    592,  0,    0,
      3848,  3850, 3,    436,  218,  0,    3849, 3848, 1,    0,    0,    0,    3850, 3853, 1,    0,    0,    0,    3851,
      3849,  1,    0,    0,    0,    3851, 3852, 1,    0,    0,    0,    3852, 3872, 1,    0,    0,    0,    3853, 3851,
      1,     0,    0,    0,    3854, 3856, 5,    77,   0,    0,    3855, 3857, 5,    647,  0,    0,    3856, 3855, 1,
      0,     0,    0,    3856, 3857, 1,    0,    0,    0,    3857, 3863, 1,    0,    0,    0,    3858, 3860, 5,    15,
      0,     0,    3859, 3861, 5,    373,  0,    0,    3860, 3859, 1,    0,    0,    0,    3860, 3861, 1,    0,    0,
      0,     3861, 3862, 1,    0,    0,    0,    3862, 3864, 5,    54,   0,    0,    3863, 3858, 1,    0,    0,    0,
      3863,  3864, 1,    0,    0,    0,    3864, 3869, 1,    0,    0,    0,    3865, 3867, 5,    373,  0,    0,    3866,
      3865,  1,    0,    0,    0,    3866, 3867, 1,    0,    0,    0,    3867, 3868, 1,    0,    0,    0,    3868, 3870,
      5,     450,  0,    0,    3869, 3866, 1,    0,    0,    0,    3869, 3870, 1,    0,    0,    0,    3870, 3872, 1,
      0,     0,    0,    3871, 3846, 1,    0,    0,    0,    3871, 3854, 1,    0,    0,    0,    3872, 433,  1,    0,
      0,     0,    3873, 3875, 5,    29,   0,    0,    3874, 3876, 5,    647,  0,    0,    3875, 3874, 1,    0,    0,
      0,     3875, 3876, 1,    0,    0,    0,    3876, 435,  1,    0,    0,    0,    3877, 3878, 5,    645,  0,    0,
      3878,  3879, 5,    85,   0,    0,    3879, 3883, 5,    517,  0,    0,    3880, 3881, 5,    435,  0,    0,    3881,
      3883,  7,    40,   0,    0,    3882, 3877, 1,    0,    0,    0,    3882, 3880, 1,    0,    0,    0,    3883, 437,
      1,     0,    0,    0,    3884, 3885, 5,    489,  0,    0,    3885, 3914, 3,    1346, 673,  0,    3886, 3888, 5,
      480,   0,    0,    3887, 3889, 5,    647,  0,    0,    3888, 3887, 1,    0,    0,    0,    3888, 3889, 1,    0,
      0,     0,    3889, 3908, 1,    0,    0,    0,    3890, 3892, 5,    590,  0,    0,    3891, 3893, 5,    489,  0,
      0,     3892, 3891, 1,    0,    0,    0,    3892, 3893, 1,    0,    0,    0,    3893, 3894, 1,    0,    0,    0,
      3894,  3909, 3,    1346, 673,  0,    3895, 3897, 5,    15,   0,    0,    3896, 3898, 5,    373,  0,    0,    3897,
      3896,  1,    0,    0,    0,    3897, 3898, 1,    0,    0,    0,    3898, 3899, 1,    0,    0,    0,    3899, 3901,
      5,     54,   0,    0,    3900, 3895, 1,    0,    0,    0,    3900, 3901, 1,    0,    0,    0,    3901, 3906, 1,
      0,     0,    0,    3902, 3904, 5,    373,  0,    0,    3903, 3902, 1,    0,    0,    0,    3903, 3904, 1,    0,
      0,     0,    3904, 3905, 1,    0,    0,    0,    3905, 3907, 5,    450,  0,    0,    3906, 3903, 1,    0,    0,
      0,     3906, 3907, 1,    0,    0,    0,    3907, 3909, 1,    0,    0,    0,    3908, 3890, 1,    0,    0,    0,
      3908,  3900, 1,    0,    0,    0,    3909, 3914, 1,    0,    0,    0,    3910, 3911, 5,    450,  0,    0,    3911,
      3912,  5,    489,  0,    0,    3912, 3914, 3,    1346, 673,  0,    3913, 3884, 1,    0,    0,    0,    3913, 3886,
      1,     0,    0,    0,    3913, 3910, 1,    0,    0,    0,    3914, 439,  1,    0,    0,    0,    3915, 3916, 5,
      287,   0,    0,    3916, 3917, 7,    17,   0,    0,    3917, 3922, 3,    442,  221,  0,    3918, 3919, 5,    773,
      0,     0,    3919, 3921, 3,    442,  221,  0,    3920, 3918, 1,    0,    0,    0,    3921, 3924, 1,    0,    0,
      0,     3922, 3920, 1,    0,    0,    0,    3922, 3923, 1,    0,    0,    0,    3923, 3932, 1,    0,    0,    0,
      3924,  3922, 1,    0,    0,    0,    3925, 3926, 5,    287,  0,    0,    3926, 3927, 5,    244,  0,    0,    3927,
      3928,  5,    200,  0,    0,    3928, 3932, 5,    27,   0,    0,    3929, 3930, 5,    611,  0,    0,    3930, 3932,
      7,     41,   0,    0,    3931, 3915, 1,    0,    0,    0,    3931, 3925, 1,    0,    0,    0,    3931, 3929, 1,
      0,     0,    0,    3932, 441,  1,    0,    0,    0,    3933, 3935, 3,    1322, 661,  0,    3934, 3936, 3,    410,
      205,   0,    3935, 3934, 1,    0,    0,    0,    3935, 3936, 1,    0,    0,    0,    3936, 3937, 1,    0,    0,
      0,     3937, 3938, 3,    444,  222,  0,    3938, 443,  1,    0,    0,    0,    3939, 3941, 5,    435,  0,    0,
      3940,  3942, 5,    284,  0,    0,    3941, 3940, 1,    0,    0,    0,    3941, 3942, 1,    0,    0,    0,    3942,
      3948,  1,    0,    0,    0,    3943, 3945, 5,    295,  0,    0,    3944, 3943, 1,    0,    0,    0,    3944, 3945,
      1,     0,    0,    0,    3945, 3946, 1,    0,    0,    0,    3946, 3948, 5,    649,  0,    0,    3947, 3939, 1,
      0,     0,    0,    3947, 3944, 1,    0,    0,    0,    3948, 445,  1,    0,    0,    0,    3949, 3978, 5,    651,
      0,     0,    3950, 3951, 7,    42,   0,    0,    3951, 3953, 3,    450,  225,  0,    3952, 3954, 7,    43,   0,
      0,     3953, 3952, 1,    0,    0,    0,    3953, 3954, 1,    0,    0,    0,    3954, 3979, 1,    0,    0,    0,
      3955,  3956, 5,    159,  0,    0,    3956, 3962, 3,    450,  225,  0,    3957, 3960, 5,    566,  0,    0,    3958,
      3959,  5,    200,  0,    0,    3959, 3961, 5,    340,  0,    0,    3960, 3958, 1,    0,    0,    0,    3960, 3961,
      1,     0,    0,    0,    3961, 3963, 1,    0,    0,    0,    3962, 3957, 1,    0,    0,    0,    3962, 3963, 1,
      0,     0,    0,    3963, 3979, 1,    0,    0,    0,    3964, 3965, 5,    417,  0,    0,    3965, 3979, 3,    450,
      225,   0,    3966, 3967, 5,    77,   0,    0,    3967, 3970, 3,    450,  225,  0,    3968, 3969, 5,    384,  0,
      0,     3969, 3971, 5,    407,  0,    0,    3970, 3968, 1,    0,    0,    0,    3970, 3971, 1,    0,    0,    0,
      3971,  3979, 1,    0,    0,    0,    3972, 3973, 5,    480,  0,    0,    3973, 3979, 3,    450,  225,  0,    3974,
      3976,  5,    439,  0,    0,    3975, 3977, 3,    448,  224,  0,    3976, 3975, 1,    0,    0,    0,    3976, 3977,
      1,     0,    0,    0,    3977, 3979, 1,    0,    0,    0,    3978, 3950, 1,    0,    0,    0,    3978, 3955, 1,
      0,     0,    0,    3978, 3964, 1,    0,    0,    0,    3978, 3966, 1,    0,    0,    0,    3978, 3972, 1,    0,
      0,     0,    3978, 3974, 1,    0,    0,    0,    3979, 447,  1,    0,    0,    0,    3980, 3981, 5,    94,   0,
      0,     3981, 3982, 5,    652,  0,    0,    3982, 449,  1,    0,    0,    0,    3983, 3990, 3,    1380, 690,  0,
      3984,  3985, 5,    773,  0,    0,    3985, 3988, 3,    1380, 690,  0,    3986, 3987, 5,    773,  0,    0,    3987,
      3989,  3,    1358, 679,  0,    3988, 3986, 1,    0,    0,    0,    3988, 3989, 1,    0,    0,    0,    3989, 3991,
      1,     0,    0,    0,    3990, 3984, 1,    0,    0,    0,    3990, 3991, 1,    0,    0,    0,    3991, 451,  1,
      0,     0,    0,    3992, 3993, 5,    428,  0,    0,    3993, 3994, 7,    44,   0,    0,    3994, 3999, 5,    289,
      0,     0,    3995, 3996, 5,    590,  0,    0,    3996, 4000, 3,    1384, 692,  0,    3997, 3998, 5,    28,   0,
      0,     3998, 4000, 3,    860,  430,  0,    3999, 3995, 1,    0,    0,    0,    3999, 3997, 1,    0,    0,    0,
      4000,  4024, 1,    0,    0,    0,    4001, 4024, 3,    462,  231,  0,    4002, 4003, 5,    468,  0,    0,    4003,
      4008,  3,    454,  227,  0,    4004, 4005, 5,    773,  0,    0,    4005, 4007, 3,    454,  227,  0,    4006, 4004,
      1,     0,    0,    0,    4007, 4010, 1,    0,    0,    0,    4008, 4006, 1,    0,    0,    0,    4008, 4009, 1,
      0,     0,    0,    4009, 4024, 1,    0,    0,    0,    4010, 4008, 1,    0,    0,    0,    4011, 4012, 5,    468,
      0,     0,    4012, 4016, 5,    658,  0,    0,    4013, 4014, 3,    1178, 589,  0,    4014, 4015, 3,    1346, 673,
      0,     4015, 4017, 1,    0,    0,    0,    4016, 4013, 1,    0,    0,    0,    4016, 4017, 1,    0,    0,    0,
      4017,  4024, 1,    0,    0,    0,    4018, 4024, 3,    548,  274,  0,    4019, 4024, 3,    550,  275,  0,    4020,
      4024,  3,    534,  267,  0,    4021, 4024, 3,    458,  229,  0,    4022, 4024, 3,    566,  283,  0,    4023, 3992,
      1,     0,    0,    0,    4023, 4001, 1,    0,    0,    0,    4023, 4002, 1,    0,    0,    0,    4023, 4011, 1,
      0,     0,    0,    4023, 4018, 1,    0,    0,    0,    4023, 4019, 1,    0,    0,    0,    4023, 4020, 1,    0,
      0,     0,    4023, 4021, 1,    0,    0,    0,    4023, 4022, 1,    0,    0,    0,    4024, 453,  1,    0,    0,
      0,     4025, 4027, 5,    316,  0,    0,    4026, 4028, 3,    456,  228,  0,    4027, 4026, 1,    0,    0,    0,
      4027,  4028, 1,    0,    0,    0,    4028, 4037, 1,    0,    0,    0,    4029, 4031, 3,    578,  289,  0,    4030,
      4032,  5,    10,   0,    0,    4031, 4030, 1,    0,    0,    0,    4031, 4032, 1,    0,    0,    0,    4032, 4034,
      1,     0,    0,    0,    4033, 4035, 3,    974,  487,  0,    4034, 4033, 1,    0,    0,    0,    4034, 4035, 1,
      0,     0,    0,    4035, 4037, 1,    0,    0,    0,    4036, 4025, 1,    0,    0,    0,    4036, 4029, 1,    0,
      0,     0,    4037, 455,  1,    0,    0,    0,    4038, 4039, 5,    590,  0,    0,    4039, 4040, 3,    1364, 682,
      0,     4040, 457,  1,    0,    0,    0,    4041, 4045, 5,    281,  0,    0,    4042, 4046, 5,    112,  0,    0,
      4043,  4044, 5,    574,  0,    0,    4044, 4046, 3,    1322, 661,  0,    4045, 4042, 1,    0,    0,    0,    4045,
      4043,  1,    0,    0,    0,    4046, 4047, 1,    0,    0,    0,    4047, 4048, 5,    203,  0,    0,    4048, 4049,
      5,     316,  0,    0,    4049, 459,  1,    0,    0,    0,    4050, 4055, 5,    316,  0,    0,    4051, 4052, 4,
      230,   32,   0,    4052, 4053, 5,    459,  0,    0,    4053, 4055, 5,    522,  0,    0,    4054, 4050, 1,    0,
      0,     0,    4054, 4051, 1,    0,    0,    0,    4055, 461,  1,    0,    0,    0,    4056, 4057, 5,    55,   0,
      0,     4057, 4058, 3,    460,  230,  0,    4058, 4059, 5,    590,  0,    0,    4059, 4061, 3,    464,  232,  0,
      4060,  4062, 3,    974,  487,  0,    4061, 4060, 1,    0,    0,    0,    4061, 4062, 1,    0,    0,    0,    4062,
      463,   1,    0,    0,    0,    4063, 4068, 3,    466,  233,  0,    4064, 4065, 5,    773,  0,    0,    4065, 4067,
      3,     466,  233,  0,    4066, 4064, 1,    0,    0,    0,    4067, 4070, 1,    0,    0,    0,    4068, 4066, 1,
      0,     0,    0,    4068, 4069, 1,    0,    0,    0,    4069, 465,  1,    0,    0,    0,    4070, 4068, 1,    0,
      0,     0,    4071, 4072, 3,    470,  235,  0,    4072, 4073, 5,    750,  0,    0,    4073, 4074, 3,    1386, 693,
      0,     4074, 4200, 1,    0,    0,    0,    4075, 4076, 5,    729,  0,    0,    4076, 4077, 5,    750,  0,    0,
      4077,  4200, 3,    1386, 693,  0,    4078, 4079, 3,    472,  236,  0,    4079, 4080, 5,    750,  0,    0,    4080,
      4081,  3,    1386, 693,  0,    4081, 4200, 1,    0,    0,    0,    4082, 4083, 3,    474,  237,  0,    4083, 4084,
      5,     750,  0,    0,    4084, 4085, 3,    1386, 693,  0,    4085, 4200, 1,    0,    0,    0,    4086, 4087, 3,
      476,   238,  0,    4087, 4088, 5,    750,  0,    0,    4088, 4089, 3,    1386, 693,  0,    4089, 4200, 1,    0,
      0,     0,    4090, 4091, 3,    478,  239,  0,    4091, 4092, 5,    750,  0,    0,    4092, 4093, 3,    1358, 679,
      0,     4093, 4200, 1,    0,    0,    0,    4094, 4095, 3,    480,  240,  0,    4095, 4096, 5,    750,  0,    0,
      4096,  4097, 3,    1358, 679,  0,    4097, 4200, 1,    0,    0,    0,    4098, 4099, 3,    482,  241,  0,    4099,
      4100,  5,    750,  0,    0,    4100, 4101, 3,    1358, 679,  0,    4101, 4200, 1,    0,    0,    0,    4102, 4103,
      3,     484,  242,  0,    4103, 4104, 5,    750,  0,    0,    4104, 4105, 3,    1358, 679,  0,    4105, 4200, 1,
      0,     0,    0,    4106, 4107, 3,    486,  243,  0,    4107, 4108, 5,    750,  0,    0,    4108, 4109, 3,    1358,
      679,   0,    4109, 4200, 1,    0,    0,    0,    4110, 4111, 3,    488,  244,  0,    4111, 4112, 5,    750,  0,
      0,     4112, 4113, 3,    1386, 693,  0,    4113, 4200, 1,    0,    0,    0,    4114, 4115, 3,    490,  245,  0,
      4115,  4116, 5,    750,  0,    0,    4116, 4117, 3,    1386, 693,  0,    4117, 4200, 1,    0,    0,    0,    4118,
      4119,  3,    502,  251,  0,    4119, 4120, 5,    750,  0,    0,    4120, 4121, 3,    1386, 693,  0,    4121, 4200,
      1,     0,    0,    0,    4122, 4123, 3,    506,  253,  0,    4123, 4124, 5,    750,  0,    0,    4124, 4125, 3,
      1386,  693,  0,    4125, 4200, 1,    0,    0,    0,    4126, 4127, 3,    504,  252,  0,    4127, 4128, 5,    750,
      0,     0,    4128, 4129, 3,    524,  262,  0,    4129, 4200, 1,    0,    0,    0,    4130, 4131, 3,    492,  246,
      0,     4131, 4132, 5,    750,  0,    0,    4132, 4133, 3,    1386, 693,  0,    4133, 4200, 1,    0,    0,    0,
      4134,  4135, 3,    498,  249,  0,    4135, 4136, 5,    750,  0,    0,    4136, 4137, 3,    1386, 693,  0,    4137,
      4200,  1,    0,    0,    0,    4138, 4139, 3,    500,  250,  0,    4139, 4140, 5,    750,  0,    0,    4140, 4141,
      3,     1358, 679,  0,    4141, 4200, 1,    0,    0,    0,    4142, 4143, 3,    494,  247,  0,    4143, 4144, 5,
      750,   0,    0,    4144, 4145, 3,    1384, 692,  0,    4145, 4200, 1,    0,    0,    0,    4146, 4147, 3,    496,
      248,   0,    4147, 4148, 5,    750,  0,    0,    4148, 4149, 3,    1386, 693,  0,    4149, 4200, 1,    0,    0,
      0,     4150, 4151, 3,    508,  254,  0,    4151, 4152, 5,    750,  0,    0,    4152, 4153, 3,    1386, 693,  0,
      4153,  4200, 1,    0,    0,    0,    4154, 4155, 3,    510,  255,  0,    4155, 4156, 5,    750,  0,    0,    4156,
      4157,  3,    1358, 679,  0,    4157, 4200, 1,    0,    0,    0,    4158, 4159, 3,    512,  256,  0,    4159, 4160,
      5,     750,  0,    0,    4160, 4161, 3,    1358, 679,  0,    4161, 4200, 1,    0,    0,    0,    4162, 4163, 5,
      233,   0,    0,    4163, 4164, 5,    750,  0,    0,    4164, 4200, 3,    532,  266,  0,    4165, 4166, 3,    514,
      257,   0,    4166, 4167, 5,    750,  0,    0,    4167, 4168, 3,    1378, 689,  0,    4168, 4200, 1,    0,    0,
      0,     4169, 4170, 3,    516,  258,  0,    4170, 4171, 5,    750,  0,    0,    4171, 4172, 3,    1358, 679,  0,
      4172,  4200, 1,    0,    0,    0,    4173, 4174, 3,    468,  234,  0,    4174, 4175, 5,    750,  0,    0,    4175,
      4176,  3,    1358, 679,  0,    4176, 4200, 1,    0,    0,    0,    4177, 4178, 5,    737,  0,    0,    4178, 4179,
      5,     750,  0,    0,    4179, 4200, 3,    518,  259,  0,    4180, 4181, 5,    739,  0,    0,    4181, 4182, 5,
      750,   0,    0,    4182, 4200, 3,    1358, 679,  0,    4183, 4184, 5,    742,  0,    0,    4184, 4185, 5,    750,
      0,     0,    4185, 4200, 3,    520,  260,  0,    4186, 4187, 4,    233,  33,   0,    4187, 4188, 5,    800,  0,
      0,     4188, 4189, 5,    750,  0,    0,    4189, 4200, 3,    1360, 680,  0,    4190, 4191, 4,    233,  34,   0,
      4191,  4192, 5,    805,  0,    0,    4192, 4193, 5,    750,  0,    0,    4193, 4200, 3,    522,  261,  0,    4194,
      4195,  4,    233,  35,   0,    4195, 4196, 5,    843,  0,    0,    4196, 4197, 5,    750,  0,    0,    4197, 4200,
      3,     1360, 680,  0,    4198, 4200, 3,    526,  263,  0,    4199, 4071, 1,    0,    0,    0,    4199, 4075, 1,
      0,     0,    0,    4199, 4078, 1,    0,    0,    0,    4199, 4082, 1,    0,    0,    0,    4199, 4086, 1,    0,
      0,     0,    4199, 4090, 1,    0,    0,    0,    4199, 4094, 1,    0,    0,    0,    4199, 4098, 1,    0,    0,
      0,     4199, 4102, 1,    0,    0,    0,    4199, 4106, 1,    0,    0,    0,    4199, 4110, 1,    0,    0,    0,
      4199,  4114, 1,    0,    0,    0,    4199, 4118, 1,    0,    0,    0,    4199, 4122, 1,    0,    0,    0,    4199,
      4126,  1,    0,    0,    0,    4199, 4130, 1,    0,    0,    0,    4199, 4134, 1,    0,    0,    0,    4199, 4138,
      1,     0,    0,    0,    4199, 4142, 1,    0,    0,    0,    4199, 4146, 1,    0,    0,    0,    4199, 4150, 1,
      0,     0,    0,    4199, 4154, 1,    0,    0,    0,    4199, 4158, 1,    0,    0,    0,    4199, 4162, 1,    0,
      0,     0,    4199, 4165, 1,    0,    0,    0,    4199, 4169, 1,    0,    0,    0,    4199, 4173, 1,    0,    0,
      0,     4199, 4177, 1,    0,    0,    0,    4199, 4180, 1,    0,    0,    0,    4199, 4183, 1,    0,    0,    0,
      4199,  4186, 1,    0,    0,    0,    4199, 4190, 1,    0,    0,    0,    4199, 4194, 1,    0,    0,    0,    4199,
      4198,  1,    0,    0,    0,    4200, 467,  1,    0,    0,    0,    4201, 4202, 7,    45,   0,    0,    4202, 469,
      1,     0,    0,    0,    4203, 4204, 7,    46,   0,    0,    4204, 471,  1,    0,    0,    0,    4205, 4206, 7,
      47,    0,    0,    4206, 473,  1,    0,    0,    0,    4207, 4208, 7,    48,   0,    0,    4208, 475,  1,    0,
      0,     0,    4209, 4210, 7,    49,   0,    0,    4210, 477,  1,    0,    0,    0,    4211, 4212, 7,    50,   0,
      0,     4212, 479,  1,    0,    0,    0,    4213, 4214, 7,    51,   0,    0,    4214, 481,  1,    0,    0,    0,
      4215,  4216, 7,    52,   0,    0,    4216, 483,  1,    0,    0,    0,    4217, 4218, 7,    53,   0,    0,    4218,
      485,   1,    0,    0,    0,    4219, 4220, 7,    54,   0,    0,    4220, 487,  1,    0,    0,    0,    4221, 4222,
      7,     55,   0,    0,    4222, 489,  1,    0,    0,    0,    4223, 4224, 7,    56,   0,    0,    4224, 491,  1,
      0,     0,    0,    4225, 4226, 7,    57,   0,    0,    4226, 493,  1,    0,    0,    0,    4227, 4228, 7,    58,
      0,     0,    4228, 495,  1,    0,    0,    0,    4229, 4230, 7,    59,   0,    0,    4230, 497,  1,    0,    0,
      0,     4231, 4232, 7,    60,   0,    0,    4232, 499,  1,    0,    0,    0,    4233, 4234, 7,    61,   0,    0,
      4234,  501,  1,    0,    0,    0,    4235, 4236, 7,    62,   0,    0,    4236, 503,  1,    0,    0,    0,    4237,
      4238,  7,    63,   0,    0,    4238, 505,  1,    0,    0,    0,    4239, 4240, 7,    64,   0,    0,    4240, 507,
      1,     0,    0,    0,    4241, 4242, 7,    65,   0,    0,    4242, 509,  1,    0,    0,    0,    4243, 4244, 7,
      66,    0,    0,    4244, 511,  1,    0,    0,    0,    4245, 4246, 7,    67,   0,    0,    4246, 513,  1,    0,
      0,     0,    4247, 4248, 7,    68,   0,    0,    4248, 515,  1,    0,    0,    0,    4249, 4250, 7,    69,   0,
      0,     4250, 517,  1,    0,    0,    0,    4251, 4254, 3,    1244, 622,  0,    4252, 4254, 5,    376,  0,    0,
      4253,  4251, 1,    0,    0,    0,    4253, 4252, 1,    0,    0,    0,    4254, 519,  1,    0,    0,    0,    4255,
      4256,  7,    70,   0,    0,    4256, 521,  1,    0,    0,    0,    4257, 4261, 5,    744,  0,    0,    4258, 4261,
      5,     284,  0,    0,    4259, 4261, 3,    1378, 689,  0,    4260, 4257, 1,    0,    0,    0,    4260, 4258, 1,
      0,     0,    0,    4260, 4259, 1,    0,    0,    0,    4261, 523,  1,    0,    0,    0,    4262, 4265, 3,    1386,
      693,   0,    4263, 4265, 5,    376,  0,    0,    4264, 4262, 1,    0,    0,    0,    4264, 4263, 1,    0,    0,
      0,     4265, 525,  1,    0,    0,    0,    4266, 4267, 3,    528,  264,  0,    4267, 4268, 5,    750,  0,    0,
      4268,  4269, 3,    1386, 693,  0,    4269, 4281, 1,    0,    0,    0,    4270, 4271, 3,    530,  265,  0,    4271,
      4272,  5,    750,  0,    0,    4272, 4273, 3,    1362, 681,  0,    4273, 4281, 1,    0,    0,    0,    4274, 4275,
      5,     447,  0,    0,    4275, 4276, 5,    750,  0,    0,    4276, 4281, 3,    1386, 693,  0,    4277, 4278, 5,
      448,   0,    0,    4278, 4279, 5,    750,  0,    0,    4279, 4281, 3,    1358, 679,  0,    4280, 4266, 1,    0,
      0,     0,    4280, 4270, 1,    0,    0,    0,    4280, 4274, 1,    0,    0,    0,    4280, 4277, 1,    0,    0,
      0,     4281, 527,  1,    0,    0,    0,    4282, 4283, 7,    71,   0,    0,    4283, 529,  1,    0,    0,    0,
      4284,  4285, 7,    72,   0,    0,    4285, 531,  1,    0,    0,    0,    4286, 4295, 5,    776,  0,    0,    4287,
      4292,  3,    1358, 679,  0,    4288, 4289, 5,    773,  0,    0,    4289, 4291, 3,    1358, 679,  0,    4290, 4288,
      1,     0,    0,    0,    4291, 4294, 1,    0,    0,    0,    4292, 4290, 1,    0,    0,    0,    4292, 4293, 1,
      0,     0,    0,    4293, 4296, 1,    0,    0,    0,    4294, 4292, 1,    0,    0,    0,    4295, 4287, 1,    0,
      0,     0,    4295, 4296, 1,    0,    0,    0,    4296, 4297, 1,    0,    0,    0,    4297, 4298, 5,    777,  0,
      0,     4298, 533,  1,    0,    0,    0,    4299, 4300, 5,    55,   0,    0,    4300, 4301, 5,    459,  0,    0,
      4301,  4302, 5,    190,  0,    0,    4302, 4307, 3,    536,  268,  0,    4303, 4304, 5,    773,  0,    0,    4304,
      4306,  3,    536,  268,  0,    4305, 4303, 1,    0,    0,    0,    4306, 4309, 1,    0,    0,    0,    4307, 4305,
      1,     0,    0,    0,    4307, 4308, 1,    0,    0,    0,    4308, 4311, 1,    0,    0,    0,    4309, 4307, 1,
      0,     0,    0,    4310, 4312, 3,    974,  487,  0,    4311, 4310, 1,    0,    0,    0,    4311, 4312, 1,    0,
      0,     0,    4312, 535,  1,    0,    0,    0,    4313, 4314, 5,    460,  0,    0,    4314, 4315, 5,    750,  0,
      0,     4315, 4317, 5,    776,  0,    0,    4316, 4318, 3,    538,  269,  0,    4317, 4316, 1,    0,    0,    0,
      4317,  4318, 1,    0,    0,    0,    4318, 4319, 1,    0,    0,    0,    4319, 4363, 5,    777,  0,    0,    4320,
      4321,  5,    461,  0,    0,    4321, 4322, 5,    750,  0,    0,    4322, 4324, 5,    776,  0,    0,    4323, 4325,
      3,     538,  269,  0,    4324, 4323, 1,    0,    0,    0,    4324, 4325, 1,    0,    0,    0,    4325, 4326, 1,
      0,     0,    0,    4326, 4363, 5,    777,  0,    0,    4327, 4328, 5,    462,  0,    0,    4328, 4329, 5,    750,
      0,     0,    4329, 4331, 5,    776,  0,    0,    4330, 4332, 3,    540,  270,  0,    4331, 4330, 1,    0,    0,
      0,     4331, 4332, 1,    0,    0,    0,    4332, 4333, 1,    0,    0,    0,    4333, 4363, 5,    777,  0,    0,
      4334,  4335, 5,    463,  0,    0,    4335, 4336, 5,    750,  0,    0,    4336, 4338, 5,    776,  0,    0,    4337,
      4339,  3,    540,  270,  0,    4338, 4337, 1,    0,    0,    0,    4338, 4339, 1,    0,    0,    0,    4339, 4340,
      1,     0,    0,    0,    4340, 4363, 5,    777,  0,    0,    4341, 4342, 5,    464,  0,    0,    4342, 4343, 5,
      750,   0,    0,    4343, 4345, 5,    776,  0,    0,    4344, 4346, 3,    542,  271,  0,    4345, 4344, 1,    0,
      0,     0,    4345, 4346, 1,    0,    0,    0,    4346, 4347, 1,    0,    0,    0,    4347, 4363, 5,    777,  0,
      0,     4348, 4349, 5,    465,  0,    0,    4349, 4350, 5,    750,  0,    0,    4350, 4352, 5,    776,  0,    0,
      4351,  4353, 3,    542,  271,  0,    4352, 4351, 1,    0,    0,    0,    4352, 4353, 1,    0,    0,    0,    4353,
      4354,  1,    0,    0,    0,    4354, 4363, 5,    777,  0,    0,    4355, 4356, 5,    466,  0,    0,    4356, 4357,
      5,     750,  0,    0,    4357, 4359, 5,    776,  0,    0,    4358, 4360, 3,    546,  273,  0,    4359, 4358, 1,
      0,     0,    0,    4359, 4360, 1,    0,    0,    0,    4360, 4361, 1,    0,    0,    0,    4361, 4363, 5,    777,
      0,     0,    4362, 4313, 1,    0,    0,    0,    4362, 4320, 1,    0,    0,    0,    4362, 4327, 1,    0,    0,
      0,     4362, 4334, 1,    0,    0,    0,    4362, 4341, 1,    0,    0,    0,    4362, 4348, 1,    0,    0,    0,
      4362,  4355, 1,    0,    0,    0,    4363, 537,  1,    0,    0,    0,    4364, 4369, 3,    1278, 639,  0,    4365,
      4366,  5,    773,  0,    0,    4366, 4368, 3,    1278, 639,  0,    4367, 4365, 1,    0,    0,    0,    4368, 4371,
      1,     0,    0,    0,    4369, 4367, 1,    0,    0,    0,    4369, 4370, 1,    0,    0,    0,    4370, 539,  1,
      0,     0,    0,    4371, 4369, 1,    0,    0,    0,    4372, 4377, 3,    1318, 659,  0,    4373, 4374, 5,    773,
      0,     0,    4374, 4376, 3,    1318, 659,  0,    4375, 4373, 1,    0,    0,    0,    4376, 4379, 1,    0,    0,
      0,     4377, 4375, 1,    0,    0,    0,    4377, 4378, 1,    0,    0,    0,    4378, 541,  1,    0,    0,    0,
      4379,  4377, 1,    0,    0,    0,    4380, 4385, 3,    544,  272,  0,    4381, 4382, 5,    773,  0,    0,    4382,
      4384,  3,    544,  272,  0,    4383, 4381, 1,    0,    0,    0,    4384, 4387, 1,    0,    0,    0,    4385, 4383,
      1,     0,    0,    0,    4385, 4386, 1,    0,    0,    0,    4386, 543,  1,    0,    0,    0,    4387, 4385, 1,
      0,     0,    0,    4388, 4389, 3,    1386, 693,  0,    4389, 545,  1,    0,    0,    0,    4390, 4395, 3,    1192,
      596,   0,    4391, 4392, 5,    773,  0,    0,    4392, 4394, 3,    1192, 596,  0,    4393, 4391, 1,    0,    0,
      0,     4394, 4397, 1,    0,    0,    0,    4395, 4393, 1,    0,    0,    0,    4395, 4396, 1,    0,    0,    0,
      4396,  547,  1,    0,    0,    0,    4397, 4395, 1,    0,    0,    0,    4398, 4399, 5,    543,  0,    0,    4399,
      4401,  3,    578,  289,  0,    4400, 4402, 3,    562,  281,  0,    4401, 4400, 1,    0,    0,    0,    4401, 4402,
      1,     0,    0,    0,    4402, 4405, 1,    0,    0,    0,    4403, 4404, 5,    613,  0,    0,    4404, 4406, 3,
      552,   276,  0,    4405, 4403, 1,    0,    0,    0,    4405, 4406, 1,    0,    0,    0,    4406, 4408, 1,    0,
      0,     0,    4407, 4409, 3,    554,  277,  0,    4408, 4407, 1,    0,    0,    0,    4408, 4409, 1,    0,    0,
      0,     4409, 4411, 1,    0,    0,    0,    4410, 4412, 3,    556,  278,  0,    4411, 4410, 1,    0,    0,    0,
      4411,  4412, 1,    0,    0,    0,    4412, 4414, 1,    0,    0,    0,    4413, 4415, 3,    558,  279,  0,    4414,
      4413,  1,    0,    0,    0,    4414, 4415, 1,    0,    0,    0,    4415, 4417, 1,    0,    0,    0,    4416, 4418,
      3,     560,  280,  0,    4417, 4416, 1,    0,    0,    0,    4417, 4418, 1,    0,    0,    0,    4418, 4420, 1,
      0,     0,    0,    4419, 4421, 3,    974,  487,  0,    4420, 4419, 1,    0,    0,    0,    4420, 4421, 1,    0,
      0,     0,    4421, 549,  1,    0,    0,    0,    4422, 4423, 5,    552,  0,    0,    4423, 4425, 3,    578,  289,
      0,     4424, 4426, 3,    562,  281,  0,    4425, 4424, 1,    0,    0,    0,    4425, 4426, 1,    0,    0,    0,
      4426,  4428, 1,    0,    0,    0,    4427, 4429, 3,    974,  487,  0,    4428, 4427, 1,    0,    0,    0,    4428,
      4429,  1,    0,    0,    0,    4429, 551,  1,    0,    0,    0,    4430, 4436, 3,    526,  263,  0,    4431, 4432,
      7,     73,   0,    0,    4432, 4433, 5,    750,  0,    0,    4433, 4436, 3,    1380, 690,  0,    4434, 4436, 5,
      529,   0,    0,    4435, 4430, 1,    0,    0,    0,    4435, 4431, 1,    0,    0,    0,    4435, 4434, 1,    0,
      0,     0,    4436, 4441, 1,    0,    0,    0,    4437, 4438, 5,    773,  0,    0,    4438, 4440, 3,    526,  263,
      0,     4439, 4437, 1,    0,    0,    0,    4440, 4443, 1,    0,    0,    0,    4441, 4439, 1,    0,    0,    0,
      4441,  4442, 1,    0,    0,    0,    4442, 553,  1,    0,    0,    0,    4443, 4441, 1,    0,    0,    0,    4444,
      4445,  5,    618,  0,    0,    4445, 4446, 5,    750,  0,    0,    4446, 4447, 3,    1380, 690,  0,    4447, 555,
      1,     0,    0,    0,    4448, 4449, 5,    406,  0,    0,    4449, 4450, 5,    750,  0,    0,    4450, 4451, 3,
      1380,  690,  0,    4451, 557,  1,    0,    0,    0,    4452, 4453, 5,    129,  0,    0,    4453, 4454, 5,    750,
      0,     0,    4454, 4455, 3,    1380, 690,  0,    4455, 559,  1,    0,    0,    0,    4456, 4457, 5,    409,  0,
      0,     4457, 4458, 5,    750,  0,    0,    4458, 4459, 3,    1380, 690,  0,    4459, 561,  1,    0,    0,    0,
      4460,  4465, 3,    564,  282,  0,    4461, 4462, 5,    773,  0,    0,    4462, 4464, 3,    564,  282,  0,    4463,
      4461,  1,    0,    0,    0,    4464, 4467, 1,    0,    0,    0,    4465, 4463, 1,    0,    0,    0,    4465, 4466,
      1,     0,    0,    0,    4466, 563,  1,    0,    0,    0,    4467, 4465, 1,    0,    0,    0,    4468, 4469, 7,
      74,    0,    0,    4469, 565,  1,    0,    0,    0,    4470, 4472, 5,    543,  0,    0,    4471, 4473, 3,    568,
      284,   0,    4472, 4471, 1,    0,    0,    0,    4472, 4473, 1,    0,    0,    0,    4473, 4476, 1,    0,    0,
      0,     4474, 4476, 5,    552,  0,    0,    4475, 4470, 1,    0,    0,    0,    4475, 4474, 1,    0,    0,    0,
      4476,  4477, 1,    0,    0,    0,    4477, 4478, 5,    210,  0,    0,    4478, 567,  1,    0,    0,    0,    4479,
      4484,  3,    570,  285,  0,    4480, 4481, 5,    773,  0,    0,    4481, 4483, 3,    570,  285,  0,    4482, 4480,
      1,     0,    0,    0,    4483, 4486, 1,    0,    0,    0,    4484, 4482, 1,    0,    0,    0,    4484, 4485, 1,
      0,     0,    0,    4485, 569,  1,    0,    0,    0,    4486, 4484, 1,    0,    0,    0,    4487, 4491, 3,    572,
      286,   0,    4488, 4491, 3,    574,  287,  0,    4489, 4491, 3,    576,  288,  0,    4490, 4487, 1,    0,    0,
      0,     4490, 4488, 1,    0,    0,    0,    4490, 4489, 1,    0,    0,    0,    4491, 571,  1,    0,    0,    0,
      4492,  4493, 5,    618,  0,    0,    4493, 4494, 5,    750,  0,    0,    4494, 4495, 3,    1386, 693,  0,    4495,
      573,   1,    0,    0,    0,    4496, 4497, 5,    406,  0,    0,    4497, 4498, 5,    750,  0,    0,    4498, 4499,
      3,     1386, 693,  0,    4499, 575,  1,    0,    0,    0,    4500, 4501, 5,    129,  0,    0,    4501, 4502, 5,
      750,   0,    0,    4502, 4503, 3,    1386, 693,  0,    4503, 577,  1,    0,    0,    0,    4504, 4505, 7,    75,
      0,     0,    4505, 579,  1,    0,    0,    0,    4506, 4507, 5,    417,  0,    0,    4507, 4508, 3,    1346, 673,
      0,     4508, 4511, 5,    203,  0,    0,    4509, 4512, 3,    1384, 692,  0,    4510, 4512, 3,    930,  465,  0,
      4511,  4509, 1,    0,    0,    0,    4511, 4510, 1,    0,    0,    0,    4512, 4518, 1,    0,    0,    0,    4513,
      4518,  3,    582,  291,  0,    4514, 4515, 7,    76,   0,    0,    4515, 4516, 5,    417,  0,    0,    4516, 4518,
      3,     1346, 673,  0,    4517, 4506, 1,    0,    0,    0,    4517, 4513, 1,    0,    0,    0,    4517, 4514, 1,
      0,     0,    0,    4518, 581,  1,    0,    0,    0,    4519, 4520, 5,    173,  0,    0,    4520, 4523, 3,    1346,
      673,   0,    4521, 4522, 5,    621,  0,    0,    4522, 4524, 3,    584,  292,  0,    4523, 4521, 1,    0,    0,
      0,     4523, 4524, 1,    0,    0,    0,    4524, 583,  1,    0,    0,    0,    4525, 4530, 3,    930,  465,  0,
      4526,  4527, 5,    773,  0,    0,    4527, 4529, 3,    930,  465,  0,    4528, 4526, 1,    0,    0,    0,    4529,
      4532,  1,    0,    0,    0,    4530, 4528, 1,    0,    0,    0,    4530, 4531, 1,    0,    0,    0,    4531, 585,
      1,     0,    0,    0,    4532, 4530, 1,    0,    0,    0,    4533, 4558, 5,    677,  0,    0,    4534, 4535, 5,
      284,   0,    0,    4535, 4536, 5,    112,  0,    0,    4536, 4538, 5,    139,  0,    0,    4537, 4539, 3,    1416,
      708,   0,    4538, 4537, 1,    0,    0,    0,    4538, 4539, 1,    0,    0,    0,    4539, 4540, 1,    0,    0,
      0,     4540, 4559, 3,    1378, 689,  0,    4541, 4544, 5,    676,  0,    0,    4542, 4543, 5,    200,  0,    0,
      4543,  4545, 5,    459,  0,    0,    4544, 4542, 1,    0,    0,    0,    4544, 4545, 1,    0,    0,    0,    4545,
      4559,  1,    0,    0,    0,    4546, 4547, 4,    293,  36,   0,    4547, 4548, 5,    244,  0,    0,    4548, 4549,
      5,     203,  0,    0,    4549, 4550, 3,    1246, 623,  0,    4550, 4551, 5,    775,  0,    0,    4551, 4552, 3,
      1358,  679,  0,    4552, 4553, 5,    230,  0,    0,    4553, 4554, 5,    45,   0,    0,    4554, 4556, 3,    1378,
      689,   0,    4555, 4557, 3,    588,  294,  0,    4556, 4555, 1,    0,    0,    0,    4556, 4557, 1,    0,    0,
      0,     4557, 4559, 1,    0,    0,    0,    4558, 4534, 1,    0,    0,    0,    4558, 4541, 1,    0,    0,    0,
      4558,  4546, 1,    0,    0,    0,    4559, 587,  1,    0,    0,    0,    4560, 4571, 3,    590,  295,  0,    4561,
      4562,  5,    112,  0,    0,    4562, 4564, 5,    139,  0,    0,    4563, 4565, 3,    1416, 708,  0,    4564, 4563,
      1,     0,    0,    0,    4564, 4565, 1,    0,    0,    0,    4565, 4566, 1,    0,    0,    0,    4566, 4568, 3,
      1378,  689,  0,    4567, 4569, 3,    590,  295,  0,    4568, 4567, 1,    0,    0,    0,    4568, 4569, 1,    0,
      0,     0,    4569, 4571, 1,    0,    0,    0,    4570, 4560, 1,    0,    0,    0,    4570, 4561, 1,    0,    0,
      0,     4571, 589,  1,    0,    0,    0,    4572, 4574, 5,    467,  0,    0,    4573, 4575, 5,    373,  0,    0,
      4574,  4573, 1,    0,    0,    0,    4574, 4575, 1,    0,    0,    0,    4575, 4576, 1,    0,    0,    0,    4576,
      4577,  5,    539,  0,    0,    4577, 591,  1,    0,    0,    0,    4578, 4586, 3,    594,  297,  0,    4579, 4586,
      3,     604,  302,  0,    4580, 4586, 3,    620,  310,  0,    4581, 4586, 3,    622,  311,  0,    4582, 4586, 3,
      636,   318,  0,    4583, 4586, 3,    638,  319,  0,    4584, 4586, 3,    654,  327,  0,    4585, 4578, 1,    0,
      0,     0,    4585, 4579, 1,    0,    0,    0,    4585, 4580, 1,    0,    0,    0,    4585, 4581, 1,    0,    0,
      0,     4585, 4582, 1,    0,    0,    0,    4585, 4583, 1,    0,    0,    0,    4585, 4584, 1,    0,    0,    0,
      4586,  593,  1,    0,    0,    0,    4587, 4588, 5,    11,   0,    0,    4588, 4590, 5,    618,  0,    0,    4589,
      4591,  3,    1178, 589,  0,    4590, 4589, 1,    0,    0,    0,    4590, 4591, 1,    0,    0,    0,    4591, 4632,
      1,     0,    0,    0,    4592, 4593, 4,    297,  37,   0,    4593, 4597, 3,    1212, 606,  0,    4594, 4595, 4,
      297,   38,   0,    4595, 4597, 3,    596,  298,  0,    4596, 4592, 1,    0,    0,    0,    4596, 4594, 1,    0,
      0,     0,    4597, 4598, 1,    0,    0,    0,    4598, 4599, 3,    606,  303,  0,    4599, 4633, 1,    0,    0,
      0,     4600, 4617, 3,    602,  301,  0,    4601, 4604, 3,    1222, 611,  0,    4602, 4604, 3,    1220, 610,  0,
      4603,  4601, 1,    0,    0,    0,    4603, 4602, 1,    0,    0,    0,    4604, 4606, 1,    0,    0,    0,    4605,
      4607,  3,    1242, 621,  0,    4606, 4605, 1,    0,    0,    0,    4606, 4607, 1,    0,    0,    0,    4607, 4609,
      1,     0,    0,    0,    4608, 4610, 3,    1234, 617,  0,    4609, 4608, 1,    0,    0,    0,    4609, 4610, 1,
      0,     0,    0,    4610, 4618, 1,    0,    0,    0,    4611, 4612, 5,    141,  0,    0,    4612, 4613, 5,    728,
      0,     0,    4613, 4618, 5,    406,  0,    0,    4614, 4616, 3,    1238, 619,  0,    4615, 4614, 1,    0,    0,
      0,     4615, 4616, 1,    0,    0,    0,    4616, 4618, 1,    0,    0,    0,    4617, 4603, 1,    0,    0,    0,
      4617,  4611, 1,    0,    0,    0,    4617, 4615, 1,    0,    0,    0,    4618, 4633, 1,    0,    0,    0,    4619,
      4630,  3,    1246, 623,  0,    4620, 4621, 5,    128,  0,    0,    4621, 4625, 5,    659,  0,    0,    4622, 4626,
      5,     10,   0,    0,    4623, 4626, 5,    369,  0,    0,    4624, 4626, 3,    656,  328,  0,    4625, 4622, 1,
      0,     0,    0,    4625, 4623, 1,    0,    0,    0,    4625, 4624, 1,    0,    0,    0,    4626, 4631, 1,    0,
      0,     0,    4627, 4629, 3,    1238, 619,  0,    4628, 4627, 1,    0,    0,    0,    4628, 4629, 1,    0,    0,
      0,     4629, 4631, 1,    0,    0,    0,    4630, 4620, 1,    0,    0,    0,    4630, 4628, 1,    0,    0,    0,
      4631,  4633, 1,    0,    0,    0,    4632, 4596, 1,    0,    0,    0,    4632, 4600, 1,    0,    0,    0,    4632,
      4619,  1,    0,    0,    0,    4633, 595,  1,    0,    0,    0,    4634, 4639, 3,    598,  299,  0,    4635, 4636,
      5,     773,  0,    0,    4636, 4638, 3,    598,  299,  0,    4637, 4635, 1,    0,    0,    0,    4638, 4641, 1,
      0,     0,    0,    4639, 4637, 1,    0,    0,    0,    4639, 4640, 1,    0,    0,    0,    4640, 597,  1,    0,
      0,     0,    4641, 4639, 1,    0,    0,    0,    4642, 4643, 4,    299,  39,   0,    4643, 4718, 3,    600,  300,
      0,     4644, 4645, 4,    299,  40,   0,    4645, 4715, 3,    1246, 623,  0,    4646, 4655, 3,    1220, 610,  0,
      4647,  4648, 5,    458,  0,    0,    4648, 4650, 3,    1378, 689,  0,    4649, 4651, 3,    1234, 617,  0,    4650,
      4649,  1,    0,    0,    0,    4650, 4651, 1,    0,    0,    0,    4651, 4656, 1,    0,    0,    0,    4652, 4654,
      3,     1234, 617,  0,    4653, 4652, 1,    0,    0,    0,    4653, 4654, 1,    0,    0,    0,    4654, 4656, 1,
      0,     0,    0,    4655, 4647, 1,    0,    0,    0,    4655, 4653, 1,    0,    0,    0,    4656, 4716, 1,    0,
      0,     0,    4657, 4666, 3,    1222, 611,  0,    4658, 4660, 3,    1234, 617,  0,    4659, 4658, 1,    0,    0,
      0,     4659, 4660, 1,    0,    0,    0,    4660, 4667, 1,    0,    0,    0,    4661, 4662, 5,    458,  0,    0,
      4662,  4664, 3,    1378, 689,  0,    4663, 4665, 3,    1234, 617,  0,    4664, 4663, 1,    0,    0,    0,    4664,
      4665,  1,    0,    0,    0,    4665, 4667, 1,    0,    0,    0,    4666, 4659, 1,    0,    0,    0,    4666, 4661,
      1,     0,    0,    0,    4667, 4716, 1,    0,    0,    0,    4668, 4716, 3,    1224, 612,  0,    4669, 4671, 3,
      1226,  613,  0,    4670, 4672, 3,    1234, 617,  0,    4671, 4670, 1,    0,    0,    0,    4671, 4672, 1,    0,
      0,     0,    4672, 4716, 1,    0,    0,    0,    4673, 4682, 3,    1228, 614,  0,    4674, 4675, 5,    458,  0,
      0,     4675, 4677, 3,    1378, 689,  0,    4676, 4678, 3,    1234, 617,  0,    4677, 4676, 1,    0,    0,    0,
      4677,  4678, 1,    0,    0,    0,    4678, 4683, 1,    0,    0,    0,    4679, 4681, 3,    1234, 617,  0,    4680,
      4679,  1,    0,    0,    0,    4680, 4681, 1,    0,    0,    0,    4681, 4683, 1,    0,    0,    0,    4682, 4674,
      1,     0,    0,    0,    4682, 4680, 1,    0,    0,    0,    4683, 4716, 1,    0,    0,    0,    4684, 4686, 3,
      1230,  615,  0,    4685, 4687, 3,    1234, 617,  0,    4686, 4685, 1,    0,    0,    0,    4686, 4687, 1,    0,
      0,     0,    4687, 4716, 1,    0,    0,    0,    4688, 4690, 3,    1236, 618,  0,    4689, 4688, 1,    0,    0,
      0,     4689, 4690, 1,    0,    0,    0,    4690, 4716, 1,    0,    0,    0,    4691, 4692, 5,    4,    0,    0,
      4692,  4693, 3,    1240, 620,  0,    4693, 4698, 3,    1218, 609,  0,    4694, 4695, 5,    4,    0,    0,    4695,
      4696,  3,    1240, 620,  0,    4696, 4697, 3,    1218, 609,  0,    4697, 4699, 1,    0,    0,    0,    4698, 4694,
      1,     0,    0,    0,    4698, 4699, 1,    0,    0,    0,    4699, 4716, 1,    0,    0,    0,    4700, 4701, 5,
      348,   0,    0,    4701, 4702, 3,    1240, 620,  0,    4702, 4707, 3,    1218, 609,  0,    4703, 4704, 5,    348,
      0,     0,    4704, 4705, 3,    1240, 620,  0,    4705, 4706, 3,    1218, 609,  0,    4706, 4708, 1,    0,    0,
      0,     4707, 4703, 1,    0,    0,    0,    4707, 4708, 1,    0,    0,    0,    4708, 4716, 1,    0,    0,    0,
      4709,  4710, 5,    148,  0,    0,    4710, 4713, 3,    1240, 620,  0,    4711, 4712, 5,    148,  0,    0,    4712,
      4714,  3,    1240, 620,  0,    4713, 4711, 1,    0,    0,    0,    4713, 4714, 1,    0,    0,    0,    4714, 4716,
      1,     0,    0,    0,    4715, 4646, 1,    0,    0,    0,    4715, 4657, 1,    0,    0,    0,    4715, 4668, 1,
      0,     0,    0,    4715, 4669, 1,    0,    0,    0,    4715, 4673, 1,    0,    0,    0,    4715, 4684, 1,    0,
      0,     0,    4715, 4689, 1,    0,    0,    0,    4715, 4691, 1,    0,    0,    0,    4715, 4700, 1,    0,    0,
      0,     4715, 4709, 1,    0,    0,    0,    4716, 4718, 1,    0,    0,    0,    4717, 4642, 1,    0,    0,    0,
      4717,  4644, 1,    0,    0,    0,    4718, 599,  1,    0,    0,    0,    4719, 4720, 3,    1246, 623,  0,    4720,
      4721,  5,    230,  0,    0,    4721, 4741, 5,    45,   0,    0,    4722, 4723, 3,    1380, 690,  0,    4723, 4724,
      5,     458,  0,    0,    4724, 4726, 3,    1380, 690,  0,    4725, 4727, 3,    1234, 617,  0,    4726, 4725, 1,
      0,     0,    0,    4726, 4727, 1,    0,    0,    0,    4727, 4742, 1,    0,    0,    0,    4728, 4730, 3,    1380,
      690,   0,    4729, 4731, 3,    1234, 617,  0,    4730, 4729, 1,    0,    0,    0,    4730, 4731, 1,    0,    0,
      0,     4731, 4742, 1,    0,    0,    0,    4732, 4733, 5,    734,  0,    0,    4733, 4736, 5,    406,  0,    0,
      4734,  4735, 5,    458,  0,    0,    4735, 4737, 3,    1380, 690,  0,    4736, 4734, 1,    0,    0,    0,    4736,
      4737,  1,    0,    0,    0,    4737, 4739, 1,    0,    0,    0,    4738, 4740, 3,    1234, 617,  0,    4739, 4738,
      1,     0,    0,    0,    4739, 4740, 1,    0,    0,    0,    4740, 4742, 1,    0,    0,    0,    4741, 4722, 1,
      0,     0,    0,    4741, 4728, 1,    0,    0,    0,    4741, 4732, 1,    0,    0,    0,    4742, 4777, 1,    0,
      0,     0,    4743, 4744, 3,    1246, 623,  0,    4744, 4745, 5,    230,  0,    0,    4745, 4746, 5,    645,  0,
      0,     4746, 4770, 3,    1406, 703,  0,    4747, 4748, 5,    45,   0,    0,    4748, 4749, 3,    1380, 690,  0,
      4749,  4750, 5,    458,  0,    0,    4750, 4752, 3,    1380, 690,  0,    4751, 4753, 3,    1234, 617,  0,    4752,
      4751,  1,    0,    0,    0,    4752, 4753, 1,    0,    0,    0,    4753, 4771, 1,    0,    0,    0,    4754, 4755,
      5,     17,   0,    0,    4755, 4757, 3,    1382, 691,  0,    4756, 4758, 3,    1234, 617,  0,    4757, 4756, 1,
      0,     0,    0,    4757, 4758, 1,    0,    0,    0,    4758, 4771, 1,    0,    0,    0,    4759, 4760, 5,    45,
      0,     0,    4760, 4762, 3,    1380, 690,  0,    4761, 4763, 3,    1234, 617,  0,    4762, 4761, 1,    0,    0,
      0,     4762, 4763, 1,    0,    0,    0,    4763, 4771, 1,    0,    0,    0,    4764, 4765, 5,    45,   0,    0,
      4765,  4766, 5,    734,  0,    0,    4766, 4768, 5,    406,  0,    0,    4767, 4769, 3,    1234, 617,  0,    4768,
      4767,  1,    0,    0,    0,    4768, 4769, 1,    0,    0,    0,    4769, 4771, 1,    0,    0,    0,    4770, 4747,
      1,     0,    0,    0,    4770, 4754, 1,    0,    0,    0,    4770, 4759, 1,    0,    0,    0,    4770, 4764, 1,
      0,     0,    0,    4770, 4771, 1,    0,    0,    0,    4771, 4777, 1,    0,    0,    0,    4772, 4774, 3,    1246,
      623,   0,    4773, 4775, 3,    1236, 618,  0,    4774, 4773, 1,    0,    0,    0,    4774, 4775, 1,    0,    0,
      0,     4775, 4777, 1,    0,    0,    0,    4776, 4719, 1,    0,    0,    0,    4776, 4743, 1,    0,    0,    0,
      4776,  4772, 1,    0,    0,    0,    4777, 601,  1,    0,    0,    0,    4778, 4779, 5,    618,  0,    0,    4779,
      4780,  3,    1414, 707,  0,    4780, 603,  1,    0,    0,    0,    4781, 4782, 5,    97,   0,    0,    4782, 4784,
      5,     618,  0,    0,    4783, 4785, 3,    1180, 590,  0,    4784, 4783, 1,    0,    0,    0,    4784, 4785, 1,
      0,     0,    0,    4785, 4786, 1,    0,    0,    0,    4786, 4788, 3,    1212, 606,  0,    4787, 4789, 3,    610,
      305,   0,    4788, 4787, 1,    0,    0,    0,    4788, 4789, 1,    0,    0,    0,    4789, 4790, 1,    0,    0,
      0,     4790, 4791, 3,    606,  303,  0,    4791, 605,  1,    0,    0,    0,    4792, 4794, 3,    612,  306,  0,
      4793,  4792, 1,    0,    0,    0,    4793, 4794, 1,    0,    0,    0,    4794, 4796, 1,    0,    0,    0,    4795,
      4797,  3,    614,  307,  0,    4796, 4795, 1,    0,    0,    0,    4796, 4797, 1,    0,    0,    0,    4797, 4801,
      1,     0,    0,    0,    4798, 4800, 3,    616,  308,  0,    4799, 4798, 1,    0,    0,    0,    4800, 4803, 1,
      0,     0,    0,    4801, 4799, 1,    0,    0,    0,    4801, 4802, 1,    0,    0,    0,    4802, 4806, 1,    0,
      0,     0,    4803, 4801, 1,    0,    0,    0,    4804, 4805, 4,    303,  41,   0,    4805, 4807, 3,    608,  304,
      0,     4806, 4804, 1,    0,    0,    0,    4806, 4807, 1,    0,    0,    0,    4807, 607,  1,    0,    0,    0,
      4808,  4809, 5,    797,  0,    0,    4809, 4813, 3,    1378, 689,  0,    4810, 4811, 5,    75,   0,    0,    4811,
      4813,  3,    1378, 689,  0,    4812, 4808, 1,    0,    0,    0,    4812, 4810, 1,    0,    0,    0,    4813, 609,
      1,     0,    0,    0,    4814, 4815, 5,    128,  0,    0,    4815, 4816, 5,    659,  0,    0,    4816, 4817, 3,
      656,   328,  0,    4817, 611,  1,    0,    0,    0,    4818, 4821, 5,    467,  0,    0,    4819, 4822, 3,    648,
      324,   0,    4820, 4822, 7,    77,   0,    0,    4821, 4819, 1,    0,    0,    0,    4821, 4820, 1,    0,    0,
      0,     4822, 613,  1,    0,    0,    0,    4823, 4832, 5,    645,  0,    0,    4824, 4825, 5,    322,  0,    0,
      4825,  4833, 3,    1358, 679,  0,    4826, 4827, 5,    327,  0,    0,    4827, 4833, 3,    1358, 679,  0,    4828,
      4829,  5,    321,  0,    0,    4829, 4833, 3,    1358, 679,  0,    4830, 4831, 5,    328,  0,    0,    4831, 4833,
      3,     1358, 679,  0,    4832, 4824, 1,    0,    0,    0,    4832, 4826, 1,    0,    0,    0,    4832, 4828, 1,
      0,     0,    0,    4832, 4830, 1,    0,    0,    0,    4833, 4834, 1,    0,    0,    0,    4834, 4832, 1,    0,
      0,     0,    4834, 4835, 1,    0,    0,    0,    4835, 615,  1,    0,    0,    0,    4836, 4837, 5,    2,    0,
      0,     4837, 4877, 7,    78,   0,    0,    4838, 4867, 5,    406,  0,    0,    4839, 4846, 5,    177,  0,    0,
      4840,  4841, 5,    247,  0,    0,    4841, 4842, 3,    1360, 680,  0,    4842, 4843, 5,    122,  0,    0,    4843,
      4847,  1,    0,    0,    0,    4844, 4847, 5,    365,  0,    0,    4845, 4847, 5,    128,  0,    0,    4846, 4840,
      1,     0,    0,    0,    4846, 4844, 1,    0,    0,    0,    4846, 4845, 1,    0,    0,    0,    4846, 4847, 1,
      0,     0,    0,    4847, 4868, 1,    0,    0,    0,    4848, 4851, 5,    705,  0,    0,    4849, 4852, 3,    1360,
      680,   0,    4850, 4852, 5,    128,  0,    0,    4851, 4849, 1,    0,    0,    0,    4851, 4850, 1,    0,    0,
      0,     4852, 4868, 1,    0,    0,    0,    4853, 4854, 5,    706,  0,    0,    4854, 4859, 5,    247,  0,    0,
      4855,  4856, 3,    1360, 680,  0,    4856, 4857, 5,    122,  0,    0,    4857, 4860, 1,    0,    0,    0,    4858,
      4860,  5,    128,  0,    0,    4859, 4855, 1,    0,    0,    0,    4859, 4858, 1,    0,    0,    0,    4860, 4868,
      1,     0,    0,    0,    4861, 4862, 4,    308,  42,   0,    4862, 4863, 5,    467,  0,    0,    4863, 4865, 5,
      101,   0,    0,    4864, 4866, 7,    79,   0,    0,    4865, 4864, 1,    0,    0,    0,    4865, 4866, 1,    0,
      0,     0,    4866, 4868, 1,    0,    0,    0,    4867, 4839, 1,    0,    0,    0,    4867, 4848, 1,    0,    0,
      0,     4867, 4853, 1,    0,    0,    0,    4867, 4861, 1,    0,    0,    0,    4868, 4877, 1,    0,    0,    0,
      4869,  4870, 5,    741,  0,    0,    4870, 4877, 3,    1360, 680,  0,    4871, 4874, 5,    740,  0,    0,    4872,
      4875,  3,    1360, 680,  0,    4873, 4875, 5,    698,  0,    0,    4874, 4872, 1,    0,    0,    0,    4874, 4873,
      1,     0,    0,    0,    4875, 4877, 1,    0,    0,    0,    4876, 4836, 1,    0,    0,    0,    4876, 4838, 1,
      0,     0,    0,    4876, 4869, 1,    0,    0,    0,    4876, 4871, 1,    0,    0,    0,    4877, 617,  1,    0,
      0,     0,    4878, 4884, 1,    0,    0,    0,    4879, 4880, 5,    797,  0,    0,    4880, 4884, 3,    1378, 689,
      0,     4881, 4882, 5,    75,   0,    0,    4882, 4884, 3,    1378, 689,  0,    4883, 4878, 1,    0,    0,    0,
      4883,  4879, 1,    0,    0,    0,    4883, 4881, 1,    0,    0,    0,    4884, 619,  1,    0,    0,    0,    4885,
      4886,  5,    148,  0,    0,    4886, 4888, 5,    618,  0,    0,    4887, 4889, 3,    1178, 589,  0,    4888, 4887,
      1,     0,    0,    0,    4888, 4889, 1,    0,    0,    0,    4889, 4890, 1,    0,    0,    0,    4890, 4891, 3,
      1210,  605,  0,    4891, 621,  1,    0,    0,    0,    4892, 4934, 5,    215,  0,    0,    4893, 4894, 3,    642,
      321,   0,    4894, 4895, 5,    590,  0,    0,    4895, 4899, 3,    1210, 605,  0,    4896, 4897, 5,    645,  0,
      0,     4897, 4898, 5,    660,  0,    0,    4898, 4900, 5,    391,  0,    0,    4899, 4896, 1,    0,    0,    0,
      4899,  4900, 1,    0,    0,    0,    4900, 4935, 1,    0,    0,    0,    4901, 4907, 3,    642,  321,  0,    4902,
      4904,  5,    10,   0,    0,    4903, 4905, 5,    421,  0,    0,    4904, 4903, 1,    0,    0,    0,    4904, 4905,
      1,     0,    0,    0,    4905, 4907, 1,    0,    0,    0,    4906, 4901, 1,    0,    0,    0,    4906, 4902, 1,
      0,     0,    0,    4907, 4908, 1,    0,    0,    0,    4908, 4910, 5,    383,  0,    0,    4909, 4911, 3,    640,
      320,   0,    4910, 4909, 1,    0,    0,    0,    4910, 4911, 1,    0,    0,    0,    4911, 4912, 1,    0,    0,
      0,     4912, 4913, 3,    646,  323,  0,    4913, 4914, 5,    590,  0,    0,    4914, 4916, 3,    624,  312,  0,
      4915,  4917, 3,    634,  317,  0,    4916, 4915, 1,    0,    0,    0,    4916, 4917, 1,    0,    0,    0,    4917,
      4919,  1,    0,    0,    0,    4918, 4920, 3,    626,  313,  0,    4919, 4918, 1,    0,    0,    0,    4919, 4920,
      1,     0,    0,    0,    4920, 4922, 1,    0,    0,    0,    4921, 4923, 3,    632,  316,  0,    4922, 4921, 1,
      0,     0,    0,    4922, 4923, 1,    0,    0,    0,    4923, 4935, 1,    0,    0,    0,    4924, 4925, 5,    427,
      0,     0,    4925, 4926, 5,    383,  0,    0,    4926, 4927, 3,    1246, 623,  0,    4927, 4928, 5,    590,  0,
      0,     4928, 4932, 3,    624,  312,  0,    4929, 4930, 5,    645,  0,    0,    4930, 4931, 5,    215,  0,    0,
      4931,  4933, 5,    391,  0,    0,    4932, 4929, 1,    0,    0,    0,    4932, 4933, 1,    0,    0,    0,    4933,
      4935,  1,    0,    0,    0,    4934, 4893, 1,    0,    0,    0,    4934, 4906, 1,    0,    0,    0,    4934, 4924,
      1,     0,    0,    0,    4935, 623,  1,    0,    0,    0,    4936, 4937, 4,    312,  43,   0,    4937, 4941, 3,
      1212,  606,  0,    4938, 4939, 4,    312,  44,   0,    4939, 4941, 3,    1210, 605,  0,    4940, 4936, 1,    0,
      0,     0,    4940, 4938, 1,    0,    0,    0,    4941, 625,  1,    0,    0,    0,    4942, 4943, 5,    645,  0,
      0,     4943, 4948, 3,    652,  326,  0,    4944, 4945, 4,    313,  45,   0,    4945, 4947, 3,    652,  326,  0,
      4946,  4944, 1,    0,    0,    0,    4947, 4950, 1,    0,    0,    0,    4948, 4946, 1,    0,    0,    0,    4948,
      4949,  1,    0,    0,    0,    4949, 627,  1,    0,    0,    0,    4950, 4948, 1,    0,    0,    0,    4951, 4952,
      5,     663,  0,    0,    4952, 4953, 3,    656,  328,  0,    4953, 629,  1,    0,    0,    0,    4954, 4955, 5,
      645,   0,    0,    4955, 4963, 5,    659,  0,    0,    4956, 4964, 3,    656,  328,  0,    4957, 4959, 5,    10,
      0,     0,    4958, 4960, 3,    628,  314,  0,    4959, 4958, 1,    0,    0,    0,    4959, 4960, 1,    0,    0,
      0,     4960, 4964, 1,    0,    0,    0,    4961, 4964, 5,    369,  0,    0,    4962, 4964, 5,    128,  0,    0,
      4963,  4956, 1,    0,    0,    0,    4963, 4957, 1,    0,    0,    0,    4963, 4961, 1,    0,    0,    0,    4963,
      4962,  1,    0,    0,    0,    4964, 631,  1,    0,    0,    0,    4965, 4966, 5,    17,   0,    0,    4966, 4968,
      5,     618,  0,    0,    4967, 4969, 3,    630,  315,  0,    4968, 4967, 1,    0,    0,    0,    4968, 4969, 1,
      0,     0,    0,    4969, 633,  1,    0,    0,    0,    4970, 4971, 4,    317,  46,   0,    4971, 4972, 3,    612,
      306,   0,    4972, 635,  1,    0,    0,    0,    4973, 4974, 5,    453,  0,    0,    4974, 4975, 5,    618,  0,
      0,     4975, 4976, 3,    1246, 623,  0,    4976, 4977, 5,    590,  0,    0,    4977, 4985, 3,    1246, 623,  0,
      4978,  4979, 5,    773,  0,    0,    4979, 4980, 3,    1246, 623,  0,    4980, 4981, 5,    590,  0,    0,    4981,
      4982,  3,    1246, 623,  0,    4982, 4984, 1,    0,    0,    0,    4983, 4978, 1,    0,    0,    0,    4984, 4987,
      1,     0,    0,    0,    4985, 4983, 1,    0,    0,    0,    4985, 4986, 1,    0,    0,    0,    4986, 637,  1,
      0,     0,    0,    4987, 4985, 1,    0,    0,    0,    4988, 4991, 5,    477,  0,    0,    4989, 4990, 4,    319,
      47,    0,    4990, 4992, 3,    1178, 589,  0,    4991, 4989, 1,    0,    0,    0,    4991, 4992, 1,    0,    0,
      0,     4992, 5028, 1,    0,    0,    0,    4993, 4994, 3,    642,  321,  0,    4994, 4995, 5,    203,  0,    0,
      4995,  4996, 3,    1210, 605,  0,    4996, 5029, 1,    0,    0,    0,    4997, 4998, 3,    642,  321,  0,    4998,
      5000,  5,    383,  0,    0,    4999, 5001, 3,    640,  320,  0,    5000, 4999, 1,    0,    0,    0,    5000, 5001,
      1,     0,    0,    0,    5001, 5002, 1,    0,    0,    0,    5002, 5003, 3,    646,  323,  0,    5003, 5004, 5,
      203,   0,    0,    5004, 5005, 3,    1210, 605,  0,    5005, 5029, 1,    0,    0,    0,    5006, 5008, 5,    10,
      0,     0,    5007, 5009, 5,    421,  0,    0,    5008, 5007, 1,    0,    0,    0,    5008, 5009, 1,    0,    0,
      0,     5009, 5018, 1,    0,    0,    0,    5010, 5012, 5,    383,  0,    0,    5011, 5013, 3,    640,  320,  0,
      5012,  5011, 1,    0,    0,    0,    5012, 5013, 1,    0,    0,    0,    5013, 5014, 1,    0,    0,    0,    5014,
      5019,  3,    646,  323,  0,    5015, 5016, 5,    773,  0,    0,    5016, 5017, 5,    215,  0,    0,    5017, 5019,
      5,     391,  0,    0,    5018, 5010, 1,    0,    0,    0,    5018, 5015, 1,    0,    0,    0,    5019, 5020, 1,
      0,     0,    0,    5020, 5021, 5,    203,  0,    0,    5021, 5029, 3,    1210, 605,  0,    5022, 5023, 5,    427,
      0,     0,    5023, 5024, 5,    383,  0,    0,    5024, 5025, 3,    1246, 623,  0,    5025, 5026, 5,    203,  0,
      0,     5026, 5027, 3,    1210, 605,  0,    5027, 5029, 1,    0,    0,    0,    5028, 4993, 1,    0,    0,    0,
      5028,  4997, 1,    0,    0,    0,    5028, 5006, 1,    0,    0,    0,    5028, 5022, 1,    0,    0,    0,    5029,
      5032,  1,    0,    0,    0,    5030, 5031, 4,    319,  48,   0,    5031, 5033, 3,    1182, 591,  0,    5032, 5030,
      1,     0,    0,    0,    5032, 5033, 1,    0,    0,    0,    5033, 639,  1,    0,    0,    0,    5034, 5035, 7,
      80,    0,    0,    5035, 641,  1,    0,    0,    0,    5036, 5041, 3,    644,  322,  0,    5037, 5038, 5,    773,
      0,     0,    5038, 5040, 3,    644,  322,  0,    5039, 5037, 1,    0,    0,    0,    5040, 5043, 1,    0,    0,
      0,     5041, 5039, 1,    0,    0,    0,    5041, 5042, 1,    0,    0,    0,    5042, 643,  1,    0,    0,    0,
      5043,  5041, 1,    0,    0,    0,    5044, 5046, 3,    1410, 705,  0,    5045, 5047, 3,    1264, 632,  0,    5046,
      5045,  1,    0,    0,    0,    5046, 5047, 1,    0,    0,    0,    5047, 5055, 1,    0,    0,    0,    5048, 5052,
      3,     1410, 705,  0,    5049, 5053, 5,    784,  0,    0,    5050, 5051, 5,    783,  0,    0,    5051, 5053, 3,
      1406,  703,  0,    5052, 5049, 1,    0,    0,    0,    5052, 5050, 1,    0,    0,    0,    5053, 5055, 1,    0,
      0,     0,    5054, 5044, 1,    0,    0,    0,    5054, 5048, 1,    0,    0,    0,    5055, 5087, 1,    0,    0,
      0,     5056, 5058, 7,    81,   0,    0,    5057, 5059, 3,    1264, 632,  0,    5058, 5057, 1,    0,    0,    0,
      5058,  5059, 1,    0,    0,    0,    5059, 5087, 1,    0,    0,    0,    5060, 5087, 7,    82,   0,    0,    5061,
      5062,  5,    215,  0,    0,    5062, 5087, 5,    391,  0,    0,    5063, 5064, 5,    509,  0,    0,    5064, 5087,
      5,     110,  0,    0,    5065, 5069, 5,    97,   0,    0,    5066, 5067, 5,    577,  0,    0,    5067, 5070, 5,
      571,   0,    0,    5068, 5070, 7,    83,   0,    0,    5069, 5066, 1,    0,    0,    0,    5069, 5068, 1,    0,
      0,     0,    5069, 5070, 1,    0,    0,    0,    5070, 5087, 1,    0,    0,    0,    5071, 5072, 5,    287,  0,
      0,     5072, 5087, 5,    571,  0,    0,    5073, 5076, 5,    459,  0,    0,    5074, 5077, 5,    65,   0,    0,
      5075,  5077, 3,    578,  289,  0,    5076, 5074, 1,    0,    0,    0,    5076, 5075, 1,    0,    0,    0,    5077,
      5087,  1,    0,    0,    0,    5078, 5079, 5,    509,  0,    0,    5079, 5087, 5,    636,  0,    0,    5080, 5082,
      5,     11,   0,    0,    5081, 5083, 5,    483,  0,    0,    5082, 5081, 1,    0,    0,    0,    5082, 5083, 1,
      0,     0,    0,    5083, 5087, 1,    0,    0,    0,    5084, 5085, 7,    84,   0,    0,    5085, 5087, 5,    659,
      0,     0,    5086, 5054, 1,    0,    0,    0,    5086, 5056, 1,    0,    0,    0,    5086, 5060, 1,    0,    0,
      0,     5086, 5061, 1,    0,    0,    0,    5086, 5063, 1,    0,    0,    0,    5086, 5065, 1,    0,    0,    0,
      5086,  5071, 1,    0,    0,    0,    5086, 5073, 1,    0,    0,    0,    5086, 5078, 1,    0,    0,    0,    5086,
      5080,  1,    0,    0,    0,    5086, 5084, 1,    0,    0,    0,    5087, 645,  1,    0,    0,    0,    5088, 5091,
      5,     760,  0,    0,    5089, 5090, 5,    772,  0,    0,    5090, 5092, 5,    760,  0,    0,    5091, 5089, 1,
      0,     0,    0,    5091, 5092, 1,    0,    0,    0,    5092, 5105, 1,    0,    0,    0,    5093, 5096, 3,    1278,
      639,   0,    5094, 5095, 5,    772,  0,    0,    5095, 5097, 5,    760,  0,    0,    5096, 5094, 1,    0,    0,
      0,     5096, 5097, 1,    0,    0,    0,    5097, 5105, 1,    0,    0,    0,    5098, 5105, 3,    1322, 661,  0,
      5099,  5100, 4,    323,  49,   0,    5100, 5101, 3,    1278, 639,  0,    5101, 5102, 5,    772,  0,    0,    5102,
      5103,  3,    1322, 661,  0,    5103, 5105, 1,    0,    0,    0,    5104, 5088, 1,    0,    0,    0,    5104, 5093,
      1,     0,    0,    0,    5104, 5098, 1,    0,    0,    0,    5104, 5099, 1,    0,    0,    0,    5105, 647,  1,
      0,     0,    0,    5106, 5113, 3,    650,  325,  0,    5107, 5109, 5,    15,   0,    0,    5108, 5107, 1,    0,
      0,     0,    5108, 5109, 1,    0,    0,    0,    5109, 5110, 1,    0,    0,    0,    5110, 5112, 3,    650,  325,
      0,     5111, 5108, 1,    0,    0,    0,    5112, 5115, 1,    0,    0,    0,    5113, 5111, 1,    0,    0,    0,
      5113,  5114, 1,    0,    0,    0,    5114, 649,  1,    0,    0,    0,    5115, 5113, 1,    0,    0,    0,    5116,
      5117,  5,    63,   0,    0,    5117, 5123, 3,    1380, 690,  0,    5118, 5119, 5,    259,  0,    0,    5119, 5123,
      3,     1380, 690,  0,    5120, 5121, 5,    559,  0,    0,    5121, 5123, 3,    1380, 690,  0,    5122, 5116, 1,
      0,     0,    0,    5122, 5118, 1,    0,    0,    0,    5122, 5120, 1,    0,    0,    0,    5123, 651,  1,    0,
      0,     0,    5124, 5125, 5,    215,  0,    0,    5125, 5138, 5,    391,  0,    0,    5126, 5135, 4,    326,  50,
      0,     5127, 5128, 5,    322,  0,    0,    5128, 5136, 3,    1358, 679,  0,    5129, 5130, 5,    327,  0,    0,
      5130,  5136, 3,    1358, 679,  0,    5131, 5132, 5,    321,  0,    0,    5132, 5136, 3,    1358, 679,  0,    5133,
      5134,  5,    328,  0,    0,    5134, 5136, 3,    1358, 679,  0,    5135, 5127, 1,    0,    0,    0,    5135, 5129,
      1,     0,    0,    0,    5135, 5131, 1,    0,    0,    0,    5135, 5133, 1,    0,    0,    0,    5136, 5138, 1,
      0,     0,    0,    5137, 5124, 1,    0,    0,    0,    5137, 5126, 1,    0,    0,    0,    5138, 653,  1,    0,
      0,     0,    5139, 5140, 5,    506,  0,    0,    5140, 5141, 5,    659,  0,    0,    5141, 5163, 3,    656,  328,
      0,     5142, 5143, 5,    506,  0,    0,    5143, 5144, 5,    659,  0,    0,    5144, 5163, 7,    85,   0,    0,
      5145,  5146, 5,    506,  0,    0,    5146, 5147, 5,    128,  0,    0,    5147, 5151, 5,    659,  0,    0,    5148,
      5152,  3,    656,  328,  0,    5149, 5152, 5,    369,  0,    0,    5150, 5152, 5,    10,   0,    0,    5151, 5148,
      1,     0,    0,    0,    5151, 5149, 1,    0,    0,    0,    5151, 5150, 1,    0,    0,    0,    5152, 5153, 1,
      0,     0,    0,    5153, 5154, 5,    590,  0,    0,    5154, 5163, 3,    656,  328,  0,    5155, 5156, 5,    506,
      0,     0,    5156, 5157, 5,    659,  0,    0,    5157, 5160, 5,    10,   0,    0,    5158, 5159, 5,    663,  0,
      0,     5159, 5161, 3,    656,  328,  0,    5160, 5158, 1,    0,    0,    0,    5160, 5161, 1,    0,    0,    0,
      5161,  5163, 1,    0,    0,    0,    5162, 5139, 1,    0,    0,    0,    5162, 5142, 1,    0,    0,    0,    5162,
      5145,  1,    0,    0,    0,    5162, 5155, 1,    0,    0,    0,    5163, 655,  1,    0,    0,    0,    5164, 5169,
      3,     658,  329,  0,    5165, 5166, 5,    773,  0,    0,    5166, 5168, 3,    658,  329,  0,    5167, 5165, 1,
      0,     0,    0,    5168, 5171, 1,    0,    0,    0,    5169, 5167, 1,    0,    0,    0,    5169, 5170, 1,    0,
      0,     0,    5170, 657,  1,    0,    0,    0,    5171, 5169, 1,    0,    0,    0,    5172, 5174, 3,    1410, 705,
      0,     5173, 5175, 3,    930,  465,  0,    5174, 5173, 1,    0,    0,    0,    5174, 5175, 1,    0,    0,    0,
      5175,  659,  1,    0,    0,    0,    5176, 5178, 5,    14,   0,    0,    5177, 5179, 3,    1254, 627,  0,    5178,
      5177,  1,    0,    0,    0,    5178, 5179, 1,    0,    0,    0,    5179, 5180, 1,    0,    0,    0,    5180, 5181,
      5,     574,  0,    0,    5181, 5183, 3,    1324, 662,  0,    5182, 5184, 3,    662,  331,  0,    5183, 5182, 1,
      0,     0,    0,    5183, 5184, 1,    0,    0,    0,    5184, 5219, 1,    0,    0,    0,    5185, 5186, 5,    62,
      0,     0,    5186, 5187, 5,    574,  0,    0,    5187, 5191, 3,    1324, 662,  0,    5188, 5190, 3,    664,  332,
      0,     5189, 5188, 1,    0,    0,    0,    5190, 5193, 1,    0,    0,    0,    5191, 5189, 1,    0,    0,    0,
      5191,  5192, 1,    0,    0,    0,    5192, 5219, 1,    0,    0,    0,    5193, 5191, 1,    0,    0,    0,    5194,
      5195,  5,    61,   0,    0,    5195, 5196, 5,    574,  0,    0,    5196, 5198, 3,    1324, 662,  0,    5197, 5199,
      7,     86,   0,    0,    5198, 5197, 1,    0,    0,    0,    5198, 5199, 1,    0,    0,    0,    5199, 5219, 1,
      0,     0,    0,    5200, 5202, 5,    388,  0,    0,    5201, 5203, 3,    1254, 627,  0,    5202, 5201, 1,    0,
      0,     0,    5202, 5203, 1,    0,    0,    0,    5203, 5204, 1,    0,    0,    0,    5204, 5205, 5,    574,  0,
      0,     5205, 5219, 3,    1324, 662,  0,    5206, 5208, 5,    455,  0,    0,    5207, 5209, 3,    1254, 627,  0,
      5208,  5207, 1,    0,    0,    0,    5208, 5209, 1,    0,    0,    0,    5209, 5210, 1,    0,    0,    0,    5210,
      5211,  5,    574,  0,    0,    5211, 5215, 3,    1324, 662,  0,    5212, 5214, 3,    666,  333,  0,    5213, 5212,
      1,     0,    0,    0,    5214, 5217, 1,    0,    0,    0,    5215, 5213, 1,    0,    0,    0,    5215, 5216, 1,
      0,     0,    0,    5216, 5219, 1,    0,    0,    0,    5217, 5215, 1,    0,    0,    0,    5218, 5176, 1,    0,
      0,     0,    5218, 5185, 1,    0,    0,    0,    5218, 5194, 1,    0,    0,    0,    5218, 5200, 1,    0,    0,
      0,     5218, 5206, 1,    0,    0,    0,    5219, 661,  1,    0,    0,    0,    5220, 5221, 5,    614,  0,    0,
      5221,  5222, 5,    674,  0,    0,    5222, 5223, 5,    383,  0,    0,    5223, 5231, 3,    1348, 674,  0,    5224,
      5225,  5,    645,  0,    0,    5225, 5226, 5,    747,  0,    0,    5226, 5232, 5,    675,  0,    0,    5227, 5228,
      4,     331,  51,   0,    5228, 5229, 5,    621,  0,    0,    5229, 5230, 5,    112,  0,    0,    5230, 5232, 3,
      1378,  689,  0,    5231, 5224, 1,    0,    0,    0,    5231, 5227, 1,    0,    0,    0,    5231, 5232, 1,    0,
      0,     0,    5232, 5238, 1,    0,    0,    0,    5233, 5234, 5,    148,  0,    0,    5234, 5235, 5,    674,  0,
      0,     5235, 5236, 5,    383,  0,    0,    5236, 5238, 3,    1348, 674,  0,    5237, 5220, 1,    0,    0,    0,
      5237,  5233, 1,    0,    0,    0,    5238, 663,  1,    0,    0,    0,    5239, 5240, 5,    200,  0,    0,    5240,
      5243,  5,    615,  0,    0,    5241, 5243, 7,    87,   0,    0,    5242, 5239, 1,    0,    0,    0,    5242, 5241,
      1,     0,    0,    0,    5243, 665,  1,    0,    0,    0,    5244, 5245, 7,    88,   0,    0,    5245, 667,  1,
      0,     0,    0,    5246, 5247, 5,    245,  0,    0,    5247, 5248, 5,    410,  0,    0,    5248, 5249, 3,    1346,
      673,   0,    5249, 5250, 5,    520,  0,    0,    5250, 5251, 3,    1378, 689,  0,    5251, 5269, 1,    0,    0,
      0,     5252, 5253, 5,    245,  0,    0,    5253, 5254, 5,    664,  0,    0,    5254, 5269, 3,    1388, 694,  0,
      5255,  5256, 5,    607,  0,    0,    5256, 5257, 5,    410,  0,    0,    5257, 5269, 3,    1336, 668,  0,    5258,
      5259,  5,    607,  0,    0,    5259, 5260, 5,    664,  0,    0,    5260, 5265, 3,    1338, 669,  0,    5261, 5262,
      5,     773,  0,    0,    5262, 5264, 3,    1338, 669,  0,    5263, 5261, 1,    0,    0,    0,    5264, 5267, 1,
      0,     0,    0,    5265, 5263, 1,    0,    0,    0,    5265, 5266, 1,    0,    0,    0,    5266, 5269, 1,    0,
      0,     0,    5267, 5265, 1,    0,    0,    0,    5268, 5246, 1,    0,    0,    0,    5268, 5252, 1,    0,    0,
      0,     5268, 5255, 1,    0,    0,    0,    5268, 5258, 1,    0,    0,    0,    5269, 669,  1,    0,    0,    0,
      5270,  5271, 5,    506,  0,    0,    5271, 5272, 3,    672,  336,  0,    5272, 671,  1,    0,    0,    0,    5273,
      5274,  3,    682,  341,  0,    5274, 5275, 3,    680,  340,  0,    5275, 5324, 1,    0,    0,    0,    5276, 5277,
      5,     592,  0,    0,    5277, 5324, 3,    674,  337,  0,    5278, 5279, 3,    1418, 709,  0,    5279, 5280, 3,
      688,   344,  0,    5280, 5324, 1,    0,    0,    0,    5281, 5284, 5,    406,  0,    0,    5282, 5283, 5,    200,
      0,     0,    5283, 5285, 3,    1246, 623,  0,    5284, 5282, 1,    0,    0,    0,    5284, 5285, 1,    0,    0,
      0,     5285, 5286, 1,    0,    0,    0,    5286, 5307, 3,    1416, 708,  0,    5287, 5289, 3,    1380, 690,  0,
      5288,  5290, 3,    1242, 621,  0,    5289, 5288, 1,    0,    0,    0,    5289, 5290, 1,    0,    0,    0,    5290,
      5292,  1,    0,    0,    0,    5291, 5293, 3,    1234, 617,  0,    5292, 5291, 1,    0,    0,    0,    5292, 5293,
      1,     0,    0,    0,    5293, 5308, 1,    0,    0,    0,    5294, 5296, 3,    1380, 690,  0,    5295, 5297, 3,
      1242,  621,  0,    5296, 5295, 1,    0,    0,    0,    5296, 5297, 1,    0,    0,    0,    5297, 5299, 1,    0,
      0,     0,    5298, 5300, 3,    1234, 617,  0,    5299, 5298, 1,    0,    0,    0,    5299, 5300, 1,    0,    0,
      0,     5300, 5308, 1,    0,    0,    0,    5301, 5302, 4,    336,  52,   0,    5302, 5303, 5,    406,  0,    0,
      5303,  5304, 5,    776,  0,    0,    5304, 5305, 3,    1380, 690,  0,    5305, 5306, 5,    777,  0,    0,    5306,
      5308,  1,    0,    0,    0,    5307, 5287, 1,    0,    0,    0,    5307, 5294, 1,    0,    0,    0,    5307, 5301,
      1,     0,    0,    0,    5308, 5324, 1,    0,    0,    0,    5309, 5310, 4,    336,  53,   0,    5310, 5313, 5,
      406,   0,    0,    5311, 5312, 5,    200,  0,    0,    5312, 5314, 3,    1246, 623,  0,    5313, 5311, 1,    0,
      0,     0,    5313, 5314, 1,    0,    0,    0,    5314, 5315, 1,    0,    0,    0,    5315, 5316, 5,    590,  0,
      0,     5316, 5318, 5,    734,  0,    0,    5317, 5319, 3,    1242, 621,  0,    5318, 5317, 1,    0,    0,    0,
      5318,  5319, 1,    0,    0,    0,    5319, 5321, 1,    0,    0,    0,    5320, 5322, 3,    1234, 617,  0,    5321,
      5320,  1,    0,    0,    0,    5321, 5322, 1,    0,    0,    0,    5322, 5324, 1,    0,    0,    0,    5323, 5273,
      1,     0,    0,    0,    5323, 5276, 1,    0,    0,    0,    5323, 5278, 1,    0,    0,    0,    5323, 5281, 1,
      0,     0,    0,    5323, 5309, 1,    0,    0,    0,    5324, 673,  1,    0,    0,    0,    5325, 5327, 3,    676,
      338,   0,    5326, 5328, 3,    678,  339,  0,    5327, 5326, 1,    0,    0,    0,    5327, 5328, 1,    0,    0,
      0,     5328, 5335, 1,    0,    0,    0,    5329, 5332, 3,    678,  339,  0,    5330, 5331, 5,    773,  0,    0,
      5331,  5333, 3,    676,  338,  0,    5332, 5330, 1,    0,    0,    0,    5332, 5333, 1,    0,    0,    0,    5333,
      5335,  1,    0,    0,    0,    5334, 5325, 1,    0,    0,    0,    5334, 5329, 1,    0,    0,    0,    5335, 675,
      1,     0,    0,    0,    5336, 5337, 5,    435,  0,    0,    5337, 5338, 7,    40,   0,    0,    5338, 677,  1,
      0,     0,    0,    5339, 5340, 5,    258,  0,    0,    5340, 5346, 5,    274,  0,    0,    5341, 5342, 5,    456,
      0,     0,    5342, 5347, 5,    435,  0,    0,    5343, 5344, 5,    435,  0,    0,    5344, 5347, 7,    89,   0,
      0,     5345, 5347, 5,    500,  0,    0,    5346, 5341, 1,    0,    0,    0,    5346, 5343, 1,    0,    0,    0,
      5346,  5345, 1,    0,    0,    0,    5347, 679,  1,    0,    0,    0,    5348, 5349, 5,    773,  0,    0,    5349,
      5351,  3,    684,  342,  0,    5350, 5348, 1,    0,    0,    0,    5351, 5354, 1,    0,    0,    0,    5352, 5350,
      1,     0,    0,    0,    5352, 5353, 1,    0,    0,    0,    5353, 681,  1,    0,    0,    0,    5354, 5352, 1,
      0,     0,    0,    5355, 5356, 3,    936,  468,  0,    5356, 5357, 3,    1416, 708,  0,    5357, 5358, 3,    692,
      346,   0,    5358, 5385, 1,    0,    0,    0,    5359, 5385, 3,    1200, 600,  0,    5360, 5361, 3,    930,  465,
      0,     5361, 5362, 3,    1416, 708,  0,    5362, 5363, 3,    860,  430,  0,    5363, 5385, 1,    0,    0,    0,
      5364,  5366, 5,    785,  0,    0,    5365, 5367, 3,    1422, 711,  0,    5366, 5365, 1,    0,    0,    0,    5366,
      5367,  1,    0,    0,    0,    5367, 5368, 1,    0,    0,    0,    5368, 5369, 3,    936,  468,  0,    5369, 5370,
      3,     1416, 708,  0,    5370, 5371, 3,    692,  346,  0,    5371, 5385, 1,    0,    0,    0,    5372, 5382, 5,
      356,   0,    0,    5373, 5374, 3,    1416, 708,  0,    5374, 5375, 3,    860,  430,  0,    5375, 5383, 1,    0,
      0,     0,    5376, 5378, 3,    1132, 566,  0,    5377, 5379, 3,    1188, 594,  0,    5378, 5377, 1,    0,    0,
      0,     5378, 5379, 1,    0,    0,    0,    5379, 5383, 1,    0,    0,    0,    5380, 5381, 4,    341,  54,   0,
      5381,  5383, 5,    128,  0,    0,    5382, 5373, 1,    0,    0,    0,    5382, 5376, 1,    0,    0,    0,    5382,
      5380,  1,    0,    0,    0,    5383, 5385, 1,    0,    0,    0,    5384, 5355, 1,    0,    0,    0,    5384, 5359,
      1,     0,    0,    0,    5384, 5360, 1,    0,    0,    0,    5384, 5364, 1,    0,    0,    0,    5384, 5372, 1,
      0,     0,    0,    5385, 683,  1,    0,    0,    0,    5386, 5387, 3,    1418, 709,  0,    5387, 5388, 3,    936,
      468,   0,    5388, 5389, 3,    1416, 708,  0,    5389, 5390, 3,    692,  346,  0,    5390, 5393, 1,    0,    0,
      0,     5391, 5393, 3,    682,  341,  0,    5392, 5386, 1,    0,    0,    0,    5392, 5391, 1,    0,    0,    0,
      5393,  685,  1,    0,    0,    0,    5394, 5396, 5,    785,  0,    0,    5395, 5397, 3,    1422, 711,  0,    5396,
      5395,  1,    0,    0,    0,    5396, 5397, 1,    0,    0,    0,    5397, 5398, 1,    0,    0,    0,    5398, 5399,
      3,     936,  468,  0,    5399, 687,  1,    0,    0,    0,    5400, 5401, 3,    690,  345,  0,    5401, 5402, 3,
      680,   340,  0,    5402, 5406, 1,    0,    0,    0,    5403, 5404, 5,    592,  0,    0,    5404, 5406, 3,    674,
      337,   0,    5405, 5400, 1,    0,    0,    0,    5405, 5403, 1,    0,    0,    0,    5406, 689,  1,    0,    0,
      0,     5407, 5408, 3,    936,  468,  0,    5408, 5409, 3,    1416, 708,  0,    5409, 5410, 3,    692,  346,  0,
      5410,  691,  1,    0,    0,    0,    5411, 5419, 3,    860,  430,  0,    5412, 5419, 5,    128,  0,    0,    5413,
      5419,  5,    383,  0,    0,    5414, 5419, 5,    10,   0,    0,    5415, 5419, 5,    32,   0,    0,    5416, 5419,
      5,     487,  0,    0,    5417, 5419, 5,    710,  0,    0,    5418, 5411, 1,    0,    0,    0,    5418, 5412, 1,
      0,     0,    0,    5418, 5413, 1,    0,    0,    0,    5418, 5414, 1,    0,    0,    0,    5418, 5415, 1,    0,
      0,     0,    5418, 5416, 1,    0,    0,    0,    5418, 5417, 1,    0,    0,    0,    5419, 693,  1,    0,    0,
      0,     5420, 5421, 5,    509,  0,    0,    5421, 5423, 5,    110,  0,    0,    5422, 5424, 3,    1250, 625,  0,
      5423,  5422, 1,    0,    0,    0,    5423, 5424, 1,    0,    0,    0,    5424, 695,  1,    0,    0,    0,    5425,
      5427,  5,    509,  0,    0,    5426, 5428, 3,    782,  391,  0,    5427, 5426, 1,    0,    0,    0,    5427, 5428,
      1,     0,    0,    0,    5428, 5429, 1,    0,    0,    0,    5429, 5431, 5,    571,  0,    0,    5430, 5432, 3,
      788,   394,  0,    5431, 5430, 1,    0,    0,    0,    5431, 5432, 1,    0,    0,    0,    5432, 5434, 1,    0,
      0,     0,    5433, 5435, 3,    1250, 625,  0,    5434, 5433, 1,    0,    0,    0,    5434, 5435, 1,    0,    0,
      0,     5435, 697,  1,    0,    0,    0,    5436, 5438, 5,    509,  0,    0,    5437, 5439, 5,    204,  0,    0,
      5438,  5437, 1,    0,    0,    0,    5438, 5439, 1,    0,    0,    0,    5439, 5440, 1,    0,    0,    0,    5440,
      5442,  5,    593,  0,    0,    5441, 5443, 3,    788,  394,  0,    5442, 5441, 1,    0,    0,    0,    5442, 5443,
      1,     0,    0,    0,    5443, 5445, 1,    0,    0,    0,    5444, 5446, 3,    1250, 625,  0,    5445, 5444, 1,
      0,     0,    0,    5445, 5446, 1,    0,    0,    0,    5446, 699,  1,    0,    0,    0,    5447, 5448, 5,    509,
      0,     0,    5448, 5450, 5,    169,  0,    0,    5449, 5451, 3,    788,  394,  0,    5450, 5449, 1,    0,    0,
      0,     5450, 5451, 1,    0,    0,    0,    5451, 5453, 1,    0,    0,    0,    5452, 5454, 3,    1250, 625,  0,
      5453,  5452, 1,    0,    0,    0,    5453, 5454, 1,    0,    0,    0,    5454, 701,  1,    0,    0,    0,    5455,
      5456,  5,    509,  0,    0,    5456, 5457, 5,    574,  0,    0,    5457, 5459, 5,    547,  0,    0,    5458, 5460,
      3,     788,  394,  0,    5459, 5458, 1,    0,    0,    0,    5459, 5460, 1,    0,    0,    0,    5460, 5462, 1,
      0,     0,    0,    5461, 5463, 3,    1250, 625,  0,    5462, 5461, 1,    0,    0,    0,    5462, 5463, 1,    0,
      0,     0,    5463, 703,  1,    0,    0,    0,    5464, 5465, 5,    509,  0,    0,    5465, 5466, 5,    387,  0,
      0,     5466, 5468, 5,    571,  0,    0,    5467, 5469, 3,    788,  394,  0,    5468, 5467, 1,    0,    0,    0,
      5468,  5469, 1,    0,    0,    0,    5469, 5471, 1,    0,    0,    0,    5470, 5472, 3,    1250, 625,  0,    5471,
      5470,  1,    0,    0,    0,    5471, 5472, 1,    0,    0,    0,    5472, 705,  1,    0,    0,    0,    5473, 5474,
      5,     509,  0,    0,    5474, 5475, 5,    408,  0,    0,    5475, 707,  1,    0,    0,    0,    5476, 5477, 5,
      509,   0,    0,    5477, 5478, 5,    163,  0,    0,    5478, 5479, 3,    784,  392,  0,    5479, 5480, 5,    289,
      0,     0,    5480, 709,  1,    0,    0,    0,    5481, 5482, 5,    509,  0,    0,    5482, 5483, 5,    163,  0,
      0,     5483, 5484, 3,    784,  392,  0,    5484, 5485, 5,    354,  0,    0,    5485, 711,  1,    0,    0,    0,
      5486,  5487, 5,    509,  0,    0,    5487, 5488, 5,    163,  0,    0,    5488, 5489, 3,    784,  392,  0,    5489,
      5490,  5,    547,  0,    0,    5490, 713,  1,    0,    0,    0,    5491, 5493, 5,    509,  0,    0,    5492, 5494,
      3,     782,  391,  0,    5493, 5492, 1,    0,    0,    0,    5493, 5494, 1,    0,    0,    0,    5494, 5495, 1,
      0,     0,    0,    5495, 5496, 5,    71,   0,    0,    5496, 5497, 7,    90,   0,    0,    5497, 5499, 3,    1322,
      661,   0,    5498, 5500, 3,    788,  394,  0,    5499, 5498, 1,    0,    0,    0,    5499, 5500, 1,    0,    0,
      0,     5500, 5502, 1,    0,    0,    0,    5501, 5503, 3,    1250, 625,  0,    5502, 5501, 1,    0,    0,    0,
      5502,  5503, 1,    0,    0,    0,    5503, 715,  1,    0,    0,    0,    5504, 5505, 5,    509,  0,    0,    5505,
      5506,  7,    44,   0,    0,    5506, 5507, 5,    289,  0,    0,    5507, 717,  1,    0,    0,    0,    5508, 5513,
      5,     509,  0,    0,    5509, 5510, 3,    578,  289,  0,    5510, 5511, 5,    225,  0,    0,    5511, 5514, 1,
      0,     0,    0,    5512, 5514, 5,    804,  0,    0,    5513, 5509, 1,    0,    0,    0,    5513, 5512, 1,    0,
      0,     0,    5514, 719,  1,    0,    0,    0,    5515, 5516, 5,    509,  0,    0,    5516, 5517, 5,    33,   0,
      0,     5517, 5520, 5,    169,  0,    0,    5518, 5519, 5,    251,  0,    0,    5519, 5521, 3,    1380, 690,  0,
      5520,  5518, 1,    0,    0,    0,    5520, 5521, 1,    0,    0,    0,    5521, 5524, 1,    0,    0,    0,    5522,
      5523,  5,    203,  0,    0,    5523, 5525, 3,    1362, 681,  0,    5524, 5522, 1,    0,    0,    0,    5524, 5525,
      1,     0,    0,    0,    5525, 5527, 1,    0,    0,    0,    5526, 5528, 3,    294,  147,  0,    5527, 5526, 1,
      0,     0,    0,    5527, 5528, 1,    0,    0,    0,    5528, 5530, 1,    0,    0,    0,    5529, 5531, 3,    974,
      487,   0,    5530, 5529, 1,    0,    0,    0,    5530, 5531, 1,    0,    0,    0,    5531, 721,  1,    0,    0,
      0,     5532, 5533, 5,    509,  0,    0,    5533, 5534, 5,    446,  0,    0,    5534, 5537, 5,    169,  0,    0,
      5535,  5536, 5,    251,  0,    0,    5536, 5538, 3,    1380, 690,  0,    5537, 5535, 1,    0,    0,    0,    5537,
      5538,  1,    0,    0,    0,    5538, 5541, 1,    0,    0,    0,    5539, 5540, 5,    203,  0,    0,    5540, 5542,
      3,     1362, 681,  0,    5541, 5539, 1,    0,    0,    0,    5541, 5542, 1,    0,    0,    0,    5542, 5544, 1,
      0,     0,    0,    5543, 5545, 3,    294,  147,  0,    5544, 5543, 1,    0,    0,    0,    5544, 5545, 1,    0,
      0,     0,    5545, 5547, 1,    0,    0,    0,    5546, 5548, 3,    974,  487,  0,    5547, 5546, 1,    0,    0,
      0,     5547, 5548, 1,    0,    0,    0,    5548, 723,  1,    0,    0,    0,    5549, 5551, 5,    509,  0,    0,
      5550,  5552, 5,    180,  0,    0,    5551, 5550, 1,    0,    0,    0,    5551, 5552, 1,    0,    0,    0,    5552,
      5553,  1,    0,    0,    0,    5553, 5554, 7,    91,   0,    0,    5554, 5555, 3,    786,  393,  0,    5555, 5557,
      3,     1322, 661,  0,    5556, 5558, 3,    788,  394,  0,    5557, 5556, 1,    0,    0,    0,    5557, 5558, 1,
      0,     0,    0,    5558, 5560, 1,    0,    0,    0,    5559, 5561, 3,    368,  184,  0,    5560, 5559, 1,    0,
      0,     0,    5560, 5561, 1,    0,    0,    0,    5561, 725,  1,    0,    0,    0,    5562, 5564, 5,    509,  0,
      0,     5563, 5565, 5,    553,  0,    0,    5564, 5563, 1,    0,    0,    0,    5564, 5565, 1,    0,    0,    0,
      5565,  5566, 1,    0,    0,    0,    5566, 5567, 5,    162,  0,    0,    5567, 727,  1,    0,    0,    0,    5568,
      5569,  5,    509,  0,    0,    5569, 5570, 5,    95,   0,    0,    5570, 5571, 5,    776,  0,    0,    5571, 5572,
      5,     760,  0,    0,    5572, 5573, 5,    777,  0,    0,    5573, 5574, 5,    639,  0,    0,    5574, 729,  1,
      0,     0,    0,    5575, 5576, 5,    509,  0,    0,    5576, 5577, 5,    95,   0,    0,    5577, 5578, 5,    776,
      0,     0,    5578, 5579, 5,    760,  0,    0,    5579, 5580, 5,    777,  0,    0,    5580, 5581, 5,    166,  0,
      0,     5581, 731,  1,    0,    0,    0,    5582, 5583, 5,    509,  0,    0,    5583, 5585, 5,    639,  0,    0,
      5584,  5586, 3,    294,  147,  0,    5585, 5584, 1,    0,    0,    0,    5585, 5586, 1,    0,    0,    0,    5586,
      733,   1,    0,    0,    0,    5587, 5588, 5,    509,  0,    0,    5588, 5590, 5,    166,  0,    0,    5589, 5591,
      3,     294,  147,  0,    5590, 5589, 1,    0,    0,    0,    5590, 5591, 1,    0,    0,    0,    5591, 735,  1,
      0,     0,    0,    5592, 5593, 5,    509,  0,    0,    5593, 5594, 5,    426,  0,    0,    5594, 737,  1,    0,
      0,     0,    5595, 5596, 5,    509,  0,    0,    5596, 5598, 5,    425,  0,    0,    5597, 5599, 3,    790,  395,
      0,     5598, 5597, 1,    0,    0,    0,    5598, 5599, 1,    0,    0,    0,    5599, 5603, 1,    0,    0,    0,
      5600,  5601, 5,    200,  0,    0,    5601, 5602, 5,    430,  0,    0,    5602, 5604, 5,    747,  0,    0,    5603,
      5600,  1,    0,    0,    0,    5603, 5604, 1,    0,    0,    0,    5604, 5606, 1,    0,    0,    0,    5605, 5607,
      3,     294,  147,  0,    5606, 5605, 1,    0,    0,    0,    5606, 5607, 1,    0,    0,    0,    5607, 739,  1,
      0,     0,    0,    5608, 5610, 5,    509,  0,    0,    5609, 5611, 3,    1418, 709,  0,    5610, 5609, 1,    0,
      0,     0,    5610, 5611, 1,    0,    0,    0,    5611, 5612, 1,    0,    0,    0,    5612, 5614, 5,    547,  0,
      0,     5613, 5615, 3,    1250, 625,  0,    5614, 5613, 1,    0,    0,    0,    5614, 5615, 1,    0,    0,    0,
      5615,  741,  1,    0,    0,    0,    5616, 5618, 5,    509,  0,    0,    5617, 5619, 5,    204,  0,    0,    5618,
      5617,  1,    0,    0,    0,    5618, 5619, 1,    0,    0,    0,    5619, 5620, 1,    0,    0,    0,    5620, 5621,
      5,     424,  0,    0,    5621, 743,  1,    0,    0,    0,    5622, 5624, 5,    509,  0,    0,    5623, 5625, 3,
      1418,  709,  0,    5624, 5623, 1,    0,    0,    0,    5624, 5625, 1,    0,    0,    0,    5625, 5626, 1,    0,
      0,     0,    5626, 5628, 5,    631,  0,    0,    5627, 5629, 3,    1250, 625,  0,    5628, 5627, 1,    0,    0,
      0,     5628, 5629, 1,    0,    0,    0,    5629, 745,  1,    0,    0,    0,    5630, 5631, 5,    509,  0,    0,
      5631,  5633, 3,    950,  475,  0,    5632, 5634, 3,    1250, 625,  0,    5633, 5632, 1,    0,    0,    0,    5633,
      5634,  1,    0,    0,    0,    5634, 747,  1,    0,    0,    0,    5635, 5636, 5,    509,  0,    0,    5636, 5638,
      5,     70,   0,    0,    5637, 5639, 3,    1250, 625,  0,    5638, 5637, 1,    0,    0,    0,    5638, 5639, 1,
      0,     0,    0,    5639, 749,  1,    0,    0,    0,    5640, 5641, 5,    509,  0,    0,    5641, 5642, 5,    421,
      0,     0,    5642, 751,  1,    0,    0,    0,    5643, 5644, 5,    509,  0,    0,    5644, 5651, 5,    216,  0,
      0,     5645, 5646, 5,    200,  0,    0,    5646, 5649, 3,    1246, 623,  0,    5647, 5648, 5,    621,  0,    0,
      5648,  5650, 3,    1210, 605,  0,    5649, 5647, 1,    0,    0,    0,    5649, 5650, 1,    0,    0,    0,    5650,
      5652,  1,    0,    0,    0,    5651, 5645, 1,    0,    0,    0,    5651, 5652, 1,    0,    0,    0,    5652, 753,
      1,     0,    0,    0,    5653, 5654, 5,    509,  0,    0,    5654, 5655, 5,    97,   0,    0,    5655, 5657, 5,
      109,   0,    0,    5656, 5658, 3,    1180, 590,  0,    5657, 5656, 1,    0,    0,    0,    5657, 5658, 1,    0,
      0,     0,    5658, 5659, 1,    0,    0,    0,    5659, 5660, 3,    1278, 639,  0,    5660, 755,  1,    0,    0,
      0,     5661, 5662, 5,    509,  0,    0,    5662, 5663, 5,    97,   0,    0,    5663, 5664, 5,    574,  0,    0,
      5664,  5665, 3,    1322, 661,  0,    5665, 757,  1,    0,    0,    0,    5666, 5667, 5,    509,  0,    0,    5667,
      5668,  5,    97,   0,    0,    5668, 5669, 5,    636,  0,    0,    5669, 5670, 3,    1294, 647,  0,    5670, 759,
      1,     0,    0,    0,    5671, 5672, 5,    509,  0,    0,    5672, 5673, 5,    316,  0,    0,    5673, 5674, 5,
      547,   0,    0,    5674, 761,  1,    0,    0,    0,    5675, 5676, 5,    509,  0,    0,    5676, 5677, 3,    578,
      289,   0,    5677, 5679, 5,    547,  0,    0,    5678, 5680, 3,    974,  487,  0,    5679, 5678, 1,    0,    0,
      0,     5679, 5680, 1,    0,    0,    0,    5680, 763,  1,    0,    0,    0,    5681, 5682, 5,    509,  0,    0,
      5682,  5683, 5,    97,   0,    0,    5683, 5684, 5,    422,  0,    0,    5684, 5685, 3,    1282, 641,  0,    5685,
      765,   1,    0,    0,    0,    5686, 5687, 5,    509,  0,    0,    5687, 5688, 5,    97,   0,    0,    5688, 5689,
      5,     206,  0,    0,    5689, 5690, 3,    1286, 643,  0,    5690, 767,  1,    0,    0,    0,    5691, 5692, 5,
      509,   0,    0,    5692, 5693, 5,    97,   0,    0,    5693, 5694, 5,    594,  0,    0,    5694, 5695, 3,    1290,
      645,   0,    5695, 769,  1,    0,    0,    0,    5696, 5697, 5,    509,  0,    0,    5697, 5698, 5,    97,   0,
      0,     5698, 5699, 5,    422,  0,    0,    5699, 5701, 5,    547,  0,    0,    5700, 5702, 3,    1250, 625,  0,
      5701,  5700, 1,    0,    0,    0,    5701, 5702, 1,    0,    0,    0,    5702, 771,  1,    0,    0,    0,    5703,
      5704,  5,    509,  0,    0,    5704, 5705, 5,    97,   0,    0,    5705, 5706, 5,    206,  0,    0,    5706, 5708,
      5,     547,  0,    0,    5707, 5709, 3,    1250, 625,  0,    5708, 5707, 1,    0,    0,    0,    5708, 5709, 1,
      0,     0,    0,    5709, 773,  1,    0,    0,    0,    5710, 5711, 5,    509,  0,    0,    5711, 5712, 5,    97,
      0,     0,    5712, 5713, 5,    422,  0,    0,    5713, 5714, 5,    68,   0,    0,    5714, 5715, 3,    1282, 641,
      0,     5715, 775,  1,    0,    0,    0,    5716, 5717, 5,    509,  0,    0,    5717, 5718, 5,    97,   0,    0,
      5718,  5719, 5,    206,  0,    0,    5719, 5720, 5,    68,   0,    0,    5720, 5721, 3,    1286, 643,  0,    5721,
      777,   1,    0,    0,    0,    5722, 5723, 5,    509,  0,    0,    5723, 5724, 5,    97,   0,    0,    5724, 5725,
      5,     170,  0,    0,    5725, 5726, 3,    1306, 653,  0,    5726, 779,  1,    0,    0,    0,    5727, 5728, 5,
      509,   0,    0,    5728, 5729, 5,    97,   0,    0,    5729, 5730, 5,    618,  0,    0,    5730, 5731, 3,    1246,
      623,   0,    5731, 781,  1,    0,    0,    0,    5732, 5738, 5,    204,  0,    0,    5733, 5735, 5,    180,  0,
      0,     5734, 5736, 5,    204,  0,    0,    5735, 5734, 1,    0,    0,    0,    5735, 5736, 1,    0,    0,    0,
      5736,  5738, 1,    0,    0,    0,    5737, 5732, 1,    0,    0,    0,    5737, 5733, 1,    0,    0,    0,    5738,
      783,   1,    0,    0,    0,    5739, 5742, 3,    1314, 657,  0,    5740, 5742, 5,    10,   0,    0,    5741, 5739,
      1,     0,    0,    0,    5741, 5740, 1,    0,    0,    0,    5742, 785,  1,    0,    0,    0,    5743, 5744, 7,
      90,    0,    0,    5744, 787,  1,    0,    0,    0,    5745, 5746, 3,    786,  393,  0,    5746, 5747, 3,    1346,
      673,   0,    5747, 789,  1,    0,    0,    0,    5748, 5753, 3,    792,  396,  0,    5749, 5750, 5,    773,  0,
      0,     5750, 5752, 3,    792,  396,  0,    5751, 5749, 1,    0,    0,    0,    5752, 5755, 1,    0,    0,    0,
      5753,  5751, 1,    0,    0,    0,    5753, 5754, 1,    0,    0,    0,    5754, 791,  1,    0,    0,    0,    5755,
      5753,  1,    0,    0,    0,    5756, 5757, 5,    40,   0,    0,    5757, 5764, 5,    255,  0,    0,    5758, 5759,
      5,     91,   0,    0,    5759, 5764, 5,    568,  0,    0,    5760, 5761, 5,    400,  0,    0,    5761, 5764, 5,
      185,   0,    0,    5762, 5764, 7,    92,   0,    0,    5763, 5756, 1,    0,    0,    0,    5763, 5758, 1,    0,
      0,     0,    5763, 5760, 1,    0,    0,    0,    5763, 5762, 1,    0,    0,    0,    5764, 793,  1,    0,    0,
      0,     5765, 5766, 5,    33,   0,    0,    5766, 5802, 3,    1384, 692,  0,    5767, 5768, 5,    47,   0,    0,
      5768,  5769, 5,    236,  0,    0,    5769, 5770, 3,    796,  398,  0,    5770, 5773, 5,    251,  0,    0,    5771,
      5774,  3,    1346, 673,  0,    5772, 5774, 5,    128,  0,    0,    5773, 5771, 1,    0,    0,    0,    5773, 5772,
      1,     0,    0,    0,    5774, 5802, 1,    0,    0,    0,    5775, 5777, 5,    196,  0,    0,    5776, 5778, 3,
      1254,  627,  0,    5777, 5776, 1,    0,    0,    0,    5777, 5778, 1,    0,    0,    0,    5778, 5788, 1,    0,
      0,     0,    5779, 5789, 3,    814,  407,  0,    5780, 5785, 3,    810,  405,  0,    5781, 5782, 5,    773,  0,
      0,     5782, 5784, 3,    810,  405,  0,    5783, 5781, 1,    0,    0,    0,    5784, 5787, 1,    0,    0,    0,
      5785,  5783, 1,    0,    0,    0,    5785, 5786, 1,    0,    0,    0,    5786, 5789, 1,    0,    0,    0,    5787,
      5785,  1,    0,    0,    0,    5788, 5779, 1,    0,    0,    0,    5788, 5780, 1,    0,    0,    0,    5789, 5802,
      1,     0,    0,    0,    5790, 5792, 5,    266,  0,    0,    5791, 5793, 7,    93,   0,    0,    5792, 5791, 1,
      0,     0,    0,    5792, 5793, 1,    0,    0,    0,    5793, 5794, 1,    0,    0,    0,    5794, 5802, 3,    860,
      430,   0,    5795, 5796, 5,    281,  0,    0,    5796, 5797, 5,    236,  0,    0,    5797, 5798, 5,    248,  0,
      0,     5798, 5799, 5,    47,   0,    0,    5799, 5802, 3,    818,  409,  0,    5800, 5802, 5,    510,  0,    0,
      5801,  5765, 1,    0,    0,    0,    5801, 5767, 1,    0,    0,    0,    5801, 5775, 1,    0,    0,    0,    5801,
      5790,  1,    0,    0,    0,    5801, 5795, 1,    0,    0,    0,    5801, 5800, 1,    0,    0,    0,    5802, 795,
      1,     0,    0,    0,    5803, 5806, 3,    798,  399,  0,    5804, 5806, 3,    802,  401,  0,    5805, 5803, 1,
      0,     0,    0,    5805, 5804, 1,    0,    0,    0,    5806, 797,  1,    0,    0,    0,    5807, 5812, 3,    800,
      400,   0,    5808, 5809, 5,    773,  0,    0,    5809, 5811, 3,    800,  400,  0,    5810, 5808, 1,    0,    0,
      0,     5811, 5814, 1,    0,    0,    0,    5812, 5810, 1,    0,    0,    0,    5812, 5813, 1,    0,    0,    0,
      5813,  799,  1,    0,    0,    0,    5814, 5812, 1,    0,    0,    0,    5815, 5817, 3,    1322, 661,  0,    5816,
      5818,  3,    804,  402,  0,    5817, 5816, 1,    0,    0,    0,    5817, 5818, 1,    0,    0,    0,    5818, 801,
      1,     0,    0,    0,    5819, 5820, 3,    1322, 661,  0,    5820, 5821, 5,    405,  0,    0,    5821, 5822, 5,
      776,   0,    0,    5822, 5823, 3,    54,   27,   0,    5823, 5825, 5,    777,  0,    0,    5824, 5826, 3,    804,
      402,   0,    5825, 5824, 1,    0,    0,    0,    5825, 5826, 1,    0,    0,    0,    5826, 803,  1,    0,    0,
      0,     5827, 5828, 3,    418,  209,  0,    5828, 5830, 5,    776,  0,    0,    5829, 5831, 3,    808,  404,  0,
      5830,  5829, 1,    0,    0,    0,    5830, 5831, 1,    0,    0,    0,    5831, 5832, 1,    0,    0,    0,    5832,
      5833,  5,    777,  0,    0,    5833, 805,  1,    0,    0,    0,    5834, 5837, 3,    1346, 673,  0,    5835, 5837,
      5,     420,  0,    0,    5836, 5834, 1,    0,    0,    0,    5836, 5835, 1,    0,    0,    0,    5837, 807,  1,
      0,     0,    0,    5838, 5843, 3,    806,  403,  0,    5839, 5840, 5,    773,  0,    0,    5840, 5842, 3,    806,
      403,   0,    5841, 5839, 1,    0,    0,    0,    5842, 5845, 1,    0,    0,    0,    5843, 5841, 1,    0,    0,
      0,     5843, 5844, 1,    0,    0,    0,    5844, 809,  1,    0,    0,    0,    5845, 5843, 1,    0,    0,    0,
      5846,  5858, 7,    94,   0,    0,    5847, 5849, 3,    812,  406,  0,    5848, 5847, 1,    0,    0,    0,    5848,
      5849,  1,    0,    0,    0,    5849, 5850, 1,    0,    0,    0,    5850, 5858, 5,    289,  0,    0,    5851, 5852,
      5,     445,  0,    0,    5852, 5854, 5,    289,  0,    0,    5853, 5855, 3,    974,  487,  0,    5854, 5853, 1,
      0,     0,    0,    5854, 5855, 1,    0,    0,    0,    5855, 5858, 1,    0,    0,    0,    5856, 5858, 5,    389,
      0,     0,    5857, 5846, 1,    0,    0,    0,    5857, 5848, 1,    0,    0,    0,    5857, 5851, 1,    0,    0,
      0,     5857, 5856, 1,    0,    0,    0,    5858, 811,  1,    0,    0,    0,    5859, 5860, 7,    95,   0,    0,
      5860,  813,  1,    0,    0,    0,    5861, 5869, 7,    17,   0,    0,    5862, 5863, 5,    645,  0,    0,    5863,
      5864,  5,    435,  0,    0,    5864, 5870, 5,    287,  0,    0,    5865, 5867, 3,    1348, 674,  0,    5866, 5868,
      3,     816,  408,  0,    5867, 5866, 1,    0,    0,    0,    5867, 5868, 1,    0,    0,    0,    5868, 5870, 1,
      0,     0,    0,    5869, 5862, 1,    0,    0,    0,    5869, 5865, 1,    0,    0,    0,    5869, 5870, 1,    0,
      0,     0,    5870, 815,  1,    0,    0,    0,    5871, 5872, 5,    200,  0,    0,    5872, 5877, 5,    179,  0,
      0,     5873, 5874, 5,    645,  0,    0,    5874, 5875, 5,    435,  0,    0,    5875, 5877, 5,    287,  0,    0,
      5876,  5871, 1,    0,    0,    0,    5876, 5873, 1,    0,    0,    0,    5877, 817,  1,    0,    0,    0,    5878,
      5879,  3,    1322, 661,  0,    5879, 5881, 3,    824,  412,  0,    5880, 5882, 3,    804,  402,  0,    5881, 5880,
      1,     0,    0,    0,    5881, 5882, 1,    0,    0,    0,    5882, 5885, 1,    0,    0,    0,    5883, 5884, 5,
      232,   0,    0,    5884, 5886, 5,    270,  0,    0,    5885, 5883, 1,    0,    0,    0,    5885, 5886, 1,    0,
      0,     0,    5886, 5889, 1,    0,    0,    0,    5887, 5889, 3,    820,  410,  0,    5888, 5878, 1,    0,    0,
      0,     5888, 5887, 1,    0,    0,    0,    5889, 819,  1,    0,    0,    0,    5890, 5895, 3,    822,  411,  0,
      5891,  5892, 5,    773,  0,    0,    5892, 5894, 3,    822,  411,  0,    5893, 5891, 1,    0,    0,    0,    5894,
      5897,  1,    0,    0,    0,    5895, 5893, 1,    0,    0,    0,    5895, 5896, 1,    0,    0,    0,    5896, 821,
      1,     0,    0,    0,    5897, 5895, 1,    0,    0,    0,    5898, 5900, 3,    1322, 661,  0,    5899, 5901, 3,
      804,   402,  0,    5900, 5899, 1,    0,    0,    0,    5900, 5901, 1,    0,    0,    0,    5901, 5904, 1,    0,
      0,     0,    5902, 5903, 5,    232,  0,    0,    5903, 5905, 5,    270,  0,    0,    5904, 5902, 1,    0,    0,
      0,     5904, 5905, 1,    0,    0,    0,    5905, 823,  1,    0,    0,    0,    5906, 5907, 5,    405,  0,    0,
      5907,  5908, 5,    776,  0,    0,    5908, 5909, 3,    54,   27,   0,    5909, 5910, 5,    777,  0,    0,    5910,
      825,   1,    0,    0,    0,    5911, 5916, 3,    828,  414,  0,    5912, 5916, 3,    838,  419,  0,    5913, 5916,
      3,     840,  420,  0,    5914, 5916, 3,    844,  422,  0,    5915, 5911, 1,    0,    0,    0,    5915, 5912, 1,
      0,     0,    0,    5915, 5913, 1,    0,    0,    0,    5915, 5914, 1,    0,    0,    0,    5916, 827,  1,    0,
      0,     0,    5917, 5918, 5,    97,   0,    0,    5918, 5919, 5,    709,  0,    0,    5919, 5920, 5,    217,  0,
      0,     5920, 5921, 3,    1346, 673,  0,    5921, 5923, 5,    599,  0,    0,    5922, 5924, 3,    1416, 708,  0,
      5923,  5922, 1,    0,    0,    0,    5923, 5924, 1,    0,    0,    0,    5924, 5925, 1,    0,    0,    0,    5925,
      5927,  7,    96,   0,    0,    5926, 5928, 3,    830,  415,  0,    5927, 5926, 1,    0,    0,    0,    5927, 5928,
      1,     0,    0,    0,    5928, 5930, 1,    0,    0,    0,    5929, 5931, 3,    834,  417,  0,    5930, 5929, 1,
      0,     0,    0,    5930, 5931, 1,    0,    0,    0,    5931, 5933, 1,    0,    0,    0,    5932, 5934, 3,    836,
      418,   0,    5933, 5932, 1,    0,    0,    0,    5933, 5934, 1,    0,    0,    0,    5934, 829,  1,    0,    0,
      0,     5935, 5937, 5,    711,  0,    0,    5936, 5938, 3,    1416, 708,  0,    5937, 5936, 1,    0,    0,    0,
      5937,  5938, 1,    0,    0,    0,    5938, 5939, 1,    0,    0,    0,    5939, 5946, 3,    832,  416,  0,    5940,
      5942,  5,    773,  0,    0,    5941, 5940, 1,    0,    0,    0,    5941, 5942, 1,    0,    0,    0,    5942, 5943,
      1,     0,    0,    0,    5943, 5945, 3,    832,  416,  0,    5944, 5941, 1,    0,    0,    0,    5945, 5948, 1,
      0,     0,    0,    5946, 5944, 1,    0,    0,    0,    5946, 5947, 1,    0,    0,    0,    5947, 831,  1,    0,
      0,     0,    5948, 5946, 1,    0,    0,    0,    5949, 5952, 5,    747,  0,    0,    5950, 5951, 5,    759,  0,
      0,     5951, 5953, 5,    747,  0,    0,    5952, 5950, 1,    0,    0,    0,    5952, 5953, 1,    0,    0,    0,
      5953,  833,  1,    0,    0,    0,    5954, 5956, 5,    708,  0,    0,    5955, 5957, 3,    1416, 708,  0,    5956,
      5955,  1,    0,    0,    0,    5956, 5957, 1,    0,    0,    0,    5957, 5958, 1,    0,    0,    0,    5958, 5959,
      5,     747,  0,    0,    5959, 835,  1,    0,    0,    0,    5960, 5961, 7,    7,    0,    0,    5961, 837,  1,
      0,     0,    0,    5962, 5963, 5,    11,   0,    0,    5963, 5964, 5,    709,  0,    0,    5964, 5965, 5,    217,
      0,     0,    5965, 5967, 3,    1340, 670,  0,    5966, 5968, 3,    830,  415,  0,    5967, 5966, 1,    0,    0,
      0,     5967, 5968, 1,    0,    0,    0,    5968, 5970, 1,    0,    0,    0,    5969, 5971, 3,    834,  417,  0,
      5970,  5969, 1,    0,    0,    0,    5970, 5971, 1,    0,    0,    0,    5971, 5973, 1,    0,    0,    0,    5972,
      5974,  3,    836,  418,  0,    5973, 5972, 1,    0,    0,    0,    5973, 5974, 1,    0,    0,    0,    5974, 5976,
      1,     0,    0,    0,    5975, 5977, 5,    198,  0,    0,    5976, 5975, 1,    0,    0,    0,    5976, 5977, 1,
      0,     0,    0,    5977, 839,  1,    0,    0,    0,    5978, 5979, 5,    506,  0,    0,    5979, 5980, 5,    709,
      0,     0,    5980, 5981, 5,    217,  0,    0,    5981, 5984, 3,    1346, 673,  0,    5982, 5983, 5,    200,  0,
      0,     5983, 5985, 3,    842,  421,  0,    5984, 5982, 1,    0,    0,    0,    5984, 5985, 1,    0,    0,    0,
      5985,  841,  1,    0,    0,    0,    5986, 5993, 3,    1360, 680,  0,    5987, 5989, 5,    773,  0,    0,    5988,
      5987,  1,    0,    0,    0,    5988, 5989, 1,    0,    0,    0,    5989, 5990, 1,    0,    0,    0,    5990, 5992,
      3,     1360, 680,  0,    5991, 5988, 1,    0,    0,    0,    5992, 5995, 1,    0,    0,    0,    5993, 5991, 1,
      0,     0,    0,    5993, 5994, 1,    0,    0,    0,    5994, 843,  1,    0,    0,    0,    5995, 5993, 1,    0,
      0,     0,    5996, 5997, 5,    148,  0,    0,    5997, 5998, 5,    709,  0,    0,    5998, 5999, 5,    217,  0,
      0,     5999, 6001, 3,    1340, 670,  0,    6000, 6002, 5,    198,  0,    0,    6001, 6000, 1,    0,    0,    0,
      6001,  6002, 1,    0,    0,    0,    6002, 845,  1,    0,    0,    0,    6003, 6010, 3,    848,  424,  0,    6004,
      6010,  3,    850,  425,  0,    6005, 6010, 3,    854,  427,  0,    6006, 6010, 3,    856,  428,  0,    6007, 6008,
      4,     423,  55,   0,    6008, 6010, 3,    858,  429,  0,    6009, 6003, 1,    0,    0,    0,    6009, 6004, 1,
      0,     0,    0,    6009, 6005, 1,    0,    0,    0,    6009, 6006, 1,    0,    0,    0,    6009, 6007, 1,    0,
      0,     0,    6010, 847,  1,    0,    0,    0,    6011, 6012, 7,    97,   0,    0,    6012, 6015, 3,    1322, 661,
      0,     6013, 6016, 3,    1380, 690,  0,    6014, 6016, 3,    1266, 633,  0,    6015, 6013, 1,    0,    0,    0,
      6015,  6014, 1,    0,    0,    0,    6015, 6016, 1,    0,    0,    0,    6016, 849,  1,    0,    0,    0,    6017,
      6029,  7,    97,   0,    0,    6018, 6030, 5,    180,  0,    0,    6019, 6020, 5,    201,  0,    0,    6020, 6021,
      5,     750,  0,    0,    6021, 6030, 3,    1406, 703,  0,    6022, 6023, 4,    425,  56,   0,    6023, 6030, 5,
      14,    0,    0,    6024, 6025, 4,    425,  57,   0,    6025, 6026, 5,    14,   0,    0,    6026, 6027, 5,    201,
      0,     0,    6027, 6028, 5,    750,  0,    0,    6028, 6030, 3,    1406, 703,  0,    6029, 6018, 1,    0,    0,
      0,     6029, 6019, 1,    0,    0,    0,    6029, 6022, 1,    0,    0,    0,    6029, 6024, 1,    0,    0,    0,
      6029,  6030, 1,    0,    0,    0,    6030, 6031, 1,    0,    0,    0,    6031, 6032, 3,    852,  426,  0,    6032,
      851,   1,    0,    0,    0,    6033, 6042, 3,    276,  138,  0,    6034, 6042, 3,    230,  115,  0,    6035, 6042,
      3,     242,  121,  0,    6036, 6042, 3,    274,  137,  0,    6037, 6042, 3,    428,  214,  0,    6038, 6039, 5,
      200,   0,    0,    6039, 6040, 5,    84,   0,    0,    6040, 6042, 3,    1360, 680,  0,    6041, 6033, 1,    0,
      0,     0,    6041, 6034, 1,    0,    0,    0,    6041, 6035, 1,    0,    0,    0,    6041, 6036, 1,    0,    0,
      0,     6041, 6037, 1,    0,    0,    0,    6041, 6038, 1,    0,    0,    0,    6042, 853,  1,    0,    0,    0,
      6043,  6044, 5,    222,  0,    0,    6044, 6045, 3,    1406, 703,  0,    6045, 855,  1,    0,    0,    0,    6046,
      6047,  5,    620,  0,    0,    6047, 6048, 3,    1278, 639,  0,    6048, 857,  1,    0,    0,    0,    6049, 6050,
      5,     714,  0,    0,    6050, 859,  1,    0,    0,    0,    6051, 6052, 6,    430,  -1,   0,    6052, 6058, 3,
      862,   431,  0,    6053, 6055, 5,    257,  0,    0,    6054, 6056, 3,    952,  476,  0,    6055, 6054, 1,    0,
      0,     0,    6055, 6056, 1,    0,    0,    0,    6056, 6057, 1,    0,    0,    0,    6057, 6059, 7,    98,   0,
      0,     6058, 6053, 1,    0,    0,    0,    6058, 6059, 1,    0,    0,    0,    6059, 6063, 1,    0,    0,    0,
      6060,  6061, 5,    371,  0,    0,    6061, 6063, 3,    860,  430,  4,    6062, 6051, 1,    0,    0,    0,    6062,
      6060,  1,    0,    0,    0,    6063, 6075, 1,    0,    0,    0,    6064, 6065, 10,   3,    0,    0,    6065, 6066,
      7,     99,   0,    0,    6066, 6074, 3,    860,  430,  4,    6067, 6068, 10,   2,    0,    0,    6068, 6069, 5,
      654,   0,    0,    6069, 6074, 3,    860,  430,  3,    6070, 6071, 10,   1,    0,    0,    6071, 6072, 7,    100,
      0,     0,    6072, 6074, 3,    860,  430,  2,    6073, 6064, 1,    0,    0,    0,    6073, 6067, 1,    0,    0,
      0,     6073, 6070, 1,    0,    0,    0,    6074, 6077, 1,    0,    0,    0,    6075, 6073, 1,    0,    0,    0,
      6075,  6076, 1,    0,    0,    0,    6076, 861,  1,    0,    0,    0,    6077, 6075, 1,    0,    0,    0,    6078,
      6079,  6,    431,  -1,   0,    6079, 6080, 3,    866,  433,  0,    6080, 6098, 1,    0,    0,    0,    6081, 6082,
      10,    3,    0,    0,    6082, 6084, 5,    257,  0,    0,    6083, 6085, 3,    952,  476,  0,    6084, 6083, 1,
      0,     0,    0,    6084, 6085, 1,    0,    0,    0,    6085, 6086, 1,    0,    0,    0,    6086, 6097, 5,    376,
      0,     0,    6087, 6088, 10,   2,    0,    0,    6088, 6089, 3,    864,  432,  0,    6089, 6090, 3,    866,  433,
      0,     6090, 6097, 1,    0,    0,    0,    6091, 6092, 10,   1,    0,    0,    6092, 6093, 3,    864,  432,  0,
      6093,  6094, 7,    101,  0,    0,    6094, 6095, 3,    290,  145,  0,    6095, 6097, 1,    0,    0,    0,    6096,
      6081,  1,    0,    0,    0,    6096, 6087, 1,    0,    0,    0,    6096, 6091, 1,    0,    0,    0,    6097, 6100,
      1,     0,    0,    0,    6098, 6096, 1,    0,    0,    0,    6098, 6099, 1,    0,    0,    0,    6099, 863,  1,
      0,     0,    0,    6100, 6098, 1,    0,    0,    0,    6101, 6102, 7,    102,  0,    0,    6102, 865,  1,    0,
      0,     0,    6103, 6117, 3,    870,  435,  0,    6104, 6106, 3,    952,  476,  0,    6105, 6104, 1,    0,    0,
      0,     6105, 6106, 1,    0,    0,    0,    6106, 6107, 1,    0,    0,    0,    6107, 6118, 3,    868,  434,  0,
      6108,  6109, 4,    433,  64,   0,    6109, 6111, 5,    733,  0,    0,    6110, 6112, 5,    668,  0,    0,    6111,
      6110,  1,    0,    0,    0,    6111, 6112, 1,    0,    0,    0,    6112, 6113, 1,    0,    0,    0,    6113, 6118,
      3,     964,  482,  0,    6114, 6115, 5,    521,  0,    0,    6115, 6116, 5,    275,  0,    0,    6116, 6118, 3,
      870,   435,  0,    6117, 6105, 1,    0,    0,    0,    6117, 6108, 1,    0,    0,    0,    6117, 6114, 1,    0,
      0,     0,    6117, 6118, 1,    0,    0,    0,    6118, 867,  1,    0,    0,    0,    6119, 6125, 5,    251,  0,
      0,     6120, 6126, 3,    290,  145,  0,    6121, 6122, 5,    776,  0,    0,    6122, 6123, 3,    948,  474,  0,
      6123,  6124, 5,    777,  0,    0,    6124, 6126, 1,    0,    0,    0,    6125, 6120, 1,    0,    0,    0,    6125,
      6121,  1,    0,    0,    0,    6126, 6141, 1,    0,    0,    0,    6127, 6128, 5,    30,   0,    0,    6128, 6129,
      3,     870,  435,  0,    6129, 6130, 5,    15,   0,    0,    6130, 6131, 3,    866,  433,  0,    6131, 6141, 1,
      0,     0,    0,    6132, 6133, 5,    275,  0,    0,    6133, 6136, 3,    872,  436,  0,    6134, 6135, 5,    168,
      0,     0,    6135, 6137, 3,    872,  436,  0,    6136, 6134, 1,    0,    0,    0,    6136, 6137, 1,    0,    0,
      0,     6137, 6141, 1,    0,    0,    0,    6138, 6139, 5,    444,  0,    0,    6139, 6141, 3,    870,  435,  0,
      6140,  6119, 1,    0,    0,    0,    6140, 6127, 1,    0,    0,    0,    6140, 6132, 1,    0,    0,    0,    6140,
      6138,  1,    0,    0,    0,    6141, 869,  1,    0,    0,    0,    6142, 6143, 6,    435,  -1,   0,    6143, 6144,
      3,     872,  436,  0,    6144, 6171, 1,    0,    0,    0,    6145, 6146, 10,   7,    0,    0,    6146, 6147, 5,
      769,   0,    0,    6147, 6170, 3,    870,  435,  8,    6148, 6149, 10,   6,    0,    0,    6149, 6150, 7,    103,
      0,     0,    6150, 6170, 3,    870,  435,  7,    6151, 6152, 10,   5,    0,    0,    6152, 6153, 7,    104,  0,
      0,     6153, 6170, 3,    870,  435,  6,    6154, 6155, 10,   3,    0,    0,    6155, 6156, 7,    105,  0,    0,
      6156,  6170, 3,    870,  435,  4,    6157, 6158, 10,   2,    0,    0,    6158, 6159, 5,    768,  0,    0,    6159,
      6170,  3,    870,  435,  3,    6160, 6161, 10,   1,    0,    0,    6161, 6162, 5,    771,  0,    0,    6162, 6170,
      3,     870,  435,  2,    6163, 6164, 10,   4,    0,    0,    6164, 6165, 7,    104,  0,    0,    6165, 6166, 5,
      247,   0,    0,    6166, 6167, 3,    860,  430,  0,    6167, 6168, 3,    956,  478,  0,    6168, 6170, 1,    0,
      0,     0,    6169, 6145, 1,    0,    0,    0,    6169, 6148, 1,    0,    0,    0,    6169, 6151, 1,    0,    0,
      0,     6169, 6154, 1,    0,    0,    0,    6169, 6157, 1,    0,    0,    0,    6169, 6160, 1,    0,    0,    0,
      6169,  6163, 1,    0,    0,    0,    6170, 6173, 1,    0,    0,    0,    6171, 6169, 1,    0,    0,    0,    6171,
      6172,  1,    0,    0,    0,    6172, 871,  1,    0,    0,    0,    6173, 6171, 1,    0,    0,    0,    6174, 6175,
      6,     436,  -1,   0,    6175, 6177, 3,    1266, 633,  0,    6176, 6178, 3,    876,  438,  0,    6177, 6176, 1,
      0,     0,    0,    6177, 6178, 1,    0,    0,    0,    6178, 6297, 1,    0,    0,    0,    6179, 6297, 3,    904,
      452,   0,    6180, 6297, 3,    924,  462,  0,    6181, 6297, 3,    1372, 686,  0,    6182, 6297, 5,    787,  0,
      0,     6183, 6297, 3,    934,  467,  0,    6184, 6297, 3,    932,  466,  0,    6185, 6297, 3,    878,  439,  0,
      6186,  6297, 3,    880,  440,  0,    6187, 6297, 3,    882,  441,  0,    6188, 6189, 7,    106,  0,    0,    6189,
      6297,  3,    872,  436,  15,   6190, 6191, 3,    954,  477,  0,    6191, 6192, 3,    872,  436,  14,   6192, 6297,
      1,     0,    0,    0,    6193, 6195, 5,    487,  0,    0,    6194, 6193, 1,    0,    0,    0,    6194, 6195, 1,
      0,     0,    0,    6195, 6196, 1,    0,    0,    0,    6196, 6197, 5,    776,  0,    0,    6197, 6198, 3,    948,
      474,   0,    6198, 6199, 5,    777,  0,    0,    6199, 6297, 1,    0,    0,    0,    6200, 6202, 5,    174,  0,
      0,     6201, 6200, 1,    0,    0,    0,    6201, 6202, 1,    0,    0,    0,    6202, 6203, 1,    0,    0,    0,
      6203,  6297, 3,    290,  145,  0,    6204, 6205, 5,    778,  0,    0,    6205, 6206, 3,    1346, 673,  0,    6206,
      6207,  3,    860,  430,  0,    6207, 6208, 5,    779,  0,    0,    6208, 6297, 1,    0,    0,    0,    6209, 6210,
      5,     320,  0,    0,    6210, 6211, 3,    898,  449,  0,    6211, 6212, 5,    7,    0,    0,    6212, 6213, 5,
      776,   0,    0,    6213, 6215, 3,    870,  435,  0,    6214, 6216, 3,    902,  451,  0,    6215, 6214, 1,    0,
      0,     0,    6215, 6216, 1,    0,    0,    0,    6216, 6217, 1,    0,    0,    0,    6217, 6218, 5,    777,  0,
      0,     6218, 6297, 1,    0,    0,    0,    6219, 6220, 5,    32,   0,    0,    6220, 6297, 3,    872,  436,  9,
      6221,  6222, 5,    52,   0,    0,    6222, 6223, 5,    776,  0,    0,    6223, 6226, 3,    860,  430,  0,    6224,
      6225,  5,    21,   0,    0,    6225, 6227, 5,    284,  0,    0,    6226, 6224, 1,    0,    0,    0,    6226, 6227,
      1,     0,    0,    0,    6227, 6228, 1,    0,    0,    0,    6228, 6229, 5,    17,   0,    0,    6229, 6231, 3,
      946,   473,  0,    6230, 6232, 3,    874,  437,  0,    6231, 6230, 1,    0,    0,    0,    6231, 6232, 1,    0,
      0,     0,    6232, 6233, 1,    0,    0,    0,    6233, 6234, 5,    777,  0,    0,    6234, 6297, 1,    0,    0,
      0,     6235, 6236, 5,    52,   0,    0,    6236, 6237, 5,    776,  0,    0,    6237, 6238, 3,    860,  430,  0,
      6238,  6239, 5,    21,   0,    0,    6239, 6240, 5,    586,  0,    0,    6240, 6242, 5,    801,  0,    0,    6241,
      6243,  5,    247,  0,    0,    6242, 6241, 1,    0,    0,    0,    6242, 6243, 1,    0,    0,    0,    6243, 6244,
      1,     0,    0,    0,    6244, 6245, 3,    1378, 689,  0,    6245, 6246, 5,    17,   0,    0,    6246, 6247, 5,
      113,   0,    0,    6247, 6248, 3,    1128, 564,  0,    6248, 6249, 5,    777,  0,    0,    6249, 6297, 1,    0,
      0,     0,    6250, 6252, 5,    51,   0,    0,    6251, 6253, 3,    860,  430,  0,    6252, 6251, 1,    0,    0,
      0,     6252, 6253, 1,    0,    0,    0,    6253, 6257, 1,    0,    0,    0,    6254, 6255, 3,    940,  470,  0,
      6255,  6256, 3,    942,  471,  0,    6256, 6258, 1,    0,    0,    0,    6257, 6254, 1,    0,    0,    0,    6258,
      6259,  1,    0,    0,    0,    6259, 6257, 1,    0,    0,    0,    6259, 6260, 1,    0,    0,    0,    6260, 6262,
      1,     0,    0,    0,    6261, 6263, 3,    944,  472,  0,    6262, 6261, 1,    0,    0,    0,    6262, 6263, 1,
      0,     0,    0,    6263, 6264, 1,    0,    0,    0,    6264, 6265, 5,    159,  0,    0,    6265, 6297, 1,    0,
      0,     0,    6266, 6267, 5,    94,   0,    0,    6267, 6268, 5,    776,  0,    0,    6268, 6269, 3,    860,  430,
      0,     6269, 6270, 5,    773,  0,    0,    6270, 6271, 3,    946,  473,  0,    6271, 6272, 5,    777,  0,    0,
      6272,  6297, 1,    0,    0,    0,    6273, 6274, 5,    94,   0,    0,    6274, 6275, 5,    776,  0,    0,    6275,
      6276,  3,    860,  430,  0,    6276, 6277, 5,    621,  0,    0,    6277, 6278, 3,    1132, 566,  0,    6278, 6279,
      5,     777,  0,    0,    6279, 6297, 1,    0,    0,    0,    6280, 6281, 5,    128,  0,    0,    6281, 6282, 5,
      776,   0,    0,    6282, 6283, 3,    1354, 677,  0,    6283, 6284, 5,    777,  0,    0,    6284, 6297, 1,    0,
      0,     0,    6285, 6286, 5,    626,  0,    0,    6286, 6287, 5,    776,  0,    0,    6287, 6288, 3,    1354, 677,
      0,     6288, 6289, 5,    777,  0,    0,    6289, 6297, 1,    0,    0,    0,    6290, 6291, 5,    247,  0,    0,
      6291,  6292, 3,    860,  430,  0,    6292, 6293, 3,    956,  478,  0,    6293, 6294, 5,    758,  0,    0,    6294,
      6295,  3,    860,  430,  0,    6295, 6297, 1,    0,    0,    0,    6296, 6174, 1,    0,    0,    0,    6296, 6179,
      1,     0,    0,    0,    6296, 6180, 1,    0,    0,    0,    6296, 6181, 1,    0,    0,    0,    6296, 6182, 1,
      0,     0,    0,    6296, 6183, 1,    0,    0,    0,    6296, 6184, 1,    0,    0,    0,    6296, 6185, 1,    0,
      0,     0,    6296, 6186, 1,    0,    0,    0,    6296, 6187, 1,    0,    0,    0,    6296, 6188, 1,    0,    0,
      0,     6296, 6190, 1,    0,    0,    0,    6296, 6194, 1,    0,    0,    0,    6296, 6201, 1,    0,    0,    0,
      6296,  6204, 1,    0,    0,    0,    6296, 6209, 1,    0,    0,    0,    6296, 6219, 1,    0,    0,    0,    6296,
      6221,  1,    0,    0,    0,    6296, 6235, 1,    0,    0,    0,    6296, 6250, 1,    0,    0,    0,    6296, 6266,
      1,     0,    0,    0,    6296, 6273, 1,    0,    0,    0,    6296, 6280, 1,    0,    0,    0,    6296, 6285, 1,
      0,     0,    0,    6296, 6290, 1,    0,    0,    0,    6297, 6306, 1,    0,    0,    0,    6298, 6299, 10,   16,
      0,     0,    6299, 6300, 5,    746,  0,    0,    6300, 6305, 3,    872,  436,  17,   6301, 6302, 10,   24,   0,
      0,     6302, 6303, 5,    69,   0,    0,    6303, 6305, 3,    1406, 703,  0,    6304, 6298, 1,    0,    0,    0,
      6304,  6301, 1,    0,    0,    0,    6305, 6308, 1,    0,    0,    0,    6306, 6304, 1,    0,    0,    0,    6306,
      6307,  1,    0,    0,    0,    6307, 873,  1,    0,    0,    0,    6308, 6306, 1,    0,    0,    0,    6309, 6310,
      4,     437,  74,   0,    6310, 6311, 5,    731,  0,    0,    6311, 875,  1,    0,    0,    0,    6312, 6313, 5,
      781,   0,    0,    6313, 6317, 3,    1378, 689,  0,    6314, 6315, 5,    782,  0,    0,    6315, 6317, 3,    1378,
      689,   0,    6316, 6312, 1,    0,    0,    0,    6316, 6314, 1,    0,    0,    0,    6317, 877,  1,    0,    0,
      0,     6318, 6319, 5,    26,   0,    0,    6319, 6321, 5,    776,  0,    0,    6320, 6322, 5,    143,  0,    0,
      6321,  6320, 1,    0,    0,    0,    6321, 6322, 1,    0,    0,    0,    6322, 6323, 1,    0,    0,    0,    6323,
      6324,  3,    896,  448,  0,    6324, 6326, 5,    777,  0,    0,    6325, 6327, 3,    884,  442,  0,    6326, 6325,
      1,     0,    0,    0,    6326, 6327, 1,    0,    0,    0,    6327, 6404, 1,    0,    0,    0,    6328, 6329, 7,
      107,   0,    0,    6329, 6330, 5,    776,  0,    0,    6330, 6331, 3,    896,  448,  0,    6331, 6333, 5,    777,
      0,     0,    6332, 6334, 3,    884,  442,  0,    6333, 6332, 1,    0,    0,    0,    6333, 6334, 1,    0,    0,
      0,     6334, 6404, 1,    0,    0,    0,    6335, 6404, 3,    894,  447,  0,    6336, 6337, 5,    833,  0,    0,
      6337,  6339, 5,    776,  0,    0,    6338, 6340, 5,    143,  0,    0,    6339, 6338, 1,    0,    0,    0,    6339,
      6340,  1,    0,    0,    0,    6340, 6341, 1,    0,    0,    0,    6341, 6342, 3,    896,  448,  0,    6342, 6344,
      5,     777,  0,    0,    6343, 6345, 3,    884,  442,  0,    6344, 6343, 1,    0,    0,    0,    6344, 6345, 1,
      0,     0,    0,    6345, 6404, 1,    0,    0,    0,    6346, 6347, 5,    95,   0,    0,    6347, 6355, 5,    776,
      0,     0,    6348, 6350, 5,    10,   0,    0,    6349, 6348, 1,    0,    0,    0,    6349, 6350, 1,    0,    0,
      0,     6350, 6351, 1,    0,    0,    0,    6351, 6356, 5,    760,  0,    0,    6352, 6356, 3,    896,  448,  0,
      6353,  6354, 5,    143,  0,    0,    6354, 6356, 3,    948,  474,  0,    6355, 6349, 1,    0,    0,    0,    6355,
      6352,  1,    0,    0,    0,    6355, 6353, 1,    0,    0,    0,    6356, 6357, 1,    0,    0,    0,    6357, 6359,
      5,     777,  0,    0,    6358, 6360, 3,    884,  442,  0,    6359, 6358, 1,    0,    0,    0,    6359, 6360, 1,
      0,     0,    0,    6360, 6404, 1,    0,    0,    0,    6361, 6362, 7,    108,  0,    0,    6362, 6364, 5,    776,
      0,     0,    6363, 6365, 5,    143,  0,    0,    6364, 6363, 1,    0,    0,    0,    6364, 6365, 1,    0,    0,
      0,     6365, 6366, 1,    0,    0,    0,    6366, 6367, 3,    896,  448,  0,    6367, 6369, 5,    777,  0,    0,
      6368,  6370, 3,    884,  442,  0,    6369, 6368, 1,    0,    0,    0,    6369, 6370, 1,    0,    0,    0,    6370,
      6404,  1,    0,    0,    0,    6371, 6372, 7,    109,  0,    0,    6372, 6373, 5,    776,  0,    0,    6373, 6374,
      3,     896,  448,  0,    6374, 6376, 5,    777,  0,    0,    6375, 6377, 3,    884,  442,  0,    6376, 6375, 1,
      0,     0,    0,    6376, 6377, 1,    0,    0,    0,    6377, 6404, 1,    0,    0,    0,    6378, 6379, 5,    564,
      0,     0,    6379, 6380, 5,    776,  0,    0,    6380, 6381, 5,    143,  0,    0,    6381, 6382, 3,    896,  448,
      0,     6382, 6384, 5,    777,  0,    0,    6383, 6385, 3,    884,  442,  0,    6384, 6383, 1,    0,    0,    0,
      6384,  6385, 1,    0,    0,    0,    6385, 6404, 1,    0,    0,    0,    6386, 6387, 5,    218,  0,    0,    6387,
      6389,  5,    776,  0,    0,    6388, 6390, 5,    143,  0,    0,    6389, 6388, 1,    0,    0,    0,    6389, 6390,
      1,     0,    0,    0,    6390, 6391, 1,    0,    0,    0,    6391, 6393, 3,    948,  474,  0,    6392, 6394, 3,
      338,   169,  0,    6393, 6392, 1,    0,    0,    0,    6393, 6394, 1,    0,    0,    0,    6394, 6397, 1,    0,
      0,     0,    6395, 6396, 5,    499,  0,    0,    6396, 6398, 3,    1380, 690,  0,    6397, 6395, 1,    0,    0,
      0,     6397, 6398, 1,    0,    0,    0,    6398, 6399, 1,    0,    0,    0,    6399, 6401, 5,    777,  0,    0,
      6400,  6402, 3,    884,  442,  0,    6401, 6400, 1,    0,    0,    0,    6401, 6402, 1,    0,    0,    0,    6402,
      6404,  1,    0,    0,    0,    6403, 6318, 1,    0,    0,    0,    6403, 6328, 1,    0,    0,    0,    6403, 6335,
      1,     0,    0,    0,    6403, 6336, 1,    0,    0,    0,    6403, 6346, 1,    0,    0,    0,    6403, 6361, 1,
      0,     0,    0,    6403, 6371, 1,    0,    0,    0,    6403, 6378, 1,    0,    0,    0,    6403, 6386, 1,    0,
      0,     0,    6404, 879,  1,    0,    0,    0,    6405, 6406, 5,    672,  0,    0,    6406, 6407, 5,    776,  0,
      0,     6407, 6408, 3,    948,  474,  0,    6408, 6409, 5,    777,  0,    0,    6409, 881,  1,    0,    0,    0,
      6410,  6411, 7,    110,  0,    0,    6411, 6412, 3,    1414, 707,  0,    6412, 6413, 3,    884,  442,  0,    6413,
      6460,  1,    0,    0,    0,    6414, 6421, 5,    688,  0,    0,    6415, 6416, 5,    776,  0,    0,    6416, 6417,
      3,     888,  444,  0,    6417, 6418, 5,    777,  0,    0,    6418, 6422, 1,    0,    0,    0,    6419, 6420, 4,
      441,   75,   0,    6420, 6422, 3,    964,  482,  0,    6421, 6415, 1,    0,    0,    0,    6421, 6419, 1,    0,
      0,     0,    6422, 6423, 1,    0,    0,    0,    6423, 6424, 3,    884,  442,  0,    6424, 6460, 1,    0,    0,
      0,     6425, 6426, 7,    111,  0,    0,    6426, 6427, 5,    776,  0,    0,    6427, 6429, 3,    860,  430,  0,
      6428,  6430, 3,    886,  443,  0,    6429, 6428, 1,    0,    0,    0,    6429, 6430, 1,    0,    0,    0,    6430,
      6431,  1,    0,    0,    0,    6431, 6433, 5,    777,  0,    0,    6432, 6434, 3,    892,  446,  0,    6433, 6432,
      1,     0,    0,    0,    6433, 6434, 1,    0,    0,    0,    6434, 6435, 1,    0,    0,    0,    6435, 6436, 3,
      884,   442,  0,    6436, 6460, 1,    0,    0,    0,    6437, 6438, 7,    112,  0,    0,    6438, 6440, 3,    962,
      481,   0,    6439, 6441, 3,    892,  446,  0,    6440, 6439, 1,    0,    0,    0,    6440, 6441, 1,    0,    0,
      0,     6441, 6442, 1,    0,    0,    0,    6442, 6443, 3,    884,  442,  0,    6443, 6460, 1,    0,    0,    0,
      6444,  6445, 5,    687,  0,    0,    6445, 6446, 5,    776,  0,    0,    6446, 6447, 3,    860,  430,  0,    6447,
      6448,  5,    773,  0,    0,    6448, 6449, 3,    872,  436,  0,    6449, 6452, 5,    777,  0,    0,    6450, 6451,
      5,     203,  0,    0,    6451, 6453, 7,    113,  0,    0,    6452, 6450, 1,    0,    0,    0,    6452, 6453, 1,
      0,     0,    0,    6453, 6455, 1,    0,    0,    0,    6454, 6456, 3,    892,  446,  0,    6455, 6454, 1,    0,
      0,     0,    6455, 6456, 1,    0,    0,    0,    6456, 6457, 1,    0,    0,    0,    6457, 6458, 3,    884,  442,
      0,     6458, 6460, 1,    0,    0,    0,    6459, 6410, 1,    0,    0,    0,    6459, 6414, 1,    0,    0,    0,
      6459,  6425, 1,    0,    0,    0,    6459, 6437, 1,    0,    0,    0,    6459, 6444, 1,    0,    0,    0,    6460,
      883,   1,    0,    0,    0,    6461, 6464, 5,    691,  0,    0,    6462, 6465, 3,    1342, 671,  0,    6463, 6465,
      3,     312,  156,  0,    6464, 6462, 1,    0,    0,    0,    6464, 6463, 1,    0,    0,    0,    6465, 885,  1,
      0,     0,    0,    6466, 6471, 5,    773,  0,    0,    6467, 6472, 3,    1362, 681,  0,    6468, 6472, 5,    787,
      0,     0,    6469, 6470, 4,    443,  76,   0,    6470, 6472, 3,    888,  444,  0,    6471, 6467, 1,    0,    0,
      0,     6471, 6468, 1,    0,    0,    0,    6471, 6469, 1,    0,    0,    0,    6472, 6475, 1,    0,    0,    0,
      6473,  6474, 5,    773,  0,    0,    6474, 6476, 3,    860,  430,  0,    6475, 6473, 1,    0,    0,    0,    6475,
      6476,  1,    0,    0,    0,    6476, 887,  1,    0,    0,    0,    6477, 6480, 3,    1396, 698,  0,    6478, 6480,
      3,     890,  445,  0,    6479, 6477, 1,    0,    0,    0,    6479, 6478, 1,    0,    0,    0,    6480, 889,  1,
      0,     0,    0,    6481, 6486, 5,    787,  0,    0,    6482, 6486, 3,    1346, 673,  0,    6483, 6484, 5,    783,
      0,     0,    6484, 6486, 3,    1406, 703,  0,    6485, 6481, 1,    0,    0,    0,    6485, 6482, 1,    0,    0,
      0,     6485, 6483, 1,    0,    0,    0,    6486, 891,  1,    0,    0,    0,    6487, 6488, 7,    114,  0,    0,
      6488,  6489, 5,    689,  0,    0,    6489, 893,  1,    0,    0,    0,    6490, 6491, 5,    667,  0,    0,    6491,
      6492,  5,    776,  0,    0,    6492, 6493, 3,    896,  448,  0,    6493, 6495, 5,    777,  0,    0,    6494, 6496,
      3,     884,  442,  0,    6495, 6494, 1,    0,    0,    0,    6495, 6496, 1,    0,    0,    0,    6496, 6507, 1,
      0,     0,    0,    6497, 6498, 5,    666,  0,    0,    6498, 6499, 5,    776,  0,    0,    6499, 6500, 3,    896,
      448,   0,    6500, 6501, 5,    773,  0,    0,    6501, 6502, 3,    896,  448,  0,    6502, 6504, 5,    777,  0,
      0,     6503, 6505, 3,    884,  442,  0,    6504, 6503, 1,    0,    0,    0,    6504, 6505, 1,    0,    0,    0,
      6505,  6507, 1,    0,    0,    0,    6506, 6490, 1,    0,    0,    0,    6506, 6497, 1,    0,    0,    0,    6507,
      895,   1,    0,    0,    0,    6508, 6510, 5,    10,   0,    0,    6509, 6508, 1,    0,    0,    0,    6509, 6510,
      1,     0,    0,    0,    6510, 6511, 1,    0,    0,    0,    6511, 6512, 3,    860,  430,  0,    6512, 897,  1,
      0,     0,    0,    6513, 6519, 3,    900,  450,  0,    6514, 6515, 5,    776,  0,    0,    6515, 6516, 3,    900,
      450,   0,    6516, 6517, 5,    777,  0,    0,    6517, 6519, 1,    0,    0,    0,    6518, 6513, 1,    0,    0,
      0,     6518, 6514, 1,    0,    0,    0,    6519, 899,  1,    0,    0,    0,    6520, 6525, 3,    1354, 677,  0,
      6521,  6522, 5,    773,  0,    0,    6522, 6524, 3,    1354, 677,  0,    6523, 6521, 1,    0,    0,    0,    6524,
      6527,  1,    0,    0,    0,    6525, 6523, 1,    0,    0,    0,    6525, 6526, 1,    0,    0,    0,    6526, 901,
      1,     0,    0,    0,    6527, 6525, 1,    0,    0,    0,    6528, 6529, 5,    251,  0,    0,    6529, 6530, 5,
      41,    0,    0,    6530, 6544, 5,    346,  0,    0,    6531, 6532, 5,    251,  0,    0,    6532, 6533, 5,    359,
      0,     0,    6533, 6534, 5,    267,  0,    0,    6534, 6538, 5,    346,  0,    0,    6535, 6536, 5,    645,  0,
      0,     6536, 6537, 5,    430,  0,    0,    6537, 6539, 5,    176,  0,    0,    6538, 6535, 1,    0,    0,    0,
      6538,  6539, 1,    0,    0,    0,    6539, 6544, 1,    0,    0,    0,    6540, 6541, 5,    645,  0,    0,    6541,
      6542,  5,    430,  0,    0,    6542, 6544, 5,    176,  0,    0,    6543, 6528, 1,    0,    0,    0,    6543, 6531,
      1,     0,    0,    0,    6543, 6540, 1,    0,    0,    0,    6544, 903,  1,    0,    0,    0,    6545, 6546, 5,
      60,    0,    0,    6546, 6547, 5,    776,  0,    0,    6547, 6550, 3,    948,  474,  0,    6548, 6549, 5,    621,
      0,     0,    6549, 6551, 3,    1132, 566,  0,    6550, 6548, 1,    0,    0,    0,    6550, 6551, 1,    0,    0,
      0,     6551, 6552, 1,    0,    0,    0,    6552, 6553, 5,    777,  0,    0,    6553, 6819, 1,    0,    0,    0,
      6554,  6556, 5,    105,  0,    0,    6555, 6557, 3,    1414, 707,  0,    6556, 6555, 1,    0,    0,    0,    6556,
      6557,  1,    0,    0,    0,    6557, 6819, 1,    0,    0,    0,    6558, 6559, 5,    116,  0,    0,    6559, 6819,
      3,     962,  481,  0,    6560, 6561, 5,    122,  0,    0,    6561, 6819, 3,    962,  481,  0,    6562, 6563, 5,
      229,   0,    0,    6563, 6819, 3,    962,  481,  0,    6564, 6565, 5,    242,  0,    0,    6565, 6566, 5,    776,
      0,     0,    6566, 6567, 3,    860,  430,  0,    6567, 6568, 5,    773,  0,    0,    6568, 6569, 3,    860,  430,
      0,     6569, 6570, 5,    773,  0,    0,    6570, 6571, 3,    860,  430,  0,    6571, 6572, 5,    773,  0,    0,
      6572,  6573, 3,    860,  430,  0,    6573, 6574, 5,    777,  0,    0,    6574, 6819, 1,    0,    0,    0,    6575,
      6576,  5,    247,  0,    0,    6576, 6577, 5,    776,  0,    0,    6577, 6580, 3,    860,  430,  0,    6578, 6579,
      5,     773,  0,    0,    6579, 6581, 3,    860,  430,  0,    6580, 6578, 1,    0,    0,    0,    6581, 6582, 1,
      0,     0,    0,    6582, 6580, 1,    0,    0,    0,    6582, 6583, 1,    0,    0,    0,    6583, 6584, 1,    0,
      0,     0,    6584, 6585, 5,    777,  0,    0,    6585, 6819, 1,    0,    0,    0,    6586, 6587, 5,    795,  0,
      0,     6587, 6588, 5,    776,  0,    0,    6588, 6589, 3,    872,  436,  0,    6589, 6590, 5,    773,  0,    0,
      6590,  6592, 3,    1384, 692,  0,    6591, 6593, 3,    906,  453,  0,    6592, 6591, 1,    0,    0,    0,    6592,
      6593,  1,    0,    0,    0,    6593, 6594, 1,    0,    0,    0,    6594, 6595, 3,    398,  199,  0,    6595, 6596,
      5,     777,  0,    0,    6596, 6819, 1,    0,    0,    0,    6597, 6598, 5,    272,  0,    0,    6598, 6599, 5,
      776,   0,    0,    6599, 6600, 3,    860,  430,  0,    6600, 6601, 5,    773,  0,    0,    6601, 6602, 3,    860,
      430,   0,    6602, 6603, 5,    777,  0,    0,    6603, 6819, 1,    0,    0,    0,    6604, 6605, 5,    343,  0,
      0,     6605, 6819, 3,    962,  481,  0,    6606, 6607, 5,    350,  0,    0,    6607, 6819, 3,    962,  481,  0,
      6608,  6609, 5,    478,  0,    0,    6609, 6610, 5,    776,  0,    0,    6610, 6611, 3,    860,  430,  0,    6611,
      6612,  5,    773,  0,    0,    6612, 6613, 3,    860,  430,  0,    6613, 6614, 5,    777,  0,    0,    6614, 6819,
      1,     0,    0,    0,    6615, 6616, 5,    495,  0,    0,    6616, 6819, 3,    962,  481,  0,    6617, 6618, 5,
      586,   0,    0,    6618, 6819, 3,    962,  481,  0,    6619, 6620, 5,    583,  0,    0,    6620, 6621, 5,    776,
      0,     0,    6621, 6624, 3,    860,  430,  0,    6622, 6623, 5,    773,  0,    0,    6623, 6625, 3,    860,  430,
      0,     6624, 6622, 1,    0,    0,    0,    6624, 6625, 1,    0,    0,    0,    6625, 6626, 1,    0,    0,    0,
      6626,  6627, 5,    777,  0,    0,    6627, 6819, 1,    0,    0,    0,    6628, 6819, 3,    920,  460,  0,    6629,
      6819,  3,    602,  301,  0,    6630, 6631, 5,    626,  0,    0,    6631, 6819, 3,    962,  481,  0,    6632, 6633,
      5,     656,  0,    0,    6633, 6819, 3,    962,  481,  0,    6634, 6635, 7,    115,  0,    0,    6635, 6636, 5,
      776,   0,    0,    6636, 6637, 3,    860,  430,  0,    6637, 6643, 5,    773,  0,    0,    6638, 6644, 3,    860,
      430,   0,    6639, 6640, 5,    247,  0,    0,    6640, 6641, 3,    860,  430,  0,    6641, 6642, 3,    956,  478,
      0,     6642, 6644, 1,    0,    0,    0,    6643, 6638, 1,    0,    0,    0,    6643, 6639, 1,    0,    0,    0,
      6644,  6645, 1,    0,    0,    0,    6645, 6646, 5,    777,  0,    0,    6646, 6819, 1,    0,    0,    0,    6647,
      6649,  5,    100,  0,    0,    6648, 6650, 3,    1414, 707,  0,    6649, 6648, 1,    0,    0,    0,    6649, 6650,
      1,     0,    0,    0,    6650, 6819, 1,    0,    0,    0,    6651, 6653, 5,    108,  0,    0,    6652, 6654, 3,
      910,   455,  0,    6653, 6652, 1,    0,    0,    0,    6653, 6654, 1,    0,    0,    0,    6654, 6819, 1,    0,
      0,     0,    6655, 6656, 7,    116,  0,    0,    6656, 6657, 5,    776,  0,    0,    6657, 6658, 3,    860,  430,
      0,     6658, 6659, 5,    773,  0,    0,    6659, 6660, 5,    247,  0,    0,    6660, 6661, 3,    860,  430,  0,
      6661,  6662, 3,    956,  478,  0,    6662, 6663, 5,    777,  0,    0,    6663, 6819, 1,    0,    0,    0,    6664,
      6665,  5,    182,  0,    0,    6665, 6666, 5,    776,  0,    0,    6666, 6667, 3,    956,  478,  0,    6667, 6668,
      5,     203,  0,    0,    6668, 6669, 3,    860,  430,  0,    6669, 6670, 5,    777,  0,    0,    6670, 6819, 1,
      0,     0,    0,    6671, 6672, 5,    213,  0,    0,    6672, 6673, 5,    776,  0,    0,    6673, 6674, 3,    918,
      459,   0,    6674, 6675, 5,    773,  0,    0,    6675, 6676, 3,    860,  430,  0,    6676, 6677, 5,    777,  0,
      0,     6677, 6819, 1,    0,    0,    0,    6678, 6680, 5,    372,  0,    0,    6679, 6681, 3,    910,  455,  0,
      6680,  6679, 1,    0,    0,    0,    6680, 6681, 1,    0,    0,    0,    6681, 6819, 1,    0,    0,    0,    6682,
      6683,  5,    414,  0,    0,    6683, 6684, 5,    776,  0,    0,    6684, 6685, 3,    870,  435,  0,    6685, 6686,
      5,     251,  0,    0,    6686, 6687, 3,    860,  430,  0,    6687, 6688, 5,    777,  0,    0,    6688, 6819, 1,
      0,     0,    0,    6689, 6819, 3,    922,  461,  0,    6690, 6692, 5,    569,  0,    0,    6691, 6693, 3,    910,
      455,   0,    6692, 6691, 1,    0,    0,    0,    6692, 6693, 1,    0,    0,    0,    6693, 6819, 1,    0,    0,
      0,     6694, 6695, 7,    117,  0,    0,    6695, 6696, 5,    776,  0,    0,    6696, 6697, 3,    958,  479,  0,
      6697,  6698, 5,    773,  0,    0,    6698, 6699, 3,    860,  430,  0,    6699, 6700, 5,    773,  0,    0,    6700,
      6701,  3,    860,  430,  0,    6701, 6702, 5,    777,  0,    0,    6702, 6819, 1,    0,    0,    0,    6703, 6705,
      5,     622,  0,    0,    6704, 6706, 3,    1414, 707,  0,    6705, 6704, 1,    0,    0,    0,    6705, 6706, 1,
      0,     0,    0,    6706, 6819, 1,    0,    0,    0,    6707, 6709, 5,    624,  0,    0,    6708, 6710, 3,    910,
      455,   0,    6709, 6708, 1,    0,    0,    0,    6709, 6710, 1,    0,    0,    0,    6710, 6819, 1,    0,    0,
      0,     6711, 6713, 5,    623,  0,    0,    6712, 6714, 3,    910,  455,  0,    6713, 6712, 1,    0,    0,    0,
      6713,  6714, 1,    0,    0,    0,    6714, 6819, 1,    0,    0,    0,    6715, 6716, 5,    19,   0,    0,    6716,
      6819,  3,    962,  481,  0,    6717, 6718, 5,    58,   0,    0,    6718, 6819, 3,    962,  481,  0,    6719, 6720,
      5,     67,   0,    0,    6720, 6819, 3,    960,  480,  0,    6721, 6722, 5,    70,   0,    0,    6722, 6819, 3,
      962,   481,  0,    6723, 6724, 5,    109,  0,    0,    6724, 6819, 3,    1414, 707,  0,    6725, 6726, 5,    231,
      0,     0,    6726, 6727, 5,    776,  0,    0,    6727, 6728, 3,    860,  430,  0,    6728, 6729, 5,    773,  0,
      0,     6729, 6730, 3,    860,  430,  0,    6730, 6731, 5,    773,  0,    0,    6731, 6732, 3,    860,  430,  0,
      6732,  6733, 5,    777,  0,    0,    6733, 6819, 1,    0,    0,    0,    6734, 6735, 5,    201,  0,    0,    6735,
      6736,  5,    776,  0,    0,    6736, 6737, 3,    860,  430,  0,    6737, 6738, 5,    773,  0,    0,    6738, 6741,
      3,     860,  430,  0,    6739, 6740, 5,    773,  0,    0,    6740, 6742, 3,    860,  430,  0,    6741, 6739, 1,
      0,     0,    0,    6741, 6742, 1,    0,    0,    0,    6742, 6743, 1,    0,    0,    0,    6743, 6744, 5,    777,
      0,     0,    6744, 6819, 1,    0,    0,    0,    6745, 6746, 5,    337,  0,    0,    6746, 6819, 3,    962,  481,
      0,     6747, 6748, 5,    349,  0,    0,    6748, 6749, 5,    776,  0,    0,    6749, 6750, 3,    860,  430,  0,
      6750,  6751, 5,    773,  0,    0,    6751, 6752, 3,    860,  430,  0,    6752, 6753, 5,    777,  0,    0,    6753,
      6819,  1,    0,    0,    0,    6754, 6755, 4,    452,  77,   0,    6755, 6756, 5,    406,  0,    0,    6756, 6819,
      3,     962,  481,  0,    6757, 6758, 5,    429,  0,    0,    6758, 6819, 3,    962,  481,  0,    6759, 6760, 5,
      457,   0,    0,    6760, 6761, 5,    776,  0,    0,    6761, 6762, 3,    860,  430,  0,    6762, 6763, 5,    773,
      0,     0,    6763, 6764, 3,    860,  430,  0,    6764, 6765, 5,    777,  0,    0,    6765, 6819, 1,    0,    0,
      0,     6766, 6767, 5,    458,  0,    0,    6767, 6768, 5,    776,  0,    0,    6768, 6769, 3,    860,  430,  0,
      6769,  6770, 5,    773,  0,    0,    6770, 6771, 3,    860,  430,  0,    6771, 6772, 5,    773,  0,    0,    6772,
      6773,  3,    860,  430,  0,    6773, 6774, 5,    777,  0,    0,    6774, 6819, 1,    0,    0,    0,    6775, 6776,
      5,     476,  0,    0,    6776, 6819, 3,    962,  481,  0,    6777, 6778, 5,    485,  0,    0,    6778, 6819, 3,
      1414,  707,  0,    6779, 6780, 5,    597,  0,    0,    6780, 6781, 5,    776,  0,    0,    6781, 6782, 3,    860,
      430,   0,    6782, 6783, 5,    773,  0,    0,    6783, 6784, 3,    860,  430,  0,    6784, 6785, 5,    777,  0,
      0,     6785, 6819, 1,    0,    0,    0,    6786, 6787, 5,    640,  0,    0,    6787, 6788, 5,    776,  0,    0,
      6788,  6791, 3,    860,  430,  0,    6789, 6790, 5,    773,  0,    0,    6790, 6792, 3,    860,  430,  0,    6791,
      6789,  1,    0,    0,    0,    6791, 6792, 1,    0,    0,    0,    6792, 6793, 1,    0,    0,    0,    6793, 6794,
      5,     777,  0,    0,    6794, 6819, 1,    0,    0,    0,    6795, 6796, 5,    641,  0,    0,    6796, 6797, 5,
      776,   0,    0,    6797, 6813, 3,    860,  430,  0,    6798, 6799, 5,    17,   0,    0,    6799, 6800, 5,    60,
      0,     0,    6800, 6802, 3,    1126, 563,  0,    6801, 6798, 1,    0,    0,    0,    6801, 6802, 1,    0,    0,
      0,     6802, 6814, 1,    0,    0,    0,    6803, 6804, 5,    17,   0,    0,    6804, 6805, 5,    32,   0,    0,
      6805,  6814, 3,    1126, 563,  0,    6806, 6807, 5,    773,  0,    0,    6807, 6808, 3,    1358, 679,  0,    6808,
      6809,  5,    773,  0,    0,    6809, 6810, 3,    1358, 679,  0,    6810, 6811, 5,    773,  0,    0,    6811, 6812,
      3,     1358, 679,  0,    6812, 6814, 1,    0,    0,    0,    6813, 6801, 1,    0,    0,    0,    6813, 6803, 1,
      0,     0,    0,    6813, 6806, 1,    0,    0,    0,    6814, 6815, 1,    0,    0,    0,    6815, 6816, 5,    777,
      0,     0,    6816, 6819, 1,    0,    0,    0,    6817, 6819, 3,    908,  454,  0,    6818, 6545, 1,    0,    0,
      0,     6818, 6554, 1,    0,    0,    0,    6818, 6558, 1,    0,    0,    0,    6818, 6560, 1,    0,    0,    0,
      6818,  6562, 1,    0,    0,    0,    6818, 6564, 1,    0,    0,    0,    6818, 6575, 1,    0,    0,    0,    6818,
      6586,  1,    0,    0,    0,    6818, 6597, 1,    0,    0,    0,    6818, 6604, 1,    0,    0,    0,    6818, 6606,
      1,     0,    0,    0,    6818, 6608, 1,    0,    0,    0,    6818, 6615, 1,    0,    0,    0,    6818, 6617, 1,
      0,     0,    0,    6818, 6619, 1,    0,    0,    0,    6818, 6628, 1,    0,    0,    0,    6818, 6629, 1,    0,
      0,     0,    6818, 6630, 1,    0,    0,    0,    6818, 6632, 1,    0,    0,    0,    6818, 6634, 1,    0,    0,
      0,     6818, 6647, 1,    0,    0,    0,    6818, 6651, 1,    0,    0,    0,    6818, 6655, 1,    0,    0,    0,
      6818,  6664, 1,    0,    0,    0,    6818, 6671, 1,    0,    0,    0,    6818, 6678, 1,    0,    0,    0,    6818,
      6682,  1,    0,    0,    0,    6818, 6689, 1,    0,    0,    0,    6818, 6690, 1,    0,    0,    0,    6818, 6694,
      1,     0,    0,    0,    6818, 6703, 1,    0,    0,    0,    6818, 6707, 1,    0,    0,    0,    6818, 6711, 1,
      0,     0,    0,    6818, 6715, 1,    0,    0,    0,    6818, 6717, 1,    0,    0,    0,    6818, 6719, 1,    0,
      0,     0,    6818, 6721, 1,    0,    0,    0,    6818, 6723, 1,    0,    0,    0,    6818, 6725, 1,    0,    0,
      0,     6818, 6734, 1,    0,    0,    0,    6818, 6745, 1,    0,    0,    0,    6818, 6747, 1,    0,    0,    0,
      6818,  6754, 1,    0,    0,    0,    6818, 6757, 1,    0,    0,    0,    6818, 6759, 1,    0,    0,    0,    6818,
      6766,  1,    0,    0,    0,    6818, 6775, 1,    0,    0,    0,    6818, 6777, 1,    0,    0,    0,    6818, 6779,
      1,     0,    0,    0,    6818, 6786, 1,    0,    0,    0,    6818, 6795, 1,    0,    0,    0,    6818, 6817, 1,
      0,     0,    0,    6819, 905,  1,    0,    0,    0,    6820, 6821, 5,    794,  0,    0,    6821, 6822, 3,    946,
      473,   0,    6822, 907,  1,    0,    0,    0,    6823, 6824, 5,    211,  0,    0,    6824, 6826, 5,    776,  0,
      0,     6825, 6827, 3,    948,  474,  0,    6826, 6825, 1,    0,    0,    0,    6826, 6827, 1,    0,    0,    0,
      6827,  6828, 1,    0,    0,    0,    6828, 6847, 5,    777,  0,    0,    6829, 6830, 5,    279,  0,    0,    6830,
      6847,  3,    960,  480,  0,    6831, 6832, 5,    351,  0,    0,    6832, 6847, 3,    960,  480,  0,    6833, 6834,
      5,     352,  0,    0,    6834, 6847, 3,    960,  480,  0,    6835, 6836, 5,    353,  0,    0,    6836, 6847, 3,
      960,   480,  0,    6837, 6838, 5,    411,  0,    0,    6838, 6839, 5,    776,  0,    0,    6839, 6840, 3,    860,
      430,   0,    6840, 6841, 5,    773,  0,    0,    6841, 6842, 3,    860,  430,  0,    6842, 6843, 5,    777,  0,
      0,     6843, 6847, 1,    0,    0,    0,    6844, 6845, 5,    412,  0,    0,    6845, 6847, 3,    960,  480,  0,
      6846,  6823, 1,    0,    0,    0,    6846, 6829, 1,    0,    0,    0,    6846, 6831, 1,    0,    0,    0,    6846,
      6833,  1,    0,    0,    0,    6846, 6835, 1,    0,    0,    0,    6846, 6837, 1,    0,    0,    0,    6846, 6844,
      1,     0,    0,    0,    6847, 909,  1,    0,    0,    0,    6848, 6850, 5,    776,  0,    0,    6849, 6851, 3,
      912,   456,  0,    6850, 6849, 1,    0,    0,    0,    6850, 6851, 1,    0,    0,    0,    6851, 6852, 1,    0,
      0,     0,    6852, 6853, 5,    777,  0,    0,    6853, 911,  1,    0,    0,    0,    6854, 6855, 5,    747,  0,
      0,     6855, 913,  1,    0,    0,    0,    6856, 6869, 5,    274,  0,    0,    6857, 6858, 3,    1360, 680,  0,
      6858,  6859, 5,    759,  0,    0,    6859, 6860, 3,    1360, 680,  0,    6860, 6870, 1,    0,    0,    0,    6861,
      6866,  3,    916,  458,  0,    6862, 6863, 5,    773,  0,    0,    6863, 6865, 3,    916,  458,  0,    6864, 6862,
      1,     0,    0,    0,    6865, 6868, 1,    0,    0,    0,    6866, 6864, 1,    0,    0,    0,    6866, 6867, 1,
      0,     0,    0,    6867, 6870, 1,    0,    0,    0,    6868, 6866, 1,    0,    0,    0,    6869, 6857, 1,    0,
      0,     0,    6869, 6861, 1,    0,    0,    0,    6870, 915,  1,    0,    0,    0,    6871, 6877, 3,    1360, 680,
      0,     6872, 6874, 7,    33,   0,    0,    6873, 6875, 5,    476,  0,    0,    6874, 6873, 1,    0,    0,    0,
      6874,  6875, 1,    0,    0,    0,    6875, 6878, 1,    0,    0,    0,    6876, 6878, 5,    476,  0,    0,    6877,
      6872,  1,    0,    0,    0,    6877, 6876, 1,    0,    0,    0,    6877, 6878, 1,    0,    0,    0,    6878, 917,
      1,     0,    0,    0,    6879, 6880, 7,    118,  0,    0,    6880, 919,  1,    0,    0,    0,    6881, 6882, 5,
      595,   0,    0,    6882, 6906, 5,    776,  0,    0,    6883, 6886, 3,    860,  430,  0,    6884, 6885, 5,    203,
      0,     0,    6885, 6887, 3,    860,  430,  0,    6886, 6884, 1,    0,    0,    0,    6886, 6887, 1,    0,    0,
      0,     6887, 6907, 1,    0,    0,    0,    6888, 6890, 5,    269,  0,    0,    6889, 6891, 3,    860,  430,  0,
      6890,  6889, 1,    0,    0,    0,    6890, 6891, 1,    0,    0,    0,    6891, 6892, 1,    0,    0,    0,    6892,
      6893,  5,    203,  0,    0,    6893, 6907, 3,    860,  430,  0,    6894, 6896, 5,    591,  0,    0,    6895, 6897,
      3,     860,  430,  0,    6896, 6895, 1,    0,    0,    0,    6896, 6897, 1,    0,    0,    0,    6897, 6898, 1,
      0,     0,    0,    6898, 6899, 5,    203,  0,    0,    6899, 6907, 3,    860,  430,  0,    6900, 6902, 5,    43,
      0,     0,    6901, 6903, 3,    860,  430,  0,    6902, 6901, 1,    0,    0,    0,    6902, 6903, 1,    0,    0,
      0,     6903, 6904, 1,    0,    0,    0,    6904, 6905, 5,    203,  0,    0,    6905, 6907, 3,    860,  430,  0,
      6906,  6883, 1,    0,    0,    0,    6906, 6888, 1,    0,    0,    0,    6906, 6894, 1,    0,    0,    0,    6906,
      6900,  1,    0,    0,    0,    6907, 6908, 1,    0,    0,    0,    6908, 6909, 5,    777,  0,    0,    6909, 921,
      1,     0,    0,    0,    6910, 6911, 5,    563,  0,    0,    6911, 6912, 5,    776,  0,    0,    6912, 6925, 3,
      860,   430,  0,    6913, 6914, 5,    773,  0,    0,    6914, 6917, 3,    860,  430,  0,    6915, 6916, 5,    773,
      0,     0,    6916, 6918, 3,    860,  430,  0,    6917, 6915, 1,    0,    0,    0,    6917, 6918, 1,    0,    0,
      0,     6918, 6926, 1,    0,    0,    0,    6919, 6920, 5,    203,  0,    0,    6920, 6923, 3,    860,  430,  0,
      6921,  6922, 5,    200,  0,    0,    6922, 6924, 3,    860,  430,  0,    6923, 6921, 1,    0,    0,    0,    6923,
      6924,  1,    0,    0,    0,    6924, 6926, 1,    0,    0,    0,    6925, 6913, 1,    0,    0,    0,    6925, 6919,
      1,     0,    0,    0,    6926, 6927, 1,    0,    0,    0,    6927, 6928, 5,    777,  0,    0,    6928, 923,  1,
      0,     0,    0,    6929, 6930, 3,    1344, 672,  0,    6930, 6932, 5,    776,  0,    0,    6931, 6933, 3,    926,
      463,   0,    6932, 6931, 1,    0,    0,    0,    6932, 6933, 1,    0,    0,    0,    6933, 6934, 1,    0,    0,
      0,     6934, 6935, 5,    777,  0,    0,    6935, 6944, 1,    0,    0,    0,    6936, 6937, 3,    1352, 676,  0,
      6937,  6939, 5,    776,  0,    0,    6938, 6940, 3,    948,  474,  0,    6939, 6938, 1,    0,    0,    0,    6939,
      6940,  1,    0,    0,    0,    6940, 6941, 1,    0,    0,    0,    6941, 6942, 5,    777,  0,    0,    6942, 6944,
      1,     0,    0,    0,    6943, 6929, 1,    0,    0,    0,    6943, 6936, 1,    0,    0,    0,    6944, 925,  1,
      0,     0,    0,    6945, 6950, 3,    928,  464,  0,    6946, 6947, 5,    773,  0,    0,    6947, 6949, 3,    928,
      464,   0,    6948, 6946, 1,    0,    0,    0,    6949, 6952, 1,    0,    0,    0,    6950, 6948, 1,    0,    0,
      0,     6950, 6951, 1,    0,    0,    0,    6951, 927,  1,    0,    0,    0,    6952, 6950, 1,    0,    0,    0,
      6953,  6955, 3,    860,  430,  0,    6954, 6956, 3,    366,  183,  0,    6955, 6954, 1,    0,    0,    0,    6955,
      6956,  1,    0,    0,    0,    6956, 929,  1,    0,    0,    0,    6957, 6958, 5,    783,  0,    0,    6958, 6961,
      3,     1406, 703,  0,    6959, 6961, 5,    784,  0,    0,    6960, 6957, 1,    0,    0,    0,    6960, 6959, 1,
      0,     0,    0,    6961, 931,  1,    0,    0,    0,    6962, 6963, 3,    930,  465,  0,    6963, 6964, 5,    751,
      0,     0,    6964, 6965, 3,    860,  430,  0,    6965, 933,  1,    0,    0,    0,    6966, 6973, 3,    930,  465,
      0,     6967, 6969, 5,    785,  0,    0,    6968, 6970, 3,    1420, 710,  0,    6969, 6968, 1,    0,    0,    0,
      6969,  6970, 1,    0,    0,    0,    6970, 6971, 1,    0,    0,    0,    6971, 6973, 3,    938,  469,  0,    6972,
      6966,  1,    0,    0,    0,    6972, 6967, 1,    0,    0,    0,    6973, 935,  1,    0,    0,    0,    6974, 6976,
      3,     1346, 673,  0,    6975, 6977, 3,    1356, 678,  0,    6976, 6975, 1,    0,    0,    0,    6976, 6977, 1,
      0,     0,    0,    6977, 6984, 1,    0,    0,    0,    6978, 6979, 4,    468,  78,   0,    6979, 6981, 3,    1408,
      704,   0,    6980, 6982, 3,    1356, 678,  0,    6981, 6980, 1,    0,    0,    0,    6981, 6982, 1,    0,    0,
      0,     6982, 6984, 1,    0,    0,    0,    6983, 6974, 1,    0,    0,    0,    6983, 6978, 1,    0,    0,    0,
      6984,  6988, 1,    0,    0,    0,    6985, 6986, 5,    128,  0,    0,    6986, 6988, 3,    1356, 678,  0,    6987,
      6983,  1,    0,    0,    0,    6987, 6985, 1,    0,    0,    0,    6988, 937,  1,    0,    0,    0,    6989, 6991,
      3,     1406, 703,  0,    6990, 6992, 3,    1356, 678,  0,    6991, 6990, 1,    0,    0,    0,    6991, 6992, 1,
      0,     0,    0,    6992, 939,  1,    0,    0,    0,    6993, 6994, 5,    642,  0,    0,    6994, 6995, 3,    860,
      430,   0,    6995, 941,  1,    0,    0,    0,    6996, 6997, 5,    582,  0,    0,    6997, 6998, 3,    860,  430,
      0,     6998, 943,  1,    0,    0,    0,    6999, 7000, 5,    154,  0,    0,    7000, 7001, 3,    860,  430,  0,
      7001,  945,  1,    0,    0,    0,    7002, 7004, 5,    32,   0,    0,    7003, 7005, 3,    1116, 558,  0,    7004,
      7003,  1,    0,    0,    0,    7004, 7005, 1,    0,    0,    0,    7005, 7051, 1,    0,    0,    0,    7006, 7008,
      5,     60,   0,    0,    7007, 7009, 3,    1116, 558,  0,    7008, 7007, 1,    0,    0,    0,    7008, 7009, 1,
      0,     0,    0,    7009, 7011, 1,    0,    0,    0,    7010, 7012, 3,    1120, 560,  0,    7011, 7010, 1,    0,
      0,     0,    7011, 7012, 1,    0,    0,    0,    7012, 7051, 1,    0,    0,    0,    7013, 7015, 3,    1112, 556,
      0,     7014, 7016, 3,    1116, 558,  0,    7015, 7014, 1,    0,    0,    0,    7015, 7016, 1,    0,    0,    0,
      7016,  7051, 1,    0,    0,    0,    7017, 7019, 5,    512,  0,    0,    7018, 7020, 5,    249,  0,    0,    7019,
      7018,  1,    0,    0,    0,    7019, 7020, 1,    0,    0,    0,    7020, 7051, 1,    0,    0,    0,    7021, 7023,
      5,     612,  0,    0,    7022, 7024, 5,    249,  0,    0,    7023, 7022, 1,    0,    0,    0,    7023, 7024, 1,
      0,     0,    0,    7024, 7051, 1,    0,    0,    0,    7025, 7051, 5,    116,  0,    0,    7026, 7027, 4,    473,
      79,    0,    7027, 7051, 5,    656,  0,    0,    7028, 7030, 5,    586,  0,    0,    7029, 7031, 3,    1128, 564,
      0,     7030, 7029, 1,    0,    0,    0,    7030, 7031, 1,    0,    0,    0,    7031, 7051, 1,    0,    0,    0,
      7032,  7034, 5,    113,  0,    0,    7033, 7035, 3,    1128, 564,  0,    7034, 7033, 1,    0,    0,    0,    7034,
      7035,  1,    0,    0,    0,    7035, 7051, 1,    0,    0,    0,    7036, 7038, 5,    126,  0,    0,    7037, 7039,
      3,     1400, 700,  0,    7038, 7037, 1,    0,    0,    0,    7038, 7039, 1,    0,    0,    0,    7039, 7051, 1,
      0,     0,    0,    7040, 7051, 5,    262,  0,    0,    7041, 7042, 4,    473,  80,   0,    7042, 7051, 3,    1114,
      557,   0,    7043, 7044, 4,    473,  81,   0,    7044, 7046, 5,    195,  0,    0,    7045, 7047, 3,    1402, 701,
      0,     7046, 7045, 1,    0,    0,    0,    7046, 7047, 1,    0,    0,    0,    7047, 7051, 1,    0,    0,    0,
      7048,  7049, 4,    473,  82,   0,    7049, 7051, 7,    119,  0,    0,    7050, 7002, 1,    0,    0,    0,    7050,
      7006,  1,    0,    0,    0,    7050, 7013, 1,    0,    0,    0,    7050, 7017, 1,    0,    0,    0,    7050, 7021,
      1,     0,    0,    0,    7050, 7025, 1,    0,    0,    0,    7050, 7026, 1,    0,    0,    0,    7050, 7028, 1,
      0,     0,    0,    7050, 7032, 1,    0,    0,    0,    7050, 7036, 1,    0,    0,    0,    7050, 7040, 1,    0,
      0,     0,    7050, 7041, 1,    0,    0,    0,    7050, 7043, 1,    0,    0,    0,    7050, 7048, 1,    0,    0,
      0,     7051, 947,  1,    0,    0,    0,    7052, 7057, 3,    860,  430,  0,    7053, 7054, 5,    773,  0,    0,
      7054,  7056, 3,    860,  430,  0,    7055, 7053, 1,    0,    0,    0,    7056, 7059, 1,    0,    0,    0,    7057,
      7055,  1,    0,    0,    0,    7057, 7058, 1,    0,    0,    0,    7058, 949,  1,    0,    0,    0,    7059, 7057,
      1,     0,    0,    0,    7060, 7061, 5,    60,   0,    0,    7061, 7064, 5,    506,  0,    0,    7062, 7064, 5,
      58,    0,    0,    7063, 7060, 1,    0,    0,    0,    7063, 7062, 1,    0,    0,    0,    7064, 951,  1,    0,
      0,     0,    7065, 7066, 7,    120,  0,    0,    7066, 953,  1,    0,    0,    0,    7067, 7068, 7,    121,  0,
      0,     7068, 955,  1,    0,    0,    0,    7069, 7072, 3,    958,  479,  0,    7070, 7072, 7,    122,  0,    0,
      7071,  7069, 1,    0,    0,    0,    7071, 7070, 1,    0,    0,    0,    7072, 957,  1,    0,    0,    0,    7073,
      7074,  7,    123,  0,    0,    7074, 959,  1,    0,    0,    0,    7075, 7076, 5,    776,  0,    0,    7076, 7077,
      3,     948,  474,  0,    7077, 7078, 5,    777,  0,    0,    7078, 961,  1,    0,    0,    0,    7079, 7080, 5,
      776,   0,    0,    7080, 7081, 3,    860,  430,  0,    7081, 7082, 5,    777,  0,    0,    7082, 963,  1,    0,
      0,     0,    7083, 7084, 5,    776,  0,    0,    7084, 7085, 3,    872,  436,  0,    7085, 7086, 5,    777,  0,
      0,     7086, 965,  1,    0,    0,    0,    7087, 7092, 3,    968,  484,  0,    7088, 7089, 5,    773,  0,    0,
      7089,  7091, 3,    968,  484,  0,    7090, 7088, 1,    0,    0,    0,    7091, 7094, 1,    0,    0,    0,    7092,
      7090,  1,    0,    0,    0,    7092, 7093, 1,    0,    0,    0,    7093, 967,  1,    0,    0,    0,    7094, 7092,
      1,     0,    0,    0,    7095, 7097, 3,    860,  430,  0,    7096, 7098, 3,    340,  170,  0,    7097, 7096, 1,
      0,     0,    0,    7097, 7098, 1,    0,    0,    0,    7098, 969,  1,    0,    0,    0,    7099, 7104, 3,    972,
      486,   0,    7100, 7101, 5,    773,  0,    0,    7101, 7103, 3,    972,  486,  0,    7102, 7100, 1,    0,    0,
      0,     7103, 7106, 1,    0,    0,    0,    7104, 7102, 1,    0,    0,    0,    7104, 7105, 1,    0,    0,    0,
      7105,  971,  1,    0,    0,    0,    7106, 7104, 1,    0,    0,    0,    7107, 7108, 3,    860,  430,  0,    7108,
      973,   1,    0,    0,    0,    7109, 7110, 5,    200,  0,    0,    7110, 7111, 5,    57,   0,    0,    7111, 7112,
      3,     1386, 693,  0,    7112, 975,  1,    0,    0,    0,    7113, 7127, 3,    2,    1,    0,    7114, 7127, 3,
      978,   489,  0,    7115, 7127, 3,    980,  490,  0,    7116, 7127, 3,    988,  494,  0,    7117, 7127, 3,    992,
      496,   0,    7118, 7127, 3,    994,  497,  0,    7119, 7127, 3,    1000, 500,  0,    7120, 7127, 3,    1002, 501,
      0,     7121, 7127, 3,    1030, 515,  0,    7122, 7127, 3,    1028, 514,  0,    7123, 7127, 3,    1048, 524,  0,
      7124,  7127, 3,    1052, 526,  0,    7125, 7127, 3,    1050, 525,  0,    7126, 7113, 1,    0,    0,    0,    7126,
      7114,  1,    0,    0,    0,    7126, 7115, 1,    0,    0,    0,    7126, 7116, 1,    0,    0,    0,    7126, 7117,
      1,     0,    0,    0,    7126, 7118, 1,    0,    0,    0,    7126, 7119, 1,    0,    0,    0,    7126, 7120, 1,
      0,     0,    0,    7126, 7121, 1,    0,    0,    0,    7126, 7122, 1,    0,    0,    0,    7126, 7123, 1,    0,
      0,     0,    7126, 7124, 1,    0,    0,    0,    7126, 7125, 1,    0,    0,    0,    7127, 977,  1,    0,    0,
      0,     7128, 7129, 5,    475,  0,    0,    7129, 7130, 3,    860,  430,  0,    7130, 979,  1,    0,    0,    0,
      7131,  7132, 5,    231,  0,    0,    7132, 7133, 3,    982,  491,  0,    7133, 7134, 5,    159,  0,    0,    7134,
      7135,  5,    231,  0,    0,    7135, 981,  1,    0,    0,    0,    7136, 7137, 3,    860,  430,  0,    7137, 7142,
      3,     984,  492,  0,    7138, 7139, 5,    155,  0,    0,    7139, 7143, 3,    982,  491,  0,    7140, 7141, 5,
      154,   0,    0,    7141, 7143, 3,    986,  493,  0,    7142, 7138, 1,    0,    0,    0,    7142, 7140, 1,    0,
      0,     0,    7142, 7143, 1,    0,    0,    0,    7143, 983,  1,    0,    0,    0,    7144, 7145, 5,    582,  0,
      0,     7145, 7146, 3,    986,  493,  0,    7146, 985,  1,    0,    0,    0,    7147, 7148, 3,    976,  488,  0,
      7148,  7149, 5,    774,  0,    0,    7149, 7151, 1,    0,    0,    0,    7150, 7147, 1,    0,    0,    0,    7151,
      7152,  1,    0,    0,    0,    7152, 7150, 1,    0,    0,    0,    7152, 7153, 1,    0,    0,    0,    7153, 987,
      1,     0,    0,    0,    7154, 7156, 5,    51,   0,    0,    7155, 7157, 3,    860,  430,  0,    7156, 7155, 1,
      0,     0,    0,    7156, 7157, 1,    0,    0,    0,    7157, 7161, 1,    0,    0,    0,    7158, 7159, 3,    940,
      470,   0,    7159, 7160, 3,    984,  492,  0,    7160, 7162, 1,    0,    0,    0,    7161, 7158, 1,    0,    0,
      0,     7162, 7163, 1,    0,    0,    0,    7163, 7161, 1,    0,    0,    0,    7163, 7164, 1,    0,    0,    0,
      7164,  7166, 1,    0,    0,    0,    7165, 7167, 3,    990,  495,  0,    7166, 7165, 1,    0,    0,    0,    7166,
      7167,  1,    0,    0,    0,    7167, 7168, 1,    0,    0,    0,    7168, 7169, 5,    159,  0,    0,    7169, 7170,
      5,     51,   0,    0,    7170, 989,  1,    0,    0,    0,    7171, 7172, 5,    154,  0,    0,    7172, 7173, 3,
      986,   493,  0,    7173, 991,  1,    0,    0,    0,    7174, 7175, 3,    996,  498,  0,    7175, 7177, 3,    998,
      499,   0,    7176, 7178, 3,    1332, 666,  0,    7177, 7176, 1,    0,    0,    0,    7177, 7178, 1,    0,    0,
      0,     7178, 993,  1,    0,    0,    0,    7179, 7180, 3,    998,  499,  0,    7180, 995,  1,    0,    0,    0,
      7181,  7182, 3,    1330, 665,  0,    7182, 7183, 5,    775,  0,    0,    7183, 997,  1,    0,    0,    0,    7184,
      7186,  5,    29,   0,    0,    7185, 7187, 3,    1010, 505,  0,    7186, 7185, 1,    0,    0,    0,    7186, 7187,
      1,     0,    0,    0,    7187, 7189, 1,    0,    0,    0,    7188, 7190, 3,    986,  493,  0,    7189, 7188, 1,
      0,     0,    0,    7189, 7190, 1,    0,    0,    0,    7190, 7191, 1,    0,    0,    0,    7191, 7192, 5,    159,
      0,     0,    7192, 999,  1,    0,    0,    0,    7193, 7194, 3,    996,  498,  0,    7194, 7196, 3,    1002, 501,
      0,     7195, 7197, 3,    1332, 666,  0,    7196, 7195, 1,    0,    0,    0,    7196, 7197, 1,    0,    0,    0,
      7197,  1001, 1,    0,    0,    0,    7198, 7202, 3,    1004, 502,  0,    7199, 7202, 3,    1006, 503,  0,    7200,
      7202,  3,    1008, 504,  0,    7201, 7198, 1,    0,    0,    0,    7201, 7199, 1,    0,    0,    0,    7201, 7200,
      1,     0,    0,    0,    7202, 1003, 1,    0,    0,    0,    7203, 7204, 5,    294,  0,    0,    7204, 7205, 3,
      986,   493,  0,    7205, 7206, 5,    159,  0,    0,    7206, 7207, 5,    294,  0,    0,    7207, 1005, 1,    0,
      0,     0,    7208, 7209, 5,    644,  0,    0,    7209, 7210, 3,    860,  430,  0,    7210, 7211, 5,    147,  0,
      0,     7211, 7212, 3,    986,  493,  0,    7212, 7213, 5,    159,  0,    0,    7213, 7214, 5,    644,  0,    0,
      7214,  1007, 1,    0,    0,    0,    7215, 7216, 5,    457,  0,    0,    7216, 7217, 3,    986,  493,  0,    7217,
      7218,  5,    613,  0,    0,    7218, 7219, 3,    860,  430,  0,    7219, 7220, 5,    159,  0,    0,    7220, 7221,
      5,     457,  0,    0,    7221, 1009, 1,    0,    0,    0,    7222, 7223, 3,    1012, 506,  0,    7223, 7224, 5,
      774,   0,    0,    7224, 7226, 1,    0,    0,    0,    7225, 7222, 1,    0,    0,    0,    7226, 7227, 1,    0,
      0,     0,    7227, 7225, 1,    0,    0,    0,    7227, 7228, 1,    0,    0,    0,    7228, 1011, 1,    0,    0,
      0,     7229, 7234, 3,    1014, 507,  0,    7230, 7234, 3,    1016, 508,  0,    7231, 7234, 3,    1022, 511,  0,
      7232,  7234, 3,    1026, 513,  0,    7233, 7229, 1,    0,    0,    0,    7233, 7230, 1,    0,    0,    0,    7233,
      7231,  1,    0,    0,    0,    7233, 7232, 1,    0,    0,    0,    7234, 1013, 1,    0,    0,    0,    7235, 7236,
      5,     127,  0,    0,    7236, 7237, 3,    1348, 674,  0,    7237, 7239, 3,    1110, 555,  0,    7238, 7240, 3,
      1188,  594,  0,    7239, 7238, 1,    0,    0,    0,    7239, 7240, 1,    0,    0,    0,    7240, 7243, 1,    0,
      0,     0,    7241, 7242, 5,    128,  0,    0,    7242, 7244, 3,    860,  430,  0,    7243, 7241, 1,    0,    0,
      0,     7243, 7244, 1,    0,    0,    0,    7244, 1015, 1,    0,    0,    0,    7245, 7246, 5,    127,  0,    0,
      7246,  7247, 3,    1346, 673,  0,    7247, 7248, 5,    83,   0,    0,    7248, 7249, 5,    200,  0,    0,    7249,
      7250,  3,    1018, 509,  0,    7250, 1017, 1,    0,    0,    0,    7251, 7254, 3,    1358, 679,  0,    7252, 7254,
      3,     1020, 510,  0,    7253, 7251, 1,    0,    0,    0,    7253, 7252, 1,    0,    0,    0,    7254, 1019, 1,
      0,     0,    0,    7255, 7257, 5,    526,  0,    0,    7256, 7258, 5,    627,  0,    0,    7257, 7256, 1,    0,
      0,     0,    7257, 7258, 1,    0,    0,    0,    7258, 7259, 1,    0,    0,    0,    7259, 7260, 3,    1384, 692,
      0,     7260, 1021, 1,    0,    0,    0,    7261, 7262, 5,    127,  0,    0,    7262, 7263, 7,    124,  0,    0,
      7263,  7264, 5,    219,  0,    0,    7264, 7265, 5,    200,  0,    0,    7265, 7270, 3,    1024, 512,  0,    7266,
      7267,  5,    773,  0,    0,    7267, 7269, 3,    1024, 512,  0,    7268, 7266, 1,    0,    0,    0,    7269, 7272,
      1,     0,    0,    0,    7270, 7268, 1,    0,    0,    0,    7270, 7271, 1,    0,    0,    0,    7271, 7273, 1,
      0,     0,    0,    7272, 7270, 1,    0,    0,    0,    7273, 7274, 3,    976,  488,  0,    7274, 1023, 1,    0,
      0,     0,    7275, 7283, 3,    1018, 509,  0,    7276, 7283, 3,    1346, 673,  0,    7277, 7283, 5,    527,  0,
      0,     7278, 7279, 3,    952,  476,  0,    7279, 7280, 5,    202,  0,    0,    7280, 7283, 1,    0,    0,    0,
      7281,  7283, 5,    525,  0,    0,    7282, 7275, 1,    0,    0,    0,    7282, 7276, 1,    0,    0,    0,    7282,
      7277,  1,    0,    0,    0,    7282, 7278, 1,    0,    0,    0,    7282, 7281, 1,    0,    0,    0,    7283, 1025,
      1,     0,    0,    0,    7284, 7285, 5,    127,  0,    0,    7285, 7286, 3,    1346, 673,  0,    7286, 7287, 5,
      106,   0,    0,    7287, 7288, 5,    200,  0,    0,    7288, 7289, 3,    276,  138,  0,    7289, 1027, 1,    0,
      0,     0,    7290, 7291, 5,    260,  0,    0,    7291, 7292, 3,    1332, 666,  0,    7292, 1029, 1,    0,    0,
      0,     7293, 7294, 5,    271,  0,    0,    7294, 7295, 3,    1332, 666,  0,    7295, 1031, 1,    0,    0,    0,
      7296,  7298, 5,    207,  0,    0,    7297, 7299, 7,    125,  0,    0,    7298, 7297, 1,    0,    0,    0,    7298,
      7299,  1,    0,    0,    0,    7299, 7300, 1,    0,    0,    0,    7300, 7319, 5,    138,  0,    0,    7301, 7306,
      3,     1036, 518,  0,    7302, 7303, 5,    773,  0,    0,    7303, 7305, 3,    1036, 518,  0,    7304, 7302, 1,
      0,     0,    0,    7305, 7308, 1,    0,    0,    0,    7306, 7304, 1,    0,    0,    0,    7306, 7307, 1,    0,
      0,     0,    7307, 7320, 1,    0,    0,    0,    7308, 7306, 1,    0,    0,    0,    7309, 7310, 5,    83,   0,
      0,     7310, 7311, 3,    1034, 517,  0,    7311, 7316, 3,    1038, 519,  0,    7312, 7313, 5,    773,  0,    0,
      7313,  7315, 3,    1038, 519,  0,    7314, 7312, 1,    0,    0,    0,    7315, 7318, 1,    0,    0,    0,    7316,
      7314,  1,    0,    0,    0,    7316, 7317, 1,    0,    0,    0,    7317, 7320, 1,    0,    0,    0,    7318, 7316,
      1,     0,    0,    0,    7319, 7301, 1,    0,    0,    0,    7319, 7309, 1,    0,    0,    0,    7320, 1033, 1,
      0,     0,    0,    7321, 7325, 3,    1370, 685,  0,    7322, 7325, 3,    934,  467,  0,    7323, 7325, 3,    1352,
      676,   0,    7324, 7321, 1,    0,    0,    0,    7324, 7322, 1,    0,    0,    0,    7324, 7323, 1,    0,    0,
      0,     7325, 1035, 1,    0,    0,    0,    7326, 7329, 3,    930,  465,  0,    7327, 7329, 3,    1346, 673,  0,
      7328,  7326, 1,    0,    0,    0,    7328, 7327, 1,    0,    0,    0,    7329, 7330, 1,    0,    0,    0,    7330,
      7331,  5,    750,  0,    0,    7331, 7332, 7,    126,  0,    0,    7332, 1037, 1,    0,    0,    0,    7333, 7336,
      3,     930,  465,  0,    7334, 7336, 3,    1346, 673,  0,    7335, 7333, 1,    0,    0,    0,    7335, 7334, 1,
      0,     0,    0,    7336, 7337, 1,    0,    0,    0,    7337, 7340, 5,    750,  0,    0,    7338, 7341, 3,    1040,
      520,   0,    7339, 7341, 5,    473,  0,    0,    7340, 7338, 1,    0,    0,    0,    7340, 7339, 1,    0,    0,
      0,     7341, 1039, 1,    0,    0,    0,    7342, 7343, 7,    127,  0,    0,    7343, 1041, 1,    0,    0,    0,
      7344,  7347, 5,    511,  0,    0,    7345, 7348, 3,    1346, 673,  0,    7346, 7348, 3,    1020, 510,  0,    7347,
      7345,  1,    0,    0,    0,    7347, 7346, 1,    0,    0,    0,    7348, 7358, 1,    0,    0,    0,    7349, 7350,
      5,     506,  0,    0,    7350, 7355, 3,    1046, 523,  0,    7351, 7352, 5,    773,  0,    0,    7352, 7354, 3,
      1046,  523,  0,    7353, 7351, 1,    0,    0,    0,    7354, 7357, 1,    0,    0,    0,    7355, 7353, 1,    0,
      0,     0,    7355, 7356, 1,    0,    0,    0,    7356, 7359, 1,    0,    0,    0,    7357, 7355, 1,    0,    0,
      0,     7358, 7349, 1,    0,    0,    0,    7358, 7359, 1,    0,    0,    0,    7359, 1043, 1,    0,    0,    0,
      7360,  7363, 5,    469,  0,    0,    7361, 7364, 3,    1346, 673,  0,    7362, 7364, 3,    1020, 510,  0,    7363,
      7361,  1,    0,    0,    0,    7363, 7362, 1,    0,    0,    0,    7363, 7364, 1,    0,    0,    0,    7364, 7374,
      1,     0,    0,    0,    7365, 7366, 5,    506,  0,    0,    7366, 7371, 3,    1046, 523,  0,    7367, 7368, 5,
      773,   0,    0,    7368, 7370, 3,    1046, 523,  0,    7369, 7367, 1,    0,    0,    0,    7370, 7373, 1,    0,
      0,     0,    7371, 7369, 1,    0,    0,    0,    7371, 7372, 1,    0,    0,    0,    7372, 7375, 1,    0,    0,
      0,     7373, 7371, 1,    0,    0,    0,    7374, 7365, 1,    0,    0,    0,    7374, 7375, 1,    0,    0,    0,
      7375,  1045, 1,    0,    0,    0,    7376, 7377, 3,    1040, 520,  0,    7377, 7378, 5,    750,  0,    0,    7378,
      7379,  3,    1034, 517,  0,    7379, 1047, 1,    0,    0,    0,    7380, 7381, 5,    387,  0,    0,    7381, 7382,
      3,     1346, 673,  0,    7382, 1049, 1,    0,    0,    0,    7383, 7384, 5,    66,   0,    0,    7384, 7385, 3,
      1346,  673,  0,    7385, 1051, 1,    0,    0,    0,    7386, 7391, 5,    186,  0,    0,    7387, 7389, 5,    367,
      0,     0,    7388, 7387, 1,    0,    0,    0,    7388, 7389, 1,    0,    0,    0,    7389, 7390, 1,    0,    0,
      0,     7390, 7392, 5,    203,  0,    0,    7391, 7388, 1,    0,    0,    0,    7391, 7392, 1,    0,    0,    0,
      7392,  7393, 1,    0,    0,    0,    7393, 7394, 3,    1346, 673,  0,    7394, 7395, 5,    248,  0,    0,    7395,
      7396,  3,    1348, 674,  0,    7396, 1053, 1,    0,    0,    0,    7397, 7398, 5,    21,   0,    0,    7398, 7411,
      3,     860,  430,  0,    7399, 7400, 5,    171,  0,    0,    7400, 7401, 3,    860,  430,  0,    7401, 7404, 3,
      956,   478,  0,    7402, 7403, 5,    542,  0,    0,    7403, 7405, 3,    860,  430,  0,    7404, 7402, 1,    0,
      0,     0,    7404, 7405, 1,    0,    0,    0,    7405, 7408, 1,    0,    0,    0,    7406, 7407, 5,    160,  0,
      0,     7407, 7409, 3,    860,  430,  0,    7408, 7406, 1,    0,    0,    0,    7408, 7409, 1,    0,    0,    0,
      7409,  7411, 1,    0,    0,    0,    7410, 7397, 1,    0,    0,    0,    7410, 7399, 1,    0,    0,    0,    7411,
      1055,  1,    0,    0,    0,    7412, 7413, 3,    1260, 630,  0,    7413, 7415, 3,    1068, 534,  0,    7414, 7416,
      3,     1058, 529,  0,    7415, 7414, 1,    0,    0,    0,    7415, 7416, 1,    0,    0,    0,    7416, 1057, 1,
      0,     0,    0,    7417, 7418, 4,    529,  83,   0,    7418, 7421, 3,    1060, 530,  0,    7419, 7421, 3,    1082,
      541,   0,    7420, 7417, 1,    0,    0,    0,    7420, 7419, 1,    0,    0,    0,    7421, 1059, 1,    0,    0,
      0,     7422, 7423, 5,    62,   0,    0,    7423, 7424, 3,    962,  481,  0,    7424, 1061, 1,    0,    0,    0,
      7425,  7427, 5,    371,  0,    0,    7426, 7425, 1,    0,    0,    0,    7426, 7427, 1,    0,    0,    0,    7427,
      7428,  1,    0,    0,    0,    7428, 7429, 5,    730,  0,    0,    7429, 1063, 1,    0,    0,    0,    7430, 7432,
      7,     39,   0,    0,    7431, 7433, 3,    116,  58,   0,    7432, 7431, 1,    0,    0,    0,    7432, 7433, 1,
      0,     0,    0,    7433, 7434, 1,    0,    0,    0,    7434, 7438, 3,    1090, 545,  0,    7435, 7437, 3,    1096,
      548,   0,    7436, 7435, 1,    0,    0,    0,    7437, 7440, 1,    0,    0,    0,    7438, 7436, 1,    0,    0,
      0,     7438, 7439, 1,    0,    0,    0,    7439, 7506, 1,    0,    0,    0,    7440, 7438, 1,    0,    0,    0,
      7441,  7443, 5,    205,  0,    0,    7442, 7444, 3,    418,  209,  0,    7443, 7442, 1,    0,    0,    0,    7443,
      7444,  1,    0,    0,    0,    7444, 7446, 1,    0,    0,    0,    7445, 7447, 3,    1270, 635,  0,    7446, 7445,
      1,     0,    0,    0,    7446, 7447, 1,    0,    0,    0,    7447, 7448, 1,    0,    0,    0,    7448, 7452, 3,
      1090,  545,  0,    7449, 7451, 3,    1104, 552,  0,    7450, 7449, 1,    0,    0,    0,    7451, 7454, 1,    0,
      0,     0,    7452, 7450, 1,    0,    0,    0,    7452, 7453, 1,    0,    0,    0,    7453, 7506, 1,    0,    0,
      0,     7454, 7452, 1,    0,    0,    0,    7455, 7457, 5,    523,  0,    0,    7456, 7458, 3,    418,  209,  0,
      7457,  7456, 1,    0,    0,    0,    7457, 7458, 1,    0,    0,    0,    7458, 7460, 1,    0,    0,    0,    7459,
      7461,  3,    1270, 635,  0,    7460, 7459, 1,    0,    0,    0,    7460, 7461, 1,    0,    0,    0,    7461, 7462,
      1,     0,    0,    0,    7462, 7466, 3,    1090, 545,  0,    7463, 7465, 3,    1106, 553,  0,    7464, 7463, 1,
      0,     0,    0,    7465, 7468, 1,    0,    0,    0,    7466, 7464, 1,    0,    0,    0,    7466, 7467, 1,    0,
      0,     0,    7467, 7506, 1,    0,    0,    0,    7468, 7466, 1,    0,    0,    0,    7469, 7471, 3,    1066, 533,
      0,     7470, 7469, 1,    0,    0,    0,    7470, 7471, 1,    0,    0,    0,    7471, 7503, 1,    0,    0,    0,
      7472,  7473, 5,    420,  0,    0,    7473, 7479, 5,    265,  0,    0,    7474, 7476, 5,    609,  0,    0,    7475,
      7477,  3,    418,  209,  0,    7476, 7475, 1,    0,    0,    0,    7476, 7477, 1,    0,    0,    0,    7477, 7479,
      1,     0,    0,    0,    7478, 7472, 1,    0,    0,    0,    7478, 7474, 1,    0,    0,    0,    7479, 7481, 1,
      0,     0,    0,    7480, 7482, 3,    116,  58,   0,    7481, 7480, 1,    0,    0,    0,    7481, 7482, 1,    0,
      0,     0,    7482, 7483, 1,    0,    0,    0,    7483, 7487, 3,    1090, 545,  0,    7484, 7486, 3,    1096, 548,
      0,     7485, 7484, 1,    0,    0,    0,    7486, 7489, 1,    0,    0,    0,    7487, 7485, 1,    0,    0,    0,
      7487,  7488, 1,    0,    0,    0,    7488, 7504, 1,    0,    0,    0,    7489, 7487, 1,    0,    0,    0,    7490,
      7491,  5,    199,  0,    0,    7491, 7493, 5,    265,  0,    0,    7492, 7494, 3,    1270, 635,  0,    7493, 7492,
      1,     0,    0,    0,    7493, 7494, 1,    0,    0,    0,    7494, 7495, 1,    0,    0,    0,    7495, 7496, 3,
      1086,  543,  0,    7496, 7497, 3,    1082, 541,  0,    7497, 7504, 1,    0,    0,    0,    7498, 7501, 3,    1060,
      530,   0,    7499, 7500, 4,    532,  84,   0,    7500, 7502, 3,    1062, 531,  0,    7501, 7499, 1,    0,    0,
      0,     7501, 7502, 1,    0,    0,    0,    7502, 7504, 1,    0,    0,    0,    7503, 7478, 1,    0,    0,    0,
      7503,  7490, 1,    0,    0,    0,    7503, 7498, 1,    0,    0,    0,    7504, 7506, 1,    0,    0,    0,    7505,
      7430,  1,    0,    0,    0,    7505, 7441, 1,    0,    0,    0,    7505, 7455, 1,    0,    0,    0,    7505, 7470,
      1,     0,    0,    0,    7506, 1065, 1,    0,    0,    0,    7507, 7509, 5,    86,   0,    0,    7508, 7510, 3,
      1346,  673,  0,    7509, 7508, 1,    0,    0,    0,    7509, 7510, 1,    0,    0,    0,    7510, 1067, 1,    0,
      0,     0,    7511, 7536, 3,    1110, 555,  0,    7512, 7514, 3,    1070, 535,  0,    7513, 7512, 1,    0,    0,
      0,     7514, 7517, 1,    0,    0,    0,    7515, 7513, 1,    0,    0,    0,    7515, 7516, 1,    0,    0,    0,
      7516,  7537, 1,    0,    0,    0,    7517, 7515, 1,    0,    0,    0,    7518, 7520, 3,    1188, 594,  0,    7519,
      7518,  1,    0,    0,    0,    7519, 7520, 1,    0,    0,    0,    7520, 7523, 1,    0,    0,    0,    7521, 7522,
      5,     209,  0,    0,    7522, 7524, 5,    12,   0,    0,    7523, 7521, 1,    0,    0,    0,    7523, 7524, 1,
      0,     0,    0,    7524, 7525, 1,    0,    0,    0,    7525, 7526, 5,    17,   0,    0,    7526, 7528, 3,    962,
      481,   0,    7527, 7529, 7,    128,  0,    0,    7528, 7527, 1,    0,    0,    0,    7528, 7529, 1,    0,    0,
      0,     7529, 7533, 1,    0,    0,    0,    7530, 7532, 3,    1070, 535,  0,    7531, 7530, 1,    0,    0,    0,
      7532,  7535, 1,    0,    0,    0,    7533, 7531, 1,    0,    0,    0,    7533, 7534, 1,    0,    0,    0,    7534,
      7537,  1,    0,    0,    0,    7535, 7533, 1,    0,    0,    0,    7536, 7515, 1,    0,    0,    0,    7536, 7519,
      1,     0,    0,    0,    7537, 1069, 1,    0,    0,    0,    7538, 7540, 5,    371,  0,    0,    7539, 7538, 1,
      0,     0,    0,    7539, 7540, 1,    0,    0,    0,    7540, 7541, 1,    0,    0,    0,    7541, 7600, 3,    1394,
      697,   0,    7542, 7543, 4,    535,  85,   0,    7543, 7544, 5,    371,  0,    0,    7544, 7600, 5,    720,  0,
      0,     7545, 7549, 5,    128,  0,    0,    7546, 7550, 3,    1078, 539,  0,    7547, 7548, 4,    535,  86,   0,
      7548,  7550, 3,    962,  481,  0,    7549, 7546, 1,    0,    0,    0,    7549, 7547, 1,    0,    0,    0,    7550,
      7600,  1,    0,    0,    0,    7551, 7552, 5,    383,  0,    0,    7552, 7553, 5,    614,  0,    0,    7553, 7555,
      5,     372,  0,    0,    7554, 7556, 3,    910,  455,  0,    7555, 7554, 1,    0,    0,    0,    7555, 7556, 1,
      0,     0,    0,    7556, 7600, 1,    0,    0,    0,    7557, 7600, 5,    24,   0,    0,    7558, 7559, 5,    501,
      0,     0,    7559, 7560, 5,    128,  0,    0,    7560, 7600, 5,    627,  0,    0,    7561, 7563, 5,    420,  0,
      0,     7562, 7561, 1,    0,    0,    0,    7562, 7563, 1,    0,    0,    0,    7563, 7564, 1,    0,    0,    0,
      7564,  7600, 5,    265,  0,    0,    7565, 7567, 5,    609,  0,    0,    7566, 7568, 5,    265,  0,    0,    7567,
      7566,  1,    0,    0,    0,    7567, 7568, 1,    0,    0,    0,    7568, 7600, 1,    0,    0,    0,    7569, 7570,
      5,     75,   0,    0,    7570, 7600, 3,    1384, 692,  0,    7571, 7600, 3,    1188, 594,  0,    7572, 7573, 5,
      74,    0,    0,    7573, 7600, 3,    1072, 536,  0,    7574, 7575, 5,    553,  0,    0,    7575, 7600, 3,    1074,
      537,   0,    7576, 7577, 5,    707,  0,    0,    7577, 7600, 3,    1364, 682,  0,    7578, 7580, 4,    535,  87,
      0,     7579, 7581, 3,    1066, 533,  0,    7580, 7579, 1,    0,    0,    0,    7580, 7581, 1,    0,    0,    0,
      7581,  7582, 1,    0,    0,    0,    7582, 7600, 3,    1060, 530,  0,    7583, 7584, 4,    535,  88,   0,    7584,
      7600,  3,    1062, 531,  0,    7585, 7586, 4,    535,  89,   0,    7586, 7588, 5,    798,  0,    0,    7587, 7589,
      5,     750,  0,    0,    7588, 7587, 1,    0,    0,    0,    7588, 7589, 1,    0,    0,    0,    7589, 7590, 1,
      0,     0,    0,    7590, 7600, 3,    1424, 712,  0,    7591, 7592, 4,    535,  90,   0,    7592, 7594, 5,    799,
      0,     0,    7593, 7595, 5,    750,  0,    0,    7594, 7593, 1,    0,    0,    0,    7594, 7595, 1,    0,    0,
      0,     7595, 7596, 1,    0,    0,    0,    7596, 7600, 3,    1424, 712,  0,    7597, 7598, 4,    535,  91,   0,
      7598,  7600, 3,    1100, 550,  0,    7599, 7539, 1,    0,    0,    0,    7599, 7542, 1,    0,    0,    0,    7599,
      7545,  1,    0,    0,    0,    7599, 7551, 1,    0,    0,    0,    7599, 7557, 1,    0,    0,    0,    7599, 7558,
      1,     0,    0,    0,    7599, 7562, 1,    0,    0,    0,    7599, 7565, 1,    0,    0,    0,    7599, 7569, 1,
      0,     0,    0,    7599, 7571, 1,    0,    0,    0,    7599, 7572, 1,    0,    0,    0,    7599, 7574, 1,    0,
      0,     0,    7599, 7576, 1,    0,    0,    0,    7599, 7578, 1,    0,    0,    0,    7599, 7583, 1,    0,    0,
      0,     7599, 7585, 1,    0,    0,    0,    7599, 7591, 1,    0,    0,    0,    7599, 7597, 1,    0,    0,    0,
      7600,  1071, 1,    0,    0,    0,    7601, 7602, 7,    129,  0,    0,    7602, 1073, 1,    0,    0,    0,    7603,
      7604,  7,    130,  0,    0,    7604, 1075, 1,    0,    0,    0,    7605, 7606, 5,    372,  0,    0,    7606, 7607,
      3,     1130, 565,  0,    7607, 1077, 1,    0,    0,    0,    7608, 7611, 3,    1076, 538,  0,    7609, 7611, 3,
      1368,  684,  0,    7610, 7608, 1,    0,    0,    0,    7610, 7609, 1,    0,    0,    0,    7611, 1079, 1,    0,
      0,     0,    7612, 7614, 5,    609,  0,    0,    7613, 7615, 5,    265,  0,    0,    7614, 7613, 1,    0,    0,
      0,     7614, 7615, 1,    0,    0,    0,    7615, 7627, 1,    0,    0,    0,    7616, 7617, 5,    75,   0,    0,
      7617,  7627, 3,    1380, 690,  0,    7618, 7620, 3,    952,  476,  0,    7619, 7618, 1,    0,    0,    0,    7619,
      7620,  1,    0,    0,    0,    7620, 7621, 1,    0,    0,    0,    7621, 7627, 5,    376,  0,    0,    7622, 7624,
      5,     420,  0,    0,    7623, 7622, 1,    0,    0,    0,    7623, 7624, 1,    0,    0,    0,    7624, 7625, 1,
      0,     0,    0,    7625, 7627, 5,    265,  0,    0,    7626, 7612, 1,    0,    0,    0,    7626, 7616, 1,    0,
      0,     0,    7626, 7619, 1,    0,    0,    0,    7626, 7623, 1,    0,    0,    0,    7627, 1081, 1,    0,    0,
      0,     7628, 7629, 5,    443,  0,    0,    7629, 7631, 3,    1322, 661,  0,    7630, 7632, 3,    1350, 675,  0,
      7631,  7630, 1,    0,    0,    0,    7631, 7632, 1,    0,    0,    0,    7632, 7635, 1,    0,    0,    0,    7633,
      7634,  5,    320,  0,    0,    7634, 7636, 7,    131,  0,    0,    7635, 7633, 1,    0,    0,    0,    7635, 7636,
      1,     0,    0,    0,    7636, 7653, 1,    0,    0,    0,    7637, 7638, 5,    383,  0,    0,    7638, 7639, 5,
      614,   0,    0,    7639, 7643, 3,    1084, 542,  0,    7640, 7641, 5,    383,  0,    0,    7641, 7642, 5,    133,
      0,     0,    7642, 7644, 3,    1084, 542,  0,    7643, 7640, 1,    0,    0,    0,    7643, 7644, 1,    0,    0,
      0,     7644, 7654, 1,    0,    0,    0,    7645, 7646, 5,    383,  0,    0,    7646, 7647, 5,    133,  0,    0,
      7647,  7651, 3,    1084, 542,  0,    7648, 7649, 5,    383,  0,    0,    7649, 7650, 5,    614,  0,    0,    7650,
      7652,  3,    1084, 542,  0,    7651, 7648, 1,    0,    0,    0,    7651, 7652, 1,    0,    0,    0,    7652, 7654,
      1,     0,    0,    0,    7653, 7637, 1,    0,    0,    0,    7653, 7645, 1,    0,    0,    0,    7653, 7654, 1,
      0,     0,    0,    7654, 1083, 1,    0,    0,    0,    7655, 7663, 7,    2,    0,    0,    7656, 7657, 5,    506,
      0,     0,    7657, 7663, 3,    1394, 697,  0,    7658, 7659, 5,    506,  0,    0,    7659, 7663, 5,    128,  0,
      0,     7660, 7661, 5,    373,  0,    0,    7661, 7663, 5,    3,    0,    0,    7662, 7655, 1,    0,    0,    0,
      7662,  7656, 1,    0,    0,    0,    7662, 7658, 1,    0,    0,    0,    7662, 7660, 1,    0,    0,    0,    7663,
      1085,  1,    0,    0,    0,    7664, 7665, 5,    776,  0,    0,    7665, 7670, 3,    1088, 544,  0,    7666, 7667,
      5,     773,  0,    0,    7667, 7669, 3,    1088, 544,  0,    7668, 7666, 1,    0,    0,    0,    7669, 7672, 1,
      0,     0,    0,    7670, 7668, 1,    0,    0,    0,    7670, 7671, 1,    0,    0,    0,    7671, 7673, 1,    0,
      0,     0,    7672, 7670, 1,    0,    0,    0,    7673, 7674, 5,    777,  0,    0,    7674, 1087, 1,    0,    0,
      0,     7675, 7677, 3,    1346, 673,  0,    7676, 7678, 3,    1116, 558,  0,    7677, 7676, 1,    0,    0,    0,
      7677,  7678, 1,    0,    0,    0,    7678, 7680, 1,    0,    0,    0,    7679, 7681, 3,    340,  170,  0,    7680,
      7679,  1,    0,    0,    0,    7680, 7681, 1,    0,    0,    0,    7681, 1089, 1,    0,    0,    0,    7682, 7683,
      5,     776,  0,    0,    7683, 7688, 3,    1092, 546,  0,    7684, 7685, 5,    773,  0,    0,    7685, 7687, 3,
      1092,  546,  0,    7686, 7684, 1,    0,    0,    0,    7687, 7690, 1,    0,    0,    0,    7688, 7686, 1,    0,
      0,     0,    7688, 7689, 1,    0,    0,    0,    7689, 7691, 1,    0,    0,    0,    7690, 7688, 1,    0,    0,
      0,     7691, 7692, 5,    777,  0,    0,    7692, 1091, 1,    0,    0,    0,    7693, 7700, 3,    1088, 544,  0,
      7694,  7695, 4,    546,  92,   0,    7695, 7697, 3,    962,  481,  0,    7696, 7698, 3,    340,  170,  0,    7697,
      7696,  1,    0,    0,    0,    7697, 7698, 1,    0,    0,    0,    7698, 7700, 1,    0,    0,    0,    7699, 7693,
      1,     0,    0,    0,    7699, 7694, 1,    0,    0,    0,    7700, 1093, 1,    0,    0,    0,    7701, 7702, 7,
      132,   0,    0,    7702, 1095, 1,    0,    0,    0,    7703, 7706, 3,    1098, 549,  0,    7704, 7706, 3,    1102,
      551,   0,    7705, 7703, 1,    0,    0,    0,    7705, 7704, 1,    0,    0,    0,    7706, 1097, 1,    0,    0,
      0,     7707, 7709, 5,    264,  0,    0,    7708, 7710, 5,    750,  0,    0,    7709, 7708, 1,    0,    0,    0,
      7709,  7710, 1,    0,    0,    0,    7710, 7711, 1,    0,    0,    0,    7711, 7728, 3,    1358, 679,  0,    7712,
      7713,  5,    75,   0,    0,    7713, 7728, 3,    1384, 692,  0,    7714, 7728, 3,    1100, 550,  0,    7715, 7716,
      4,     549,  93,   0,    7716, 7718, 5,    798,  0,    0,    7717, 7719, 5,    750,  0,    0,    7718, 7717, 1,
      0,     0,    0,    7718, 7719, 1,    0,    0,    0,    7719, 7720, 1,    0,    0,    0,    7720, 7728, 3,    1424,
      712,   0,    7721, 7722, 4,    549,  94,   0,    7722, 7724, 5,    799,  0,    0,    7723, 7725, 5,    750,  0,
      0,     7724, 7723, 1,    0,    0,    0,    7724, 7725, 1,    0,    0,    0,    7725, 7726, 1,    0,    0,    0,
      7726,  7728, 3,    1424, 712,  0,    7727, 7707, 1,    0,    0,    0,    7727, 7712, 1,    0,    0,    0,    7727,
      7714,  1,    0,    0,    0,    7727, 7715, 1,    0,    0,    0,    7727, 7721, 1,    0,    0,    0,    7728, 1099,
      1,     0,    0,    0,    7729, 7730, 7,    133,  0,    0,    7730, 1101, 1,    0,    0,    0,    7731, 7732, 7,
      134,   0,    0,    7732, 7733, 3,    1094, 547,  0,    7733, 1103, 1,    0,    0,    0,    7734, 7739, 3,    1098,
      549,   0,    7735, 7736, 5,    645,  0,    0,    7736, 7737, 5,    401,  0,    0,    7737, 7739, 3,    1346, 673,
      0,     7738, 7734, 1,    0,    0,    0,    7738, 7735, 1,    0,    0,    0,    7739, 1105, 1,    0,    0,    0,
      7740,  7741, 3,    1098, 549,  0,    7741, 1107, 1,    0,    0,    0,    7742, 7743, 3,    1110, 555,  0,    7743,
      7744,  5,    0,    0,    1,    7744, 1109, 1,    0,    0,    0,    7745, 7747, 7,    135,  0,    0,    7746, 7748,
      3,     1116, 558,  0,    7747, 7746, 1,    0,    0,    0,    7747, 7748, 1,    0,    0,    0,    7748, 7750, 1,
      0,     0,    0,    7749, 7751, 3,    1118, 559,  0,    7750, 7749, 1,    0,    0,    0,    7750, 7751, 1,    0,
      0,     0,    7751, 7892, 1,    0,    0,    0,    7752, 7758, 5,    437,  0,    0,    7753, 7755, 5,    146,  0,
      0,     7754, 7756, 5,    416,  0,    0,    7755, 7754, 1,    0,    0,    0,    7755, 7756, 1,    0,    0,    0,
      7756,  7758, 1,    0,    0,    0,    7757, 7752, 1,    0,    0,    0,    7757, 7753, 1,    0,    0,    0,    7758,
      7760,  1,    0,    0,    0,    7759, 7761, 3,    1404, 702,  0,    7760, 7759, 1,    0,    0,    0,    7760, 7761,
      1,     0,    0,    0,    7761, 7763, 1,    0,    0,    0,    7762, 7764, 3,    1118, 559,  0,    7763, 7762, 1,
      0,     0,    0,    7763, 7764, 1,    0,    0,    0,    7764, 7892, 1,    0,    0,    0,    7765, 7767, 7,    136,
      0,     0,    7766, 7768, 3,    1400, 700,  0,    7767, 7766, 1,    0,    0,    0,    7767, 7768, 1,    0,    0,
      0,     7768, 7770, 1,    0,    0,    0,    7769, 7771, 3,    1118, 559,  0,    7770, 7769, 1,    0,    0,    0,
      7770,  7771, 1,    0,    0,    0,    7771, 7892, 1,    0,    0,    0,    7772, 7774, 5,    37,   0,    0,    7773,
      7775,  3,    1116, 558,  0,    7774, 7773, 1,    0,    0,    0,    7774, 7775, 1,    0,    0,    0,    7775, 7892,
      1,     0,    0,    0,    7776, 7892, 7,    137,  0,    0,    7777, 7779, 5,    60,   0,    0,    7778, 7780, 3,
      1116,  558,  0,    7779, 7778, 1,    0,    0,    0,    7779, 7780, 1,    0,    0,    0,    7780, 7782, 1,    0,
      0,     0,    7781, 7783, 3,    1120, 560,  0,    7782, 7781, 1,    0,    0,    0,    7782, 7783, 1,    0,    0,
      0,     7783, 7892, 1,    0,    0,    0,    7784, 7786, 3,    1112, 556,  0,    7785, 7787, 3,    1116, 558,  0,
      7786,  7785, 1,    0,    0,    0,    7786, 7787, 1,    0,    0,    0,    7787, 7789, 1,    0,    0,    0,    7788,
      7790,  5,    32,   0,    0,    7789, 7788, 1,    0,    0,    0,    7789, 7790, 1,    0,    0,    0,    7790, 7892,
      1,     0,    0,    0,    7791, 7793, 5,    32,   0,    0,    7792, 7794, 3,    1116, 558,  0,    7793, 7792, 1,
      0,     0,    0,    7793, 7794, 1,    0,    0,    0,    7794, 7892, 1,    0,    0,    0,    7795, 7796, 5,    60,
      0,     0,    7796, 7799, 5,    633,  0,    0,    7797, 7799, 5,    629,  0,    0,    7798, 7795, 1,    0,    0,
      0,     7798, 7797, 1,    0,    0,    0,    7799, 7800, 1,    0,    0,    0,    7800, 7802, 3,    1116, 558,  0,
      7801,  7803, 3,    1120, 560,  0,    7802, 7801, 1,    0,    0,    0,    7802, 7803, 1,    0,    0,    0,    7803,
      7892,  1,    0,    0,    0,    7804, 7805, 5,    358,  0,    0,    7805, 7815, 5,    629,  0,    0,    7806, 7815,
      5,     379,  0,    0,    7807, 7808, 5,    361,  0,    0,    7808, 7815, 5,    629,  0,    0,    7809, 7810, 5,
      358,   0,    0,    7810, 7811, 5,    60,   0,    0,    7811, 7815, 5,    633,  0,    0,    7812, 7813, 5,    361,
      0,     0,    7813, 7815, 5,    633,  0,    0,    7814, 7804, 1,    0,    0,    0,    7814, 7806, 1,    0,    0,
      0,     7814, 7807, 1,    0,    0,    0,    7814, 7809, 1,    0,    0,    0,    7814, 7812, 1,    0,    0,    0,
      7815,  7816, 1,    0,    0,    0,    7816, 7818, 3,    1116, 558,  0,    7817, 7819, 5,    32,   0,    0,    7818,
      7817,  1,    0,    0,    0,    7818, 7819, 1,    0,    0,    0,    7819, 7892, 1,    0,    0,    0,    7820, 7821,
      5,     628,  0,    0,    7821, 7892, 3,    1116, 558,  0,    7822, 7824, 5,    656,  0,    0,    7823, 7825, 3,
      1116,  558,  0,    7824, 7823, 1,    0,    0,    0,    7824, 7825, 1,    0,    0,    0,    7825, 7827, 1,    0,
      0,     0,    7826, 7828, 3,    1118, 559,  0,    7827, 7826, 1,    0,    0,    0,    7827, 7828, 1,    0,    0,
      0,     7828, 7892, 1,    0,    0,    0,    7829, 7892, 5,    116,  0,    0,    7830, 7832, 5,    586,  0,    0,
      7831,  7833, 3,    1128, 564,  0,    7832, 7831, 1,    0,    0,    0,    7832, 7833, 1,    0,    0,    0,    7833,
      7892,  1,    0,    0,    0,    7834, 7836, 5,    583,  0,    0,    7835, 7837, 3,    1128, 564,  0,    7836, 7835,
      1,     0,    0,    0,    7836, 7837, 1,    0,    0,    0,    7837, 7892, 1,    0,    0,    0,    7838, 7840, 5,
      113,   0,    0,    7839, 7841, 3,    1128, 564,  0,    7840, 7839, 1,    0,    0,    0,    7840, 7841, 1,    0,
      0,     0,    7841, 7892, 1,    0,    0,    0,    7842, 7892, 5,    587,  0,    0,    7843, 7845, 5,    39,   0,
      0,     7844, 7846, 3,    1116, 558,  0,    7845, 7844, 1,    0,    0,    0,    7845, 7846, 1,    0,    0,    0,
      7846,  7892, 1,    0,    0,    0,    7847, 7892, 7,    138,  0,    0,    7848, 7849, 5,    293,  0,    0,    7849,
      7892,  5,    628,  0,    0,    7850, 7854, 5,    293,  0,    0,    7851, 7852, 5,    60,   0,    0,    7852, 7855,
      5,     633,  0,    0,    7853, 7855, 5,    629,  0,    0,    7854, 7851, 1,    0,    0,    0,    7854, 7853, 1,
      0,     0,    0,    7854, 7855, 1,    0,    0,    0,    7855, 7857, 1,    0,    0,    0,    7856, 7858, 3,    1120,
      560,   0,    7857, 7856, 1,    0,    0,    0,    7857, 7858, 1,    0,    0,    0,    7858, 7892, 1,    0,    0,
      0,     7859, 7861, 5,    589,  0,    0,    7860, 7862, 3,    1120, 560,  0,    7861, 7860, 1,    0,    0,    0,
      7861,  7862, 1,    0,    0,    0,    7862, 7892, 1,    0,    0,    0,    7863, 7865, 5,    580,  0,    0,    7864,
      7866,  3,    1116, 558,  0,    7865, 7864, 1,    0,    0,    0,    7865, 7866, 1,    0,    0,    0,    7866, 7868,
      1,     0,    0,    0,    7867, 7869, 3,    1120, 560,  0,    7868, 7867, 1,    0,    0,    0,    7868, 7869, 1,
      0,     0,    0,    7869, 7892, 1,    0,    0,    0,    7870, 7872, 5,    332,  0,    0,    7871, 7873, 3,    1120,
      560,   0,    7872, 7871, 1,    0,    0,    0,    7872, 7873, 1,    0,    0,    0,    7873, 7892, 1,    0,    0,
      0,     7874, 7876, 5,    291,  0,    0,    7875, 7877, 3,    1120, 560,  0,    7876, 7875, 1,    0,    0,    0,
      7876,  7877, 1,    0,    0,    0,    7877, 7892, 1,    0,    0,    0,    7878, 7879, 5,    164,  0,    0,    7879,
      7881,  3,    1376, 688,  0,    7880, 7882, 3,    1120, 560,  0,    7881, 7880, 1,    0,    0,    0,    7881, 7882,
      1,     0,    0,    0,    7882, 7892, 1,    0,    0,    0,    7883, 7884, 5,    506,  0,    0,    7884, 7886, 3,
      1376,  688,  0,    7885, 7887, 3,    1120, 560,  0,    7886, 7885, 1,    0,    0,    0,    7886, 7887, 1,    0,
      0,     0,    7887, 7892, 1,    0,    0,    0,    7888, 7892, 5,    501,  0,    0,    7889, 7892, 5,    262,  0,
      0,     7890, 7892, 7,    139,  0,    0,    7891, 7745, 1,    0,    0,    0,    7891, 7757, 1,    0,    0,    0,
      7891,  7765, 1,    0,    0,    0,    7891, 7772, 1,    0,    0,    0,    7891, 7776, 1,    0,    0,    0,    7891,
      7777,  1,    0,    0,    0,    7891, 7784, 1,    0,    0,    0,    7891, 7791, 1,    0,    0,    0,    7891, 7798,
      1,     0,    0,    0,    7891, 7814, 1,    0,    0,    0,    7891, 7820, 1,    0,    0,    0,    7891, 7822, 1,
      0,     0,    0,    7891, 7829, 1,    0,    0,    0,    7891, 7830, 1,    0,    0,    0,    7891, 7834, 1,    0,
      0,     0,    7891, 7838, 1,    0,    0,    0,    7891, 7842, 1,    0,    0,    0,    7891, 7843, 1,    0,    0,
      0,     7891, 7847, 1,    0,    0,    0,    7891, 7848, 1,    0,    0,    0,    7891, 7850, 1,    0,    0,    0,
      7891,  7859, 1,    0,    0,    0,    7891, 7863, 1,    0,    0,    0,    7891, 7870, 1,    0,    0,    0,    7891,
      7874,  1,    0,    0,    0,    7891, 7878, 1,    0,    0,    0,    7891, 7883, 1,    0,    0,    0,    7891, 7888,
      1,     0,    0,    0,    7891, 7889, 1,    0,    0,    0,    7891, 7890, 1,    0,    0,    0,    7892, 1111, 1,
      0,     0,    0,    7893, 7897, 5,    361,  0,    0,    7894, 7895, 5,    358,  0,    0,    7895, 7897, 5,    60,
      0,     0,    7896, 7893, 1,    0,    0,    0,    7896, 7894, 1,    0,    0,    0,    7897, 1113, 1,    0,    0,
      0,     7898, 7904, 5,    437,  0,    0,    7899, 7901, 5,    146,  0,    0,    7900, 7902, 5,    416,  0,    0,
      7901,  7900, 1,    0,    0,    0,    7901, 7902, 1,    0,    0,    0,    7902, 7904, 1,    0,    0,    0,    7903,
      7898,  1,    0,    0,    0,    7903, 7899, 1,    0,    0,    0,    7904, 1115, 1,    0,    0,    0,    7905, 7908,
      5,     776,  0,    0,    7906, 7909, 3,    1364, 682,  0,    7907, 7909, 5,    790,  0,    0,    7908, 7906, 1,
      0,     0,    0,    7908, 7907, 1,    0,    0,    0,    7909, 7910, 1,    0,    0,    0,    7910, 7911, 5,    777,
      0,     0,    7911, 1117, 1,    0,    0,    0,    7912, 7914, 7,    140,  0,    0,    7913, 7912, 1,    0,    0,
      0,     7914, 7915, 1,    0,    0,    0,    7915, 7913, 1,    0,    0,    0,    7915, 7916, 1,    0,    0,    0,
      7916,  1119, 1,    0,    0,    0,    7917, 7932, 3,    1122, 561,  0,    7918, 7932, 3,    1124, 562,  0,    7919,
      7932,  5,    46,   0,    0,    7920, 7921, 3,    950,  475,  0,    7921, 7923, 3,    1132, 566,  0,    7922, 7924,
      5,     32,   0,    0,    7923, 7922, 1,    0,    0,    0,    7923, 7924, 1,    0,    0,    0,    7924, 7932, 1,
      0,     0,    0,    7925, 7929, 5,    32,   0,    0,    7926, 7927, 3,    950,  475,  0,    7927, 7928, 3,    1132,
      566,   0,    7928, 7930, 1,    0,    0,    0,    7929, 7926, 1,    0,    0,    0,    7929, 7930, 1,    0,    0,
      0,     7930, 7932, 1,    0,    0,    0,    7931, 7917, 1,    0,    0,    0,    7931, 7918, 1,    0,    0,    0,
      7931,  7919, 1,    0,    0,    0,    7931, 7920, 1,    0,    0,    0,    7931, 7925, 1,    0,    0,    0,    7932,
      1121,  1,    0,    0,    0,    7933, 7935, 5,    19,   0,    0,    7934, 7936, 5,    32,   0,    0,    7935, 7934,
      1,     0,    0,    0,    7935, 7936, 1,    0,    0,    0,    7936, 7940, 1,    0,    0,    0,    7937, 7938, 5,
      32,    0,    0,    7938, 7940, 5,    19,   0,    0,    7939, 7933, 1,    0,    0,    0,    7939, 7937, 1,    0,
      0,     0,    7940, 1123, 1,    0,    0,    0,    7941, 7943, 5,    606,  0,    0,    7942, 7944, 5,    32,   0,
      0,     7943, 7942, 1,    0,    0,    0,    7943, 7944, 1,    0,    0,    0,    7944, 7948, 1,    0,    0,    0,
      7945,  7946, 5,    32,   0,    0,    7946, 7948, 5,    606,  0,    0,    7947, 7941, 1,    0,    0,    0,    7947,
      7945,  1,    0,    0,    0,    7948, 1125, 1,    0,    0,    0,    7949, 7950, 5,    776,  0,    0,    7950, 7951,
      3,     1360, 680,  0,    7951, 7952, 5,    777,  0,    0,    7952, 1127, 1,    0,    0,    0,    7953, 7954, 5,
      776,   0,    0,    7954, 7955, 5,    747,  0,    0,    7955, 7956, 5,    777,  0,    0,    7956, 1129, 1,    0,
      0,     0,    7957, 7963, 1,    0,    0,    0,    7958, 7963, 3,    1414, 707,  0,    7959, 7960, 5,    776,  0,
      0,     7960, 7961, 5,    747,  0,    0,    7961, 7963, 5,    777,  0,    0,    7962, 7957, 1,    0,    0,    0,
      7962,  7958, 1,    0,    0,    0,    7962, 7959, 1,    0,    0,    0,    7963, 1131, 1,    0,    0,    0,    7964,
      7969,  3,    1406, 703,  0,    7965, 7969, 5,    32,   0,    0,    7966, 7967, 4,    566,  95,   0,    7967, 7969,
      5,     128,  0,    0,    7968, 7964, 1,    0,    0,    0,    7968, 7965, 1,    0,    0,    0,    7968, 7966, 1,
      0,     0,    0,    7969, 1133, 1,    0,    0,    0,    7970, 7976, 3,    1406, 703,  0,    7971, 7972, 4,    567,
      96,    0,    7972, 7976, 5,    128,  0,    0,    7973, 7974, 4,    567,  97,   0,    7974, 7976, 5,    32,   0,
      0,     7975, 7970, 1,    0,    0,    0,    7975, 7971, 1,    0,    0,    0,    7975, 7973, 1,    0,    0,    0,
      7976,  1135, 1,    0,    0,    0,    7977, 7984, 3,    1144, 572,  0,    7978, 7980, 5,    773,  0,    0,    7979,
      7978,  1,    0,    0,    0,    7979, 7980, 1,    0,    0,    0,    7980, 7981, 1,    0,    0,    0,    7981, 7983,
      3,     1144, 572,  0,    7982, 7979, 1,    0,    0,    0,    7983, 7986, 1,    0,    0,    0,    7984, 7982, 1,
      0,     0,    0,    7984, 7985, 1,    0,    0,    0,    7985, 1137, 1,    0,    0,    0,    7986, 7984, 1,    0,
      0,     0,    7987, 7989, 3,    1136, 568,  0,    7988, 7990, 3,    1140, 570,  0,    7989, 7988, 1,    0,    0,
      0,     7989, 7990, 1,    0,    0,    0,    7990, 7993, 1,    0,    0,    0,    7991, 7993, 3,    1140, 570,  0,
      7992,  7987, 1,    0,    0,    0,    7992, 7991, 1,    0,    0,    0,    7993, 1139, 1,    0,    0,    0,    7994,
      7996,  3,    1154, 577,  0,    7995, 7997, 3,    92,   46,   0,    7996, 7995, 1,    0,    0,    0,    7996, 7997,
      1,     0,    0,    0,    7997, 8000, 1,    0,    0,    0,    7998, 8000, 3,    92,   46,   0,    7999, 7994, 1,
      0,     0,    0,    7999, 7998, 1,    0,    0,    0,    8000, 1141, 1,    0,    0,    0,    8001, 8003, 3,    1144,
      572,   0,    8002, 8001, 1,    0,    0,    0,    8003, 8004, 1,    0,    0,    0,    8004, 8002, 1,    0,    0,
      0,     8004, 8005, 1,    0,    0,    0,    8005, 1143, 1,    0,    0,    0,    8006, 8008, 5,    163,  0,    0,
      8007,  8009, 5,    750,  0,    0,    8008, 8007, 1,    0,    0,    0,    8008, 8009, 1,    0,    0,    0,    8009,
      8010,  1,    0,    0,    0,    8010, 8147, 3,    1314, 657,  0,    8011, 8012, 4,    572,  98,   0,    8012, 8014,
      5,     721,  0,    0,    8013, 8015, 3,    1416, 708,  0,    8014, 8013, 1,    0,    0,    0,    8014, 8015, 1,
      0,     0,    0,    8015, 8018, 1,    0,    0,    0,    8016, 8019, 5,    376,  0,    0,    8017, 8019, 3,    1406,
      703,   0,    8018, 8016, 1,    0,    0,    0,    8018, 8017, 1,    0,    0,    0,    8019, 8147, 1,    0,    0,
      0,     8020, 8022, 5,    323,  0,    0,    8021, 8023, 5,    750,  0,    0,    8022, 8021, 1,    0,    0,    0,
      8022,  8023, 1,    0,    0,    0,    8023, 8024, 1,    0,    0,    0,    8024, 8147, 3,    1362, 681,  0,    8025,
      8027,  5,    344,  0,    0,    8026, 8028, 5,    750,  0,    0,    8027, 8026, 1,    0,    0,    0,    8027, 8028,
      1,     0,    0,    0,    8028, 8029, 1,    0,    0,    0,    8029, 8147, 3,    1362, 681,  0,    8030, 8032, 5,
      25,    0,    0,    8031, 8033, 5,    750,  0,    0,    8032, 8031, 1,    0,    0,    0,    8032, 8033, 1,    0,
      0,     0,    8033, 8034, 1,    0,    0,    0,    8034, 8147, 3,    1362, 681,  0,    8035, 8037, 5,    406,  0,
      0,     8036, 8038, 5,    750,  0,    0,    8037, 8036, 1,    0,    0,    0,    8037, 8038, 1,    0,    0,    0,
      8038,  8039, 1,    0,    0,    0,    8039, 8147, 3,    1378, 689,  0,    8040, 8042, 5,    75,   0,    0,    8041,
      8043,  5,    750,  0,    0,    8042, 8041, 1,    0,    0,    0,    8042, 8043, 1,    0,    0,    0,    8043, 8044,
      1,     0,    0,    0,    8044, 8147, 3,    1378, 689,  0,    8045, 8047, 5,    81,   0,    0,    8046, 8048, 5,
      750,   0,    0,    8047, 8046, 1,    0,    0,    0,    8047, 8048, 1,    0,    0,    0,    8048, 8049, 1,    0,
      0,     0,    8049, 8147, 3,    1380, 690,  0,    8050, 8052, 5,    158,  0,    0,    8051, 8053, 5,    750,  0,
      0,     8052, 8051, 1,    0,    0,    0,    8052, 8053, 1,    0,    0,    0,    8053, 8054, 1,    0,    0,    0,
      8054,  8147, 3,    1380, 690,  0,    8055, 8057, 5,    24,   0,    0,    8056, 8058, 5,    750,  0,    0,    8057,
      8056,  1,    0,    0,    0,    8057, 8058, 1,    0,    0,    0,    8058, 8059, 1,    0,    0,    0,    8059, 8147,
      3,     1362, 681,  0,    8060, 8062, 5,    399,  0,    0,    8061, 8063, 5,    750,  0,    0,    8062, 8061, 1,
      0,     0,    0,    8062, 8063, 1,    0,    0,    0,    8063, 8064, 1,    0,    0,    0,    8064, 8147, 3,    1146,
      573,   0,    8065, 8067, 7,    141,  0,    0,    8066, 8068, 5,    750,  0,    0,    8067, 8066, 1,    0,    0,
      0,     8067, 8068, 1,    0,    0,    0,    8068, 8069, 1,    0,    0,    0,    8069, 8147, 3,    1146, 573,  0,
      8070,  8072, 7,    142,  0,    0,    8071, 8073, 5,    750,  0,    0,    8072, 8071, 1,    0,    0,    0,    8072,
      8073,  1,    0,    0,    0,    8073, 8074, 1,    0,    0,    0,    8074, 8147, 3,    1358, 679,  0,    8075, 8077,
      5,     132,  0,    0,    8076, 8078, 5,    750,  0,    0,    8077, 8076, 1,    0,    0,    0,    8077, 8078, 1,
      0,     0,    0,    8078, 8079, 1,    0,    0,    0,    8079, 8147, 3,    1358, 679,  0,    8080, 8082, 5,    486,
      0,     0,    8081, 8083, 5,    750,  0,    0,    8082, 8081, 1,    0,    0,    0,    8082, 8083, 1,    0,    0,
      0,     8083, 8084, 1,    0,    0,    0,    8084, 8147, 7,    143,  0,    0,    8085, 8087, 5,    608,  0,    0,
      8086,  8088, 5,    750,  0,    0,    8087, 8086, 1,    0,    0,    0,    8087, 8088, 1,    0,    0,    0,    8088,
      8089,  1,    0,    0,    0,    8089, 8090, 5,    776,  0,    0,    8090, 8091, 3,    1324, 662,  0,    8091, 8092,
      5,     777,  0,    0,    8092, 8147, 1,    0,    0,    0,    8093, 8147, 3,    1152, 576,  0,    8094, 8147, 3,
      1148,  574,  0,    8095, 8097, 5,    243,  0,    0,    8096, 8098, 5,    750,  0,    0,    8097, 8096, 1,    0,
      0,     0,    8097, 8098, 1,    0,    0,    0,    8098, 8099, 1,    0,    0,    0,    8099, 8147, 7,    144,  0,
      0,     8100, 8101, 5,    112,  0,    0,    8101, 8103, 5,    139,  0,    0,    8102, 8104, 5,    750,  0,    0,
      8103,  8102, 1,    0,    0,    0,    8103, 8104, 1,    0,    0,    0,    8104, 8105, 1,    0,    0,    0,    8105,
      8147,  3,    1380, 690,  0,    8106, 8107, 5,    236,  0,    0,    8107, 8109, 5,    139,  0,    0,    8108, 8110,
      5,     750,  0,    0,    8109, 8108, 1,    0,    0,    0,    8109, 8110, 1,    0,    0,    0,    8110, 8111, 1,
      0,     0,    0,    8111, 8147, 3,    1380, 690,  0,    8112, 8114, 5,    572,  0,    0,    8113, 8115, 5,    750,
      0,     0,    8114, 8113, 1,    0,    0,    0,    8114, 8115, 1,    0,    0,    0,    8115, 8116, 1,    0,    0,
      0,     8116, 8147, 3,    1346, 673,  0,    8117, 8118, 5,    553,  0,    0,    8118, 8147, 7,    145,  0,    0,
      8119,  8121, 5,    84,   0,    0,    8120, 8122, 5,    750,  0,    0,    8121, 8120, 1,    0,    0,    0,    8121,
      8122,  1,    0,    0,    0,    8122, 8123, 1,    0,    0,    0,    8123, 8147, 3,    1380, 690,  0,    8124, 8126,
      5,     264,  0,    0,    8125, 8127, 5,    750,  0,    0,    8126, 8125, 1,    0,    0,    0,    8126, 8127, 1,
      0,     0,    0,    8127, 8128, 1,    0,    0,    0,    8128, 8147, 3,    1362, 681,  0,    8129, 8130, 4,    572,
      99,    0,    8130, 8131, 5,    543,  0,    0,    8131, 8147, 5,    592,  0,    0,    8132, 8133, 4,    572,  100,
      0,     8133, 8135, 5,    798,  0,    0,    8134, 8136, 5,    750,  0,    0,    8135, 8134, 1,    0,    0,    0,
      8135,  8136, 1,    0,    0,    0,    8136, 8137, 1,    0,    0,    0,    8137, 8147, 3,    1424, 712,  0,    8138,
      8139,  4,    572,  101,  0,    8139, 8141, 5,    799,  0,    0,    8140, 8142, 5,    750,  0,    0,    8141, 8140,
      1,     0,    0,    0,    8141, 8142, 1,    0,    0,    0,    8142, 8143, 1,    0,    0,    0,    8143, 8147, 3,
      1424,  712,  0,    8144, 8145, 4,    572,  102,  0,    8145, 8147, 3,    148,  74,   0,    8146, 8006, 1,    0,
      0,     0,    8146, 8011, 1,    0,    0,    0,    8146, 8020, 1,    0,    0,    0,    8146, 8025, 1,    0,    0,
      0,     8146, 8030, 1,    0,    0,    0,    8146, 8035, 1,    0,    0,    0,    8146, 8040, 1,    0,    0,    0,
      8146,  8045, 1,    0,    0,    0,    8146, 8050, 1,    0,    0,    0,    8146, 8055, 1,    0,    0,    0,    8146,
      8060,  1,    0,    0,    0,    8146, 8065, 1,    0,    0,    0,    8146, 8070, 1,    0,    0,    0,    8146, 8075,
      1,     0,    0,    0,    8146, 8080, 1,    0,    0,    0,    8146, 8085, 1,    0,    0,    0,    8146, 8093, 1,
      0,     0,    0,    8146, 8094, 1,    0,    0,    0,    8146, 8095, 1,    0,    0,    0,    8146, 8100, 1,    0,
      0,     0,    8146, 8106, 1,    0,    0,    0,    8146, 8112, 1,    0,    0,    0,    8146, 8117, 1,    0,    0,
      0,     8146, 8119, 1,    0,    0,    0,    8146, 8124, 1,    0,    0,    0,    8146, 8129, 1,    0,    0,    0,
      8146,  8132, 1,    0,    0,    0,    8146, 8138, 1,    0,    0,    0,    8146, 8144, 1,    0,    0,    0,    8147,
      1145,  1,    0,    0,    0,    8148, 8151, 3,    1358, 679,  0,    8149, 8151, 5,    128,  0,    0,    8150, 8148,
      1,     0,    0,    0,    8150, 8149, 1,    0,    0,    0,    8151, 1147, 1,    0,    0,    0,    8152, 8154, 5,
      128,   0,    0,    8153, 8152, 1,    0,    0,    0,    8153, 8154, 1,    0,    0,    0,    8154, 8155, 1,    0,
      0,     0,    8155, 8157, 5,    69,   0,    0,    8156, 8158, 5,    750,  0,    0,    8157, 8156, 1,    0,    0,
      0,     8157, 8158, 1,    0,    0,    0,    8158, 8159, 1,    0,    0,    0,    8159, 8160, 3,    1134, 567,  0,
      8160,  1149, 1,    0,    0,    0,    8161, 8163, 5,    128,  0,    0,    8162, 8161, 1,    0,    0,    0,    8162,
      8163,  1,    0,    0,    0,    8163, 8164, 1,    0,    0,    0,    8164, 8166, 5,    158,  0,    0,    8165, 8167,
      5,     750,  0,    0,    8166, 8165, 1,    0,    0,    0,    8166, 8167, 1,    0,    0,    0,    8167, 8168, 1,
      0,     0,    0,    8168, 8169, 3,    1378, 689,  0,    8169, 1151, 1,    0,    0,    0,    8170, 8172, 5,    128,
      0,     0,    8171, 8170, 1,    0,    0,    0,    8171, 8172, 1,    0,    0,    0,    8172, 8173, 1,    0,    0,
      0,     8173, 8175, 3,    950,  475,  0,    8174, 8176, 5,    750,  0,    0,    8175, 8174, 1,    0,    0,    0,
      8175,  8176, 1,    0,    0,    0,    8176, 8177, 1,    0,    0,    0,    8177, 8178, 3,    1132, 566,  0,    8178,
      1153,  1,    0,    0,    0,    8179, 8180, 5,    405,  0,    0,    8180, 8181, 5,    45,   0,    0,    8181, 8184,
      3,     1156, 578,  0,    8182, 8183, 5,    404,  0,    0,    8183, 8185, 3,    1360, 680,  0,    8184, 8182, 1,
      0,     0,    0,    8184, 8185, 1,    0,    0,    0,    8185, 8187, 1,    0,    0,    0,    8186, 8188, 3,    1158,
      579,   0,    8187, 8186, 1,    0,    0,    0,    8187, 8188, 1,    0,    0,    0,    8188, 8190, 1,    0,    0,
      0,     8189, 8191, 3,    1162, 581,  0,    8190, 8189, 1,    0,    0,    0,    8190, 8191, 1,    0,    0,    0,
      8191,  1155, 1,    0,    0,    0,    8192, 8194, 5,    277,  0,    0,    8193, 8192, 1,    0,    0,    0,    8193,
      8194,  1,    0,    0,    0,    8194, 8195, 1,    0,    0,    0,    8195, 8197, 5,    265,  0,    0,    8196, 8198,
      3,     1160, 580,  0,    8197, 8196, 1,    0,    0,    0,    8197, 8198, 1,    0,    0,    0,    8198, 8199, 1,
      0,     0,    0,    8199, 8201, 5,    776,  0,    0,    8200, 8202, 3,    1348, 674,  0,    8201, 8200, 1,    0,
      0,     0,    8201, 8202, 1,    0,    0,    0,    8202, 8203, 1,    0,    0,    0,    8203, 8226, 5,    777,  0,
      0,     8204, 8206, 5,    277,  0,    0,    8205, 8204, 1,    0,    0,    0,    8205, 8206, 1,    0,    0,    0,
      8206,  8207, 1,    0,    0,    0,    8207, 8208, 5,    220,  0,    0,    8208, 8209, 5,    776,  0,    0,    8209,
      8210,  3,    870,  435,  0,    8210, 8211, 5,    777,  0,    0,    8211, 8226, 1,    0,    0,    0,    8212, 8223,
      7,     146,  0,    0,    8213, 8214, 5,    776,  0,    0,    8214, 8215, 3,    870,  435,  0,    8215, 8216, 5,
      777,   0,    0,    8216, 8224, 1,    0,    0,    0,    8217, 8218, 5,    71,   0,    0,    8218, 8220, 5,    776,
      0,     0,    8219, 8221, 3,    1348, 674,  0,    8220, 8219, 1,    0,    0,    0,    8220, 8221, 1,    0,    0,
      0,     8221, 8222, 1,    0,    0,    0,    8222, 8224, 5,    777,  0,    0,    8223, 8213, 1,    0,    0,    0,
      8223,  8217, 1,    0,    0,    0,    8224, 8226, 1,    0,    0,    0,    8225, 8193, 1,    0,    0,    0,    8225,
      8205,  1,    0,    0,    0,    8225, 8212, 1,    0,    0,    0,    8226, 1157, 1,    0,    0,    0,    8227, 8228,
      5,     561,  0,    0,    8228, 8230, 5,    45,   0,    0,    8229, 8231, 5,    277,  0,    0,    8230, 8229, 1,
      0,     0,    0,    8230, 8231, 1,    0,    0,    0,    8231, 8242, 1,    0,    0,    0,    8232, 8233, 5,    220,
      0,     0,    8233, 8234, 5,    776,  0,    0,    8234, 8235, 3,    870,  435,  0,    8235, 8236, 5,    777,  0,
      0,     8236, 8243, 1,    0,    0,    0,    8237, 8239, 5,    265,  0,    0,    8238, 8240, 3,    1160, 580,  0,
      8239,  8238, 1,    0,    0,    0,    8239, 8240, 1,    0,    0,    0,    8240, 8241, 1,    0,    0,    0,    8241,
      8243,  3,    1350, 675,  0,    8242, 8232, 1,    0,    0,    0,    8242, 8237, 1,    0,    0,    0,    8243, 8246,
      1,     0,    0,    0,    8244, 8245, 5,    560,  0,    0,    8245, 8247, 3,    1360, 680,  0,    8246, 8244, 1,
      0,     0,    0,    8246, 8247, 1,    0,    0,    0,    8247, 1159, 1,    0,    0,    0,    8248, 8249, 5,    9,
      0,     0,    8249, 8250, 5,    750,  0,    0,    8250, 8251, 3,    1360, 680,  0,    8251, 1161, 1,    0,    0,
      0,     8252, 8253, 5,    776,  0,    0,    8253, 8258, 3,    1164, 582,  0,    8254, 8255, 5,    773,  0,    0,
      8255,  8257, 3,    1164, 582,  0,    8256, 8254, 1,    0,    0,    0,    8257, 8260, 1,    0,    0,    0,    8258,
      8256,  1,    0,    0,    0,    8258, 8259, 1,    0,    0,    0,    8259, 8261, 1,    0,    0,    0,    8260, 8258,
      1,     0,    0,    0,    8261, 8262, 5,    777,  0,    0,    8262, 1163, 1,    0,    0,    0,    8263, 8264, 5,
      405,   0,    0,    8264, 8275, 3,    1346, 673,  0,    8265, 8266, 5,    626,  0,    0,    8266, 8267, 5,    273,
      0,     0,    8267, 8270, 5,    581,  0,    0,    8268, 8271, 3,    1172, 586,  0,    8269, 8271, 5,    329,  0,
      0,     8270, 8268, 1,    0,    0,    0,    8270, 8269, 1,    0,    0,    0,    8271, 8276, 1,    0,    0,    0,
      8272,  8273, 5,    626,  0,    0,    8273, 8274, 5,    251,  0,    0,    8274, 8276, 3,    1166, 583,  0,    8275,
      8265,  1,    0,    0,    0,    8275, 8272, 1,    0,    0,    0,    8275, 8276, 1,    0,    0,    0,    8276, 8280,
      1,     0,    0,    0,    8277, 8279, 3,    1168, 584,  0,    8278, 8277, 1,    0,    0,    0,    8279, 8282, 1,
      0,     0,    0,    8280, 8278, 1,    0,    0,    0,    8280, 8281, 1,    0,    0,    0,    8281, 8294, 1,    0,
      0,     0,    8282, 8280, 1,    0,    0,    0,    8283, 8284, 5,    776,  0,    0,    8284, 8289, 3,    1170, 585,
      0,     8285, 8286, 5,    773,  0,    0,    8286, 8288, 3,    1170, 585,  0,    8287, 8285, 1,    0,    0,    0,
      8288,  8291, 1,    0,    0,    0,    8289, 8287, 1,    0,    0,    0,    8289, 8290, 1,    0,    0,    0,    8290,
      8292,  1,    0,    0,    0,    8291, 8289, 1,    0,    0,    0,    8292, 8293, 5,    777,  0,    0,    8293, 8295,
      1,     0,    0,    0,    8294, 8283, 1,    0,    0,    0,    8294, 8295, 1,    0,    0,    0,    8295, 1165, 1,
      0,     0,    0,    8296, 8309, 3,    1172, 586,  0,    8297, 8298, 5,    776,  0,    0,    8298, 8303, 3,    1172,
      586,   0,    8299, 8300, 5,    773,  0,    0,    8300, 8302, 3,    1172, 586,  0,    8301, 8299, 1,    0,    0,
      0,     8302, 8305, 1,    0,    0,    0,    8303, 8301, 1,    0,    0,    0,    8303, 8304, 1,    0,    0,    0,
      8304,  8306, 1,    0,    0,    0,    8305, 8303, 1,    0,    0,    0,    8306, 8307, 5,    777,  0,    0,    8307,
      8309,  1,    0,    0,    0,    8308, 8296, 1,    0,    0,    0,    8308, 8297, 1,    0,    0,    0,    8309, 1167,
      1,     0,    0,    0,    8310, 8312, 5,    572,  0,    0,    8311, 8313, 5,    750,  0,    0,    8312, 8311, 1,
      0,     0,    0,    8312, 8313, 1,    0,    0,    0,    8313, 8314, 1,    0,    0,    0,    8314, 8345, 3,    1346,
      673,   0,    8315, 8317, 5,    553,  0,    0,    8316, 8315, 1,    0,    0,    0,    8316, 8317, 1,    0,    0,
      0,     8317, 8318, 1,    0,    0,    0,    8318, 8320, 5,    163,  0,    0,    8319, 8321, 5,    750,  0,    0,
      8320,  8319, 1,    0,    0,    0,    8320, 8321, 1,    0,    0,    0,    8321, 8322, 1,    0,    0,    0,    8322,
      8345,  3,    1314, 657,  0,    8323, 8325, 5,    368,  0,    0,    8324, 8326, 5,    750,  0,    0,    8325, 8324,
      1,     0,    0,    0,    8325, 8326, 1,    0,    0,    0,    8326, 8327, 1,    0,    0,    0,    8327, 8345, 3,
      1360,  680,  0,    8328, 8330, 7,    147,  0,    0,    8329, 8331, 5,    750,  0,    0,    8330, 8329, 1,    0,
      0,     0,    8330, 8331, 1,    0,    0,    0,    8331, 8332, 1,    0,    0,    0,    8332, 8345, 3,    1360, 680,
      0,     8333, 8334, 7,    148,  0,    0,    8334, 8336, 5,    139,  0,    0,    8335, 8337, 5,    750,  0,    0,
      8336,  8335, 1,    0,    0,    0,    8336, 8337, 1,    0,    0,    0,    8337, 8338, 1,    0,    0,    0,    8338,
      8345,  3,    1384, 692,  0,    8339, 8341, 5,    75,   0,    0,    8340, 8342, 5,    750,  0,    0,    8341, 8340,
      1,     0,    0,    0,    8341, 8342, 1,    0,    0,    0,    8342, 8343, 1,    0,    0,    0,    8343, 8345, 3,
      1384,  692,  0,    8344, 8310, 1,    0,    0,    0,    8344, 8316, 1,    0,    0,    0,    8344, 8323, 1,    0,
      0,     0,    8344, 8328, 1,    0,    0,    0,    8344, 8333, 1,    0,    0,    0,    8344, 8339, 1,    0,    0,
      0,     8345, 1169, 1,    0,    0,    0,    8346, 8347, 5,    561,  0,    0,    8347, 8351, 3,    1406, 703,  0,
      8348,  8350, 3,    1168, 584,  0,    8349, 8348, 1,    0,    0,    0,    8350, 8353, 1,    0,    0,    0,    8351,
      8349,  1,    0,    0,    0,    8351, 8352, 1,    0,    0,    0,    8352, 1171, 1,    0,    0,    0,    8353, 8351,
      1,     0,    0,    0,    8354, 8355, 5,    776,  0,    0,    8355, 8360, 3,    1174, 587,  0,    8356, 8357, 5,
      773,   0,    0,    8357, 8359, 3,    1174, 587,  0,    8358, 8356, 1,    0,    0,    0,    8359, 8362, 1,    0,
      0,     0,    8360, 8358, 1,    0,    0,    0,    8360, 8361, 1,    0,    0,    0,    8361, 8363, 1,    0,    0,
      0,     8362, 8360, 1,    0,    0,    0,    8363, 8364, 5,    777,  0,    0,    8364, 1173, 1,    0,    0,    0,
      8365,  8368, 3,    870,  435,  0,    8366, 8368, 5,    329,  0,    0,    8367, 8365, 1,    0,    0,    0,    8367,
      8366,  1,    0,    0,    0,    8368, 1175, 1,    0,    0,    0,    8369, 8370, 5,    130,  0,    0,    8370, 8371,
      5,     750,  0,    0,    8371, 8372, 3,    1246, 623,  0,    8372, 1177, 1,    0,    0,    0,    8373, 8374, 5,
      231,   0,    0,    8374, 8375, 5,    174,  0,    0,    8375, 1179, 1,    0,    0,    0,    8376, 8377, 5,    231,
      0,     0,    8377, 8378, 3,    952,  476,  0,    8378, 8379, 5,    174,  0,    0,    8379, 1181, 1,    0,    0,
      0,     8380, 8381, 5,    232,  0,    0,    8381, 8382, 5,    610,  0,    0,    8382, 8383, 5,    618,  0,    0,
      8383,  1183, 1,    0,    0,    0,    8384, 8386, 7,    149,  0,    0,    8385, 8384, 1,    0,    0,    0,    8385,
      8386,  1,    0,    0,    0,    8386, 8387, 1,    0,    0,    0,    8387, 8388, 3,    1186, 593,  0,    8388, 1185,
      1,     0,    0,    0,    8389, 8390, 3,    1328, 664,  0,    8390, 8391, 3,    1190, 595,  0,    8391, 1187, 1,
      0,     0,    0,    8392, 8393, 5,    69,   0,    0,    8393, 8394, 3,    1134, 567,  0,    8394, 1189, 1,    0,
      0,     0,    8395, 8397, 3,    1110, 555,  0,    8396, 8398, 3,    1188, 594,  0,    8397, 8396, 1,    0,    0,
      0,     8397, 8398, 1,    0,    0,    0,    8398, 1191, 1,    0,    0,    0,    8399, 8400, 5,    776,  0,    0,
      8400,  8401, 3,    1278, 639,  0,    8401, 8402, 5,    773,  0,    0,    8402, 8403, 3,    1278, 639,  0,    8403,
      8404,  5,    777,  0,    0,    8404, 1193, 1,    0,    0,    0,    8405, 8410, 3,    1294, 647,  0,    8406, 8407,
      5,     773,  0,    0,    8407, 8409, 3,    1294, 647,  0,    8408, 8406, 1,    0,    0,    0,    8409, 8412, 1,
      0,     0,    0,    8410, 8408, 1,    0,    0,    0,    8410, 8411, 1,    0,    0,    0,    8411, 1195, 1,    0,
      0,     0,    8412, 8410, 1,    0,    0,    0,    8413, 8418, 3,    1198, 599,  0,    8414, 8415, 5,    773,  0,
      0,     8415, 8417, 3,    1198, 599,  0,    8416, 8414, 1,    0,    0,    0,    8417, 8420, 1,    0,    0,    0,
      8418,  8416, 1,    0,    0,    0,    8418, 8419, 1,    0,    0,    0,    8419, 1197, 1,    0,    0,    0,    8420,
      8418,  1,    0,    0,    0,    8421, 8422, 3,    1266, 633,  0,    8422, 8425, 5,    750,  0,    0,    8423, 8426,
      3,     860,  430,  0,    8424, 8426, 5,    128,  0,    0,    8425, 8423, 1,    0,    0,    0,    8425, 8424, 1,
      0,     0,    0,    8426, 1199, 1,    0,    0,    0,    8427, 8428, 3,    950,  475,  0,    8428, 8429, 3,    1132,
      566,   0,    8429, 1201, 1,    0,    0,    0,    8430, 8432, 5,    71,   0,    0,    8431, 8433, 3,    1204, 602,
      0,     8432, 8431, 1,    0,    0,    0,    8433, 8434, 1,    0,    0,    0,    8434, 8432, 1,    0,    0,    0,
      8434,  8435, 1,    0,    0,    0,    8435, 1203, 1,    0,    0,    0,    8436, 8437, 5,    579,  0,    0,    8437,
      8438,  5,    45,   0,    0,    8438, 8449, 3,    1380, 690,  0,    8439, 8441, 5,    392,  0,    0,    8440, 8439,
      1,     0,    0,    0,    8440, 8441, 1,    0,    0,    0,    8441, 8442, 1,    0,    0,    0,    8442, 8443, 5,
      157,   0,    0,    8443, 8444, 5,    45,   0,    0,    8444, 8449, 3,    1380, 690,  0,    8445, 8446, 5,    167,
      0,     0,    8446, 8447, 5,    45,   0,    0,    8447, 8449, 3,    1380, 690,  0,    8448, 8436, 1,    0,    0,
      0,     8448, 8440, 1,    0,    0,    0,    8448, 8445, 1,    0,    0,    0,    8449, 1205, 1,    0,    0,    0,
      8450,  8452, 5,    278,  0,    0,    8451, 8453, 3,    1208, 604,  0,    8452, 8451, 1,    0,    0,    0,    8453,
      8454,  1,    0,    0,    0,    8454, 8452, 1,    0,    0,    0,    8454, 8455, 1,    0,    0,    0,    8455, 1207,
      1,     0,    0,    0,    8456, 8457, 7,    150,  0,    0,    8457, 8458, 5,    45,   0,    0,    8458, 8459, 3,
      1380,  690,  0,    8459, 1209, 1,    0,    0,    0,    8460, 8465, 3,    1246, 623,  0,    8461, 8462, 5,    773,
      0,     0,    8462, 8464, 3,    1246, 623,  0,    8463, 8461, 1,    0,    0,    0,    8464, 8467, 1,    0,    0,
      0,     8465, 8463, 1,    0,    0,    0,    8465, 8466, 1,    0,    0,    0,    8466, 1211, 1,    0,    0,    0,
      8467,  8465, 1,    0,    0,    0,    8468, 8473, 3,    1214, 607,  0,    8469, 8470, 5,    773,  0,    0,    8470,
      8472,  3,    1214, 607,  0,    8471, 8469, 1,    0,    0,    0,    8472, 8475, 1,    0,    0,    0,    8473, 8471,
      1,     0,    0,    0,    8473, 8474, 1,    0,    0,    0,    8474, 1213, 1,    0,    0,    0,    8475, 8473, 1,
      0,     0,    0,    8476, 8486, 3,    1246, 623,  0,    8477, 8479, 3,    1218, 609,  0,    8478, 8480, 3,    1216,
      608,   0,    8479, 8478, 1,    0,    0,    0,    8479, 8480, 1,    0,    0,    0,    8480, 8487, 1,    0,    0,
      0,     8481, 8483, 3,    1224, 612,  0,    8482, 8484, 3,    1232, 616,  0,    8483, 8482, 1,    0,    0,    0,
      8483,  8484, 1,    0,    0,    0,    8484, 8487, 1,    0,    0,    0,    8485, 8487, 3,    1216, 608,  0,    8486,
      8477,  1,    0,    0,    0,    8486, 8481, 1,    0,    0,    0,    8486, 8485, 1,    0,    0,    0,    8486, 8487,
      1,     0,    0,    0,    8487, 1215, 1,    0,    0,    0,    8488, 8489, 5,    15,   0,    0,    8489, 8492, 3,
      1218,  609,  0,    8490, 8491, 5,    15,   0,    0,    8491, 8493, 3,    1218, 609,  0,    8492, 8490, 1,    0,
      0,     0,    8492, 8493, 1,    0,    0,    0,    8493, 1217, 1,    0,    0,    0,    8494, 8501, 3,    1220, 610,
      0,     8495, 8501, 3,    1222, 611,  0,    8496, 8501, 3,    1224, 612,  0,    8497, 8501, 3,    1226, 613,  0,
      8498,  8501, 3,    1228, 614,  0,    8499, 8501, 3,    1230, 615,  0,    8500, 8494, 1,    0,    0,    0,    8500,
      8495,  1,    0,    0,    0,    8500, 8496, 1,    0,    0,    0,    8500, 8497, 1,    0,    0,    0,    8500, 8498,
      1,     0,    0,    0,    8500, 8499, 1,    0,    0,    0,    8501, 1219, 1,    0,    0,    0,    8502, 8503, 5,
      230,   0,    0,    8503, 8504, 5,    45,   0,    0,    8504, 8505, 3,    1378, 689,  0,    8505, 1221, 1,    0,
      0,     0,    8506, 8507, 5,    230,  0,    0,    8507, 8508, 5,    45,   0,    0,    8508, 8509, 5,    734,  0,
      0,     8509, 8510, 5,    406,  0,    0,    8510, 1223, 1,    0,    0,    0,    8511, 8512, 5,    230,  0,    0,
      8512,  8513, 5,    645,  0,    0,    8513, 8514, 3,    1406, 703,  0,    8514, 1225, 1,    0,    0,    0,    8515,
      8516,  5,    230,  0,    0,    8516, 8517, 5,    645,  0,    0,    8517, 8518, 3,    1406, 703,  0,    8518, 8519,
      5,     17,   0,    0,    8519, 8520, 3,    1382, 691,  0,    8520, 1227, 1,    0,    0,    0,    8521, 8522, 5,
      230,   0,    0,    8522, 8523, 5,    645,  0,    0,    8523, 8524, 3,    1406, 703,  0,    8524, 8525, 5,    45,
      0,     0,    8525, 8526, 3,    1378, 689,  0,    8526, 1229, 1,    0,    0,    0,    8527, 8528, 5,    230,  0,
      0,     8528, 8529, 5,    645,  0,    0,    8529, 8530, 3,    1406, 703,  0,    8530, 8531, 5,    45,   0,    0,
      8531,  8532, 5,    734,  0,    0,    8532, 8533, 5,    406,  0,    0,    8533, 1231, 1,    0,    0,    0,    8534,
      8535,  5,    841,  0,    0,    8535, 8539, 5,    835,  0,    0,    8536, 8540, 3,    1222, 611,  0,    8537, 8540,
      3,     1226, 613,  0,    8538, 8540, 3,    1220, 610,  0,    8539, 8536, 1,    0,    0,    0,    8539, 8537, 1,
      0,     0,    0,    8539, 8538, 1,    0,    0,    0,    8540, 1233, 1,    0,    0,    0,    8541, 8542, 5,    727,
      0,     0,    8542, 8543, 5,    101,  0,    0,    8543, 8544, 5,    406,  0,    0,    8544, 1235, 1,    0,    0,
      0,     8545, 8546, 5,    141,  0,    0,    8546, 8547, 5,    728,  0,    0,    8547, 8548, 5,    406,  0,    0,
      8548,  1237, 1,    0,    0,    0,    8549, 8550, 3,    1240, 620,  0,    8550, 8551, 5,    838,  0,    0,    8551,
      8552,  5,    839,  0,    0,    8552, 8565, 1,    0,    0,    0,    8553, 8554, 3,    1240, 620,  0,    8554, 8555,
      5,     840,  0,    0,    8555, 8565, 1,    0,    0,    0,    8556, 8557, 3,    1240, 620,  0,    8557, 8558, 5,
      837,   0,    0,    8558, 8559, 5,    839,  0,    0,    8559, 8560, 5,    506,  0,    0,    8560, 8561, 5,    842,
      0,     0,    8561, 8562, 5,    17,   0,    0,    8562, 8563, 3,    1382, 691,  0,    8563, 8565, 1,    0,    0,
      0,     8564, 8549, 1,    0,    0,    0,    8564, 8553, 1,    0,    0,    0,    8564, 8556, 1,    0,    0,    0,
      8565,  1239, 1,    0,    0,    0,    8566, 8567, 3,    1390, 695,  0,    8567, 8568, 5,    836,  0,    0,    8568,
      1241,  1,    0,    0,    0,    8569, 8570, 5,    458,  0,    0,    8570, 8571, 3,    1380, 690,  0,    8571, 1243,
      1,     0,    0,    0,    8572, 8574, 3,    1406, 703,  0,    8573, 8575, 3,    930,  465,  0,    8574, 8573, 1,
      0,     0,    0,    8574, 8575, 1,    0,    0,    0,    8575, 1245, 1,    0,    0,    0,    8576, 8582, 3,    1244,
      622,   0,    8577, 8579, 5,    105,  0,    0,    8578, 8580, 3,    1414, 707,  0,    8579, 8578, 1,    0,    0,
      0,     8579, 8580, 1,    0,    0,    0,    8580, 8582, 1,    0,    0,    0,    8581, 8576, 1,    0,    0,    0,
      8581,  8577, 1,    0,    0,    0,    8582, 1247, 1,    0,    0,    0,    8583, 8584, 5,    275,  0,    0,    8584,
      8585,  3,    1378, 689,  0,    8585, 1249, 1,    0,    0,    0,    8586, 8589, 3,    1248, 624,  0,    8587, 8589,
      3,     368,  184,  0,    8588, 8586, 1,    0,    0,    0,    8588, 8587, 1,    0,    0,    0,    8589, 1251, 1,
      0,     0,    0,    8590, 8591, 7,    151,  0,    0,    8591, 1253, 1,    0,    0,    0,    8592, 8593, 7,    152,
      0,     0,    8593, 1255, 1,    0,    0,    0,    8594, 8595, 5,    405,  0,    0,    8595, 8596, 3,    1350, 675,
      0,     8596, 1257, 1,    0,    0,    0,    8597, 8603, 3,    1356, 678,  0,    8598, 8600, 3,    1352, 676,  0,
      8599,  8601, 3,    1356, 678,  0,    8600, 8599, 1,    0,    0,    0,    8600, 8601, 1,    0,    0,    0,    8601,
      8603,  1,    0,    0,    0,    8602, 8597, 1,    0,    0,    0,    8602, 8598, 1,    0,    0,    0,    8603, 1259,
      1,     0,    0,    0,    8604, 8605, 3,    1346, 673,  0,    8605, 1261, 1,    0,    0,    0,    8606, 8607, 3,
      1346,  673,  0,    8607, 1263, 1,    0,    0,    0,    8608, 8609, 5,    776,  0,    0,    8609, 8614, 3,    1262,
      631,   0,    8610, 8611, 5,    773,  0,    0,    8611, 8613, 3,    1262, 631,  0,    8612, 8610, 1,    0,    0,
      0,     8613, 8616, 1,    0,    0,    0,    8614, 8612, 1,    0,    0,    0,    8614, 8615, 1,    0,    0,    0,
      8615,  8617, 1,    0,    0,    0,    8616, 8614, 1,    0,    0,    0,    8617, 8618, 5,    777,  0,    0,    8618,
      1265,  1,    0,    0,    0,    8619, 8620, 3,    1258, 629,  0,    8620, 1267, 1,    0,    0,    0,    8621, 8624,
      3,     1266, 633,  0,    8622, 8624, 3,    1274, 637,  0,    8623, 8621, 1,    0,    0,    0,    8623, 8622, 1,
      0,     0,    0,    8624, 1269, 1,    0,    0,    0,    8625, 8626, 3,    1346, 673,  0,    8626, 1271, 1,    0,
      0,     0,    8627, 8628, 3,    1258, 629,  0,    8628, 1273, 1,    0,    0,    0,    8629, 8630, 3,    1346, 673,
      0,     8630, 8634, 5,    772,  0,    0,    8631, 8632, 3,    1346, 673,  0,    8632, 8633, 5,    772,  0,    0,
      8633,  8635, 1,    0,    0,    0,    8634, 8631, 1,    0,    0,    0,    8634, 8635, 1,    0,    0,    0,    8635,
      8636,  1,    0,    0,    0,    8636, 8637, 5,    760,  0,    0,    8637, 1275, 1,    0,    0,    0,    8638, 8639,
      3,     1346, 673,  0,    8639, 1277, 1,    0,    0,    0,    8640, 8641, 3,    1346, 673,  0,    8641, 1279, 1,
      0,     0,    0,    8642, 8643, 3,    1352, 676,  0,    8643, 1281, 1,    0,    0,    0,    8644, 8645, 3,    1352,
      676,   0,    8645, 1283, 1,    0,    0,    0,    8646, 8647, 3,    1352, 676,  0,    8647, 1285, 1,    0,    0,
      0,     8648, 8649, 3,    1352, 676,  0,    8649, 1287, 1,    0,    0,    0,    8650, 8651, 3,    1352, 676,  0,
      8651,  1289, 1,    0,    0,    0,    8652, 8653, 3,    1352, 676,  0,    8653, 1291, 1,    0,    0,    0,    8654,
      8657,  3,    1352, 676,  0,    8655, 8657, 3,    1356, 678,  0,    8656, 8654, 1,    0,    0,    0,    8656, 8655,
      1,     0,    0,    0,    8657, 1293, 1,    0,    0,    0,    8658, 8661, 3,    1352, 676,  0,    8659, 8661, 3,
      1356,  678,  0,    8660, 8658, 1,    0,    0,    0,    8660, 8659, 1,    0,    0,    0,    8661, 1295, 1,    0,
      0,     0,    8662, 8663, 3,    1346, 673,  0,    8663, 1297, 1,    0,    0,    0,    8664, 8665, 3,    1346, 673,
      0,     8665, 1299, 1,    0,    0,    0,    8666, 8667, 3,    1346, 673,  0,    8667, 1301, 1,    0,    0,    0,
      8668,  8669, 3,    1346, 673,  0,    8669, 1303, 1,    0,    0,    0,    8670, 8671, 3,    1352, 676,  0,    8671,
      1305,  1,    0,    0,    0,    8672, 8673, 3,    1352, 676,  0,    8673, 1307, 1,    0,    0,    0,    8674, 8675,
      3,     1346, 673,  0,    8675, 1309, 1,    0,    0,    0,    8676, 8677, 3,    1406, 703,  0,    8677, 1311, 1,
      0,     0,    0,    8678, 8679, 3,    1406, 703,  0,    8679, 1313, 1,    0,    0,    0,    8680, 8681, 3,    1406,
      703,   0,    8681, 1315, 1,    0,    0,    0,    8682, 8685, 3,    1352, 676,  0,    8683, 8685, 3,    1356, 678,
      0,     8684, 8682, 1,    0,    0,    0,    8684, 8683, 1,    0,    0,    0,    8685, 1317, 1,    0,    0,    0,
      8686,  8687, 3,    1278, 639,  0,    8687, 8688, 3,    1356, 678,  0,    8688, 1319, 1,    0,    0,    0,    8689,
      8697,  3,    1346, 673,  0,    8690, 8691, 5,    772,  0,    0,    8691, 8698, 5,    760,  0,    0,    8692, 8695,
      3,     1356, 678,  0,    8693, 8694, 5,    772,  0,    0,    8694, 8696, 5,    760,  0,    0,    8695, 8693, 1,
      0,     0,    0,    8695, 8696, 1,    0,    0,    0,    8696, 8698, 1,    0,    0,    0,    8697, 8690, 1,    0,
      0,     0,    8697, 8692, 1,    0,    0,    0,    8697, 8698, 1,    0,    0,    0,    8698, 1321, 1,    0,    0,
      0,     8699, 8702, 3,    1352, 676,  0,    8700, 8702, 3,    1356, 678,  0,    8701, 8699, 1,    0,    0,    0,
      8701,  8700, 1,    0,    0,    0,    8702, 1323, 1,    0,    0,    0,    8703, 8708, 3,    1322, 661,  0,    8704,
      8705,  5,    773,  0,    0,    8705, 8707, 3,    1322, 661,  0,    8706, 8704, 1,    0,    0,    0,    8707, 8710,
      1,     0,    0,    0,    8708, 8706, 1,    0,    0,    0,    8708, 8709, 1,    0,    0,    0,    8709, 1325, 1,
      0,     0,    0,    8710, 8708, 1,    0,    0,    0,    8711, 8716, 3,    1320, 660,  0,    8712, 8713, 5,    773,
      0,     0,    8713, 8715, 3,    1320, 660,  0,    8714, 8712, 1,    0,    0,    0,    8715, 8718, 1,    0,    0,
      0,     8716, 8714, 1,    0,    0,    0,    8716, 8717, 1,    0,    0,    0,    8717, 1327, 1,    0,    0,    0,
      8718,  8716, 1,    0,    0,    0,    8719, 8720, 3,    1346, 673,  0,    8720, 1329, 1,    0,    0,    0,    8721,
      8724,  3,    1344, 672,  0,    8722, 8724, 3,    1432, 716,  0,    8723, 8721, 1,    0,    0,    0,    8723, 8722,
      1,     0,    0,    0,    8724, 1331, 1,    0,    0,    0,    8725, 8726, 3,    1330, 665,  0,    8726, 1333, 1,
      0,     0,    0,    8727, 8730, 3,    1344, 672,  0,    8728, 8730, 3,    1438, 719,  0,    8729, 8727, 1,    0,
      0,     0,    8729, 8728, 1,    0,    0,    0,    8730, 1335, 1,    0,    0,    0,    8731, 8732, 3,    1346, 673,
      0,     8732, 1337, 1,    0,    0,    0,    8733, 8734, 3,    1378, 689,  0,    8734, 1339, 1,    0,    0,    0,
      8735,  8736, 3,    1346, 673,  0,    8736, 1341, 1,    0,    0,    0,    8737, 8738, 3,    1346, 673,  0,    8738,
      1343,  1,    0,    0,    0,    8739, 8743, 7,    153,  0,    0,    8740, 8741, 4,    672,  103,  0,    8741, 8743,
      5,     851,  0,    0,    8742, 8739, 1,    0,    0,    0,    8742, 8740, 1,    0,    0,    0,    8743, 1345, 1,
      0,     0,    0,    8744, 8747, 3,    1344, 672,  0,    8745, 8747, 3,    1426, 713,  0,    8746, 8744, 1,    0,
      0,     0,    8746, 8745, 1,    0,    0,    0,    8747, 1347, 1,    0,    0,    0,    8748, 8753, 3,    1346, 673,
      0,     8749, 8750, 5,    773,  0,    0,    8750, 8752, 3,    1346, 673,  0,    8751, 8749, 1,    0,    0,    0,
      8752,  8755, 1,    0,    0,    0,    8753, 8751, 1,    0,    0,    0,    8753, 8754, 1,    0,    0,    0,    8754,
      1349,  1,    0,    0,    0,    8755, 8753, 1,    0,    0,    0,    8756, 8757, 5,    776,  0,    0,    8757, 8758,
      3,     1348, 674,  0,    8758, 8759, 5,    777,  0,    0,    8759, 1351, 1,    0,    0,    0,    8760, 8762, 3,
      1346,  673,  0,    8761, 8763, 3,    1356, 678,  0,    8762, 8761, 1,    0,    0,    0,    8762, 8763, 1,    0,
      0,     0,    8763, 1353, 1,    0,    0,    0,    8764, 8769, 3,    1346, 673,  0,    8765, 8767, 3,    1356, 678,
      0,     8766, 8768, 3,    1356, 678,  0,    8767, 8766, 1,    0,    0,    0,    8767, 8768, 1,    0,    0,    0,
      8768,  8770, 1,    0,    0,    0,    8769, 8765, 1,    0,    0,    0,    8769, 8770, 1,    0,    0,    0,    8770,
      1355,  1,    0,    0,    0,    8771, 8772, 5,    772,  0,    0,    8772, 8773, 3,    1346, 673,  0,    8773, 1357,
      1,     0,    0,    0,    8774, 8775, 7,    154,  0,    0,    8775, 1359, 1,    0,    0,    0,    8776, 8777, 7,
      155,   0,    0,    8777, 1361, 1,    0,    0,    0,    8778, 8779, 7,    156,  0,    0,    8779, 1363, 1,    0,
      0,     0,    8780, 8786, 5,    747,  0,    0,    8781, 8782, 4,    682,  104,  0,    8782, 8786, 5,    788,  0,
      0,     8783, 8786, 5,    749,  0,    0,    8784, 8786, 5,    748,  0,    0,    8785, 8780, 1,    0,    0,    0,
      8785,  8781, 1,    0,    0,    0,    8785, 8783, 1,    0,    0,    0,    8785, 8784, 1,    0,    0,    0,    8786,
      1365,  1,    0,    0,    0,    8787, 8793, 3,    1370, 685,  0,    8788, 8789, 5,    758,  0,    0,    8789, 8793,
      3,     1358, 679,  0,    8790, 8791, 5,    759,  0,    0,    8791, 8793, 3,    1358, 679,  0,    8792, 8787, 1,
      0,     0,    0,    8792, 8788, 1,    0,    0,    0,    8792, 8790, 1,    0,    0,    0,    8793, 1367, 1,    0,
      0,     0,    8794, 8798, 3,    1366, 683,  0,    8795, 8796, 4,    684,  105,  0,    8796, 8798, 3,    1374, 687,
      0,     8797, 8794, 1,    0,    0,    0,    8797, 8795, 1,    0,    0,    0,    8798, 1369, 1,    0,    0,    0,
      8799,  8809, 3,    1384, 692,  0,    8800, 8809, 3,    1390, 695,  0,    8801, 8809, 3,    1398, 699,  0,    8802,
      8809,  3,    1394, 697,  0,    8803, 8809, 3,    1392, 696,  0,    8804, 8806, 5,    847,  0,    0,    8805, 8804,
      1,     0,    0,    0,    8805, 8806, 1,    0,    0,    0,    8806, 8807, 1,    0,    0,    0,    8807, 8809, 7,
      157,   0,    0,    8808, 8799, 1,    0,    0,    0,    8808, 8800, 1,    0,    0,    0,    8808, 8801, 1,    0,
      0,     0,    8808, 8802, 1,    0,    0,    0,    8808, 8803, 1,    0,    0,    0,    8808, 8805, 1,    0,    0,
      0,     8809, 1371, 1,    0,    0,    0,    8810, 8814, 3,    1370, 685,  0,    8811, 8812, 4,    686,  106,  0,
      8812,  8814, 3,    1374, 687,  0,    8813, 8810, 1,    0,    0,    0,    8813, 8811, 1,    0,    0,    0,    8814,
      1373,  1,    0,    0,    0,    8815, 8816, 5,    376,  0,    0,    8816, 1375, 1,    0,    0,    0,    8817, 8818,
      5,     776,  0,    0,    8818, 8823, 3,    1380, 690,  0,    8819, 8820, 5,    773,  0,    0,    8820, 8822, 3,
      1380,  690,  0,    8821, 8819, 1,    0,    0,    0,    8822, 8825, 1,    0,    0,    0,    8823, 8821, 1,    0,
      0,     0,    8823, 8824, 1,    0,    0,    0,    8824, 8826, 1,    0,    0,    0,    8825, 8823, 1,    0,    0,
      0,     8826, 8827, 5,    777,  0,    0,    8827, 1377, 1,    0,    0,    0,    8828, 8832, 5,    852,  0,    0,
      8829,  8830, 4,    689,  107,  0,    8830, 8832, 5,    851,  0,    0,    8831, 8828, 1,    0,    0,    0,    8831,
      8829,  1,    0,    0,    0,    8832, 1379, 1,    0,    0,    0,    8833, 8837, 3,    1378, 689,  0,    8834, 8837,
      5,     788,  0,    0,    8835, 8837, 5,    789,  0,    0,    8836, 8833, 1,    0,    0,    0,    8836, 8834, 1,
      0,     0,    0,    8836, 8835, 1,    0,    0,    0,    8837, 1381, 1,    0,    0,    0,    8838, 8842, 3,    1378,
      689,   0,    8839, 8840, 4,    691,  108,  0,    8840, 8842, 5,    788,  0,    0,    8841, 8838, 1,    0,    0,
      0,     8841, 8839, 1,    0,    0,    0,    8842, 1383, 1,    0,    0,    0,    8843, 8845, 5,    847,  0,    0,
      8844,  8843, 1,    0,    0,    0,    8844, 8845, 1,    0,    0,    0,    8845, 8846, 1,    0,    0,    0,    8846,
      8849,  3,    1378, 689,  0,    8847, 8849, 5,    849,  0,    0,    8848, 8844, 1,    0,    0,    0,    8848, 8847,
      1,     0,    0,    0,    8849, 8853, 1,    0,    0,    0,    8850, 8852, 3,    1378, 689,  0,    8851, 8850, 1,
      0,     0,    0,    8852, 8855, 1,    0,    0,    0,    8853, 8851, 1,    0,    0,    0,    8853, 8854, 1,    0,
      0,     0,    8854, 1385, 1,    0,    0,    0,    8855, 8853, 1,    0,    0,    0,    8856, 8857, 3,    1378, 689,
      0,     8857, 1387, 1,    0,    0,    0,    8858, 8863, 3,    1378, 689,  0,    8859, 8860, 5,    773,  0,    0,
      8860,  8862, 3,    1378, 689,  0,    8861, 8859, 1,    0,    0,    0,    8862, 8865, 1,    0,    0,    0,    8863,
      8861,  1,    0,    0,    0,    8863, 8864, 1,    0,    0,    0,    8864, 1389, 1,    0,    0,    0,    8865, 8863,
      1,     0,    0,    0,    8866, 8870, 3,    1396, 698,  0,    8867, 8870, 5,    790,  0,    0,    8868, 8870, 5,
      791,   0,    0,    8869, 8866, 1,    0,    0,    0,    8869, 8867, 1,    0,    0,    0,    8869, 8868, 1,    0,
      0,     0,    8870, 1391, 1,    0,    0,    0,    8871, 8872, 7,    158,  0,    0,    8872, 1393, 1,    0,    0,
      0,     8873, 8874, 7,    159,  0,    0,    8874, 1395, 1,    0,    0,    0,    8875, 8876, 7,    160,  0,    0,
      8876,  1397, 1,    0,    0,    0,    8877, 8878, 5,    116,  0,    0,    8878, 8884, 5,    852,  0,    0,    8879,
      8880,  5,    586,  0,    0,    8880, 8884, 5,    852,  0,    0,    8881, 8882, 5,    583,  0,    0,    8882, 8884,
      5,     852,  0,    0,    8883, 8877, 1,    0,    0,    0,    8883, 8879, 1,    0,    0,    0,    8883, 8881, 1,
      0,     0,    0,    8884, 1399, 1,    0,    0,    0,    8885, 8888, 3,    1116, 558,  0,    8886, 8888, 3,    1404,
      702,   0,    8887, 8885, 1,    0,    0,    0,    8887, 8886, 1,    0,    0,    0,    8888, 1401, 1,    0,    0,
      0,     8889, 8890, 3,    1404, 702,  0,    8890, 1403, 1,    0,    0,    0,    8891, 8892, 5,    776,  0,    0,
      8892,  8893, 5,    747,  0,    0,    8893, 8894, 5,    773,  0,    0,    8894, 8895, 5,    747,  0,    0,    8895,
      8896,  5,    777,  0,    0,    8896, 1405, 1,    0,    0,    0,    8897, 8900, 3,    1346, 673,  0,    8898, 8900,
      3,     1378, 689,  0,    8899, 8897, 1,    0,    0,    0,    8899, 8898, 1,    0,    0,    0,    8900, 1407, 1,
      0,     0,    0,    8901, 8904, 3,    1344, 672,  0,    8902, 8904, 3,    1440, 720,  0,    8903, 8901, 1,    0,
      0,     0,    8903, 8902, 1,    0,    0,    0,    8904, 1409, 1,    0,    0,    0,    8905, 8908, 3,    1334, 667,
      0,     8906, 8908, 3,    1378, 689,  0,    8907, 8905, 1,    0,    0,    0,    8907, 8906, 1,    0,    0,    0,
      8908,  1411, 1,    0,    0,    0,    8909, 8912, 3,    1364, 682,  0,    8910, 8912, 3,    1344, 672,  0,    8911,
      8909,  1,    0,    0,    0,    8911, 8910, 1,    0,    0,    0,    8912, 1413, 1,    0,    0,    0,    8913, 8914,
      5,     776,  0,    0,    8914, 8915, 5,    777,  0,    0,    8915, 1415, 1,    0,    0,    0,    8916, 8917, 7,
      161,   0,    0,    8917, 1417, 1,    0,    0,    0,    8918, 8919, 7,    162,  0,    0,    8919, 1419, 1,    0,
      0,     0,    8920, 8921, 5,    214,  0,    0,    8921, 8927, 5,    772,  0,    0,    8922, 8923, 5,    284,  0,
      0,     8923, 8927, 5,    772,  0,    0,    8924, 8925, 5,    502,  0,    0,    8925, 8927, 5,    772,  0,    0,
      8926,  8920, 1,    0,    0,    0,    8926, 8922, 1,    0,    0,    0,    8926, 8924, 1,    0,    0,    0,    8927,
      1421,  1,    0,    0,    0,    8928, 8929, 7,    162,  0,    0,    8929, 8930, 5,    772,  0,    0,    8930, 1423,
      1,     0,    0,    0,    8931, 8932, 3,    1378, 689,  0,    8932, 1425, 1,    0,    0,    0,    8933, 8940, 4,
      713,   109,  0,    8934, 8941, 3,    1432, 716,  0,    8935, 8941, 3,    1444, 722,  0,    8936, 8941, 5,    173,
      0,     0,    8937, 8941, 5,    510,  0,    0,    8938, 8939, 4,    713,  110,  0,    8939, 8941, 5,    714,  0,
      0,     8940, 8934, 1,    0,    0,    0,    8940, 8935, 1,    0,    0,    0,    8940, 8936, 1,    0,    0,    0,
      8940,  8937, 1,    0,    0,    0,    8940, 8938, 1,    0,    0,    0,    8941, 8950, 1,    0,    0,    0,    8942,
      8948,  3,    1436, 718,  0,    8943, 8948, 3,    1428, 714,  0,    8944, 8948, 3,    1430, 715,  0,    8945, 8948,
      3,     1434, 717,  0,    8946, 8948, 3,    1442, 721,  0,    8947, 8942, 1,    0,    0,    0,    8947, 8943, 1,
      0,     0,    0,    8947, 8944, 1,    0,    0,    0,    8947, 8945, 1,    0,    0,    0,    8947, 8946, 1,    0,
      0,     0,    8948, 8950, 1,    0,    0,    0,    8949, 8933, 1,    0,    0,    0,    8949, 8947, 1,    0,    0,
      0,     8950, 1427, 1,    0,    0,    0,    8951, 8952, 7,    163,  0,    0,    8952, 1429, 1,    0,    0,    0,
      8953,  8954, 7,    164,  0,    0,    8954, 1431, 1,    0,    0,    0,    8955, 8966, 4,    716,  111,  0,    8956,
      8967,  3,    1446, 723,  0,    8957, 8967, 5,    170,  0,    0,    8958, 8967, 5,    188,  0,    0,    8959, 8967,
      5,     369,  0,    0,    8960, 8967, 5,    423,  0,    0,    8961, 8967, 5,    427,  0,    0,    8962, 8967, 5,
      451,   0,    0,    8963, 8967, 5,    459,  0,    0,    8964, 8967, 5,    709,  0,    0,    8965, 8967, 5,    565,
      0,     0,    8966, 8956, 1,    0,    0,    0,    8966, 8957, 1,    0,    0,    0,    8966, 8958, 1,    0,    0,
      0,     8966, 8959, 1,    0,    0,    0,    8966, 8960, 1,    0,    0,    0,    8966, 8961, 1,    0,    0,    0,
      8966,  8962, 1,    0,    0,    0,    8966, 8963, 1,    0,    0,    0,    8966, 8964, 1,    0,    0,    0,    8966,
      8965,  1,    0,    0,    0,    8967, 8974, 1,    0,    0,    0,    8968, 8972, 3,    1436, 718,  0,    8969, 8972,
      3,     1434, 717,  0,    8970, 8972, 3,    1442, 721,  0,    8971, 8968, 1,    0,    0,    0,    8971, 8969, 1,
      0,     0,    0,    8971, 8970, 1,    0,    0,    0,    8972, 8974, 1,    0,    0,    0,    8973, 8955, 1,    0,
      0,     0,    8973, 8971, 1,    0,    0,    0,    8974, 1433, 1,    0,    0,    0,    8975, 8976, 7,    165,  0,
      0,     8976, 1435, 1,    0,    0,    0,    8977, 8981, 7,    166,  0,    0,    8978, 8979, 4,    718,  112,  0,
      8979,  8981, 7,    167,  0,    0,    8980, 8977, 1,    0,    0,    0,    8980, 8978, 1,    0,    0,    0,    8981,
      1437,  1,    0,    0,    0,    8982, 8985, 4,    719,  113,  0,    8983, 8986, 3,    1446, 723,  0,    8984, 8986,
      3,     1444, 722,  0,    8985, 8983, 1,    0,    0,    0,    8985, 8984, 1,    0,    0,    0,    8986, 8993, 1,
      0,     0,    0,    8987, 8991, 3,    1436, 718,  0,    8988, 8991, 3,    1430, 715,  0,    8989, 8991, 3,    1442,
      721,   0,    8990, 8987, 1,    0,    0,    0,    8990, 8988, 1,    0,    0,    0,    8990, 8989, 1,    0,    0,
      0,     8991, 8993, 1,    0,    0,    0,    8992, 8982, 1,    0,    0,    0,    8992, 8990, 1,    0,    0,    0,
      8993,  1439, 1,    0,    0,    0,    8994, 8999, 3,    1436, 718,  0,    8995, 8999, 3,    1428, 714,  0,    8996,
      8999,  3,    1430, 715,  0,    8997, 8999, 3,    1434, 717,  0,    8998, 8994, 1,    0,    0,    0,    8998, 8995,
      1,     0,    0,    0,    8998, 8996, 1,    0,    0,    0,    8998, 8997, 1,    0,    0,    0,    8999, 1441, 1,
      0,     0,    0,    9000, 9001, 7,    162,  0,    0,    9001, 1443, 1,    0,    0,    0,    9002, 9003, 7,    168,
      0,     0,    9003, 1445, 1,    0,    0,    0,    9004, 9008, 7,    169,  0,    0,    9005, 9006, 4,    723,  114,
      0,     9006, 9008, 5,    660,  0,    0,    9007, 9004, 1,    0,    0,    0,    9007, 9005, 1,    0,    0,    0,
      9008,  1447, 1,    0,    0,    0,    1149, 1450, 1453, 1455, 1532, 1540, 1545, 1555, 1562, 1568, 1571, 1574, 1581,
      1586,  1589, 1594, 1600, 1602, 1606, 1610, 1619, 1623, 1628, 1634, 1641, 1646, 1651, 1658, 1661, 1667, 1670, 1677,
      1687,  1692, 1697, 1705, 1711, 1715, 1720, 1729, 1735, 1741, 1747, 1756, 1762, 1771, 1783, 1787, 1793, 1797, 1803,
      1807,  1812, 1815, 1821, 1827, 1833, 1837, 1842, 1846, 1850, 1866, 1874, 1882, 1889, 1916, 1931, 1934, 1940, 1945,
      1951,  1956, 1960, 1965, 1969, 1973, 1977, 1981, 1985, 1987, 1997, 2005, 2012, 2020, 2024, 2029, 2036, 2041, 2046,
      2056,  2060, 2065, 2068, 2071, 2074, 2081, 2088, 2092, 2117, 2119, 2127, 2129, 2149, 2153, 2159, 2166, 2169, 2173,
      2180,  2183, 2192, 2199, 2204, 2207, 2212, 2219, 2222, 2226, 2232, 2235, 2240, 2244, 2253, 2256, 2262, 2268, 2272,
      2281,  2284, 2292, 2298, 2302, 2312, 2315, 2320, 2339, 2342, 2345, 2350, 2356, 2366, 2376, 2379, 2382, 2386, 2394,
      2407,  2411, 2416, 2425, 2442, 2461, 2470, 2473, 2481, 2488, 2490, 2497, 2502, 2516, 2520, 2526, 2532, 2538, 2544,
      2550,  2555, 2559, 2567, 2573, 2579, 2585, 2590, 2593, 2596, 2605, 2608, 2619, 2623, 2634, 2642, 2646, 2655, 2658,
      2664,  2666, 2670, 2677, 2690, 2697, 2703, 2706, 2723, 2742, 2746, 2752, 2758, 2764, 2769, 2776, 2783, 2788, 2791,
      2795,  2799, 2804, 2808, 2812, 2818, 2823, 2826, 2830, 2836, 2840, 2844, 2852, 2860, 2869, 2878, 2891, 2894, 2897,
      2903,  2911, 2916, 2919, 2922, 2925, 2928, 2930, 2936, 2938, 2954, 2961, 2964, 2966, 2968, 2978, 2980, 2984, 2987,
      2990,  2994, 2999, 3005, 3008, 3011, 3017, 3020, 3029, 3039, 3042, 3045, 3049, 3055, 3060, 3065, 3070, 3074, 3080,
      3091,  3094, 3099, 3105, 3108, 3111, 3114, 3117, 3131, 3134, 3138, 3142, 3150, 3158, 3162, 3167, 3170, 3174, 3180,
      3184,  3187, 3196, 3206, 3209, 3213, 3216, 3220, 3225, 3228, 3233, 3239, 3248, 3254, 3259, 3262, 3265, 3268, 3271,
      3274,  3289, 3293, 3299, 3302, 3305, 3311, 3316, 3320, 3323, 3330, 3332, 3345, 3357, 3362, 3365, 3368, 3373, 3379,
      3395,  3415, 3424, 3428, 3435, 3440, 3449, 3463, 3470, 3479, 3488, 3494, 3499, 3505, 3508, 3514, 3521, 3525, 3531,
      3537,  3539, 3542, 3546, 3556, 3561, 3566, 3573, 3582, 3590, 3595, 3599, 3605, 3608, 3611, 3615, 3619, 3629, 3633,
      3636,  3639, 3644, 3650, 3653, 3659, 3662, 3664, 3669, 3681, 3690, 3703, 3706, 3711, 3718, 3722, 3725, 3731, 3745,
      3752,  3761, 3767, 3776, 3780, 3784, 3794, 3796, 3804, 3811, 3816, 3819, 3823, 3826, 3832, 3835, 3838, 3844, 3851,
      3856,  3860, 3863, 3866, 3869, 3871, 3875, 3882, 3888, 3892, 3897, 3900, 3903, 3906, 3908, 3913, 3922, 3931, 3935,
      3941,  3944, 3947, 3953, 3960, 3962, 3970, 3976, 3978, 3988, 3990, 3999, 4008, 4016, 4023, 4027, 4031, 4034, 4036,
      4045,  4054, 4061, 4068, 4199, 4253, 4260, 4264, 4280, 4292, 4295, 4307, 4311, 4317, 4324, 4331, 4338, 4345, 4352,
      4359,  4362, 4369, 4377, 4385, 4395, 4401, 4405, 4408, 4411, 4414, 4417, 4420, 4425, 4428, 4435, 4441, 4465, 4472,
      4475,  4484, 4490, 4511, 4517, 4523, 4530, 4538, 4544, 4556, 4558, 4564, 4568, 4570, 4574, 4585, 4590, 4596, 4603,
      4606,  4609, 4615, 4617, 4625, 4628, 4630, 4632, 4639, 4650, 4653, 4655, 4659, 4664, 4666, 4671, 4677, 4680, 4682,
      4686,  4689, 4698, 4707, 4713, 4715, 4717, 4726, 4730, 4736, 4739, 4741, 4752, 4757, 4762, 4768, 4770, 4774, 4776,
      4784,  4788, 4793, 4796, 4801, 4806, 4812, 4821, 4832, 4834, 4846, 4851, 4859, 4865, 4867, 4874, 4876, 4883, 4888,
      4899,  4904, 4906, 4910, 4916, 4919, 4922, 4932, 4934, 4940, 4948, 4959, 4963, 4968, 4985, 4991, 5000, 5008, 5012,
      5018,  5028, 5032, 5041, 5046, 5052, 5054, 5058, 5069, 5076, 5082, 5086, 5091, 5096, 5104, 5108, 5113, 5122, 5135,
      5137,  5151, 5160, 5162, 5169, 5174, 5178, 5183, 5191, 5198, 5202, 5208, 5215, 5218, 5231, 5237, 5242, 5265, 5268,
      5284,  5289, 5292, 5296, 5299, 5307, 5313, 5318, 5321, 5323, 5327, 5332, 5334, 5346, 5352, 5366, 5378, 5382, 5384,
      5392,  5396, 5405, 5418, 5423, 5427, 5431, 5434, 5438, 5442, 5445, 5450, 5453, 5459, 5462, 5468, 5471, 5493, 5499,
      5502,  5513, 5520, 5524, 5527, 5530, 5537, 5541, 5544, 5547, 5551, 5557, 5560, 5564, 5585, 5590, 5598, 5603, 5606,
      5610,  5614, 5618, 5624, 5628, 5633, 5638, 5649, 5651, 5657, 5679, 5701, 5708, 5735, 5737, 5741, 5753, 5763, 5773,
      5777,  5785, 5788, 5792, 5801, 5805, 5812, 5817, 5825, 5830, 5836, 5843, 5848, 5854, 5857, 5867, 5869, 5876, 5881,
      5885,  5888, 5895, 5900, 5904, 5915, 5923, 5927, 5930, 5933, 5937, 5941, 5946, 5952, 5956, 5967, 5970, 5973, 5976,
      5984,  5988, 5993, 6001, 6009, 6015, 6029, 6041, 6055, 6058, 6062, 6073, 6075, 6084, 6096, 6098, 6105, 6111, 6117,
      6125,  6136, 6140, 6169, 6171, 6177, 6194, 6201, 6215, 6226, 6231, 6242, 6252, 6259, 6262, 6296, 6304, 6306, 6316,
      6321,  6326, 6333, 6339, 6344, 6349, 6355, 6359, 6364, 6369, 6376, 6384, 6389, 6393, 6397, 6401, 6403, 6421, 6429,
      6433,  6440, 6452, 6455, 6459, 6464, 6471, 6475, 6479, 6485, 6495, 6504, 6506, 6509, 6518, 6525, 6538, 6543, 6550,
      6556,  6582, 6592, 6624, 6643, 6649, 6653, 6680, 6692, 6705, 6709, 6713, 6741, 6791, 6801, 6813, 6818, 6826, 6846,
      6850,  6866, 6869, 6874, 6877, 6886, 6890, 6896, 6902, 6906, 6917, 6923, 6925, 6932, 6939, 6943, 6950, 6955, 6960,
      6969,  6972, 6976, 6981, 6983, 6987, 6991, 7004, 7008, 7011, 7015, 7019, 7023, 7030, 7034, 7038, 7046, 7050, 7057,
      7063,  7071, 7092, 7097, 7104, 7126, 7142, 7152, 7156, 7163, 7166, 7177, 7186, 7189, 7196, 7201, 7227, 7233, 7239,
      7243,  7253, 7257, 7270, 7282, 7298, 7306, 7316, 7319, 7324, 7328, 7335, 7340, 7347, 7355, 7358, 7363, 7371, 7374,
      7388,  7391, 7404, 7408, 7410, 7415, 7420, 7426, 7432, 7438, 7443, 7446, 7452, 7457, 7460, 7466, 7470, 7476, 7478,
      7481,  7487, 7493, 7501, 7503, 7505, 7509, 7515, 7519, 7523, 7528, 7533, 7536, 7539, 7549, 7555, 7562, 7567, 7580,
      7588,  7594, 7599, 7610, 7614, 7619, 7623, 7626, 7631, 7635, 7643, 7651, 7653, 7662, 7670, 7677, 7680, 7688, 7697,
      7699,  7705, 7709, 7718, 7724, 7727, 7738, 7747, 7750, 7755, 7757, 7760, 7763, 7767, 7770, 7774, 7779, 7782, 7786,
      7789,  7793, 7798, 7802, 7814, 7818, 7824, 7827, 7832, 7836, 7840, 7845, 7854, 7857, 7861, 7865, 7868, 7872, 7876,
      7881,  7886, 7891, 7896, 7901, 7903, 7908, 7915, 7923, 7929, 7931, 7935, 7939, 7943, 7947, 7962, 7968, 7975, 7979,
      7984,  7989, 7992, 7996, 7999, 8004, 8008, 8014, 8018, 8022, 8027, 8032, 8037, 8042, 8047, 8052, 8057, 8062, 8067,
      8072,  8077, 8082, 8087, 8097, 8103, 8109, 8114, 8121, 8126, 8135, 8141, 8146, 8150, 8153, 8157, 8162, 8166, 8171,
      8175,  8184, 8187, 8190, 8193, 8197, 8201, 8205, 8220, 8223, 8225, 8230, 8239, 8242, 8246, 8258, 8270, 8275, 8280,
      8289,  8294, 8303, 8308, 8312, 8316, 8320, 8325, 8330, 8336, 8341, 8344, 8351, 8360, 8367, 8385, 8397, 8410, 8418,
      8425,  8434, 8440, 8448, 8454, 8465, 8473, 8479, 8483, 8486, 8492, 8500, 8539, 8564, 8574, 8579, 8581, 8588, 8600,
      8602,  8614, 8623, 8634, 8656, 8660, 8684, 8695, 8697, 8701, 8708, 8716, 8723, 8729, 8742, 8746, 8753, 8762, 8767,
      8769,  8785, 8792, 8797, 8805, 8808, 8813, 8823, 8831, 8836, 8841, 8844, 8848, 8853, 8863, 8869, 8883, 8887, 8899,
      8903,  8907, 8911, 8926, 8940, 8947, 8949, 8966, 8971, 8973, 8980, 8985, 8990, 8992, 8998, 9007
    };
    staticData->serializedATN = antlr4::atn::SerializedATNView(
      serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

    antlr4::atn::ATNDeserializer deserializer;
    staticData->atn = deserializer.deserialize(staticData->serializedATN);

    const size_t count = staticData->atn->getNumberOfDecisions();
    staticData->decisionToDFA.reserve(count);
    for (size_t i = 0; i < count; i++) {
      staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
    }
    mysqlparserParserStaticData = staticData.release();
  }

} // namespace

MySQLParser::MySQLParser(TokenStream *input) : MySQLParser(input, antlr4::atn::ParserATNSimulatorOptions()) {
}

MySQLParser::MySQLParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options)
  : MySQLBaseRecognizer(input) {
  MySQLParser::initialize();
  _interpreter =
    new atn::ParserATNSimulator(this, *mysqlparserParserStaticData->atn, mysqlparserParserStaticData->decisionToDFA,
                                mysqlparserParserStaticData->sharedContextCache, options);
}

MySQLParser::~MySQLParser() {
  delete _interpreter;
}

const atn::ATN &MySQLParser::getATN() const {
  return *mysqlparserParserStaticData->atn;
}

std::string MySQLParser::getGrammarFileName() const {
  return "MySQLParser.g4";
}

const std::vector<std::string> &MySQLParser::getRuleNames() const {
  return mysqlparserParserStaticData->ruleNames;
}

const dfa::Vocabulary &MySQLParser::getVocabulary() const {
  return mysqlparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView MySQLParser::getSerializedATN() const {
  return mysqlparserParserStaticData->serializedATN;
}

//----------------- QueryContext ------------------------------------------------------------------

MySQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::QueryContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::SimpleStatementContext *MySQLParser::QueryContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::BeginWorkContext *MySQLParser::QueryContext::beginWork() {
  return getRuleContext<MySQLParser::BeginWorkContext>(0);
}

tree::TerminalNode *MySQLParser::QueryContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}

size_t MySQLParser::QueryContext::getRuleIndex() const {
  return MySQLParser::RuleQuery;
}

void MySQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void MySQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}

std::any MySQLParser::QueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQuery(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryContext *MySQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 0, MySQLParser::RuleQuery);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1455);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
      case 1: {
        setState(1450);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
          case 1: {
            setState(1448);
            simpleStatement();
            break;
          }

          case 2: {
            setState(1449);
            beginWork();
            break;
          }

          default:
            break;
        }
        setState(1453);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SEMICOLON_SYMBOL) {
          setState(1452);
          match(MySQLParser::SEMICOLON_SYMBOL);
        }
        break;
      }

      default:
        break;
    }
    setState(1457);
    match(MySQLParser::EOF);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

MySQLParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterStatementContext *MySQLParser::SimpleStatementContext::alterStatement() {
  return getRuleContext<MySQLParser::AlterStatementContext>(0);
}

MySQLParser::CreateStatementContext *MySQLParser::SimpleStatementContext::createStatement() {
  return getRuleContext<MySQLParser::CreateStatementContext>(0);
}

MySQLParser::DropStatementContext *MySQLParser::SimpleStatementContext::dropStatement() {
  return getRuleContext<MySQLParser::DropStatementContext>(0);
}

MySQLParser::RenameTableStatementContext *MySQLParser::SimpleStatementContext::renameTableStatement() {
  return getRuleContext<MySQLParser::RenameTableStatementContext>(0);
}

MySQLParser::TruncateTableStatementContext *MySQLParser::SimpleStatementContext::truncateTableStatement() {
  return getRuleContext<MySQLParser::TruncateTableStatementContext>(0);
}

MySQLParser::ImportStatementContext *MySQLParser::SimpleStatementContext::importStatement() {
  return getRuleContext<MySQLParser::ImportStatementContext>(0);
}

MySQLParser::CallStatementContext *MySQLParser::SimpleStatementContext::callStatement() {
  return getRuleContext<MySQLParser::CallStatementContext>(0);
}

MySQLParser::DeleteStatementContext *MySQLParser::SimpleStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::DoStatementContext *MySQLParser::SimpleStatementContext::doStatement() {
  return getRuleContext<MySQLParser::DoStatementContext>(0);
}

MySQLParser::HandlerStatementContext *MySQLParser::SimpleStatementContext::handlerStatement() {
  return getRuleContext<MySQLParser::HandlerStatementContext>(0);
}

MySQLParser::InsertStatementContext *MySQLParser::SimpleStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::LoadStatementContext *MySQLParser::SimpleStatementContext::loadStatement() {
  return getRuleContext<MySQLParser::LoadStatementContext>(0);
}

MySQLParser::ReplaceStatementContext *MySQLParser::SimpleStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::SelectStatementContext *MySQLParser::SimpleStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::UpdateStatementContext *MySQLParser::SimpleStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

MySQLParser::TransactionOrLockingStatementContext *
MySQLParser::SimpleStatementContext::transactionOrLockingStatement() {
  return getRuleContext<MySQLParser::TransactionOrLockingStatementContext>(0);
}

MySQLParser::ReplicationStatementContext *MySQLParser::SimpleStatementContext::replicationStatement() {
  return getRuleContext<MySQLParser::ReplicationStatementContext>(0);
}

MySQLParser::PreparedStatementContext *MySQLParser::SimpleStatementContext::preparedStatement() {
  return getRuleContext<MySQLParser::PreparedStatementContext>(0);
}

MySQLParser::CloneStatementContext *MySQLParser::SimpleStatementContext::cloneStatement() {
  return getRuleContext<MySQLParser::CloneStatementContext>(0);
}

MySQLParser::AccountManagementStatementContext *MySQLParser::SimpleStatementContext::accountManagementStatement() {
  return getRuleContext<MySQLParser::AccountManagementStatementContext>(0);
}

MySQLParser::TableAdministrationStatementContext *MySQLParser::SimpleStatementContext::tableAdministrationStatement() {
  return getRuleContext<MySQLParser::TableAdministrationStatementContext>(0);
}

MySQLParser::InstallUninstallStatementContext *MySQLParser::SimpleStatementContext::installUninstallStatement() {
  return getRuleContext<MySQLParser::InstallUninstallStatementContext>(0);
}

MySQLParser::SetStatementContext *MySQLParser::SimpleStatementContext::setStatement() {
  return getRuleContext<MySQLParser::SetStatementContext>(0);
}

MySQLParser::ShowDatabasesStatementContext *MySQLParser::SimpleStatementContext::showDatabasesStatement() {
  return getRuleContext<MySQLParser::ShowDatabasesStatementContext>(0);
}

MySQLParser::ShowTablesStatementContext *MySQLParser::SimpleStatementContext::showTablesStatement() {
  return getRuleContext<MySQLParser::ShowTablesStatementContext>(0);
}

MySQLParser::ShowTriggersStatementContext *MySQLParser::SimpleStatementContext::showTriggersStatement() {
  return getRuleContext<MySQLParser::ShowTriggersStatementContext>(0);
}

MySQLParser::ShowEventsStatementContext *MySQLParser::SimpleStatementContext::showEventsStatement() {
  return getRuleContext<MySQLParser::ShowEventsStatementContext>(0);
}

MySQLParser::ShowTableStatusStatementContext *MySQLParser::SimpleStatementContext::showTableStatusStatement() {
  return getRuleContext<MySQLParser::ShowTableStatusStatementContext>(0);
}

MySQLParser::ShowOpenTablesStatementContext *MySQLParser::SimpleStatementContext::showOpenTablesStatement() {
  return getRuleContext<MySQLParser::ShowOpenTablesStatementContext>(0);
}

MySQLParser::ShowPluginsStatementContext *MySQLParser::SimpleStatementContext::showPluginsStatement() {
  return getRuleContext<MySQLParser::ShowPluginsStatementContext>(0);
}

MySQLParser::ShowEngineLogsStatementContext *MySQLParser::SimpleStatementContext::showEngineLogsStatement() {
  return getRuleContext<MySQLParser::ShowEngineLogsStatementContext>(0);
}

MySQLParser::ShowEngineMutexStatementContext *MySQLParser::SimpleStatementContext::showEngineMutexStatement() {
  return getRuleContext<MySQLParser::ShowEngineMutexStatementContext>(0);
}

MySQLParser::ShowEngineStatusStatementContext *MySQLParser::SimpleStatementContext::showEngineStatusStatement() {
  return getRuleContext<MySQLParser::ShowEngineStatusStatementContext>(0);
}

MySQLParser::ShowColumnsStatementContext *MySQLParser::SimpleStatementContext::showColumnsStatement() {
  return getRuleContext<MySQLParser::ShowColumnsStatementContext>(0);
}

MySQLParser::ShowBinaryLogsStatementContext *MySQLParser::SimpleStatementContext::showBinaryLogsStatement() {
  return getRuleContext<MySQLParser::ShowBinaryLogsStatementContext>(0);
}

MySQLParser::ShowReplicasStatementContext *MySQLParser::SimpleStatementContext::showReplicasStatement() {
  return getRuleContext<MySQLParser::ShowReplicasStatementContext>(0);
}

MySQLParser::ShowBinlogEventsStatementContext *MySQLParser::SimpleStatementContext::showBinlogEventsStatement() {
  return getRuleContext<MySQLParser::ShowBinlogEventsStatementContext>(0);
}

MySQLParser::ShowRelaylogEventsStatementContext *MySQLParser::SimpleStatementContext::showRelaylogEventsStatement() {
  return getRuleContext<MySQLParser::ShowRelaylogEventsStatementContext>(0);
}

MySQLParser::ShowKeysStatementContext *MySQLParser::SimpleStatementContext::showKeysStatement() {
  return getRuleContext<MySQLParser::ShowKeysStatementContext>(0);
}

MySQLParser::ShowEnginesStatementContext *MySQLParser::SimpleStatementContext::showEnginesStatement() {
  return getRuleContext<MySQLParser::ShowEnginesStatementContext>(0);
}

MySQLParser::ShowCountWarningsStatementContext *MySQLParser::SimpleStatementContext::showCountWarningsStatement() {
  return getRuleContext<MySQLParser::ShowCountWarningsStatementContext>(0);
}

MySQLParser::ShowCountErrorsStatementContext *MySQLParser::SimpleStatementContext::showCountErrorsStatement() {
  return getRuleContext<MySQLParser::ShowCountErrorsStatementContext>(0);
}

MySQLParser::ShowWarningsStatementContext *MySQLParser::SimpleStatementContext::showWarningsStatement() {
  return getRuleContext<MySQLParser::ShowWarningsStatementContext>(0);
}

MySQLParser::ShowErrorsStatementContext *MySQLParser::SimpleStatementContext::showErrorsStatement() {
  return getRuleContext<MySQLParser::ShowErrorsStatementContext>(0);
}

MySQLParser::ShowProfilesStatementContext *MySQLParser::SimpleStatementContext::showProfilesStatement() {
  return getRuleContext<MySQLParser::ShowProfilesStatementContext>(0);
}

MySQLParser::ShowProfileStatementContext *MySQLParser::SimpleStatementContext::showProfileStatement() {
  return getRuleContext<MySQLParser::ShowProfileStatementContext>(0);
}

MySQLParser::ShowStatusStatementContext *MySQLParser::SimpleStatementContext::showStatusStatement() {
  return getRuleContext<MySQLParser::ShowStatusStatementContext>(0);
}

MySQLParser::ShowProcessListStatementContext *MySQLParser::SimpleStatementContext::showProcessListStatement() {
  return getRuleContext<MySQLParser::ShowProcessListStatementContext>(0);
}

MySQLParser::ShowVariablesStatementContext *MySQLParser::SimpleStatementContext::showVariablesStatement() {
  return getRuleContext<MySQLParser::ShowVariablesStatementContext>(0);
}

MySQLParser::ShowCharacterSetStatementContext *MySQLParser::SimpleStatementContext::showCharacterSetStatement() {
  return getRuleContext<MySQLParser::ShowCharacterSetStatementContext>(0);
}

MySQLParser::ShowCollationStatementContext *MySQLParser::SimpleStatementContext::showCollationStatement() {
  return getRuleContext<MySQLParser::ShowCollationStatementContext>(0);
}

MySQLParser::ShowPrivilegesStatementContext *MySQLParser::SimpleStatementContext::showPrivilegesStatement() {
  return getRuleContext<MySQLParser::ShowPrivilegesStatementContext>(0);
}

MySQLParser::ShowGrantsStatementContext *MySQLParser::SimpleStatementContext::showGrantsStatement() {
  return getRuleContext<MySQLParser::ShowGrantsStatementContext>(0);
}

MySQLParser::ShowCreateDatabaseStatementContext *MySQLParser::SimpleStatementContext::showCreateDatabaseStatement() {
  return getRuleContext<MySQLParser::ShowCreateDatabaseStatementContext>(0);
}

MySQLParser::ShowCreateTableStatementContext *MySQLParser::SimpleStatementContext::showCreateTableStatement() {
  return getRuleContext<MySQLParser::ShowCreateTableStatementContext>(0);
}

MySQLParser::ShowCreateViewStatementContext *MySQLParser::SimpleStatementContext::showCreateViewStatement() {
  return getRuleContext<MySQLParser::ShowCreateViewStatementContext>(0);
}

MySQLParser::ShowMasterStatusStatementContext *MySQLParser::SimpleStatementContext::showMasterStatusStatement() {
  return getRuleContext<MySQLParser::ShowMasterStatusStatementContext>(0);
}

MySQLParser::ShowReplicaStatusStatementContext *MySQLParser::SimpleStatementContext::showReplicaStatusStatement() {
  return getRuleContext<MySQLParser::ShowReplicaStatusStatementContext>(0);
}

MySQLParser::ShowCreateProcedureStatementContext *MySQLParser::SimpleStatementContext::showCreateProcedureStatement() {
  return getRuleContext<MySQLParser::ShowCreateProcedureStatementContext>(0);
}

MySQLParser::ShowCreateFunctionStatementContext *MySQLParser::SimpleStatementContext::showCreateFunctionStatement() {
  return getRuleContext<MySQLParser::ShowCreateFunctionStatementContext>(0);
}

MySQLParser::ShowCreateTriggerStatementContext *MySQLParser::SimpleStatementContext::showCreateTriggerStatement() {
  return getRuleContext<MySQLParser::ShowCreateTriggerStatementContext>(0);
}

MySQLParser::ShowCreateProcedureStatusStatementContext *
MySQLParser::SimpleStatementContext::showCreateProcedureStatusStatement() {
  return getRuleContext<MySQLParser::ShowCreateProcedureStatusStatementContext>(0);
}

MySQLParser::ShowCreateFunctionStatusStatementContext *
MySQLParser::SimpleStatementContext::showCreateFunctionStatusStatement() {
  return getRuleContext<MySQLParser::ShowCreateFunctionStatusStatementContext>(0);
}

MySQLParser::ShowCreateProcedureCodeStatementContext *
MySQLParser::SimpleStatementContext::showCreateProcedureCodeStatement() {
  return getRuleContext<MySQLParser::ShowCreateProcedureCodeStatementContext>(0);
}

MySQLParser::ShowCreateFunctionCodeStatementContext *
MySQLParser::SimpleStatementContext::showCreateFunctionCodeStatement() {
  return getRuleContext<MySQLParser::ShowCreateFunctionCodeStatementContext>(0);
}

MySQLParser::ShowCreateEventStatementContext *MySQLParser::SimpleStatementContext::showCreateEventStatement() {
  return getRuleContext<MySQLParser::ShowCreateEventStatementContext>(0);
}

MySQLParser::ShowCreateUserStatementContext *MySQLParser::SimpleStatementContext::showCreateUserStatement() {
  return getRuleContext<MySQLParser::ShowCreateUserStatementContext>(0);
}

MySQLParser::ResourceGroupManagementContext *MySQLParser::SimpleStatementContext::resourceGroupManagement() {
  return getRuleContext<MySQLParser::ResourceGroupManagementContext>(0);
}

MySQLParser::OtherAdministrativeStatementContext *MySQLParser::SimpleStatementContext::otherAdministrativeStatement() {
  return getRuleContext<MySQLParser::OtherAdministrativeStatementContext>(0);
}

MySQLParser::UtilityStatementContext *MySQLParser::SimpleStatementContext::utilityStatement() {
  return getRuleContext<MySQLParser::UtilityStatementContext>(0);
}

MySQLParser::GetDiagnosticsStatementContext *MySQLParser::SimpleStatementContext::getDiagnosticsStatement() {
  return getRuleContext<MySQLParser::GetDiagnosticsStatementContext>(0);
}

MySQLParser::SignalStatementContext *MySQLParser::SimpleStatementContext::signalStatement() {
  return getRuleContext<MySQLParser::SignalStatementContext>(0);
}

MySQLParser::ResignalStatementContext *MySQLParser::SimpleStatementContext::resignalStatement() {
  return getRuleContext<MySQLParser::ResignalStatementContext>(0);
}

size_t MySQLParser::SimpleStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleStatement;
}

void MySQLParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void MySQLParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}

std::any MySQLParser::SimpleStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleStatementContext *MySQLParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 2, MySQLParser::RuleSimpleStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1532);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1459);
        alterStatement();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1460);
        createStatement();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1461);
        dropStatement();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1462);
        renameTableStatement();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(1463);
        truncateTableStatement();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(1464);
        importStatement();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(1465);
        callStatement();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(1466);
        deleteStatement();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(1467);
        doStatement();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(1468);
        handlerStatement();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(1469);
        insertStatement();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(1470);
        loadStatement();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(1471);
        replaceStatement();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(1472);
        selectStatement();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(1473);
        updateStatement();
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(1474);
        transactionOrLockingStatement();
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(1475);
        replicationStatement();
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(1476);
        preparedStatement();
        break;
      }

      case 19: {
        enterOuterAlt(_localctx, 19);
        setState(1477);
        cloneStatement();
        break;
      }

      case 20: {
        enterOuterAlt(_localctx, 20);
        setState(1478);
        accountManagementStatement();
        break;
      }

      case 21: {
        enterOuterAlt(_localctx, 21);
        setState(1479);
        tableAdministrationStatement();
        break;
      }

      case 22: {
        enterOuterAlt(_localctx, 22);
        setState(1480);
        installUninstallStatement();
        break;
      }

      case 23: {
        enterOuterAlt(_localctx, 23);
        setState(1481);
        setStatement();
        break;
      }

      case 24: {
        enterOuterAlt(_localctx, 24);
        setState(1482);
        showDatabasesStatement();
        break;
      }

      case 25: {
        enterOuterAlt(_localctx, 25);
        setState(1483);
        showTablesStatement();
        break;
      }

      case 26: {
        enterOuterAlt(_localctx, 26);
        setState(1484);
        showTriggersStatement();
        break;
      }

      case 27: {
        enterOuterAlt(_localctx, 27);
        setState(1485);
        showEventsStatement();
        break;
      }

      case 28: {
        enterOuterAlt(_localctx, 28);
        setState(1486);
        showTableStatusStatement();
        break;
      }

      case 29: {
        enterOuterAlt(_localctx, 29);
        setState(1487);
        showOpenTablesStatement();
        break;
      }

      case 30: {
        enterOuterAlt(_localctx, 30);
        setState(1488);
        showPluginsStatement();
        break;
      }

      case 31: {
        enterOuterAlt(_localctx, 31);
        setState(1489);
        showEngineLogsStatement();
        break;
      }

      case 32: {
        enterOuterAlt(_localctx, 32);
        setState(1490);
        showEngineMutexStatement();
        break;
      }

      case 33: {
        enterOuterAlt(_localctx, 33);
        setState(1491);
        showEngineStatusStatement();
        break;
      }

      case 34: {
        enterOuterAlt(_localctx, 34);
        setState(1492);
        showColumnsStatement();
        break;
      }

      case 35: {
        enterOuterAlt(_localctx, 35);
        setState(1493);
        showBinaryLogsStatement();
        break;
      }

      case 36: {
        enterOuterAlt(_localctx, 36);
        setState(1494);
        showReplicasStatement();
        break;
      }

      case 37: {
        enterOuterAlt(_localctx, 37);
        setState(1495);
        showBinlogEventsStatement();
        break;
      }

      case 38: {
        enterOuterAlt(_localctx, 38);
        setState(1496);
        showRelaylogEventsStatement();
        break;
      }

      case 39: {
        enterOuterAlt(_localctx, 39);
        setState(1497);
        showKeysStatement();
        break;
      }

      case 40: {
        enterOuterAlt(_localctx, 40);
        setState(1498);
        showEnginesStatement();
        break;
      }

      case 41: {
        enterOuterAlt(_localctx, 41);
        setState(1499);
        showCountWarningsStatement();
        break;
      }

      case 42: {
        enterOuterAlt(_localctx, 42);
        setState(1500);
        showCountErrorsStatement();
        break;
      }

      case 43: {
        enterOuterAlt(_localctx, 43);
        setState(1501);
        showWarningsStatement();
        break;
      }

      case 44: {
        enterOuterAlt(_localctx, 44);
        setState(1502);
        showErrorsStatement();
        break;
      }

      case 45: {
        enterOuterAlt(_localctx, 45);
        setState(1503);
        showProfilesStatement();
        break;
      }

      case 46: {
        enterOuterAlt(_localctx, 46);
        setState(1504);
        showProfileStatement();
        break;
      }

      case 47: {
        enterOuterAlt(_localctx, 47);
        setState(1505);
        showStatusStatement();
        break;
      }

      case 48: {
        enterOuterAlt(_localctx, 48);
        setState(1506);
        showProcessListStatement();
        break;
      }

      case 49: {
        enterOuterAlt(_localctx, 49);
        setState(1507);
        showVariablesStatement();
        break;
      }

      case 50: {
        enterOuterAlt(_localctx, 50);
        setState(1508);
        showCharacterSetStatement();
        break;
      }

      case 51: {
        enterOuterAlt(_localctx, 51);
        setState(1509);
        showCollationStatement();
        break;
      }

      case 52: {
        enterOuterAlt(_localctx, 52);
        setState(1510);
        showPrivilegesStatement();
        break;
      }

      case 53: {
        enterOuterAlt(_localctx, 53);
        setState(1511);
        showGrantsStatement();
        break;
      }

      case 54: {
        enterOuterAlt(_localctx, 54);
        setState(1512);
        showCreateDatabaseStatement();
        break;
      }

      case 55: {
        enterOuterAlt(_localctx, 55);
        setState(1513);
        showCreateTableStatement();
        break;
      }

      case 56: {
        enterOuterAlt(_localctx, 56);
        setState(1514);
        showCreateViewStatement();
        break;
      }

      case 57: {
        enterOuterAlt(_localctx, 57);
        setState(1515);
        showMasterStatusStatement();
        break;
      }

      case 58: {
        enterOuterAlt(_localctx, 58);
        setState(1516);
        showReplicaStatusStatement();
        break;
      }

      case 59: {
        enterOuterAlt(_localctx, 59);
        setState(1517);
        showCreateProcedureStatement();
        break;
      }

      case 60: {
        enterOuterAlt(_localctx, 60);
        setState(1518);
        showCreateFunctionStatement();
        break;
      }

      case 61: {
        enterOuterAlt(_localctx, 61);
        setState(1519);
        showCreateTriggerStatement();
        break;
      }

      case 62: {
        enterOuterAlt(_localctx, 62);
        setState(1520);
        showCreateProcedureStatusStatement();
        break;
      }

      case 63: {
        enterOuterAlt(_localctx, 63);
        setState(1521);
        showCreateFunctionStatusStatement();
        break;
      }

      case 64: {
        enterOuterAlt(_localctx, 64);
        setState(1522);
        showCreateProcedureCodeStatement();
        break;
      }

      case 65: {
        enterOuterAlt(_localctx, 65);
        setState(1523);
        showCreateFunctionCodeStatement();
        break;
      }

      case 66: {
        enterOuterAlt(_localctx, 66);
        setState(1524);
        showCreateEventStatement();
        break;
      }

      case 67: {
        enterOuterAlt(_localctx, 67);
        setState(1525);
        showCreateUserStatement();
        break;
      }

      case 68: {
        enterOuterAlt(_localctx, 68);
        setState(1526);
        resourceGroupManagement();
        break;
      }

      case 69: {
        enterOuterAlt(_localctx, 69);
        setState(1527);
        otherAdministrativeStatement();
        break;
      }

      case 70: {
        enterOuterAlt(_localctx, 70);
        setState(1528);
        utilityStatement();
        break;
      }

      case 71: {
        enterOuterAlt(_localctx, 71);
        setState(1529);
        getDiagnosticsStatement();
        break;
      }

      case 72: {
        enterOuterAlt(_localctx, 72);
        setState(1530);
        signalStatement();
        break;
      }

      case 73: {
        enterOuterAlt(_localctx, 73);
        setState(1531);
        resignalStatement();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterStatementContext ------------------------------------------------------------------

MySQLParser::AlterStatementContext::AlterStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterStatementContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

MySQLParser::AlterTableContext *MySQLParser::AlterStatementContext::alterTable() {
  return getRuleContext<MySQLParser::AlterTableContext>(0);
}

MySQLParser::AlterDatabaseContext *MySQLParser::AlterStatementContext::alterDatabase() {
  return getRuleContext<MySQLParser::AlterDatabaseContext>(0);
}

tree::TerminalNode *MySQLParser::AlterStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext *MySQLParser::AlterStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext *MySQLParser::AlterStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::AlterViewContext *MySQLParser::AlterStatementContext::alterView() {
  return getRuleContext<MySQLParser::AlterViewContext>(0);
}

MySQLParser::AlterEventContext *MySQLParser::AlterStatementContext::alterEvent() {
  return getRuleContext<MySQLParser::AlterEventContext>(0);
}

MySQLParser::AlterTablespaceContext *MySQLParser::AlterStatementContext::alterTablespace() {
  return getRuleContext<MySQLParser::AlterTablespaceContext>(0);
}

MySQLParser::AlterUndoTablespaceContext *MySQLParser::AlterStatementContext::alterUndoTablespace() {
  return getRuleContext<MySQLParser::AlterUndoTablespaceContext>(0);
}

MySQLParser::AlterLogfileGroupContext *MySQLParser::AlterStatementContext::alterLogfileGroup() {
  return getRuleContext<MySQLParser::AlterLogfileGroupContext>(0);
}

MySQLParser::AlterServerContext *MySQLParser::AlterStatementContext::alterServer() {
  return getRuleContext<MySQLParser::AlterServerContext>(0);
}

MySQLParser::AlterInstanceStatementContext *MySQLParser::AlterStatementContext::alterInstanceStatement() {
  return getRuleContext<MySQLParser::AlterInstanceStatementContext>(0);
}

MySQLParser::RoutineAlterOptionsContext *MySQLParser::AlterStatementContext::routineAlterOptions() {
  return getRuleContext<MySQLParser::RoutineAlterOptionsContext>(0);
}

size_t MySQLParser::AlterStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAlterStatement;
}

void MySQLParser::AlterStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterStatement(this);
}

void MySQLParser::AlterStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterStatement(this);
}

std::any MySQLParser::AlterStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterStatementContext *MySQLParser::alterStatement() {
  AlterStatementContext *_localctx = _tracker.createInstance<AlterStatementContext>(_ctx, getState());
  enterRule(_localctx, 4, MySQLParser::RuleAlterStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1534);
    match(MySQLParser::ALTER_SYMBOL);
    setState(1555);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
      case 1: {
        setState(1535);
        alterTable();
        break;
      }

      case 2: {
        setState(1536);
        alterDatabase();
        break;
      }

      case 3: {
        setState(1537);
        match(MySQLParser::PROCEDURE_SYMBOL);
        setState(1538);
        procedureRef();
        setState(1540);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 75) & ~0x3fULL) == 0) && ((1ULL << (_la - 75)) & 4611686018427420673) != 0) ||
            _la == MySQLParser::LANGUAGE_SYMBOL ||
            ((((_la - 347) & ~0x3fULL) == 0) && ((1ULL << (_la - 347)) & 83886081) != 0) ||
            _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL) {
          setState(1539);
          routineAlterOptions();
        }
        break;
      }

      case 4: {
        setState(1542);
        match(MySQLParser::FUNCTION_SYMBOL);
        setState(1543);
        functionRef();
        setState(1545);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (((((_la - 75) & ~0x3fULL) == 0) && ((1ULL << (_la - 75)) & 4611686018427420673) != 0) ||
            _la == MySQLParser::LANGUAGE_SYMBOL ||
            ((((_la - 347) & ~0x3fULL) == 0) && ((1ULL << (_la - 347)) & 83886081) != 0) ||
            _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL) {
          setState(1544);
          routineAlterOptions();
        }
        break;
      }

      case 5: {
        setState(1547);
        alterView();
        break;
      }

      case 6: {
        setState(1548);
        alterEvent();
        break;
      }

      case 7: {
        setState(1549);
        alterTablespace();
        break;
      }

      case 8: {
        setState(1550);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(1551);
        alterUndoTablespace();
        break;
      }

      case 9: {
        setState(1552);
        alterLogfileGroup();
        break;
      }

      case 10: {
        setState(1553);
        alterServer();
        break;
      }

      case 11: {
        setState(1554);
        alterInstanceStatement();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseContext ------------------------------------------------------------------

MySQLParser::AlterDatabaseContext::AlterDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext *MySQLParser::AlterDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

std::vector<MySQLParser::AlterDatabaseOptionContext *> MySQLParser::AlterDatabaseContext::alterDatabaseOption() {
  return getRuleContexts<MySQLParser::AlterDatabaseOptionContext>();
}

MySQLParser::AlterDatabaseOptionContext *MySQLParser::AlterDatabaseContext::alterDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::AlterDatabaseOptionContext>(i);
}

size_t MySQLParser::AlterDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleAlterDatabase;
}

void MySQLParser::AlterDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabase(this);
}

void MySQLParser::AlterDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabase(this);
}

std::any MySQLParser::AlterDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterDatabaseContext *MySQLParser::alterDatabase() {
  AlterDatabaseContext *_localctx = _tracker.createInstance<AlterDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 6, MySQLParser::RuleAlterDatabase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1557);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(1558);
    schemaRef();
    setState(1560);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(1559);
          alterDatabaseOption();
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(1562);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 7, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseOptionContext ------------------------------------------------------------------

MySQLParser::AlterDatabaseOptionContext::AlterDatabaseOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateDatabaseOptionContext *MySQLParser::AlterDatabaseOptionContext::createDatabaseOption() {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(0);
}

tree::TerminalNode *MySQLParser::AlterDatabaseOptionContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterDatabaseOptionContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

MySQLParser::TernaryOptionContext *MySQLParser::AlterDatabaseOptionContext::ternaryOption() {
  return getRuleContext<MySQLParser::TernaryOptionContext>(0);
}

tree::TerminalNode *MySQLParser::AlterDatabaseOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::AlterDatabaseOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterDatabaseOption;
}

void MySQLParser::AlterDatabaseOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabaseOption(this);
}

void MySQLParser::AlterDatabaseOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabaseOption(this);
}

std::any MySQLParser::AlterDatabaseOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterDatabaseOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterDatabaseOptionContext *MySQLParser::alterDatabaseOption() {
  AlterDatabaseOptionContext *_localctx = _tracker.createInstance<AlterDatabaseOptionContext>(_ctx, getState());
  enterRule(_localctx, 8, MySQLParser::RuleAlterDatabaseOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1571);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1564);
        createDatabaseOption();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1565);
        match(MySQLParser::READ_SYMBOL);
        setState(1566);
        match(MySQLParser::ONLY_SYMBOL);
        setState(1568);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(1567);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(1570);
        ternaryOption();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterEventContext ------------------------------------------------------------------

MySQLParser::AlterEventContext::AlterEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext *MySQLParser::AlterEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::AlterEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::AlterEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext *MySQLParser::AlterEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterEventContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::AlterEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext *MySQLParser::AlterEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode *MySQLParser::AlterEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::AlterEventContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

size_t MySQLParser::AlterEventContext::getRuleIndex() const {
  return MySQLParser::RuleAlterEvent;
}

void MySQLParser::AlterEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterEvent(this);
}

void MySQLParser::AlterEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterEvent(this);
}

std::any MySQLParser::AlterEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterEventContext *MySQLParser::alterEvent() {
  AlterEventContext *_localctx = _tracker.createInstance<AlterEventContext>(_ctx, getState());
  enterRule(_localctx, 10, MySQLParser::RuleAlterEvent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1574);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1573);
      definerClause();
    }
    setState(1576);
    match(MySQLParser::EVENT_SYMBOL);
    setState(1577);
    eventRef();
    setState(1581);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
      case 1: {
        setState(1578);
        match(MySQLParser::ON_SYMBOL);
        setState(1579);
        match(MySQLParser::SCHEDULE_SYMBOL);
        setState(1580);
        schedule();
        break;
      }

      default:
        break;
    }
    setState(1589);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(1583);
      match(MySQLParser::ON_SYMBOL);
      setState(1584);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(1586);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(1585);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(1588);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(1594);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RENAME_SYMBOL) {
      setState(1591);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1592);
      match(MySQLParser::TO_SYMBOL);
      setState(1593);
      identifier();
    }
    setState(1602);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(1596);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(1597);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(1600);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(1598);
          match(MySQLParser::ON_SYMBOL);
          setState(1599);
          replica();
        }
        break;
      }

      case MySQLParser::EOF:
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL:
      case MySQLParser::SEMICOLON_SYMBOL: {
        break;
      }

      default:
        break;
    }
    setState(1606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(1604);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(1605);
      textLiteral();
    }
    setState(1610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DO_SYMBOL) {
      setState(1608);
      match(MySQLParser::DO_SYMBOL);
      setState(1609);
      compoundStatement();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupContext::AlterLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext *MySQLParser::AlterLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::AlterLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::AlterLogfileGroupOptionsContext *MySQLParser::AlterLogfileGroupContext::alterLogfileGroupOptions() {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionsContext>(0);
}

size_t MySQLParser::AlterLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroup;
}

void MySQLParser::AlterLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroup(this);
}

void MySQLParser::AlterLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroup(this);
}

std::any MySQLParser::AlterLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupContext *MySQLParser::alterLogfileGroup() {
  AlterLogfileGroupContext *_localctx = _tracker.createInstance<AlterLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 12, MySQLParser::RuleAlterLogfileGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1612);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(1613);
    match(MySQLParser::GROUP_SYMBOL);
    setState(1614);
    logfileGroupRef();
    setState(1615);
    match(MySQLParser::ADD_SYMBOL);
    setState(1616);
    match(MySQLParser::UNDOFILE_SYMBOL);
    setState(1617);
    textLiteral();
    setState(1619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL ||
        _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(1618);
      alterLogfileGroupOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionsContext::AlterLogfileGroupOptionsContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterLogfileGroupOptionContext *>
MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption() {
  return getRuleContexts<MySQLParser::AlterLogfileGroupOptionContext>();
}

MySQLParser::AlterLogfileGroupOptionContext *MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption(
  size_t i) {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::AlterLogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOptions;
}

void MySQLParser::AlterLogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOptions(this);
}

void MySQLParser::AlterLogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOptions(this);
}

std::any MySQLParser::AlterLogfileGroupOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterLogfileGroupOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupOptionsContext *MySQLParser::alterLogfileGroupOptions() {
  AlterLogfileGroupOptionsContext *_localctx =
    _tracker.createInstance<AlterLogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 14, MySQLParser::RuleAlterLogfileGroupOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1621);
    alterLogfileGroupOption();
    setState(1628);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL ||
           _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL ||
           _la == MySQLParser::WAIT_SYMBOL || _la == MySQLParser::COMMA_SYMBOL) {
      setState(1623);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1622);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1625);
      alterLogfileGroupOption();
      setState(1630);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionContext::AlterLogfileGroupOptionContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext *MySQLParser::AlterLogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionEngineContext *MySQLParser::AlterLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext *MySQLParser::AlterLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

size_t MySQLParser::AlterLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOption;
}

void MySQLParser::AlterLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOption(this);
}

void MySQLParser::AlterLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOption(this);
}

std::any MySQLParser::AlterLogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLogfileGroupOptionContext *MySQLParser::alterLogfileGroupOption() {
  AlterLogfileGroupOptionContext *_localctx = _tracker.createInstance<AlterLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 16, MySQLParser::RuleAlterLogfileGroupOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1634);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1631);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1632);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1633);
        tsOptionWait();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterServerContext ------------------------------------------------------------------

MySQLParser::AlterServerContext::AlterServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext *MySQLParser::AlterServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::ServerOptionsContext *MySQLParser::AlterServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}

size_t MySQLParser::AlterServerContext::getRuleIndex() const {
  return MySQLParser::RuleAlterServer;
}

void MySQLParser::AlterServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterServer(this);
}

void MySQLParser::AlterServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterServer(this);
}

std::any MySQLParser::AlterServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterServerContext *MySQLParser::alterServer() {
  AlterServerContext *_localctx = _tracker.createInstance<AlterServerContext>(_ctx, getState());
  enterRule(_localctx, 18, MySQLParser::RuleAlterServer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1636);
    match(MySQLParser::SERVER_SYMBOL);
    setState(1637);
    serverRef();
    setState(1638);
    serverOptions();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableContext ------------------------------------------------------------------

MySQLParser::AlterTableContext::AlterTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::AlterTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::OnlineOptionContext *MySQLParser::AlterTableContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

MySQLParser::AlterTableActionsContext *MySQLParser::AlterTableContext::alterTableActions() {
  return getRuleContext<MySQLParser::AlterTableActionsContext>(0);
}

size_t MySQLParser::AlterTableContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTable;
}

void MySQLParser::AlterTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTable(this);
}

void MySQLParser::AlterTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTable(this);
}

std::any MySQLParser::AlterTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTableContext *MySQLParser::alterTable() {
  AlterTableContext *_localctx = _tracker.createInstance<AlterTableContext>(_ctx, getState());
  enterRule(_localctx, 20, MySQLParser::RuleAlterTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1641);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OFFLINE_SYMBOL

        || _la == MySQLParser::ONLINE_SYMBOL) {
      setState(1640);
      onlineOption();
    }
    setState(1643);
    match(MySQLParser::TABLE_SYMBOL);
    setState(1644);
    tableRef();
    setState(1646);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 24, _ctx)) {
      case 1: {
        setState(1645);
        alterTableActions();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableActionsContext ------------------------------------------------------------------

MySQLParser::AlterTableActionsContext::AlterTableActionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandListContext *MySQLParser::AlterTableActionsContext::alterCommandList() {
  return getRuleContext<MySQLParser::AlterCommandListContext>(0);
}

MySQLParser::PartitionClauseContext *MySQLParser::AlterTableActionsContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::RemovePartitioningContext *MySQLParser::AlterTableActionsContext::removePartitioning() {
  return getRuleContext<MySQLParser::RemovePartitioningContext>(0);
}

MySQLParser::StandaloneAlterCommandsContext *MySQLParser::AlterTableActionsContext::standaloneAlterCommands() {
  return getRuleContext<MySQLParser::StandaloneAlterCommandsContext>(0);
}

MySQLParser::AlterCommandsModifierListContext *MySQLParser::AlterTableActionsContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterTableActionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

size_t MySQLParser::AlterTableActionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTableActions;
}

void MySQLParser::AlterTableActionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableActions(this);
}

void MySQLParser::AlterTableActionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableActions(this);
}

std::any MySQLParser::AlterTableActionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterTableActions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTableActionsContext *MySQLParser::alterTableActions() {
  AlterTableActionsContext *_localctx = _tracker.createInstance<AlterTableActionsContext>(_ctx, getState());
  enterRule(_localctx, 22, MySQLParser::RuleAlterTableActions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1661);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1648);
        alterCommandList();
        setState(1651);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::PARTITION_SYMBOL: {
            setState(1649);
            partitionClause();
            break;
          }

          case MySQLParser::REMOVE_SYMBOL: {
            setState(1650);
            removePartitioning();
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::SEMICOLON_SYMBOL: {
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1653);
        partitionClause();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1654);
        removePartitioning();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1658);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
          case 1: {
            setState(1655);
            alterCommandsModifierList();
            setState(1656);
            match(MySQLParser::COMMA_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1660);
        standaloneAlterCommands();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandListContext ------------------------------------------------------------------

MySQLParser::AlterCommandListContext::AlterCommandListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandsModifierListContext *MySQLParser::AlterCommandListContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

MySQLParser::AlterListContext *MySQLParser::AlterCommandListContext::alterList() {
  return getRuleContext<MySQLParser::AlterListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterCommandListContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

size_t MySQLParser::AlterCommandListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandList;
}

void MySQLParser::AlterCommandListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandList(this);
}

void MySQLParser::AlterCommandListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandList(this);
}

std::any MySQLParser::AlterCommandListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterCommandList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandListContext *MySQLParser::alterCommandList() {
  AlterCommandListContext *_localctx = _tracker.createInstance<AlterCommandListContext>(_ctx, getState());
  enterRule(_localctx, 24, MySQLParser::RuleAlterCommandList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1670);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1663);
        alterCommandsModifierList();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1667);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 28, _ctx)) {
          case 1: {
            setState(1664);
            alterCommandsModifierList();
            setState(1665);
            match(MySQLParser::COMMA_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1669);
        alterList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierListContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierListContext::AlterCommandsModifierListContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterCommandsModifierContext *>
MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext *MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier(
  size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::AlterCommandsModifierListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifierList;
}

void MySQLParser::AlterCommandsModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifierList(this);
}

void MySQLParser::AlterCommandsModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifierList(this);
}

std::any MySQLParser::AlterCommandsModifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterCommandsModifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandsModifierListContext *MySQLParser::alterCommandsModifierList() {
  AlterCommandsModifierListContext *_localctx =
    _tracker.createInstance<AlterCommandsModifierListContext>(_ctx, getState());
  enterRule(_localctx, 26, MySQLParser::RuleAlterCommandsModifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1672);
    alterCommandsModifier();
    setState(1677);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1673);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1674);
        alterCommandsModifier();
      }
      setState(1679);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandaloneAlterCommandsContext ------------------------------------------------------------------

MySQLParser::StandaloneAlterCommandsContext::StandaloneAlterCommandsContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StandaloneAlterCommandsContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StandaloneAlterCommandsContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StandaloneAlterCommandsContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

MySQLParser::AlterPartitionContext *MySQLParser::StandaloneAlterCommandsContext::alterPartition() {
  return getRuleContext<MySQLParser::AlterPartitionContext>(0);
}

tree::TerminalNode *MySQLParser::StandaloneAlterCommandsContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StandaloneAlterCommandsContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

size_t MySQLParser::StandaloneAlterCommandsContext::getRuleIndex() const {
  return MySQLParser::RuleStandaloneAlterCommands;
}

void MySQLParser::StandaloneAlterCommandsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandaloneAlterCommands(this);
}

void MySQLParser::StandaloneAlterCommandsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandaloneAlterCommands(this);
}

std::any MySQLParser::StandaloneAlterCommandsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStandaloneAlterCommands(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StandaloneAlterCommandsContext *MySQLParser::standaloneAlterCommands() {
  StandaloneAlterCommandsContext *_localctx = _tracker.createInstance<StandaloneAlterCommandsContext>(_ctx, getState());
  enterRule(_localctx, 28, MySQLParser::RuleStandaloneAlterCommands);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1687);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1680);
        match(MySQLParser::DISCARD_SYMBOL);
        setState(1681);
        match(MySQLParser::TABLESPACE_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1682);
        match(MySQLParser::IMPORT_SYMBOL);
        setState(1683);
        match(MySQLParser::TABLESPACE_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1684);
        alterPartition();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1685);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(1686);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::SECONDARY_LOAD_SYMBOL

              || _la == MySQLParser::SECONDARY_UNLOAD_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterPartitionContext ------------------------------------------------------------------

MySQLParser::AlterPartitionContext::AlterPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::PartitionDefinitionsContext *MySQLParser::AlterPartitionContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::AlterPartitionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

std::vector<MySQLParser::NoWriteToBinLogContext *> MySQLParser::AlterPartitionContext::noWriteToBinLog() {
  return getRuleContexts<MySQLParser::NoWriteToBinLogContext>();
}

MySQLParser::NoWriteToBinLogContext *MySQLParser::AlterPartitionContext::noWriteToBinLog(size_t i) {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(i);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::AlterPartitionContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext *MySQLParser::AlterPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::AlterPartitionContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext *MySQLParser::AlterPartitionContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::AlterPartitionContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext *MySQLParser::AlterPartitionContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterPartitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::AlterPartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WithValidationContext *MySQLParser::AlterPartitionContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterPartitionContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

size_t MySQLParser::AlterPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterPartition;
}

void MySQLParser::AlterPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterPartition(this);
}

void MySQLParser::AlterPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterPartition(this);
}

std::any MySQLParser::AlterPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterPartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterPartitionContext *MySQLParser::alterPartition() {
  AlterPartitionContext *_localctx = _tracker.createInstance<AlterPartitionContext>(_ctx, getState());
  enterRule(_localctx, 30, MySQLParser::RuleAlterPartition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1783);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ADD_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1689);
        match(MySQLParser::ADD_SYMBOL);
        setState(1690);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1692);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(1691);
          noWriteToBinLog();
        }
        setState(1697);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(1694);
            partitionDefinitions();
            break;
          }

          case MySQLParser::PARTITIONS_SYMBOL: {
            setState(1695);
            match(MySQLParser::PARTITIONS_SYMBOL);
            setState(1696);
            real_ulong_number();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1699);
        match(MySQLParser::DROP_SYMBOL);
        setState(1700);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1701);
        identifierList();
        break;
      }

      case MySQLParser::REBUILD_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1702);
        match(MySQLParser::REBUILD_SYMBOL);
        setState(1703);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1705);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
          case 1: {
            setState(1704);
            noWriteToBinLog();
            break;
          }

          default:
            break;
        }
        setState(1707);
        allOrPartitionNameList();
        break;
      }

      case MySQLParser::OPTIMIZE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(1708);
        match(MySQLParser::OPTIMIZE_SYMBOL);
        setState(1709);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1711);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 35, _ctx)) {
          case 1: {
            setState(1710);
            noWriteToBinLog();
            break;
          }

          default:
            break;
        }
        setState(1713);
        allOrPartitionNameList();
        setState(1715);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(1714);
          noWriteToBinLog();
        }
        break;
      }

      case MySQLParser::ANALYZE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(1717);
        match(MySQLParser::ANALYZE_SYMBOL);
        setState(1718);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1720);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
          case 1: {
            setState(1719);
            noWriteToBinLog();
            break;
          }

          default:
            break;
        }
        setState(1722);
        allOrPartitionNameList();
        break;
      }

      case MySQLParser::CHECK_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(1723);
        match(MySQLParser::CHECK_SYMBOL);
        setState(1724);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1725);
        allOrPartitionNameList();
        setState(1729);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::CHANGED_SYMBOL ||
               ((((_la - 180) & ~0x3fULL) == 0) && ((1ULL << (_la - 180)) & 1048593) != 0) ||
               _la == MySQLParser::MEDIUM_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(1726);
          checkOption();
          setState(1731);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::REPAIR_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(1732);
        match(MySQLParser::REPAIR_SYMBOL);
        setState(1733);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1735);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 39, _ctx)) {
          case 1: {
            setState(1734);
            noWriteToBinLog();
            break;
          }

          default:
            break;
        }
        setState(1737);
        allOrPartitionNameList();
        setState(1741);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL ||
               _la == MySQLParser::USE_FRM_SYMBOL) {
          setState(1738);
          repairType();
          setState(1743);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::COALESCE_SYMBOL: {
        enterOuterAlt(_localctx, 8);
        setState(1744);
        match(MySQLParser::COALESCE_SYMBOL);
        setState(1745);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1747);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(1746);
          noWriteToBinLog();
        }
        setState(1749);
        real_ulong_number();
        break;
      }

      case MySQLParser::TRUNCATE_SYMBOL: {
        enterOuterAlt(_localctx, 9);
        setState(1750);
        match(MySQLParser::TRUNCATE_SYMBOL);
        setState(1751);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1752);
        allOrPartitionNameList();
        break;
      }

      case MySQLParser::REORGANIZE_SYMBOL: {
        enterOuterAlt(_localctx, 10);
        setState(1753);
        match(MySQLParser::REORGANIZE_SYMBOL);
        setState(1754);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1756);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
          case 1: {
            setState(1755);
            noWriteToBinLog();
            break;
          }

          default:
            break;
        }
        setState(1762);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 43, _ctx)) {
          case 1: {
            setState(1758);
            identifierList();
            setState(1759);
            match(MySQLParser::INTO_SYMBOL);
            setState(1760);
            partitionDefinitions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::EXCHANGE_SYMBOL: {
        enterOuterAlt(_localctx, 11);
        setState(1764);
        match(MySQLParser::EXCHANGE_SYMBOL);
        setState(1765);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1766);
        identifier();
        setState(1767);
        match(MySQLParser::WITH_SYMBOL);
        setState(1768);
        match(MySQLParser::TABLE_SYMBOL);
        setState(1769);
        tableRef();
        setState(1771);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL

            || _la == MySQLParser::WITHOUT_SYMBOL) {
          setState(1770);
          withValidation();
        }
        break;
      }

      case MySQLParser::DISCARD_SYMBOL: {
        enterOuterAlt(_localctx, 12);
        setState(1773);
        match(MySQLParser::DISCARD_SYMBOL);
        setState(1774);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1775);
        allOrPartitionNameList();
        setState(1776);
        match(MySQLParser::TABLESPACE_SYMBOL);
        break;
      }

      case MySQLParser::IMPORT_SYMBOL: {
        enterOuterAlt(_localctx, 13);
        setState(1778);
        match(MySQLParser::IMPORT_SYMBOL);
        setState(1779);
        match(MySQLParser::PARTITION_SYMBOL);
        setState(1780);
        allOrPartitionNameList();
        setState(1781);
        match(MySQLParser::TABLESPACE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListContext ------------------------------------------------------------------

MySQLParser::AlterListContext::AlterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterListItemContext *> MySQLParser::AlterListContext::alterListItem() {
  return getRuleContexts<MySQLParser::AlterListItemContext>();
}

MySQLParser::AlterListItemContext *MySQLParser::AlterListContext::alterListItem(size_t i) {
  return getRuleContext<MySQLParser::AlterListItemContext>(i);
}

std::vector<MySQLParser::CreateTableOptionsSpaceSeparatedContext *>
MySQLParser::AlterListContext::createTableOptionsSpaceSeparated() {
  return getRuleContexts<MySQLParser::CreateTableOptionsSpaceSeparatedContext>();
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext *MySQLParser::AlterListContext::createTableOptionsSpaceSeparated(
  size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionsSpaceSeparatedContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

std::vector<MySQLParser::AlterCommandsModifierContext *> MySQLParser::AlterListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext *MySQLParser::AlterListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}

size_t MySQLParser::AlterListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterList;
}

void MySQLParser::AlterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterList(this);
}

void MySQLParser::AlterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterList(this);
}

std::any MySQLParser::AlterListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterListContext *MySQLParser::alterList() {
  AlterListContext *_localctx = _tracker.createInstance<AlterListContext>(_ctx, getState());
  enterRule(_localctx, 32, MySQLParser::RuleAlterList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1787);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(1785);
        alterListItem();
        break;
      }

      case 2: {
        setState(1786);
        createTableOptionsSpaceSeparated();
        break;
      }

      default:
        break;
    }
    setState(1797);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(1789);
      match(MySQLParser::COMMA_SYMBOL);
      setState(1793);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
        case 1: {
          setState(1790);
          alterListItem();
          break;
        }

        case 2: {
          setState(1791);
          alterCommandsModifier();
          break;
        }

        case 3: {
          setState(1792);
          createTableOptionsSpaceSeparated();
          break;
        }

        default:
          break;
      }
      setState(1799);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierContext::AlterCommandsModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext *MySQLParser::AlterCommandsModifierContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext *MySQLParser::AlterCommandsModifierContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}

MySQLParser::WithValidationContext *MySQLParser::AlterCommandsModifierContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}

size_t MySQLParser::AlterCommandsModifierContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifier;
}

void MySQLParser::AlterCommandsModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifier(this);
}

void MySQLParser::AlterCommandsModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifier(this);
}

std::any MySQLParser::AlterCommandsModifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterCommandsModifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterCommandsModifierContext *MySQLParser::alterCommandsModifier() {
  AlterCommandsModifierContext *_localctx = _tracker.createInstance<AlterCommandsModifierContext>(_ctx, getState());
  enterRule(_localctx, 34, MySQLParser::RuleAlterCommandsModifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1803);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALGORITHM_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1800);
        alterAlgorithmOption();
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1801);
        alterLockOption();
        break;
      }

      case MySQLParser::WITH_SYMBOL:
      case MySQLParser::WITHOUT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1802);
        withValidation();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListItemContext ------------------------------------------------------------------

MySQLParser::AlterListItemContext::AlterListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterListItemContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterListItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldDefinitionContext *MySQLParser::AlterListItemContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableElementListContext *MySQLParser::AlterListItemContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::COLUMN_SYMBOL() {
  return getToken(MySQLParser::COLUMN_SYMBOL, 0);
}

MySQLParser::CheckOrReferencesContext *MySQLParser::AlterListItemContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}

MySQLParser::PlaceContext *MySQLParser::AlterListItemContext::place() {
  return getRuleContext<MySQLParser::PlaceContext>(0);
}

MySQLParser::TableConstraintDefContext *MySQLParser::AlterListItemContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

MySQLParser::ColumnInternalRefContext *MySQLParser::AlterListItemContext::columnInternalRef() {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext *MySQLParser::AlterListItemContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexRefContext *MySQLParser::AlterListItemContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::CONSTRAINT_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SYMBOL, 0);
}

MySQLParser::RestrictContext *MySQLParser::AlterListItemContext::restrict() {
  return getRuleContext<MySQLParser::RestrictContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::VisibilityContext *MySQLParser::AlterListItemContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::AlterListItemContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::SignedLiteralOrNullContext *MySQLParser::AlterListItemContext::signedLiteralOrNull() {
  return getRuleContext<MySQLParser::SignedLiteralOrNullContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::ConstraintEnforcementContext *MySQLParser::AlterListItemContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TableNameContext *MySQLParser::AlterListItemContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::IndexNameContext *MySQLParser::AlterListItemContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

MySQLParser::CharsetContext *MySQLParser::AlterListItemContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext *MySQLParser::AlterListItemContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

MySQLParser::CollateContext *MySQLParser::AlterListItemContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterListItemContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::AlterOrderListContext *MySQLParser::AlterListItemContext::alterOrderList() {
  return getRuleContext<MySQLParser::AlterOrderListContext>(0);
}

size_t MySQLParser::AlterListItemContext::getRuleIndex() const {
  return MySQLParser::RuleAlterListItem;
}

void MySQLParser::AlterListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterListItem(this);
}

void MySQLParser::AlterListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterListItem(this);
}

std::any MySQLParser::AlterListItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterListItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterListItemContext *MySQLParser::alterListItem() {
  AlterListItemContext *_localctx = _tracker.createInstance<AlterListItemContext>(_ctx, getState());
  enterRule(_localctx, 36, MySQLParser::RuleAlterListItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1940);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1805);
        match(MySQLParser::ADD_SYMBOL);
        setState(1807);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
          case 1: {
            setState(1806);
            match(MySQLParser::COLUMN_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1821);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
          case 1: {
            setState(1809);
            identifier();
            setState(1810);
            fieldDefinition();
            setState(1812);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 51, _ctx)) {
              case 1: {
                setState(1811);
                checkOrReferences();
                break;
              }

              default:
                break;
            }
            setState(1815);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
              setState(1814);
              place();
            }
            break;
          }

          case 2: {
            setState(1817);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(1818);
            tableElementList();
            setState(1819);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1823);
        match(MySQLParser::ADD_SYMBOL);
        setState(1824);
        tableConstraintDef();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(1825);
        match(MySQLParser::CHANGE_SYMBOL);
        setState(1827);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
          case 1: {
            setState(1826);
            match(MySQLParser::COLUMN_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1829);
        columnInternalRef();
        setState(1830);
        identifier();
        setState(1831);
        fieldDefinition();
        setState(1833);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
          setState(1832);
          place();
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(1835);
        match(MySQLParser::MODIFY_SYMBOL);
        setState(1837);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
          case 1: {
            setState(1836);
            match(MySQLParser::COLUMN_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1839);
        columnInternalRef();
        setState(1840);
        fieldDefinition();
        setState(1842);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
          setState(1841);
          place();
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(1844);
        match(MySQLParser::DROP_SYMBOL);
        setState(1866);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 60, _ctx)) {
          case 1: {
            setState(1846);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 58, _ctx)) {
              case 1: {
                setState(1845);
                match(MySQLParser::COLUMN_SYMBOL);
                break;
              }

              default:
                break;
            }
            setState(1848);
            columnInternalRef();
            setState(1850);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
              setState(1849);
              restrict();
            }
            break;
          }

          case 2: {
            setState(1852);
            match(MySQLParser::FOREIGN_SYMBOL);
            setState(1853);
            match(MySQLParser::KEY_SYMBOL);
            setState(1854);
            columnInternalRef();
            break;
          }

          case 3: {
            setState(1855);
            match(MySQLParser::PRIMARY_SYMBOL);
            setState(1856);
            match(MySQLParser::KEY_SYMBOL);
            break;
          }

          case 4: {
            setState(1857);
            keyOrIndex();
            setState(1858);
            indexRef();
            break;
          }

          case 5: {
            setState(1860);

            if (!(serverVersion >= 80017))
              throw FailedPredicateException(this, "serverVersion >= 80017");
            setState(1861);
            match(MySQLParser::CHECK_SYMBOL);
            setState(1862);
            identifier();
            break;
          }

          case 6: {
            setState(1863);

            if (!(serverVersion >= 80019))
              throw FailedPredicateException(this, "serverVersion >= 80019");
            setState(1864);
            match(MySQLParser::CONSTRAINT_SYMBOL);
            setState(1865);
            identifier();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(1868);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(1869);
        match(MySQLParser::KEYS_SYMBOL);
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(1870);
        match(MySQLParser::ENABLE_SYMBOL);
        setState(1871);
        match(MySQLParser::KEYS_SYMBOL);
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(1872);
        match(MySQLParser::ALTER_SYMBOL);
        setState(1874);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
          case 1: {
            setState(1873);
            match(MySQLParser::COLUMN_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(1876);
        columnInternalRef();
        setState(1889);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
          case 1: {
            setState(1877);
            match(MySQLParser::SET_SYMBOL);
            setState(1878);
            match(MySQLParser::DEFAULT_SYMBOL);
            setState(1882);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
              case 1: {
                setState(1879);

                if (!(serverVersion >= 80014))
                  throw FailedPredicateException(this, "serverVersion >= 80014");
                setState(1880);
                exprWithParentheses();
                break;
              }

              case 2: {
                setState(1881);
                signedLiteralOrNull();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 2: {
            setState(1884);
            match(MySQLParser::DROP_SYMBOL);
            setState(1885);
            match(MySQLParser::DEFAULT_SYMBOL);
            break;
          }

          case 3: {
            setState(1886);

            if (!(serverVersion >= 80024))
              throw FailedPredicateException(this, "serverVersion >= 80024");
            setState(1887);
            match(MySQLParser::SET_SYMBOL);
            setState(1888);
            visibility();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(1891);
        match(MySQLParser::ALTER_SYMBOL);
        setState(1892);
        match(MySQLParser::INDEX_SYMBOL);
        setState(1893);
        indexRef();
        setState(1894);
        visibility();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(1896);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(1897);
        match(MySQLParser::ALTER_SYMBOL);
        setState(1898);
        match(MySQLParser::CHECK_SYMBOL);
        setState(1899);
        identifier();
        setState(1900);
        constraintEnforcement();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(1902);

        if (!(serverVersion >= 80019))
          throw FailedPredicateException(this, "serverVersion >= 80019");
        setState(1903);
        match(MySQLParser::ALTER_SYMBOL);
        setState(1904);
        match(MySQLParser::CONSTRAINT_SYMBOL);
        setState(1905);
        identifier();
        setState(1906);
        constraintEnforcement();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(1908);
        match(MySQLParser::RENAME_SYMBOL);
        setState(1909);
        match(MySQLParser::COLUMN_SYMBOL);
        setState(1910);
        columnInternalRef();
        setState(1911);
        match(MySQLParser::TO_SYMBOL);
        setState(1912);
        identifier();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(1914);
        match(MySQLParser::RENAME_SYMBOL);
        setState(1916);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
          case 1: {
            setState(1915);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::AS_SYMBOL || _la == MySQLParser::TO_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          default:
            break;
        }
        setState(1918);
        tableName();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(1919);
        match(MySQLParser::RENAME_SYMBOL);
        setState(1920);
        keyOrIndex();
        setState(1921);
        indexRef();
        setState(1922);
        match(MySQLParser::TO_SYMBOL);
        setState(1923);
        indexName();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(1925);
        match(MySQLParser::CONVERT_SYMBOL);
        setState(1926);
        match(MySQLParser::TO_SYMBOL);
        setState(1927);
        charset();
        setState(1931);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
          case 1: {
            setState(1928);

            if (!(serverVersion >= 80014))
              throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(1929);
            match(MySQLParser::DEFAULT_SYMBOL);
            break;
          }

          case 2: {
            setState(1930);
            charsetName();
            break;
          }

          default:
            break;
        }
        setState(1934);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COLLATE_SYMBOL) {
          setState(1933);
          collate();
        }
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(1936);
        match(MySQLParser::FORCE_SYMBOL);
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(1937);
        match(MySQLParser::ORDER_SYMBOL);
        setState(1938);
        match(MySQLParser::BY_SYMBOL);
        setState(1939);
        alterOrderList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlaceContext ------------------------------------------------------------------

MySQLParser::PlaceContext::PlaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PlaceContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::PlaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::PlaceContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

size_t MySQLParser::PlaceContext::getRuleIndex() const {
  return MySQLParser::RulePlace;
}

void MySQLParser::PlaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlace(this);
}

void MySQLParser::PlaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlace(this);
}

std::any MySQLParser::PlaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPlace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PlaceContext *MySQLParser::place() {
  PlaceContext *_localctx = _tracker.createInstance<PlaceContext>(_ctx, getState());
  enterRule(_localctx, 38, MySQLParser::RulePlace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1945);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AFTER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1942);
        match(MySQLParser::AFTER_SYMBOL);
        setState(1943);
        identifier();
        break;
      }

      case MySQLParser::FIRST_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1944);
        match(MySQLParser::FIRST_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestrictContext ------------------------------------------------------------------

MySQLParser::RestrictContext::RestrictContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RestrictContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RestrictContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

size_t MySQLParser::RestrictContext::getRuleIndex() const {
  return MySQLParser::RuleRestrict;
}

void MySQLParser::RestrictContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestrict(this);
}

void MySQLParser::RestrictContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestrict(this);
}

std::any MySQLParser::RestrictContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRestrict(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RestrictContext *MySQLParser::restrict() {
  RestrictContext *_localctx = _tracker.createInstance<RestrictContext>(_ctx, getState());
  enterRule(_localctx, 40, MySQLParser::RuleRestrict);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1947);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterOrderListContext ------------------------------------------------------------------

MySQLParser::AlterOrderListContext::AlterOrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::AlterOrderListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext *MySQLParser::AlterOrderListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<MySQLParser::DirectionContext *> MySQLParser::AlterOrderListContext::direction() {
  return getRuleContexts<MySQLParser::DirectionContext>();
}

MySQLParser::DirectionContext *MySQLParser::AlterOrderListContext::direction(size_t i) {
  return getRuleContext<MySQLParser::DirectionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterOrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterOrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::AlterOrderListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterOrderList;
}

void MySQLParser::AlterOrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterOrderList(this);
}

void MySQLParser::AlterOrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterOrderList(this);
}

std::any MySQLParser::AlterOrderListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterOrderList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterOrderListContext *MySQLParser::alterOrderList() {
  AlterOrderListContext *_localctx = _tracker.createInstance<AlterOrderListContext>(_ctx, getState());
  enterRule(_localctx, 42, MySQLParser::RuleAlterOrderList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1949);
    identifier();
    setState(1951);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
      setState(1950);
      direction();
    }
    setState(1960);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1953);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1954);
        identifier();
        setState(1956);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
          setState(1955);
          direction();
        }
      }
      setState(1962);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 71, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterAlgorithmOptionContext ------------------------------------------------------------------

MySQLParser::AlterAlgorithmOptionContext::AlterAlgorithmOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterAlgorithmOptionContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterAlgorithmOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterAlgorithmOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::AlterAlgorithmOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::AlterAlgorithmOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterAlgorithmOption;
}

void MySQLParser::AlterAlgorithmOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterAlgorithmOption(this);
}

void MySQLParser::AlterAlgorithmOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterAlgorithmOption(this);
}

std::any MySQLParser::AlterAlgorithmOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterAlgorithmOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterAlgorithmOptionContext *MySQLParser::alterAlgorithmOption() {
  AlterAlgorithmOptionContext *_localctx = _tracker.createInstance<AlterAlgorithmOptionContext>(_ctx, getState());
  enterRule(_localctx, 44, MySQLParser::RuleAlterAlgorithmOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1963);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(1965);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
      case 1: {
        setState(1964);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(1969);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 73, _ctx)) {
      case 1: {
        setState(1967);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 2: {
        setState(1968);
        identifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLockOptionContext ------------------------------------------------------------------

MySQLParser::AlterLockOptionContext::AlterLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterLockOptionContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterLockOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterLockOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::AlterLockOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::AlterLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLockOption;
}

void MySQLParser::AlterLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLockOption(this);
}

void MySQLParser::AlterLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLockOption(this);
}

std::any MySQLParser::AlterLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterLockOptionContext *MySQLParser::alterLockOption() {
  AlterLockOptionContext *_localctx = _tracker.createInstance<AlterLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 46, MySQLParser::RuleAlterLockOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1971);
    match(MySQLParser::LOCK_SYMBOL);
    setState(1973);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 74, _ctx)) {
      case 1: {
        setState(1972);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(1977);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 75, _ctx)) {
      case 1: {
        setState(1975);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 2: {
        setState(1976);
        identifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexLockAndAlgorithmContext ------------------------------------------------------------------

MySQLParser::IndexLockAndAlgorithmContext::IndexLockAndAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext *MySQLParser::IndexLockAndAlgorithmContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext *MySQLParser::IndexLockAndAlgorithmContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}

size_t MySQLParser::IndexLockAndAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleIndexLockAndAlgorithm;
}

void MySQLParser::IndexLockAndAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexLockAndAlgorithm(this);
}

void MySQLParser::IndexLockAndAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexLockAndAlgorithm(this);
}

std::any MySQLParser::IndexLockAndAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexLockAndAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexLockAndAlgorithmContext *MySQLParser::indexLockAndAlgorithm() {
  IndexLockAndAlgorithmContext *_localctx = _tracker.createInstance<IndexLockAndAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 48, MySQLParser::RuleIndexLockAndAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1987);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALGORITHM_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1979);
        alterAlgorithmOption();
        setState(1981);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCK_SYMBOL) {
          setState(1980);
          alterLockOption();
        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1983);
        alterLockOption();
        setState(1985);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(1984);
          alterAlgorithmOption();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithValidationContext ------------------------------------------------------------------

MySQLParser::WithValidationContext::WithValidationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WithValidationContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WithValidationContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WithValidationContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}

size_t MySQLParser::WithValidationContext::getRuleIndex() const {
  return MySQLParser::RuleWithValidation;
}

void MySQLParser::WithValidationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithValidation(this);
}

void MySQLParser::WithValidationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithValidation(this);
}

std::any MySQLParser::WithValidationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWithValidation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WithValidationContext *MySQLParser::withValidation() {
  WithValidationContext *_localctx = _tracker.createInstance<WithValidationContext>(_ctx, getState());
  enterRule(_localctx, 50, MySQLParser::RuleWithValidation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1989);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::WITH_SYMBOL

          || _la == MySQLParser::WITHOUT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1990);
    match(MySQLParser::VALIDATION_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemovePartitioningContext ------------------------------------------------------------------

MySQLParser::RemovePartitioningContext::RemovePartitioningContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RemovePartitioningContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RemovePartitioningContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

size_t MySQLParser::RemovePartitioningContext::getRuleIndex() const {
  return MySQLParser::RuleRemovePartitioning;
}

void MySQLParser::RemovePartitioningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemovePartitioning(this);
}

void MySQLParser::RemovePartitioningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemovePartitioning(this);
}

std::any MySQLParser::RemovePartitioningContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRemovePartitioning(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RemovePartitioningContext *MySQLParser::removePartitioning() {
  RemovePartitioningContext *_localctx = _tracker.createInstance<RemovePartitioningContext>(_ctx, getState());
  enterRule(_localctx, 52, MySQLParser::RuleRemovePartitioning);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1992);
    match(MySQLParser::REMOVE_SYMBOL);
    setState(1993);
    match(MySQLParser::PARTITIONING_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllOrPartitionNameListContext ------------------------------------------------------------------

MySQLParser::AllOrPartitionNameListContext::AllOrPartitionNameListContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AllOrPartitionNameListContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::AllOrPartitionNameListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

size_t MySQLParser::AllOrPartitionNameListContext::getRuleIndex() const {
  return MySQLParser::RuleAllOrPartitionNameList;
}

void MySQLParser::AllOrPartitionNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllOrPartitionNameList(this);
}

void MySQLParser::AllOrPartitionNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllOrPartitionNameList(this);
}

std::any MySQLParser::AllOrPartitionNameListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAllOrPartitionNameList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AllOrPartitionNameListContext *MySQLParser::allOrPartitionNameList() {
  AllOrPartitionNameListContext *_localctx = _tracker.createInstance<AllOrPartitionNameListContext>(_ctx, getState());
  enterRule(_localctx, 54, MySQLParser::RuleAllOrPartitionNameList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1997);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(1995);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(1996);
        identifierList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceContext::AlterTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext *MySQLParser::AlterTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::AlterTablespaceContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::AlterTablespaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::AlterTablespaceOptionsContext *MySQLParser::AlterTablespaceContext::alterTablespaceOptions() {
  return getRuleContext<MySQLParser::AlterTablespaceOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

size_t MySQLParser::AlterTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespace;
}

void MySQLParser::AlterTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespace(this);
}

void MySQLParser::AlterTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespace(this);
}

std::any MySQLParser::AlterTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceContext *MySQLParser::alterTablespace() {
  AlterTablespaceContext *_localctx = _tracker.createInstance<AlterTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 56, MySQLParser::RuleAlterTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1999);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2000);
    tablespaceRef();
    setState(2012);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
      case 1: {
        setState(2001);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ADD_SYMBOL || _la == MySQLParser::DROP_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(2002);
        match(MySQLParser::DATAFILE_SYMBOL);
        setState(2003);
        textLiteral();
        setState(2005);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
          case 1: {
            setState(2004);
            alterTablespaceOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(2007);
        match(MySQLParser::RENAME_SYMBOL);
        setState(2008);
        match(MySQLParser::TO_SYMBOL);
        setState(2009);
        identifier();
        break;
      }

      case 3: {
        setState(2010);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(2011);
        alterTablespaceOptions();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterUndoTablespaceContext::AlterUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext *MySQLParser::AlterUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode *MySQLParser::AlterUndoTablespaceContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUndoTablespaceContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUndoTablespaceContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

MySQLParser::UndoTableSpaceOptionsContext *MySQLParser::AlterUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}

size_t MySQLParser::AlterUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUndoTablespace;
}

void MySQLParser::AlterUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUndoTablespace(this);
}

void MySQLParser::AlterUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUndoTablespace(this);
}

std::any MySQLParser::AlterUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUndoTablespaceContext *MySQLParser::alterUndoTablespace() {
  AlterUndoTablespaceContext *_localctx = _tracker.createInstance<AlterUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 58, MySQLParser::RuleAlterUndoTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2014);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2015);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2016);
    tablespaceRef();
    setState(2017);
    match(MySQLParser::SET_SYMBOL);
    setState(2018);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ACTIVE_SYMBOL

          || _la == MySQLParser::INACTIVE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2020);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2019);
      undoTableSpaceOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionsContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionsContext::UndoTableSpaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UndoTableSpaceOptionContext *>
MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption() {
  return getRuleContexts<MySQLParser::UndoTableSpaceOptionContext>();
}

MySQLParser::UndoTableSpaceOptionContext *MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption(size_t i) {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::UndoTableSpaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOptions;
}

void MySQLParser::UndoTableSpaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOptions(this);
}

void MySQLParser::UndoTableSpaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOptions(this);
}

std::any MySQLParser::UndoTableSpaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUndoTableSpaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UndoTableSpaceOptionsContext *MySQLParser::undoTableSpaceOptions() {
  UndoTableSpaceOptionsContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 60, MySQLParser::RuleUndoTableSpaceOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2022);
    undoTableSpaceOption();
    setState(2029);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL ||
           _la == MySQLParser::COMMA_SYMBOL) {
      setState(2024);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2023);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(2026);
      undoTableSpaceOption();
      setState(2031);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionContext::UndoTableSpaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionEngineContext *MySQLParser::UndoTableSpaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

size_t MySQLParser::UndoTableSpaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOption;
}

void MySQLParser::UndoTableSpaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOption(this);
}

void MySQLParser::UndoTableSpaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOption(this);
}

std::any MySQLParser::UndoTableSpaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUndoTableSpaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UndoTableSpaceOptionContext *MySQLParser::undoTableSpaceOption() {
  UndoTableSpaceOptionContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 62, MySQLParser::RuleUndoTableSpaceOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2032);
    tsOptionEngine();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionsContext::AlterTablespaceOptionsContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterTablespaceOptionContext *>
MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption() {
  return getRuleContexts<MySQLParser::AlterTablespaceOptionContext>();
}

MySQLParser::AlterTablespaceOptionContext *MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::AlterTablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::AlterTablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOptions;
}

void MySQLParser::AlterTablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOptions(this);
}

void MySQLParser::AlterTablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOptions(this);
}

std::any MySQLParser::AlterTablespaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterTablespaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceOptionsContext *MySQLParser::alterTablespaceOptions() {
  AlterTablespaceOptionsContext *_localctx = _tracker.createInstance<AlterTablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 64, MySQLParser::RuleAlterTablespaceOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2034);
    alterTablespaceOption();
    setState(2041);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2036);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
          case 1: {
            setState(2035);
            match(MySQLParser::COMMA_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(2038);
        alterTablespaceOption();
      }
      setState(2043);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionContext::AlterTablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::AlterTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::AlterTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext *MySQLParser::AlterTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext *MySQLParser::AlterTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionEngineContext *MySQLParser::AlterTablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext *MySQLParser::AlterTablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEncryptionContext *MySQLParser::AlterTablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}

MySQLParser::TsOptionEngineAttributeContext *MySQLParser::AlterTablespaceOptionContext::tsOptionEngineAttribute() {
  return getRuleContext<MySQLParser::TsOptionEngineAttributeContext>(0);
}

size_t MySQLParser::AlterTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOption;
}

void MySQLParser::AlterTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOption(this);
}

void MySQLParser::AlterTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOption(this);
}

std::any MySQLParser::AlterTablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterTablespaceOptionContext *MySQLParser::alterTablespaceOption() {
  AlterTablespaceOptionContext *_localctx = _tracker.createInstance<AlterTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 66, MySQLParser::RuleAlterTablespaceOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2056);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 88, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2044);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(2046);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx)) {
          case 1: {
            setState(2045);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(2048);
        sizeNumber();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2049);
        tsOptionAutoextendSize();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2050);
        tsOptionMaxSize();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2051);
        tsOptionEngine();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2052);
        tsOptionWait();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2053);
        tsOptionEncryption();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2054);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(2055);
        tsOptionEngineAttribute();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::ChangeTablespaceOptionContext::ChangeTablespaceOptionContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::ChangeTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::ChangeTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext *MySQLParser::ChangeTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext *MySQLParser::ChangeTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

size_t MySQLParser::ChangeTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleChangeTablespaceOption;
}

void MySQLParser::ChangeTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeTablespaceOption(this);
}

void MySQLParser::ChangeTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeTablespaceOption(this);
}

std::any MySQLParser::ChangeTablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeTablespaceOptionContext *MySQLParser::changeTablespaceOption() {
  ChangeTablespaceOptionContext *_localctx = _tracker.createInstance<ChangeTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 68, MySQLParser::RuleChangeTablespaceOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2065);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2058);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(2060);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 89, _ctx)) {
          case 1: {
            setState(2059);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(2062);
        sizeNumber();
        break;
      }

      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2063);
        tsOptionAutoextendSize();
        break;
      }

      case MySQLParser::MAX_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2064);
        tsOptionMaxSize();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterViewContext ------------------------------------------------------------------

MySQLParser::AlterViewContext::AlterViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefContext *MySQLParser::AlterViewContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

MySQLParser::ViewTailContext *MySQLParser::AlterViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewAlgorithmContext *MySQLParser::AlterViewContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::AlterViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext *MySQLParser::AlterViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}

size_t MySQLParser::AlterViewContext::getRuleIndex() const {
  return MySQLParser::RuleAlterView;
}

void MySQLParser::AlterViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterView(this);
}

void MySQLParser::AlterViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterView(this);
}

std::any MySQLParser::AlterViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterViewContext *MySQLParser::alterView() {
  AlterViewContext *_localctx = _tracker.createInstance<AlterViewContext>(_ctx, getState());
  enterRule(_localctx, 70, MySQLParser::RuleAlterView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2068);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL) {
      setState(2067);
      viewAlgorithm();
    }
    setState(2071);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2070);
      definerClause();
    }
    setState(2074);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(2073);
      viewSuid();
    }
    setState(2076);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2077);
    viewRef();
    setState(2078);
    viewTail();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewTailContext ------------------------------------------------------------------

MySQLParser::ViewTailContext::ViewTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ViewTailContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ViewQueryBlockContext *MySQLParser::ViewTailContext::viewQueryBlock() {
  return getRuleContext<MySQLParser::ViewQueryBlockContext>(0);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::ViewTailContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

size_t MySQLParser::ViewTailContext::getRuleIndex() const {
  return MySQLParser::RuleViewTail;
}

void MySQLParser::ViewTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewTail(this);
}

void MySQLParser::ViewTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewTail(this);
}

std::any MySQLParser::ViewTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewTailContext *MySQLParser::viewTail() {
  ViewTailContext *_localctx = _tracker.createInstance<ViewTailContext>(_ctx, getState());
  enterRule(_localctx, 72, MySQLParser::RuleViewTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2081);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2080);
      columnInternalRefList();
    }
    setState(2083);
    match(MySQLParser::AS_SYMBOL);
    setState(2084);
    viewQueryBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewQueryBlockContext ------------------------------------------------------------------

MySQLParser::ViewQueryBlockContext::ViewQueryBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionWithOptLockingClausesContext *
MySQLParser::ViewQueryBlockContext::queryExpressionWithOptLockingClauses() {
  return getRuleContext<MySQLParser::QueryExpressionWithOptLockingClausesContext>(0);
}

MySQLParser::ViewCheckOptionContext *MySQLParser::ViewQueryBlockContext::viewCheckOption() {
  return getRuleContext<MySQLParser::ViewCheckOptionContext>(0);
}

size_t MySQLParser::ViewQueryBlockContext::getRuleIndex() const {
  return MySQLParser::RuleViewQueryBlock;
}

void MySQLParser::ViewQueryBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewQueryBlock(this);
}

void MySQLParser::ViewQueryBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewQueryBlock(this);
}

std::any MySQLParser::ViewQueryBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewQueryBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewQueryBlockContext *MySQLParser::viewQueryBlock() {
  ViewQueryBlockContext *_localctx = _tracker.createInstance<ViewQueryBlockContext>(_ctx, getState());
  enterRule(_localctx, 74, MySQLParser::RuleViewQueryBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2086);
    queryExpressionWithOptLockingClauses();
    setState(2088);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(2087);
      viewCheckOption();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewCheckOptionContext ------------------------------------------------------------------

MySQLParser::ViewCheckOptionContext::ViewCheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ViewCheckOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewCheckOptionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewCheckOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewCheckOptionContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewCheckOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

size_t MySQLParser::ViewCheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleViewCheckOption;
}

void MySQLParser::ViewCheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewCheckOption(this);
}

void MySQLParser::ViewCheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewCheckOption(this);
}

std::any MySQLParser::ViewCheckOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewCheckOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewCheckOptionContext *MySQLParser::viewCheckOption() {
  ViewCheckOptionContext *_localctx = _tracker.createInstance<ViewCheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 76, MySQLParser::RuleViewCheckOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2090);
    match(MySQLParser::WITH_SYMBOL);
    setState(2092);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL) {
      setState(2091);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2094);
    match(MySQLParser::CHECK_SYMBOL);
    setState(2095);
    match(MySQLParser::OPTION_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterInstanceStatementContext ------------------------------------------------------------------

MySQLParser::AlterInstanceStatementContext::AlterInstanceStatementContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::AlterInstanceStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::TLS_SYMBOL() {
  return getToken(MySQLParser::TLS_SYMBOL, 0);
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::AlterInstanceStatementContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext *MySQLParser::AlterInstanceStatementContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::KEYRING_SYMBOL() {
  return getToken(MySQLParser::KEYRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterInstanceStatementContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

size_t MySQLParser::AlterInstanceStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAlterInstanceStatement;
}

void MySQLParser::AlterInstanceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterInstanceStatement(this);
}

void MySQLParser::AlterInstanceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterInstanceStatement(this);
}

std::any MySQLParser::AlterInstanceStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterInstanceStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterInstanceStatementContext *MySQLParser::alterInstanceStatement() {
  AlterInstanceStatementContext *_localctx = _tracker.createInstance<AlterInstanceStatementContext>(_ctx, getState());
  enterRule(_localctx, 78, MySQLParser::RuleAlterInstanceStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2129);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2097);
        match(MySQLParser::INSTANCE_SYMBOL);
        setState(2098);
        match(MySQLParser::ROTATE_SYMBOL);
        setState(2099);
        textOrIdentifier();
        setState(2100);
        match(MySQLParser::MASTER_SYMBOL);
        setState(2101);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2103);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(2127);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 99, _ctx)) {
          case 1: {
            setState(2104);
            match(MySQLParser::RELOAD_SYMBOL);
            setState(2105);
            match(MySQLParser::TLS_SYMBOL);
            setState(2119);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::NO_SYMBOL: {
                setState(2106);
                match(MySQLParser::NO_SYMBOL);
                setState(2107);
                match(MySQLParser::ROLLBACK_SYMBOL);
                setState(2108);
                match(MySQLParser::ON_SYMBOL);
                setState(2109);
                match(MySQLParser::ERROR_SYMBOL);
                break;
              }

              case MySQLParser::FOR_SYMBOL: {
                setState(2110);
                match(MySQLParser::FOR_SYMBOL);
                setState(2111);
                match(MySQLParser::CHANNEL_SYMBOL);
                setState(2112);
                identifier();
                setState(2117);
                _errHandler->sync(this);

                _la = _input->LA(1);
                if (_la == MySQLParser::NO_SYMBOL) {
                  setState(2113);
                  match(MySQLParser::NO_SYMBOL);
                  setState(2114);
                  match(MySQLParser::ROLLBACK_SYMBOL);
                  setState(2115);
                  match(MySQLParser::ON_SYMBOL);
                  setState(2116);
                  match(MySQLParser::ERROR_SYMBOL);
                }
                break;
              }

              default:
                throw NoViableAltException(this);
            }
            break;
          }

          case 2: {
            setState(2121);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::DISABLE_SYMBOL

                  || _la == MySQLParser::ENABLE_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(2122);
            identifier();
            setState(2123);
            identifier();
            break;
          }

          case 3: {
            setState(2125);
            match(MySQLParser::RELOAD_SYMBOL);
            setState(2126);
            match(MySQLParser::KEYRING_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateStatementContext ------------------------------------------------------------------

MySQLParser::CreateStatementContext::CreateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

MySQLParser::CreateDatabaseContext *MySQLParser::CreateStatementContext::createDatabase() {
  return getRuleContext<MySQLParser::CreateDatabaseContext>(0);
}

MySQLParser::CreateTableContext *MySQLParser::CreateStatementContext::createTable() {
  return getRuleContext<MySQLParser::CreateTableContext>(0);
}

MySQLParser::CreateFunctionContext *MySQLParser::CreateStatementContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateProcedureContext *MySQLParser::CreateStatementContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateUdfContext *MySQLParser::CreateStatementContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

MySQLParser::CreateLogfileGroupContext *MySQLParser::CreateStatementContext::createLogfileGroup() {
  return getRuleContext<MySQLParser::CreateLogfileGroupContext>(0);
}

MySQLParser::CreateViewContext *MySQLParser::CreateStatementContext::createView() {
  return getRuleContext<MySQLParser::CreateViewContext>(0);
}

MySQLParser::CreateTriggerContext *MySQLParser::CreateStatementContext::createTrigger() {
  return getRuleContext<MySQLParser::CreateTriggerContext>(0);
}

MySQLParser::CreateIndexContext *MySQLParser::CreateStatementContext::createIndex() {
  return getRuleContext<MySQLParser::CreateIndexContext>(0);
}

MySQLParser::CreateServerContext *MySQLParser::CreateStatementContext::createServer() {
  return getRuleContext<MySQLParser::CreateServerContext>(0);
}

MySQLParser::CreateTablespaceContext *MySQLParser::CreateStatementContext::createTablespace() {
  return getRuleContext<MySQLParser::CreateTablespaceContext>(0);
}

MySQLParser::CreateEventContext *MySQLParser::CreateStatementContext::createEvent() {
  return getRuleContext<MySQLParser::CreateEventContext>(0);
}

MySQLParser::CreateRoleContext *MySQLParser::CreateStatementContext::createRole() {
  return getRuleContext<MySQLParser::CreateRoleContext>(0);
}

MySQLParser::CreateSpatialReferenceContext *MySQLParser::CreateStatementContext::createSpatialReference() {
  return getRuleContext<MySQLParser::CreateSpatialReferenceContext>(0);
}

MySQLParser::CreateUndoTablespaceContext *MySQLParser::CreateStatementContext::createUndoTablespace() {
  return getRuleContext<MySQLParser::CreateUndoTablespaceContext>(0);
}

size_t MySQLParser::CreateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCreateStatement;
}

void MySQLParser::CreateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateStatement(this);
}

void MySQLParser::CreateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateStatement(this);
}

std::any MySQLParser::CreateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateStatementContext *MySQLParser::createStatement() {
  CreateStatementContext *_localctx = _tracker.createInstance<CreateStatementContext>(_ctx, getState());
  enterRule(_localctx, 80, MySQLParser::RuleCreateStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2131);
    match(MySQLParser::CREATE_SYMBOL);
    setState(2149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx)) {
      case 1: {
        setState(2132);
        createDatabase();
        break;
      }

      case 2: {
        setState(2133);
        createTable();
        break;
      }

      case 3: {
        setState(2134);
        createFunction();
        break;
      }

      case 4: {
        setState(2135);
        createProcedure();
        break;
      }

      case 5: {
        setState(2136);
        createUdf();
        break;
      }

      case 6: {
        setState(2137);
        createLogfileGroup();
        break;
      }

      case 7: {
        setState(2138);
        createView();
        break;
      }

      case 8: {
        setState(2139);
        createTrigger();
        break;
      }

      case 9: {
        setState(2140);
        createIndex();
        break;
      }

      case 10: {
        setState(2141);
        createServer();
        break;
      }

      case 11: {
        setState(2142);
        createTablespace();
        break;
      }

      case 12: {
        setState(2143);
        createEvent();
        break;
      }

      case 13: {
        setState(2144);
        createRole();
        break;
      }

      case 14: {
        setState(2145);

        if (!(serverVersion >= 80011))
          throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(2146);
        createSpatialReference();
        break;
      }

      case 15: {
        setState(2147);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(2148);
        createUndoTablespace();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseContext::CreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaNameContext *MySQLParser::CreateDatabaseContext::schemaName() {
  return getRuleContext<MySQLParser::SchemaNameContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateDatabaseContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<MySQLParser::CreateDatabaseOptionContext *> MySQLParser::CreateDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySQLParser::CreateDatabaseOptionContext>();
}

MySQLParser::CreateDatabaseOptionContext *MySQLParser::CreateDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(i);
}

size_t MySQLParser::CreateDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabase;
}

void MySQLParser::CreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabase(this);
}

void MySQLParser::CreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabase(this);
}

std::any MySQLParser::CreateDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateDatabaseContext *MySQLParser::createDatabase() {
  CreateDatabaseContext *_localctx = _tracker.createInstance<CreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 82, MySQLParser::RuleCreateDatabase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2151);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(2153);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx)) {
      case 1: {
        setState(2152);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2155);
    schemaName();
    setState(2159);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2156);
        createDatabaseOption();
      }
      setState(2161);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 103, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseOptionContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseOptionContext::CreateDatabaseOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DefaultCharsetContext *MySQLParser::CreateDatabaseOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext *MySQLParser::CreateDatabaseOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

MySQLParser::DefaultEncryptionContext *MySQLParser::CreateDatabaseOptionContext::defaultEncryption() {
  return getRuleContext<MySQLParser::DefaultEncryptionContext>(0);
}

size_t MySQLParser::CreateDatabaseOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabaseOption;
}

void MySQLParser::CreateDatabaseOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabaseOption(this);
}

void MySQLParser::CreateDatabaseOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabaseOption(this);
}

std::any MySQLParser::CreateDatabaseOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateDatabaseOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateDatabaseOptionContext *MySQLParser::createDatabaseOption() {
  CreateDatabaseOptionContext *_localctx = _tracker.createInstance<CreateDatabaseOptionContext>(_ctx, getState());
  enterRule(_localctx, 84, MySQLParser::RuleCreateDatabaseOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2166);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 104, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2162);
        defaultCharset();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2163);
        defaultCollation();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2164);

        if (!(serverVersion >= 80016))
          throw FailedPredicateException(this, "serverVersion >= 80016");
        setState(2165);
        defaultEncryption();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableContext ------------------------------------------------------------------

MySQLParser::CreateTableContext::CreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableNameContext *MySQLParser::CreateTableContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::CreateTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateTableContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

MySQLParser::TableElementListContext *MySQLParser::CreateTableContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

MySQLParser::CreateTableOptionsEtcContext *MySQLParser::CreateTableContext::createTableOptionsEtc() {
  return getRuleContext<MySQLParser::CreateTableOptionsEtcContext>(0);
}

size_t MySQLParser::CreateTableContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTable;
}

void MySQLParser::CreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTable(this);
}

void MySQLParser::CreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTable(this);
}

std::any MySQLParser::CreateTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableContext *MySQLParser::createTable() {
  CreateTableContext *_localctx = _tracker.createInstance<CreateTableContext>(_ctx, getState());
  enterRule(_localctx, 86, MySQLParser::RuleCreateTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2169);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(2168);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(2171);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2173);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 106, _ctx)) {
      case 1: {
        setState(2172);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2175);
    tableName();
    setState(2192);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
      case 1: {
        setState(2180);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 107, _ctx)) {
          case 1: {
            setState(2176);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(2177);
            tableElementList();
            setState(2178);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(2183);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
          case 1: {
            setState(2182);
            createTableOptionsEtc();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(2185);
        match(MySQLParser::LIKE_SYMBOL);
        setState(2186);
        tableRef();
        break;
      }

      case 3: {
        setState(2187);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(2188);
        match(MySQLParser::LIKE_SYMBOL);
        setState(2189);
        tableRef();
        setState(2190);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementListContext ------------------------------------------------------------------

MySQLParser::TableElementListContext::TableElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableElementContext *> MySQLParser::TableElementListContext::tableElement() {
  return getRuleContexts<MySQLParser::TableElementContext>();
}

MySQLParser::TableElementContext *MySQLParser::TableElementListContext::tableElement(size_t i) {
  return getRuleContext<MySQLParser::TableElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableElementListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableElementListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TableElementListContext::getRuleIndex() const {
  return MySQLParser::RuleTableElementList;
}

void MySQLParser::TableElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElementList(this);
}

void MySQLParser::TableElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElementList(this);
}

std::any MySQLParser::TableElementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableElementList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableElementListContext *MySQLParser::tableElementList() {
  TableElementListContext *_localctx = _tracker.createInstance<TableElementListContext>(_ctx, getState());
  enterRule(_localctx, 88, MySQLParser::RuleTableElementList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2194);
    tableElement();
    setState(2199);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2195);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2196);
      tableElement();
      setState(2201);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementContext ------------------------------------------------------------------

MySQLParser::TableElementContext::TableElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnDefinitionContext *MySQLParser::TableElementContext::columnDefinition() {
  return getRuleContext<MySQLParser::ColumnDefinitionContext>(0);
}

MySQLParser::TableConstraintDefContext *MySQLParser::TableElementContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}

size_t MySQLParser::TableElementContext::getRuleIndex() const {
  return MySQLParser::RuleTableElement;
}

void MySQLParser::TableElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElement(this);
}

void MySQLParser::TableElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElement(this);
}

std::any MySQLParser::TableElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableElementContext *MySQLParser::tableElement() {
  TableElementContext *_localctx = _tracker.createInstance<TableElementContext>(_ctx, getState());
  enterRule(_localctx, 90, MySQLParser::RuleTableElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2204);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2202);
        columnDefinition();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2203);
        tableConstraintDef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DuplicateAsQeContext ------------------------------------------------------------------

MySQLParser::DuplicateAsQeContext::DuplicateAsQeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AsCreateQueryExpressionContext *MySQLParser::DuplicateAsQeContext::asCreateQueryExpression() {
  return getRuleContext<MySQLParser::AsCreateQueryExpressionContext>(0);
}

tree::TerminalNode *MySQLParser::DuplicateAsQeContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DuplicateAsQeContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

size_t MySQLParser::DuplicateAsQeContext::getRuleIndex() const {
  return MySQLParser::RuleDuplicateAsQe;
}

void MySQLParser::DuplicateAsQeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDuplicateAsQe(this);
}

void MySQLParser::DuplicateAsQeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDuplicateAsQe(this);
}

std::any MySQLParser::DuplicateAsQeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDuplicateAsQe(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DuplicateAsQeContext *MySQLParser::duplicateAsQe() {
  DuplicateAsQeContext *_localctx = _tracker.createInstance<DuplicateAsQeContext>(_ctx, getState());
  enterRule(_localctx, 92, MySQLParser::RuleDuplicateAsQe);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2207);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 112, _ctx)) {
      case 1: {
        setState(2206);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }
    setState(2209);
    asCreateQueryExpression();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsCreateQueryExpressionContext ------------------------------------------------------------------

MySQLParser::AsCreateQueryExpressionContext::AsCreateQueryExpressionContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionWithOptLockingClausesContext *
MySQLParser::AsCreateQueryExpressionContext::queryExpressionWithOptLockingClauses() {
  return getRuleContext<MySQLParser::QueryExpressionWithOptLockingClausesContext>(0);
}

tree::TerminalNode *MySQLParser::AsCreateQueryExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

size_t MySQLParser::AsCreateQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleAsCreateQueryExpression;
}

void MySQLParser::AsCreateQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAsCreateQueryExpression(this);
}

void MySQLParser::AsCreateQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAsCreateQueryExpression(this);
}

std::any MySQLParser::AsCreateQueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAsCreateQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AsCreateQueryExpressionContext *MySQLParser::asCreateQueryExpression() {
  AsCreateQueryExpressionContext *_localctx = _tracker.createInstance<AsCreateQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 94, MySQLParser::RuleAsCreateQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2212);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
      case 1: {
        setState(2211);
        match(MySQLParser::AS_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(2214);
    queryExpressionWithOptLockingClauses();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionOrParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionOrParensContext::QueryExpressionOrParensContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext *MySQLParser::QueryExpressionOrParensContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::LockingClauseListContext *MySQLParser::QueryExpressionOrParensContext::lockingClauseList() {
  return getRuleContext<MySQLParser::LockingClauseListContext>(0);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::QueryExpressionOrParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

size_t MySQLParser::QueryExpressionOrParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionOrParens;
}

void MySQLParser::QueryExpressionOrParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionOrParens(this);
}

void MySQLParser::QueryExpressionOrParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionOrParens(this);
}

std::any MySQLParser::QueryExpressionOrParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryExpressionOrParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionOrParensContext *MySQLParser::queryExpressionOrParens() {
  QueryExpressionOrParensContext *_localctx = _tracker.createInstance<QueryExpressionOrParensContext>(_ctx, getState());
  enterRule(_localctx, 96, MySQLParser::RuleQueryExpressionOrParens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2222);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2216);
        queryExpression();
        setState(2219);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
          case 1: {
            setState(2217);

            if (!(serverVersion >= 80031))
              throw FailedPredicateException(this, "serverVersion >= 80031");
            setState(2218);
            lockingClauseList();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2221);
        queryExpressionParens();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionWithOptLockingClausesContext
//------------------------------------------------------------------

MySQLParser::QueryExpressionWithOptLockingClausesContext::QueryExpressionWithOptLockingClausesContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext *MySQLParser::QueryExpressionWithOptLockingClausesContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::LockingClauseListContext *MySQLParser::QueryExpressionWithOptLockingClausesContext::lockingClauseList() {
  return getRuleContext<MySQLParser::LockingClauseListContext>(0);
}

size_t MySQLParser::QueryExpressionWithOptLockingClausesContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionWithOptLockingClauses;
}

void MySQLParser::QueryExpressionWithOptLockingClausesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionWithOptLockingClauses(this);
}

void MySQLParser::QueryExpressionWithOptLockingClausesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionWithOptLockingClauses(this);
}

std::any MySQLParser::QueryExpressionWithOptLockingClausesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryExpressionWithOptLockingClauses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionWithOptLockingClausesContext *MySQLParser::queryExpressionWithOptLockingClauses() {
  QueryExpressionWithOptLockingClausesContext *_localctx =
    _tracker.createInstance<QueryExpressionWithOptLockingClausesContext>(_ctx, getState());
  enterRule(_localctx, 98, MySQLParser::RuleQueryExpressionWithOptLockingClauses);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2224);
    queryExpression();
    setState(2226);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
      setState(2225);
      lockingClauseList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoutineContext ------------------------------------------------------------------

MySQLParser::CreateRoutineContext::CreateRoutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateRoutineContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateRoutineContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::CreateProcedureContext *MySQLParser::CreateRoutineContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateFunctionContext *MySQLParser::CreateRoutineContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateUdfContext *MySQLParser::CreateRoutineContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

tree::TerminalNode *MySQLParser::CreateRoutineContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}

size_t MySQLParser::CreateRoutineContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRoutine;
}

void MySQLParser::CreateRoutineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRoutine(this);
}

void MySQLParser::CreateRoutineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRoutine(this);
}

std::any MySQLParser::CreateRoutineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateRoutine(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateRoutineContext *MySQLParser::createRoutine() {
  CreateRoutineContext *_localctx = _tracker.createInstance<CreateRoutineContext>(_ctx, getState());
  enterRule(_localctx, 100, MySQLParser::RuleCreateRoutine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2228);
    match(MySQLParser::CREATE_SYMBOL);
    setState(2232);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
      case 1: {
        setState(2229);
        createProcedure();
        break;
      }

      case 2: {
        setState(2230);
        createFunction();
        break;
      }

      case 3: {
        setState(2231);
        createUdf();
        break;
      }

      default:
        break;
    }
    setState(2235);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SEMICOLON_SYMBOL) {
      setState(2234);
      match(MySQLParser::SEMICOLON_SYMBOL);
    }
    setState(2237);
    match(MySQLParser::EOF);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateProcedureContext ------------------------------------------------------------------

MySQLParser::CreateProcedureContext::CreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureNameContext *MySQLParser::CreateProcedureContext::procedureName() {
  return getRuleContext<MySQLParser::ProcedureNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateProcedureContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateProcedureContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext *MySQLParser::CreateProcedureContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::CreateProcedureContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateProcedureContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<MySQLParser::ProcedureParameterContext *> MySQLParser::CreateProcedureContext::procedureParameter() {
  return getRuleContexts<MySQLParser::ProcedureParameterContext>();
}

MySQLParser::ProcedureParameterContext *MySQLParser::CreateProcedureContext::procedureParameter(size_t i) {
  return getRuleContext<MySQLParser::ProcedureParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateProcedureContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext *MySQLParser::CreateProcedureContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateProcedureContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateProcedureContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::CreateProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleCreateProcedure;
}

void MySQLParser::CreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateProcedure(this);
}

void MySQLParser::CreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateProcedure(this);
}

std::any MySQLParser::CreateProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateProcedureContext *MySQLParser::createProcedure() {
  CreateProcedureContext *_localctx = _tracker.createInstance<CreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 102, MySQLParser::RuleCreateProcedure);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2240);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2239);
      definerClause();
    }
    setState(2242);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(2244);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
      case 1: {
        setState(2243);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2246);
    procedureName();
    setState(2247);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2256);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
      case 1: {
        setState(2248);
        procedureParameter();
        setState(2253);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2249);
          match(MySQLParser::COMMA_SYMBOL);
          setState(2250);
          procedureParameter();
          setState(2255);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
    }
    setState(2258);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2262);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2259);
        routineCreateOption();
      }
      setState(2264);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx);
    }
    setState(2265);
    compoundStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateFunctionContext ------------------------------------------------------------------

MySQLParser::CreateFunctionContext::CreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionNameContext *MySQLParser::CreateFunctionContext::functionName() {
  return getRuleContext<MySQLParser::FunctionNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateFunctionContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

MySQLParser::TypeWithOptCollateContext *MySQLParser::CreateFunctionContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}

MySQLParser::CompoundStatementContext *MySQLParser::CreateFunctionContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::CreateFunctionContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateFunctionContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<MySQLParser::FunctionParameterContext *> MySQLParser::CreateFunctionContext::functionParameter() {
  return getRuleContexts<MySQLParser::FunctionParameterContext>();
}

MySQLParser::FunctionParameterContext *MySQLParser::CreateFunctionContext::functionParameter(size_t i) {
  return getRuleContext<MySQLParser::FunctionParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateFunctionContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext *MySQLParser::CreateFunctionContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::CreateFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateFunction;
}

void MySQLParser::CreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateFunction(this);
}

void MySQLParser::CreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateFunction(this);
}

std::any MySQLParser::CreateFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateFunctionContext *MySQLParser::createFunction() {
  CreateFunctionContext *_localctx = _tracker.createInstance<CreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 104, MySQLParser::RuleCreateFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2268);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2267);
      definerClause();
    }
    setState(2270);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2272);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 125, _ctx)) {
      case 1: {
        setState(2271);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2274);
    functionName();
    setState(2275);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2284);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 127, _ctx)) {
      case 1: {
        setState(2276);
        functionParameter();
        setState(2281);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2277);
          match(MySQLParser::COMMA_SYMBOL);
          setState(2278);
          functionParameter();
          setState(2283);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
    }
    setState(2286);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2287);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(2288);
    typeWithOptCollate();
    setState(2292);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2289);
        routineCreateOption();
      }
      setState(2294);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx);
    }
    setState(2295);
    compoundStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUdfContext ------------------------------------------------------------------

MySQLParser::CreateUdfContext::CreateUdfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateUdfContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::UdfNameContext *MySQLParser::CreateUdfContext::udfName() {
  return getRuleContext<MySQLParser::UdfNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::CreateUdfContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUdfContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateUdfContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

size_t MySQLParser::CreateUdfContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUdf;
}

void MySQLParser::CreateUdfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUdf(this);
}

void MySQLParser::CreateUdfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUdf(this);
}

std::any MySQLParser::CreateUdfContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUdf(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUdfContext *MySQLParser::createUdf() {
  CreateUdfContext *_localctx = _tracker.createInstance<CreateUdfContext>(_ctx, getState());
  enterRule(_localctx, 106, MySQLParser::RuleCreateUdf);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::AGGREGATE_SYMBOL) {
      setState(2297);
      match(MySQLParser::AGGREGATE_SYMBOL);
    }
    setState(2300);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2302);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 130, _ctx)) {
      case 1: {
        setState(2301);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2304);
    udfName();
    setState(2305);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(2306);
    antlrcpp::downCast<CreateUdfContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DECIMAL_SYMBOL || _la == MySQLParser::INT_SYMBOL || _la == MySQLParser::REAL_SYMBOL ||
          _la == MySQLParser::STRING_SYMBOL)) {
      antlrcpp::downCast<CreateUdfContext *>(_localctx)->type = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2307);
    match(MySQLParser::SONAME_SYMBOL);
    setState(2308);
    textLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineCreateOptionContext ------------------------------------------------------------------

MySQLParser::RoutineCreateOptionContext::RoutineCreateOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoutineOptionContext *MySQLParser::RoutineCreateOptionContext::routineOption() {
  return getRuleContext<MySQLParser::RoutineOptionContext>(0);
}

tree::TerminalNode *MySQLParser::RoutineCreateOptionContext::DETERMINISTIC_SYMBOL() {
  return getToken(MySQLParser::DETERMINISTIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineCreateOptionContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

size_t MySQLParser::RoutineCreateOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineCreateOption;
}

void MySQLParser::RoutineCreateOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineCreateOption(this);
}

void MySQLParser::RoutineCreateOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineCreateOption(this);
}

std::any MySQLParser::RoutineCreateOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoutineCreateOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineCreateOptionContext *MySQLParser::routineCreateOption() {
  RoutineCreateOptionContext *_localctx = _tracker.createInstance<RoutineCreateOptionContext>(_ctx, getState());
  enterRule(_localctx, 108, MySQLParser::RuleRoutineCreateOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2315);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::CONTAINS_SYMBOL:
      case MySQLParser::LANGUAGE_SYMBOL:
      case MySQLParser::MODIFIES_SYMBOL:
      case MySQLParser::NO_SYMBOL:
      case MySQLParser::READS_SYMBOL:
      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2310);
        routineOption();
        break;
      }

      case MySQLParser::DETERMINISTIC_SYMBOL:
      case MySQLParser::NOT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2312);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL) {
          setState(2311);
          match(MySQLParser::NOT_SYMBOL);
        }
        setState(2314);
        match(MySQLParser::DETERMINISTIC_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineAlterOptionsContext ------------------------------------------------------------------

MySQLParser::RoutineAlterOptionsContext::RoutineAlterOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::RoutineAlterOptionsContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext *MySQLParser::RoutineAlterOptionsContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

size_t MySQLParser::RoutineAlterOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineAlterOptions;
}

void MySQLParser::RoutineAlterOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineAlterOptions(this);
}

void MySQLParser::RoutineAlterOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineAlterOptions(this);
}

std::any MySQLParser::RoutineAlterOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoutineAlterOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineAlterOptionsContext *MySQLParser::routineAlterOptions() {
  RoutineAlterOptionsContext *_localctx = _tracker.createInstance<RoutineAlterOptionsContext>(_ctx, getState());
  enterRule(_localctx, 110, MySQLParser::RuleRoutineAlterOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2318);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2317);
      routineCreateOption();
      setState(2320);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 75) & ~0x3fULL) == 0) && ((1ULL << (_la - 75)) & 4611686018427420673) != 0) ||
             _la == MySQLParser::LANGUAGE_SYMBOL ||
             ((((_la - 347) & ~0x3fULL) == 0) && ((1ULL << (_la - 347)) & 83886081) != 0) ||
             _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineOptionContext ------------------------------------------------------------------

MySQLParser::RoutineOptionContext::RoutineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext *MySQLParser::RoutineOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::READS_SYMBOL() {
  return getToken(MySQLParser::READS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::MODIFIES_SYMBOL() {
  return getToken(MySQLParser::MODIFIES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoutineOptionContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

size_t MySQLParser::RoutineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineOption;
}

void MySQLParser::RoutineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineOption(this);
}

void MySQLParser::RoutineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineOption(this);
}

std::any MySQLParser::RoutineOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoutineOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoutineOptionContext *MySQLParser::routineOption() {
  RoutineOptionContext *_localctx = _tracker.createInstance<RoutineOptionContext>(_ctx, getState());
  enterRule(_localctx, 112, MySQLParser::RuleRoutineOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2339);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2322);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(2323);
        textLiteral();
        break;
      }

      case MySQLParser::LANGUAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2324);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::LANGUAGE_SYMBOL);
        setState(2325);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2326);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::NO_SYMBOL);
        setState(2327);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::CONTAINS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2328);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::CONTAINS_SYMBOL);
        setState(2329);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::READS_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2330);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::READS_SYMBOL);
        setState(2331);
        match(MySQLParser::SQL_SYMBOL);
        setState(2332);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::MODIFIES_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2333);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::MODIFIES_SYMBOL);
        setState(2334);
        match(MySQLParser::SQL_SYMBOL);
        setState(2335);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2336);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::SQL_SYMBOL);
        setState(2337);
        match(MySQLParser::SECURITY_SYMBOL);
        setState(2338);
        antlrcpp::downCast<RoutineOptionContext *>(_localctx)->security = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEFINER_SYMBOL || _la == MySQLParser::INVOKER_SYMBOL)) {
          antlrcpp::downCast<RoutineOptionContext *>(_localctx)->security = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MySQLParser::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexNameContext *MySQLParser::CreateIndexContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

MySQLParser::CreateIndexTargetContext *MySQLParser::CreateIndexContext::createIndexTarget() {
  return getRuleContext<MySQLParser::CreateIndexTargetContext>(0);
}

tree::TerminalNode *MySQLParser::CreateIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::OnlineOptionContext *MySQLParser::CreateIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

tree::TerminalNode *MySQLParser::CreateIndexContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateIndexContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

MySQLParser::IndexLockAndAlgorithmContext *MySQLParser::CreateIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}

tree::TerminalNode *MySQLParser::CreateIndexContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::IndexTypeClauseContext *MySQLParser::CreateIndexContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::CreateIndexContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext *MySQLParser::CreateIndexContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::CreateIndexContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext *MySQLParser::CreateIndexContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::CreateIndexContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext *MySQLParser::CreateIndexContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

size_t MySQLParser::CreateIndexContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndex;
}

void MySQLParser::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MySQLParser::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}

std::any MySQLParser::CreateIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateIndexContext *MySQLParser::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 114, MySQLParser::RuleCreateIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2342);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OFFLINE_SYMBOL

        || _la == MySQLParser::ONLINE_SYMBOL) {
      setState(2341);
      onlineOption();
    }
    setState(2379);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        setState(2345);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::UNIQUE_SYMBOL) {
          setState(2344);
          match(MySQLParser::UNIQUE_SYMBOL);
        }
        setState(2347);
        antlrcpp::downCast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
        setState(2348);
        indexName();
        setState(2350);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::TYPE_SYMBOL

            || _la == MySQLParser::USING_SYMBOL) {
          setState(2349);
          indexTypeClause();
        }
        setState(2352);
        createIndexTarget();
        setState(2356);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2353);
            indexOption();
          }
          setState(2358);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 138, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        setState(2359);
        antlrcpp::downCast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(2360);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2361);
        indexName();
        setState(2362);
        createIndexTarget();
        setState(2366);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2363);
            fulltextIndexOption();
          }
          setState(2368);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        setState(2369);
        antlrcpp::downCast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(2370);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2371);
        indexName();
        setState(2372);
        createIndexTarget();
        setState(2376);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2373);
            spatialIndexOption();
          }
          setState(2378);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 140, _ctx);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(2382);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
      setState(2381);
      indexLockAndAlgorithm();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameAndTypeContext ------------------------------------------------------------------

MySQLParser::IndexNameAndTypeContext::IndexNameAndTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexNameContext *MySQLParser::IndexNameAndTypeContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode *MySQLParser::IndexNameAndTypeContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IndexTypeContext *MySQLParser::IndexNameAndTypeContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode *MySQLParser::IndexNameAndTypeContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

size_t MySQLParser::IndexNameAndTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexNameAndType;
}

void MySQLParser::IndexNameAndTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexNameAndType(this);
}

void MySQLParser::IndexNameAndTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexNameAndType(this);
}

std::any MySQLParser::IndexNameAndTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexNameAndType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexNameAndTypeContext *MySQLParser::indexNameAndType() {
  IndexNameAndTypeContext *_localctx = _tracker.createInstance<IndexNameAndTypeContext>(_ctx, getState());
  enterRule(_localctx, 116, MySQLParser::RuleIndexNameAndType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2394);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2384);
        indexName();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2386);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
          case 1: {
            setState(2385);
            indexName();
            break;
          }

          default:
            break;
        }
        setState(2388);
        match(MySQLParser::USING_SYMBOL);
        setState(2389);
        indexType();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2390);
        indexName();
        setState(2391);
        match(MySQLParser::TYPE_SYMBOL);
        setState(2392);
        indexType();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexTargetContext ------------------------------------------------------------------

MySQLParser::CreateIndexTargetContext::CreateIndexTargetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateIndexTargetContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::CreateIndexTargetContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::KeyListWithExpressionContext *MySQLParser::CreateIndexTargetContext::keyListWithExpression() {
  return getRuleContext<MySQLParser::KeyListWithExpressionContext>(0);
}

size_t MySQLParser::CreateIndexTargetContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndexTarget;
}

void MySQLParser::CreateIndexTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndexTarget(this);
}

void MySQLParser::CreateIndexTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndexTarget(this);
}

std::any MySQLParser::CreateIndexTargetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateIndexTarget(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateIndexTargetContext *MySQLParser::createIndexTarget() {
  CreateIndexTargetContext *_localctx = _tracker.createInstance<CreateIndexTargetContext>(_ctx, getState());
  enterRule(_localctx, 118, MySQLParser::RuleCreateIndexTarget);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2396);
    match(MySQLParser::ON_SYMBOL);
    setState(2397);
    tableRef();
    setState(2398);
    keyListWithExpression();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLogfileGroupContext ------------------------------------------------------------------

MySQLParser::CreateLogfileGroupContext::CreateLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupNameContext *MySQLParser::CreateLogfileGroupContext::logfileGroupName() {
  return getRuleContext<MySQLParser::LogfileGroupNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::CreateLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::LogfileGroupOptionsContext *MySQLParser::CreateLogfileGroupContext::logfileGroupOptions() {
  return getRuleContext<MySQLParser::LogfileGroupOptionsContext>(0);
}

size_t MySQLParser::CreateLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateLogfileGroup;
}

void MySQLParser::CreateLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLogfileGroup(this);
}

void MySQLParser::CreateLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLogfileGroup(this);
}

std::any MySQLParser::CreateLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateLogfileGroupContext *MySQLParser::createLogfileGroup() {
  CreateLogfileGroupContext *_localctx = _tracker.createInstance<CreateLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 120, MySQLParser::RuleCreateLogfileGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2400);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2401);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2402);
    logfileGroupName();
    setState(2403);
    match(MySQLParser::ADD_SYMBOL);
    setState(2404);
    match(MySQLParser::UNDOFILE_SYMBOL);
    setState(2405);
    textLiteral();
    setState(2407);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL ||
        _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NODEGROUP_SYMBOL

        || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL ||
        _la == MySQLParser::STORAGE_SYMBOL

        || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2406);
      logfileGroupOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionsContext::LogfileGroupOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LogfileGroupOptionContext *> MySQLParser::LogfileGroupOptionsContext::logfileGroupOption() {
  return getRuleContexts<MySQLParser::LogfileGroupOptionContext>();
}

MySQLParser::LogfileGroupOptionContext *MySQLParser::LogfileGroupOptionsContext::logfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::LogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::LogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOptions;
}

void MySQLParser::LogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOptions(this);
}

void MySQLParser::LogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOptions(this);
}

std::any MySQLParser::LogfileGroupOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLogfileGroupOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupOptionsContext *MySQLParser::logfileGroupOptions() {
  LogfileGroupOptionsContext *_localctx = _tracker.createInstance<LogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 122, MySQLParser::RuleLogfileGroupOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2409);
    logfileGroupOption();
    setState(2416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL ||
           _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NODEGROUP_SYMBOL

           || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL ||
           _la == MySQLParser::STORAGE_SYMBOL

           || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL ||
           _la == MySQLParser::COMMA_SYMBOL) {
      setState(2411);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2410);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(2413);
      logfileGroupOption();
      setState(2418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionContext::LogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext *MySQLParser::LogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext *MySQLParser::LogfileGroupOptionContext::tsOptionUndoRedoBufferSize() {
  return getRuleContext<MySQLParser::TsOptionUndoRedoBufferSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext *MySQLParser::LogfileGroupOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext *MySQLParser::LogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext *MySQLParser::LogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext *MySQLParser::LogfileGroupOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}

size_t MySQLParser::LogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOption;
}

void MySQLParser::LogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOption(this);
}

void MySQLParser::LogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOption(this);
}

std::any MySQLParser::LogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupOptionContext *MySQLParser::logfileGroupOption() {
  LogfileGroupOptionContext *_localctx = _tracker.createInstance<LogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 124, MySQLParser::RuleLogfileGroupOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2425);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2419);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
      case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2420);
        tsOptionUndoRedoBufferSize();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2421);
        tsOptionNodegroup();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2422);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2423);
        tsOptionWait();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2424);
        tsOptionComment();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateServerContext ------------------------------------------------------------------

MySQLParser::CreateServerContext::CreateServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerNameContext *MySQLParser::CreateServerContext::serverName() {
  return getRuleContext<MySQLParser::ServerNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateServerContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateServerContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateServerContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::CreateServerContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ServerOptionsContext *MySQLParser::CreateServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}

size_t MySQLParser::CreateServerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateServer;
}

void MySQLParser::CreateServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateServer(this);
}

void MySQLParser::CreateServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateServer(this);
}

std::any MySQLParser::CreateServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateServerContext *MySQLParser::createServer() {
  CreateServerContext *_localctx = _tracker.createInstance<CreateServerContext>(_ctx, getState());
  enterRule(_localctx, 126, MySQLParser::RuleCreateServer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2427);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2428);
    serverName();
    setState(2429);
    match(MySQLParser::FOREIGN_SYMBOL);
    setState(2430);
    match(MySQLParser::DATA_SYMBOL);
    setState(2431);
    match(MySQLParser::WRAPPER_SYMBOL);
    setState(2432);
    textOrIdentifier();
    setState(2433);
    serverOptions();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionsContext ------------------------------------------------------------------

MySQLParser::ServerOptionsContext::ServerOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ServerOptionsContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ServerOptionContext *> MySQLParser::ServerOptionsContext::serverOption() {
  return getRuleContexts<MySQLParser::ServerOptionContext>();
}

MySQLParser::ServerOptionContext *MySQLParser::ServerOptionsContext::serverOption(size_t i) {
  return getRuleContext<MySQLParser::ServerOptionContext>(i);
}

tree::TerminalNode *MySQLParser::ServerOptionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ServerOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ServerOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleServerOptions;
}

void MySQLParser::ServerOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOptions(this);
}

void MySQLParser::ServerOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOptions(this);
}

std::any MySQLParser::ServerOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitServerOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerOptionsContext *MySQLParser::serverOptions() {
  ServerOptionsContext *_localctx = _tracker.createInstance<ServerOptionsContext>(_ctx, getState());
  enterRule(_localctx, 128, MySQLParser::RuleServerOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2435);
    match(MySQLParser::OPTIONS_SYMBOL);
    setState(2436);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2437);
    serverOption();
    setState(2442);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2438);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2439);
      serverOption();
      setState(2444);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2445);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionContext ------------------------------------------------------------------

MySQLParser::ServerOptionContext::ServerOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext *MySQLParser::ServerOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::ServerOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::ServerOptionContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

size_t MySQLParser::ServerOptionContext::getRuleIndex() const {
  return MySQLParser::RuleServerOption;
}

void MySQLParser::ServerOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOption(this);
}

void MySQLParser::ServerOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOption(this);
}

std::any MySQLParser::ServerOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitServerOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerOptionContext *MySQLParser::serverOption() {
  ServerOptionContext *_localctx = _tracker.createInstance<ServerOptionContext>(_ctx, getState());
  enterRule(_localctx, 130, MySQLParser::RuleServerOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2461);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HOST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2447);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::HOST_SYMBOL);
        setState(2448);
        textLiteral();
        break;
      }

      case MySQLParser::DATABASE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2449);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::DATABASE_SYMBOL);
        setState(2450);
        textLiteral();
        break;
      }

      case MySQLParser::USER_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2451);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::USER_SYMBOL);
        setState(2452);
        textLiteral();
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2453);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
        setState(2454);
        textLiteral();
        break;
      }

      case MySQLParser::SOCKET_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2455);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::SOCKET_SYMBOL);
        setState(2456);
        textLiteral();
        break;
      }

      case MySQLParser::OWNER_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2457);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::OWNER_SYMBOL);
        setState(2458);
        textLiteral();
        break;
      }

      case MySQLParser::PORT_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2459);
        antlrcpp::downCast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PORT_SYMBOL);
        setState(2460);
        ulong_number();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateTablespaceContext::CreateTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext *MySQLParser::CreateTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

MySQLParser::TsDataFileNameContext *MySQLParser::CreateTablespaceContext::tsDataFileName() {
  return getRuleContext<MySQLParser::TsDataFileNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTablespaceContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTablespaceContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTablespaceContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext *MySQLParser::CreateTablespaceContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

MySQLParser::TablespaceOptionsContext *MySQLParser::CreateTablespaceContext::tablespaceOptions() {
  return getRuleContext<MySQLParser::TablespaceOptionsContext>(0);
}

size_t MySQLParser::CreateTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTablespace;
}

void MySQLParser::CreateTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespace(this);
}

void MySQLParser::CreateTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespace(this);
}

std::any MySQLParser::CreateTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTablespaceContext *MySQLParser::createTablespace() {
  CreateTablespaceContext *_localctx = _tracker.createInstance<CreateTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 132, MySQLParser::RuleCreateTablespace);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2463);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2464);
    tablespaceName();
    setState(2465);
    tsDataFileName();
    setState(2470);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 151, _ctx)) {
      case 1: {
        setState(2466);
        match(MySQLParser::USE_SYMBOL);
        setState(2467);
        match(MySQLParser::LOGFILE_SYMBOL);
        setState(2468);
        match(MySQLParser::GROUP_SYMBOL);
        setState(2469);
        logfileGroupRef();
        break;
      }

      default:
        break;
    }
    setState(2473);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 152, _ctx)) {
      case 1: {
        setState(2472);
        tablespaceOptions();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateUndoTablespaceContext::CreateUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext *MySQLParser::CreateUndoTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateUndoTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext *MySQLParser::CreateUndoTablespaceContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext *MySQLParser::CreateUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}

size_t MySQLParser::CreateUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUndoTablespace;
}

void MySQLParser::CreateUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUndoTablespace(this);
}

void MySQLParser::CreateUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUndoTablespace(this);
}

std::any MySQLParser::CreateUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUndoTablespaceContext *MySQLParser::createUndoTablespace() {
  CreateUndoTablespaceContext *_localctx = _tracker.createInstance<CreateUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 134, MySQLParser::RuleCreateUndoTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2475);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2476);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2477);
    tablespaceName();
    setState(2478);
    match(MySQLParser::ADD_SYMBOL);
    setState(2479);
    tsDataFile();
    setState(2481);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2480);
      undoTableSpaceOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileNameContext ------------------------------------------------------------------

MySQLParser::TsDataFileNameContext::TsDataFileNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsDataFileNameContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext *MySQLParser::TsDataFileNameContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}

size_t MySQLParser::TsDataFileNameContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFileName;
}

void MySQLParser::TsDataFileNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFileName(this);
}

void MySQLParser::TsDataFileNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFileName(this);
}

std::any MySQLParser::TsDataFileNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsDataFileName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsDataFileNameContext *MySQLParser::tsDataFileName() {
  TsDataFileNameContext *_localctx = _tracker.createInstance<TsDataFileNameContext>(_ctx, getState());
  enterRule(_localctx, 136, MySQLParser::RuleTsDataFileName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2490);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 155, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2483);
        match(MySQLParser::ADD_SYMBOL);
        setState(2484);
        tsDataFile();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2485);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(2488);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 154, _ctx)) {
          case 1: {
            setState(2486);
            match(MySQLParser::ADD_SYMBOL);
            setState(2487);
            tsDataFile();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileContext ------------------------------------------------------------------

MySQLParser::TsDataFileContext::TsDataFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsDataFileContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::TsDataFileContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

size_t MySQLParser::TsDataFileContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFile;
}

void MySQLParser::TsDataFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFile(this);
}

void MySQLParser::TsDataFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFile(this);
}

std::any MySQLParser::TsDataFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsDataFile(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsDataFileContext *MySQLParser::tsDataFile() {
  TsDataFileContext *_localctx = _tracker.createInstance<TsDataFileContext>(_ctx, getState());
  enterRule(_localctx, 138, MySQLParser::RuleTsDataFile);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2492);
    match(MySQLParser::DATAFILE_SYMBOL);
    setState(2493);
    textLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionsContext::TablespaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TablespaceOptionContext *> MySQLParser::TablespaceOptionsContext::tablespaceOption() {
  return getRuleContexts<MySQLParser::TablespaceOptionContext>();
}

MySQLParser::TablespaceOptionContext *MySQLParser::TablespaceOptionsContext::tablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::TablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOptions;
}

void MySQLParser::TablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOptions(this);
}

void MySQLParser::TablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOptions(this);
}

std::any MySQLParser::TablespaceOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTablespaceOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceOptionsContext *MySQLParser::tablespaceOptions() {
  TablespaceOptionsContext *_localctx = _tracker.createInstance<TablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 140, MySQLParser::RuleTablespaceOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2495);
    tablespaceOption();
    setState(2502);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2497);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 156, _ctx)) {
          case 1: {
            setState(2496);
            match(MySQLParser::COMMA_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(2499);
        tablespaceOption();
      }
      setState(2504);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionContext::TablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext *MySQLParser::TablespaceOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionAutoextendSizeContext *MySQLParser::TablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext *MySQLParser::TablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionExtentSizeContext *MySQLParser::TablespaceOptionContext::tsOptionExtentSize() {
  return getRuleContext<MySQLParser::TsOptionExtentSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext *MySQLParser::TablespaceOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext *MySQLParser::TablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext *MySQLParser::TablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext *MySQLParser::TablespaceOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}

MySQLParser::TsOptionFileblockSizeContext *MySQLParser::TablespaceOptionContext::tsOptionFileblockSize() {
  return getRuleContext<MySQLParser::TsOptionFileblockSizeContext>(0);
}

MySQLParser::TsOptionEncryptionContext *MySQLParser::TablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}

size_t MySQLParser::TablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOption;
}

void MySQLParser::TablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOption(this);
}

void MySQLParser::TablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOption(this);
}

std::any MySQLParser::TablespaceOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTablespaceOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceOptionContext *MySQLParser::tablespaceOption() {
  TablespaceOptionContext *_localctx = _tracker.createInstance<TablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 142, MySQLParser::RuleTablespaceOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2516);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2505);
        tsOptionInitialSize();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2506);
        tsOptionAutoextendSize();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(2507);
        tsOptionMaxSize();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(2508);
        tsOptionExtentSize();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(2509);
        tsOptionNodegroup();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(2510);
        tsOptionEngine();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(2511);
        tsOptionWait();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(2512);
        tsOptionComment();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(2513);
        tsOptionFileblockSize();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(2514);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(2515);
        tsOptionEncryption();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionInitialSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionInitialSizeContext::TsOptionInitialSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionInitialSizeContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionInitialSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionInitialSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionInitialSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionInitialSize;
}

void MySQLParser::TsOptionInitialSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionInitialSize(this);
}

void MySQLParser::TsOptionInitialSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionInitialSize(this);
}

std::any MySQLParser::TsOptionInitialSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionInitialSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionInitialSizeContext *MySQLParser::tsOptionInitialSize() {
  TsOptionInitialSizeContext *_localctx = _tracker.createInstance<TsOptionInitialSizeContext>(_ctx, getState());
  enterRule(_localctx, 144, MySQLParser::RuleTsOptionInitialSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2518);
    match(MySQLParser::INITIAL_SIZE_SYMBOL);
    setState(2520);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 159, _ctx)) {
      case 1: {
        setState(2519);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2522);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionUndoRedoBufferSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionUndoRedoBufferSizeContext::TsOptionUndoRedoBufferSizeContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionUndoRedoBufferSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionUndoRedoBufferSizeContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TsOptionUndoRedoBufferSizeContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TsOptionUndoRedoBufferSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionUndoRedoBufferSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionUndoRedoBufferSize;
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionUndoRedoBufferSize(this);
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionUndoRedoBufferSize(this);
}

std::any MySQLParser::TsOptionUndoRedoBufferSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionUndoRedoBufferSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext *MySQLParser::tsOptionUndoRedoBufferSize() {
  TsOptionUndoRedoBufferSizeContext *_localctx =
    _tracker.createInstance<TsOptionUndoRedoBufferSizeContext>(_ctx, getState());
  enterRule(_localctx, 146, MySQLParser::RuleTsOptionUndoRedoBufferSize);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2524);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2526);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
      case 1: {
        setState(2525);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2528);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionAutoextendSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionAutoextendSizeContext::TsOptionAutoextendSizeContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionAutoextendSizeContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionAutoextendSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionAutoextendSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionAutoextendSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionAutoextendSize;
}

void MySQLParser::TsOptionAutoextendSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionAutoextendSize(this);
}

void MySQLParser::TsOptionAutoextendSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionAutoextendSize(this);
}

std::any MySQLParser::TsOptionAutoextendSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionAutoextendSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionAutoextendSizeContext *MySQLParser::tsOptionAutoextendSize() {
  TsOptionAutoextendSizeContext *_localctx = _tracker.createInstance<TsOptionAutoextendSizeContext>(_ctx, getState());
  enterRule(_localctx, 148, MySQLParser::RuleTsOptionAutoextendSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2530);
    match(MySQLParser::AUTOEXTEND_SIZE_SYMBOL);
    setState(2532);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
      case 1: {
        setState(2531);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2534);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionMaxSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionMaxSizeContext::TsOptionMaxSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionMaxSizeContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionMaxSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionMaxSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionMaxSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionMaxSize;
}

void MySQLParser::TsOptionMaxSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionMaxSize(this);
}

void MySQLParser::TsOptionMaxSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionMaxSize(this);
}

std::any MySQLParser::TsOptionMaxSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionMaxSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionMaxSizeContext *MySQLParser::tsOptionMaxSize() {
  TsOptionMaxSizeContext *_localctx = _tracker.createInstance<TsOptionMaxSizeContext>(_ctx, getState());
  enterRule(_localctx, 150, MySQLParser::RuleTsOptionMaxSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2536);
    match(MySQLParser::MAX_SIZE_SYMBOL);
    setState(2538);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
      case 1: {
        setState(2537);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2540);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionExtentSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionExtentSizeContext::TsOptionExtentSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionExtentSizeContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionExtentSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionExtentSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionExtentSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionExtentSize;
}

void MySQLParser::TsOptionExtentSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionExtentSize(this);
}

void MySQLParser::TsOptionExtentSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionExtentSize(this);
}

std::any MySQLParser::TsOptionExtentSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionExtentSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionExtentSizeContext *MySQLParser::tsOptionExtentSize() {
  TsOptionExtentSizeContext *_localctx = _tracker.createInstance<TsOptionExtentSizeContext>(_ctx, getState());
  enterRule(_localctx, 152, MySQLParser::RuleTsOptionExtentSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2542);
    match(MySQLParser::EXTENT_SIZE_SYMBOL);
    setState(2544);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx)) {
      case 1: {
        setState(2543);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2546);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionNodegroupContext ------------------------------------------------------------------

MySQLParser::TsOptionNodegroupContext::TsOptionNodegroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionNodegroupContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::TsOptionNodegroupContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionNodegroupContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionNodegroupContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionNodegroup;
}

void MySQLParser::TsOptionNodegroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionNodegroup(this);
}

void MySQLParser::TsOptionNodegroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionNodegroup(this);
}

std::any MySQLParser::TsOptionNodegroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionNodegroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionNodegroupContext *MySQLParser::tsOptionNodegroup() {
  TsOptionNodegroupContext *_localctx = _tracker.createInstance<TsOptionNodegroupContext>(_ctx, getState());
  enterRule(_localctx, 154, MySQLParser::RuleTsOptionNodegroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2548);
    match(MySQLParser::NODEGROUP_SYMBOL);
    setState(2550);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR) {
      setState(2549);
      match(MySQLParser::EQUAL_OPERATOR);
    }
    setState(2552);
    real_ulong_number();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEngineContext ------------------------------------------------------------------

MySQLParser::TsOptionEngineContext::TsOptionEngineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionEngineContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineRefContext *MySQLParser::TsOptionEngineContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionEngineContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TsOptionEngineContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionEngineContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEngine;
}

void MySQLParser::TsOptionEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEngine(this);
}

void MySQLParser::TsOptionEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEngine(this);
}

std::any MySQLParser::TsOptionEngineContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionEngine(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionEngineContext *MySQLParser::tsOptionEngine() {
  TsOptionEngineContext *_localctx = _tracker.createInstance<TsOptionEngineContext>(_ctx, getState());
  enterRule(_localctx, 156, MySQLParser::RuleTsOptionEngine);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2555);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::STORAGE_SYMBOL) {
      setState(2554);
      match(MySQLParser::STORAGE_SYMBOL);
    }
    setState(2557);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(2559);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
      case 1: {
        setState(2558);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2561);
    engineRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionWaitContext ------------------------------------------------------------------

MySQLParser::TsOptionWaitContext::TsOptionWaitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionWaitContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TsOptionWaitContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

size_t MySQLParser::TsOptionWaitContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionWait;
}

void MySQLParser::TsOptionWaitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionWait(this);
}

void MySQLParser::TsOptionWaitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionWait(this);
}

std::any MySQLParser::TsOptionWaitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionWait(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionWaitContext *MySQLParser::tsOptionWait() {
  TsOptionWaitContext *_localctx = _tracker.createInstance<TsOptionWaitContext>(_ctx, getState());
  enterRule(_localctx, 158, MySQLParser::RuleTsOptionWait);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2563);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::WAIT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionCommentContext ------------------------------------------------------------------

MySQLParser::TsOptionCommentContext::TsOptionCommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionCommentContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::TsOptionCommentContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionCommentContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionCommentContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionComment;
}

void MySQLParser::TsOptionCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionComment(this);
}

void MySQLParser::TsOptionCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionComment(this);
}

std::any MySQLParser::TsOptionCommentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionComment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionCommentContext *MySQLParser::tsOptionComment() {
  TsOptionCommentContext *_localctx = _tracker.createInstance<TsOptionCommentContext>(_ctx, getState());
  enterRule(_localctx, 160, MySQLParser::RuleTsOptionComment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2565);
    match(MySQLParser::COMMENT_SYMBOL);
    setState(2567);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
      case 1: {
        setState(2566);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2569);
    textLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionFileblockSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionFileblockSizeContext::TsOptionFileblockSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionFileblockSizeContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext *MySQLParser::TsOptionFileblockSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionFileblockSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionFileblockSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionFileblockSize;
}

void MySQLParser::TsOptionFileblockSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionFileblockSize(this);
}

void MySQLParser::TsOptionFileblockSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionFileblockSize(this);
}

std::any MySQLParser::TsOptionFileblockSizeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionFileblockSize(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionFileblockSizeContext *MySQLParser::tsOptionFileblockSize() {
  TsOptionFileblockSizeContext *_localctx = _tracker.createInstance<TsOptionFileblockSizeContext>(_ctx, getState());
  enterRule(_localctx, 162, MySQLParser::RuleTsOptionFileblockSize);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2571);
    match(MySQLParser::FILE_BLOCK_SIZE_SYMBOL);
    setState(2573);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
      case 1: {
        setState(2572);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2575);
    sizeNumber();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEncryptionContext ------------------------------------------------------------------

MySQLParser::TsOptionEncryptionContext::TsOptionEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::TsOptionEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEncryption;
}

void MySQLParser::TsOptionEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEncryption(this);
}

void MySQLParser::TsOptionEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEncryption(this);
}

std::any MySQLParser::TsOptionEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionEncryption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionEncryptionContext *MySQLParser::tsOptionEncryption() {
  TsOptionEncryptionContext *_localctx = _tracker.createInstance<TsOptionEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 164, MySQLParser::RuleTsOptionEncryption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2577);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(2579);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
      case 1: {
        setState(2578);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2581);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEngineAttributeContext ------------------------------------------------------------------

MySQLParser::TsOptionEngineAttributeContext::TsOptionEngineAttributeContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TsOptionEngineAttributeContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::JsonAttributeContext *MySQLParser::TsOptionEngineAttributeContext::jsonAttribute() {
  return getRuleContext<MySQLParser::JsonAttributeContext>(0);
}

tree::TerminalNode *MySQLParser::TsOptionEngineAttributeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TsOptionEngineAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEngineAttribute;
}

void MySQLParser::TsOptionEngineAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEngineAttribute(this);
}

void MySQLParser::TsOptionEngineAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEngineAttribute(this);
}

std::any MySQLParser::TsOptionEngineAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTsOptionEngineAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TsOptionEngineAttributeContext *MySQLParser::tsOptionEngineAttribute() {
  TsOptionEngineAttributeContext *_localctx = _tracker.createInstance<TsOptionEngineAttributeContext>(_ctx, getState());
  enterRule(_localctx, 166, MySQLParser::RuleTsOptionEngineAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2583);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(2585);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 170, _ctx)) {
      case 1: {
        setState(2584);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(2587);
    jsonAttribute();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateViewContext ------------------------------------------------------------------

MySQLParser::CreateViewContext::CreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewNameContext *MySQLParser::CreateViewContext::viewName() {
  return getRuleContext<MySQLParser::ViewNameContext>(0);
}

MySQLParser::ViewTailContext *MySQLParser::CreateViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewReplaceOrAlgorithmContext *MySQLParser::CreateViewContext::viewReplaceOrAlgorithm() {
  return getRuleContext<MySQLParser::ViewReplaceOrAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::CreateViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext *MySQLParser::CreateViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}

size_t MySQLParser::CreateViewContext::getRuleIndex() const {
  return MySQLParser::RuleCreateView;
}

void MySQLParser::CreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateView(this);
}

void MySQLParser::CreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateView(this);
}

std::any MySQLParser::CreateViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateViewContext *MySQLParser::createView() {
  CreateViewContext *_localctx = _tracker.createInstance<CreateViewContext>(_ctx, getState());
  enterRule(_localctx, 168, MySQLParser::RuleCreateView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2590);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL || _la == MySQLParser::OR_SYMBOL) {
      setState(2589);
      viewReplaceOrAlgorithm();
    }
    setState(2593);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2592);
      definerClause();
    }
    setState(2596);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(2595);
      viewSuid();
    }
    setState(2598);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2599);
    viewName();
    setState(2600);
    viewTail();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewReplaceOrAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewReplaceOrAlgorithmContext::ViewReplaceOrAlgorithmContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ViewReplaceOrAlgorithmContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewReplaceOrAlgorithmContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::ViewAlgorithmContext *MySQLParser::ViewReplaceOrAlgorithmContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}

size_t MySQLParser::ViewReplaceOrAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewReplaceOrAlgorithm;
}

void MySQLParser::ViewReplaceOrAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewReplaceOrAlgorithm(this);
}

void MySQLParser::ViewReplaceOrAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewReplaceOrAlgorithm(this);
}

std::any MySQLParser::ViewReplaceOrAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewReplaceOrAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewReplaceOrAlgorithmContext *MySQLParser::viewReplaceOrAlgorithm() {
  ViewReplaceOrAlgorithmContext *_localctx = _tracker.createInstance<ViewReplaceOrAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 170, MySQLParser::RuleViewReplaceOrAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2608);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2602);
        match(MySQLParser::OR_SYMBOL);
        setState(2603);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2605);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(2604);
          viewAlgorithm();
        }
        break;
      }

      case MySQLParser::ALGORITHM_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2607);
        viewAlgorithm();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewAlgorithmContext::ViewAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ViewAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::ViewAlgorithmContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewAlgorithmContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewAlgorithmContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

size_t MySQLParser::ViewAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewAlgorithm;
}

void MySQLParser::ViewAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewAlgorithm(this);
}

void MySQLParser::ViewAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewAlgorithm(this);
}

std::any MySQLParser::ViewAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewAlgorithmContext *MySQLParser::viewAlgorithm() {
  ViewAlgorithmContext *_localctx = _tracker.createInstance<ViewAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 172, MySQLParser::RuleViewAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2610);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(2611);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(2612);
    antlrcpp::downCast<ViewAlgorithmContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MERGE_SYMBOL || _la == MySQLParser::TEMPTABLE_SYMBOL

          || _la == MySQLParser::UNDEFINED_SYMBOL)) {
      antlrcpp::downCast<ViewAlgorithmContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewSuidContext ------------------------------------------------------------------

MySQLParser::ViewSuidContext::ViewSuidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ViewSuidContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewSuidContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewSuidContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ViewSuidContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

size_t MySQLParser::ViewSuidContext::getRuleIndex() const {
  return MySQLParser::RuleViewSuid;
}

void MySQLParser::ViewSuidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewSuid(this);
}

void MySQLParser::ViewSuidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewSuid(this);
}

std::any MySQLParser::ViewSuidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewSuid(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewSuidContext *MySQLParser::viewSuid() {
  ViewSuidContext *_localctx = _tracker.createInstance<ViewSuidContext>(_ctx, getState());
  enterRule(_localctx, 174, MySQLParser::RuleViewSuid);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2614);
    match(MySQLParser::SQL_SYMBOL);
    setState(2615);
    match(MySQLParser::SECURITY_SYMBOL);
    setState(2616);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFINER_SYMBOL || _la == MySQLParser::INVOKER_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MySQLParser::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerNameContext *MySQLParser::CreateTriggerContext::triggerName() {
  return getRuleContext<MySQLParser::TriggerNameContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::CreateTriggerContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::EACH_SYMBOL() {
  return getToken(MySQLParser::EACH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext *MySQLParser::CreateTriggerContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTriggerContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

MySQLParser::DefinerClauseContext *MySQLParser::CreateTriggerContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateTriggerContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

MySQLParser::TriggerFollowsPrecedesClauseContext *MySQLParser::CreateTriggerContext::triggerFollowsPrecedesClause() {
  return getRuleContext<MySQLParser::TriggerFollowsPrecedesClauseContext>(0);
}

size_t MySQLParser::CreateTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTrigger;
}

void MySQLParser::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MySQLParser::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}

std::any MySQLParser::CreateTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTriggerContext *MySQLParser::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 176, MySQLParser::RuleCreateTrigger);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2618);
      definerClause();
    }
    setState(2621);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2623);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 177, _ctx)) {
      case 1: {
        setState(2622);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2625);
    triggerName();
    setState(2626);
    antlrcpp::downCast<CreateTriggerContext *>(_localctx)->timing = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::AFTER_SYMBOL

          || _la == MySQLParser::BEFORE_SYMBOL)) {
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->timing = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2627);
    antlrcpp::downCast<CreateTriggerContext *>(_localctx)->event = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELETE_SYMBOL || _la == MySQLParser::INSERT_SYMBOL ||
          _la == MySQLParser::UPDATE_SYMBOL)) {
      antlrcpp::downCast<CreateTriggerContext *>(_localctx)->event = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2628);
    match(MySQLParser::ON_SYMBOL);
    setState(2629);
    tableRef();
    setState(2630);
    match(MySQLParser::FOR_SYMBOL);
    setState(2631);
    match(MySQLParser::EACH_SYMBOL);
    setState(2632);
    match(MySQLParser::ROW_SYMBOL);
    setState(2634);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 178, _ctx)) {
      case 1: {
        setState(2633);
        triggerFollowsPrecedesClause();
        break;
      }

      default:
        break;
    }
    setState(2636);
    compoundStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerFollowsPrecedesClauseContext
//------------------------------------------------------------------

MySQLParser::TriggerFollowsPrecedesClauseContext::TriggerFollowsPrecedesClauseContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::TriggerFollowsPrecedesClauseContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::TriggerFollowsPrecedesClauseContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TriggerFollowsPrecedesClauseContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

size_t MySQLParser::TriggerFollowsPrecedesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerFollowsPrecedesClause;
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerFollowsPrecedesClause(this);
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerFollowsPrecedesClause(this);
}

std::any MySQLParser::TriggerFollowsPrecedesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTriggerFollowsPrecedesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerFollowsPrecedesClauseContext *MySQLParser::triggerFollowsPrecedesClause() {
  TriggerFollowsPrecedesClauseContext *_localctx =
    _tracker.createInstance<TriggerFollowsPrecedesClauseContext>(_ctx, getState());
  enterRule(_localctx, 178, MySQLParser::RuleTriggerFollowsPrecedesClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2638);
    antlrcpp::downCast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FOLLOWS_SYMBOL || _la == MySQLParser::PRECEDES_SYMBOL)) {
      antlrcpp::downCast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2639);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateEventContext ------------------------------------------------------------------

MySQLParser::CreateEventContext::CreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventNameContext *MySQLParser::CreateEventContext::eventName() {
  return getRuleContext<MySQLParser::EventNameContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::CreateEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext *MySQLParser::CreateEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext *MySQLParser::CreateEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext *MySQLParser::CreateEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateEventContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::CreateEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::CreateEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::CreateEventContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

size_t MySQLParser::CreateEventContext::getRuleIndex() const {
  return MySQLParser::RuleCreateEvent;
}

void MySQLParser::CreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateEvent(this);
}

void MySQLParser::CreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateEvent(this);
}

std::any MySQLParser::CreateEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateEventContext *MySQLParser::createEvent() {
  CreateEventContext *_localctx = _tracker.createInstance<CreateEventContext>(_ctx, getState());
  enterRule(_localctx, 180, MySQLParser::RuleCreateEvent);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2642);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2641);
      definerClause();
    }
    setState(2644);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2646);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 180, _ctx)) {
      case 1: {
        setState(2645);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2648);
    eventName();
    setState(2649);
    match(MySQLParser::ON_SYMBOL);
    setState(2650);
    match(MySQLParser::SCHEDULE_SYMBOL);
    setState(2651);
    schedule();
    setState(2658);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(2652);
      match(MySQLParser::ON_SYMBOL);
      setState(2653);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(2655);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(2654);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(2657);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(2666);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(2660);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(2661);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(2664);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(2662);
          match(MySQLParser::ON_SYMBOL);
          setState(2663);
          replica();
        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL: {
        break;
      }

      default:
        break;
    }
    setState(2670);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(2668);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(2669);
      textLiteral();
    }
    setState(2672);
    match(MySQLParser::DO_SYMBOL);
    setState(2673);
    compoundStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MySQLParser::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::CreateRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateRoleContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

size_t MySQLParser::CreateRoleContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRole;
}

void MySQLParser::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MySQLParser::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}

std::any MySQLParser::CreateRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateRoleContext *MySQLParser::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 182, MySQLParser::RuleCreateRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2675);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2677);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 186, _ctx)) {
      case 1: {
        setState(2676);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(2679);
    roleList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::CreateSpatialReferenceContext::CreateSpatialReferenceContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateSpatialReferenceContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateSpatialReferenceContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::CreateSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

std::vector<MySQLParser::SrsAttributeContext *> MySQLParser::CreateSpatialReferenceContext::srsAttribute() {
  return getRuleContexts<MySQLParser::SrsAttributeContext>();
}

MySQLParser::SrsAttributeContext *MySQLParser::CreateSpatialReferenceContext::srsAttribute(size_t i) {
  return getRuleContext<MySQLParser::SrsAttributeContext>(i);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateSpatialReferenceContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

size_t MySQLParser::CreateSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateSpatialReference;
}

void MySQLParser::CreateSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateSpatialReference(this);
}

void MySQLParser::CreateSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateSpatialReference(this);
}

std::any MySQLParser::CreateSpatialReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateSpatialReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateSpatialReferenceContext *MySQLParser::createSpatialReference() {
  CreateSpatialReferenceContext *_localctx = _tracker.createInstance<CreateSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 184, MySQLParser::RuleCreateSpatialReference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2706);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2681);
        match(MySQLParser::OR_SYMBOL);
        setState(2682);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2683);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2684);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2685);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2686);
        real_ulonglong_number();
        setState(2690);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL ||
               ((((_la - 715) & ~0x3fULL) == 0) && ((1ULL << (_la - 715)) & 7) != 0)) {
          setState(2687);
          srsAttribute();
          setState(2692);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2693);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2694);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2695);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2697);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 188, _ctx)) {
          case 1: {
            setState(2696);
            ifNotExists();
            break;
          }

          default:
            break;
        }
        setState(2699);
        real_ulonglong_number();
        setState(2703);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL ||
               ((((_la - 715) & ~0x3fULL) == 0) && ((1ULL << (_la - 715)) & 7) != 0)) {
          setState(2700);
          srsAttribute();
          setState(2705);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrsAttributeContext ------------------------------------------------------------------

MySQLParser::SrsAttributeContext::SrsAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::SrsAttributeContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::DEFINITION_SYMBOL() {
  return getToken(MySQLParser::DEFINITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::SrsAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::SrsAttributeContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

size_t MySQLParser::SrsAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleSrsAttribute;
}

void MySQLParser::SrsAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrsAttribute(this);
}

void MySQLParser::SrsAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrsAttribute(this);
}

std::any MySQLParser::SrsAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSrsAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SrsAttributeContext *MySQLParser::srsAttribute() {
  SrsAttributeContext *_localctx = _tracker.createInstance<SrsAttributeContext>(_ctx, getState());
  enterRule(_localctx, 186, MySQLParser::RuleSrsAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2723);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NAME_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2708);
        match(MySQLParser::NAME_SYMBOL);
        setState(2709);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2710);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::DEFINITION_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2711);
        match(MySQLParser::DEFINITION_SYMBOL);
        setState(2712);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2713);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::ORGANIZATION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2714);
        match(MySQLParser::ORGANIZATION_SYMBOL);
        setState(2715);
        textStringNoLinebreak();
        setState(2716);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(2717);
        match(MySQLParser::BY_SYMBOL);
        setState(2718);
        real_ulonglong_number();
        break;
      }

      case MySQLParser::DESCRIPTION_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2720);
        match(MySQLParser::DESCRIPTION_SYMBOL);
        setState(2721);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2722);
        textStringNoLinebreak();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropStatementContext ------------------------------------------------------------------

MySQLParser::DropStatementContext::DropStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::DropDatabaseContext *MySQLParser::DropStatementContext::dropDatabase() {
  return getRuleContext<MySQLParser::DropDatabaseContext>(0);
}

MySQLParser::DropEventContext *MySQLParser::DropStatementContext::dropEvent() {
  return getRuleContext<MySQLParser::DropEventContext>(0);
}

MySQLParser::DropFunctionContext *MySQLParser::DropStatementContext::dropFunction() {
  return getRuleContext<MySQLParser::DropFunctionContext>(0);
}

MySQLParser::DropProcedureContext *MySQLParser::DropStatementContext::dropProcedure() {
  return getRuleContext<MySQLParser::DropProcedureContext>(0);
}

MySQLParser::DropIndexContext *MySQLParser::DropStatementContext::dropIndex() {
  return getRuleContext<MySQLParser::DropIndexContext>(0);
}

MySQLParser::DropLogfileGroupContext *MySQLParser::DropStatementContext::dropLogfileGroup() {
  return getRuleContext<MySQLParser::DropLogfileGroupContext>(0);
}

MySQLParser::DropServerContext *MySQLParser::DropStatementContext::dropServer() {
  return getRuleContext<MySQLParser::DropServerContext>(0);
}

MySQLParser::DropTableContext *MySQLParser::DropStatementContext::dropTable() {
  return getRuleContext<MySQLParser::DropTableContext>(0);
}

MySQLParser::DropTableSpaceContext *MySQLParser::DropStatementContext::dropTableSpace() {
  return getRuleContext<MySQLParser::DropTableSpaceContext>(0);
}

MySQLParser::DropTriggerContext *MySQLParser::DropStatementContext::dropTrigger() {
  return getRuleContext<MySQLParser::DropTriggerContext>(0);
}

MySQLParser::DropViewContext *MySQLParser::DropStatementContext::dropView() {
  return getRuleContext<MySQLParser::DropViewContext>(0);
}

MySQLParser::DropRoleContext *MySQLParser::DropStatementContext::dropRole() {
  return getRuleContext<MySQLParser::DropRoleContext>(0);
}

MySQLParser::DropSpatialReferenceContext *MySQLParser::DropStatementContext::dropSpatialReference() {
  return getRuleContext<MySQLParser::DropSpatialReferenceContext>(0);
}

MySQLParser::DropUndoTablespaceContext *MySQLParser::DropStatementContext::dropUndoTablespace() {
  return getRuleContext<MySQLParser::DropUndoTablespaceContext>(0);
}

size_t MySQLParser::DropStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDropStatement;
}

void MySQLParser::DropStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropStatement(this);
}

void MySQLParser::DropStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropStatement(this);
}

std::any MySQLParser::DropStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropStatementContext *MySQLParser::dropStatement() {
  DropStatementContext *_localctx = _tracker.createInstance<DropStatementContext>(_ctx, getState());
  enterRule(_localctx, 188, MySQLParser::RuleDropStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2725);
    match(MySQLParser::DROP_SYMBOL);
    setState(2742);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
      case 1: {
        setState(2726);
        dropDatabase();
        break;
      }

      case 2: {
        setState(2727);
        dropEvent();
        break;
      }

      case 3: {
        setState(2728);
        dropFunction();
        break;
      }

      case 4: {
        setState(2729);
        dropProcedure();
        break;
      }

      case 5: {
        setState(2730);
        dropIndex();
        break;
      }

      case 6: {
        setState(2731);
        dropLogfileGroup();
        break;
      }

      case 7: {
        setState(2732);
        dropServer();
        break;
      }

      case 8: {
        setState(2733);
        dropTable();
        break;
      }

      case 9: {
        setState(2734);
        dropTableSpace();
        break;
      }

      case 10: {
        setState(2735);
        dropTrigger();
        break;
      }

      case 11: {
        setState(2736);
        dropView();
        break;
      }

      case 12: {
        setState(2737);
        dropRole();
        break;
      }

      case 13: {
        setState(2738);

        if (!(serverVersion >= 80011))
          throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(2739);
        dropSpatialReference();
        break;
      }

      case 14: {
        setState(2740);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(2741);
        dropUndoTablespace();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropDatabaseContext ------------------------------------------------------------------

MySQLParser::DropDatabaseContext::DropDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext *MySQLParser::DropDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropDatabaseContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleDropDatabase;
}

void MySQLParser::DropDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropDatabase(this);
}

void MySQLParser::DropDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropDatabase(this);
}

std::any MySQLParser::DropDatabaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropDatabase(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropDatabaseContext *MySQLParser::dropDatabase() {
  DropDatabaseContext *_localctx = _tracker.createInstance<DropDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 190, MySQLParser::RuleDropDatabase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2744);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(2746);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 193, _ctx)) {
      case 1: {
        setState(2745);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2748);
    schemaRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropEventContext ------------------------------------------------------------------

MySQLParser::DropEventContext::DropEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext *MySQLParser::DropEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropEventContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropEventContext::getRuleIndex() const {
  return MySQLParser::RuleDropEvent;
}

void MySQLParser::DropEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropEvent(this);
}

void MySQLParser::DropEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropEvent(this);
}

std::any MySQLParser::DropEventContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropEvent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropEventContext *MySQLParser::dropEvent() {
  DropEventContext *_localctx = _tracker.createInstance<DropEventContext>(_ctx, getState());
  enterRule(_localctx, 192, MySQLParser::RuleDropEvent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2750);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2752);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 194, _ctx)) {
      case 1: {
        setState(2751);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2754);
    eventRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropFunctionContext ------------------------------------------------------------------

MySQLParser::DropFunctionContext::DropFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext *MySQLParser::DropFunctionContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropFunctionContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleDropFunction;
}

void MySQLParser::DropFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropFunction(this);
}

void MySQLParser::DropFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropFunction(this);
}

std::any MySQLParser::DropFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropFunctionContext *MySQLParser::dropFunction() {
  DropFunctionContext *_localctx = _tracker.createInstance<DropFunctionContext>(_ctx, getState());
  enterRule(_localctx, 194, MySQLParser::RuleDropFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2756);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2758);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 195, _ctx)) {
      case 1: {
        setState(2757);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2760);
    functionRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropProcedureContext ------------------------------------------------------------------

MySQLParser::DropProcedureContext::DropProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext *MySQLParser::DropProcedureContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropProcedureContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleDropProcedure;
}

void MySQLParser::DropProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropProcedure(this);
}

void MySQLParser::DropProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropProcedure(this);
}

std::any MySQLParser::DropProcedureContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropProcedure(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropProcedureContext *MySQLParser::dropProcedure() {
  DropProcedureContext *_localctx = _tracker.createInstance<DropProcedureContext>(_ctx, getState());
  enterRule(_localctx, 196, MySQLParser::RuleDropProcedure);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2762);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(2764);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
      case 1: {
        setState(2763);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2766);
    procedureRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MySQLParser::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexRefContext *MySQLParser::DropIndexContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

tree::TerminalNode *MySQLParser::DropIndexContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::DropIndexContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::DropIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::OnlineOptionContext *MySQLParser::DropIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

MySQLParser::IndexLockAndAlgorithmContext *MySQLParser::DropIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}

size_t MySQLParser::DropIndexContext::getRuleIndex() const {
  return MySQLParser::RuleDropIndex;
}

void MySQLParser::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MySQLParser::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}

std::any MySQLParser::DropIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropIndexContext *MySQLParser::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 198, MySQLParser::RuleDropIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OFFLINE_SYMBOL

        || _la == MySQLParser::ONLINE_SYMBOL) {
      setState(2768);
      onlineOption();
    }
    setState(2771);
    antlrcpp::downCast<DropIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
    setState(2772);
    indexRef();
    setState(2773);
    match(MySQLParser::ON_SYMBOL);
    setState(2774);
    tableRef();
    setState(2776);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
      setState(2775);
      indexLockAndAlgorithm();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupContext::DropLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext *MySQLParser::DropLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *>
MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext *MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::DropLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroup;
}

void MySQLParser::DropLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroup(this);
}

void MySQLParser::DropLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroup(this);
}

std::any MySQLParser::DropLogfileGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropLogfileGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropLogfileGroupContext *MySQLParser::dropLogfileGroup() {
  DropLogfileGroupContext *_localctx = _tracker.createInstance<DropLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 200, MySQLParser::RuleDropLogfileGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2778);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2779);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2780);
    logfileGroupRef();
    setState(2791);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL ||
        _la == MySQLParser::WAIT_SYMBOL) {
      setState(2781);
      dropLogfileGroupOption();
      setState(2788);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL ||
             _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL ||
             _la == MySQLParser::COMMA_SYMBOL) {
        setState(2783);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2782);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2785);
        dropLogfileGroupOption();
        setState(2790);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupOptionContext::DropLogfileGroupOptionContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionWaitContext *MySQLParser::DropLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEngineContext *MySQLParser::DropLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

size_t MySQLParser::DropLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroupOption;
}

void MySQLParser::DropLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroupOption(this);
}

void MySQLParser::DropLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroupOption(this);
}

std::any MySQLParser::DropLogfileGroupOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropLogfileGroupOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropLogfileGroupOptionContext *MySQLParser::dropLogfileGroupOption() {
  DropLogfileGroupOptionContext *_localctx = _tracker.createInstance<DropLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 202, MySQLParser::RuleDropLogfileGroupOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2795);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2793);
        tsOptionWait();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2794);
        tsOptionEngine();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropServerContext ------------------------------------------------------------------

MySQLParser::DropServerContext::DropServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext *MySQLParser::DropServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropServerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropServerContext::getRuleIndex() const {
  return MySQLParser::RuleDropServer;
}

void MySQLParser::DropServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropServer(this);
}

void MySQLParser::DropServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropServer(this);
}

std::any MySQLParser::DropServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropServerContext *MySQLParser::dropServer() {
  DropServerContext *_localctx = _tracker.createInstance<DropServerContext>(_ctx, getState());
  enterRule(_localctx, 204, MySQLParser::RuleDropServer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2797);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2799);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 203, _ctx)) {
      case 1: {
        setState(2798);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2801);
    serverRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableContext ------------------------------------------------------------------

MySQLParser::DropTableContext::DropTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefListContext *MySQLParser::DropTableContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode *MySQLParser::DropTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropTableContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfExistsContext *MySQLParser::DropTableContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode *MySQLParser::DropTableContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropTableContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

size_t MySQLParser::DropTableContext::getRuleIndex() const {
  return MySQLParser::RuleDropTable;
}

void MySQLParser::DropTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTable(this);
}

void MySQLParser::DropTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTable(this);
}

std::any MySQLParser::DropTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTableContext *MySQLParser::dropTable() {
  DropTableContext *_localctx = _tracker.createInstance<DropTableContext>(_ctx, getState());
  enterRule(_localctx, 206, MySQLParser::RuleDropTable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2804);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(2803);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(2806);
    antlrcpp::downCast<DropTableContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

          || _la == MySQLParser::TABLE_SYMBOL)) {
      antlrcpp::downCast<DropTableContext *>(_localctx)->type = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2808);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 205, _ctx)) {
      case 1: {
        setState(2807);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2810);
    tableRefList();
    setState(2812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2811);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableSpaceContext ------------------------------------------------------------------

MySQLParser::DropTableSpaceContext::DropTableSpaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropTableSpaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext *MySQLParser::DropTableSpaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *> MySQLParser::DropTableSpaceContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext *MySQLParser::DropTableSpaceContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropTableSpaceContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::DropTableSpaceContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::DropTableSpaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropTableSpace;
}

void MySQLParser::DropTableSpaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTableSpace(this);
}

void MySQLParser::DropTableSpaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTableSpace(this);
}

std::any MySQLParser::DropTableSpaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropTableSpace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTableSpaceContext *MySQLParser::dropTableSpace() {
  DropTableSpaceContext *_localctx = _tracker.createInstance<DropTableSpaceContext>(_ctx, getState());
  enterRule(_localctx, 208, MySQLParser::RuleDropTableSpace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2814);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2815);
    tablespaceRef();
    setState(2826);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL ||
        _la == MySQLParser::WAIT_SYMBOL) {
      setState(2816);
      dropLogfileGroupOption();
      setState(2823);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL ||
             _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL ||
             _la == MySQLParser::COMMA_SYMBOL) {
        setState(2818);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2817);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2820);
        dropLogfileGroupOption();
        setState(2825);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MySQLParser::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerRefContext *MySQLParser::DropTriggerContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropTriggerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleDropTrigger;
}

void MySQLParser::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MySQLParser::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}

std::any MySQLParser::DropTriggerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropTrigger(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropTriggerContext *MySQLParser::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 210, MySQLParser::RuleDropTrigger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2828);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 210, _ctx)) {
      case 1: {
        setState(2829);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2832);
    triggerRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropViewContext ------------------------------------------------------------------

MySQLParser::DropViewContext::DropViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefListContext *MySQLParser::DropViewContext::viewRefList() {
  return getRuleContext<MySQLParser::ViewRefListContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropViewContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode *MySQLParser::DropViewContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropViewContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

size_t MySQLParser::DropViewContext::getRuleIndex() const {
  return MySQLParser::RuleDropView;
}

void MySQLParser::DropViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropView(this);
}

void MySQLParser::DropViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropView(this);
}

std::any MySQLParser::DropViewContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropView(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropViewContext *MySQLParser::dropView() {
  DropViewContext *_localctx = _tracker.createInstance<DropViewContext>(_ctx, getState());
  enterRule(_localctx, 212, MySQLParser::RuleDropView);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2834);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2836);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 211, _ctx)) {
      case 1: {
        setState(2835);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2838);
    viewRefList();
    setState(2840);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2839);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MySQLParser::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::DropRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropRoleContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropRoleContext::getRuleIndex() const {
  return MySQLParser::RuleDropRole;
}

void MySQLParser::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MySQLParser::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}

std::any MySQLParser::DropRoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropRoleContext *MySQLParser::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 214, MySQLParser::RuleDropRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2842);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2844);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 213, _ctx)) {
      case 1: {
        setState(2843);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2846);
    roleList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::DropSpatialReferenceContext::DropSpatialReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::DropSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropSpatialReferenceContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleDropSpatialReference;
}

void MySQLParser::DropSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropSpatialReference(this);
}

void MySQLParser::DropSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropSpatialReference(this);
}

std::any MySQLParser::DropSpatialReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropSpatialReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropSpatialReferenceContext *MySQLParser::dropSpatialReference() {
  DropSpatialReferenceContext *_localctx = _tracker.createInstance<DropSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 216, MySQLParser::RuleDropSpatialReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2848);
    match(MySQLParser::SPATIAL_SYMBOL);
    setState(2849);
    match(MySQLParser::REFERENCE_SYMBOL);
    setState(2850);
    match(MySQLParser::SYSTEM_SYMBOL);
    setState(2852);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
      case 1: {
        setState(2851);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(2854);
    real_ulonglong_number();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::DropUndoTablespaceContext::DropUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext *MySQLParser::DropUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext *MySQLParser::DropUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}

size_t MySQLParser::DropUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropUndoTablespace;
}

void MySQLParser::DropUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUndoTablespace(this);
}

void MySQLParser::DropUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUndoTablespace(this);
}

std::any MySQLParser::DropUndoTablespaceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropUndoTablespace(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropUndoTablespaceContext *MySQLParser::dropUndoTablespace() {
  DropUndoTablespaceContext *_localctx = _tracker.createInstance<DropUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 218, MySQLParser::RuleDropUndoTablespace);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2856);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2857);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2858);
    tablespaceRef();
    setState(2860);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2859);
      undoTableSpaceOptions();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableStatementContext ------------------------------------------------------------------

MySQLParser::RenameTableStatementContext::RenameTableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RenameTableStatementContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

std::vector<MySQLParser::RenamePairContext *> MySQLParser::RenameTableStatementContext::renamePair() {
  return getRuleContexts<MySQLParser::RenamePairContext>();
}

MySQLParser::RenamePairContext *MySQLParser::RenameTableStatementContext::renamePair(size_t i) {
  return getRuleContext<MySQLParser::RenamePairContext>(i);
}

tree::TerminalNode *MySQLParser::RenameTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RenameTableStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameTableStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::RenameTableStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::RenameTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleRenameTableStatement;
}

void MySQLParser::RenameTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTableStatement(this);
}

void MySQLParser::RenameTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTableStatement(this);
}

std::any MySQLParser::RenameTableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRenameTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenameTableStatementContext *MySQLParser::renameTableStatement() {
  RenameTableStatementContext *_localctx = _tracker.createInstance<RenameTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 220, MySQLParser::RuleRenameTableStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2862);
    match(MySQLParser::RENAME_SYMBOL);
    setState(2863);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

          || _la == MySQLParser::TABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2864);
    renamePair();
    setState(2869);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2865);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2866);
      renamePair();
      setState(2871);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenamePairContext ------------------------------------------------------------------

MySQLParser::RenamePairContext::RenamePairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::RenamePairContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::RenamePairContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TableNameContext *MySQLParser::RenamePairContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

size_t MySQLParser::RenamePairContext::getRuleIndex() const {
  return MySQLParser::RuleRenamePair;
}

void MySQLParser::RenamePairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenamePair(this);
}

void MySQLParser::RenamePairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenamePair(this);
}

std::any MySQLParser::RenamePairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRenamePair(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenamePairContext *MySQLParser::renamePair() {
  RenamePairContext *_localctx = _tracker.createInstance<RenamePairContext>(_ctx, getState());
  enterRule(_localctx, 222, MySQLParser::RuleRenamePair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2872);
    tableRef();
    setState(2873);
    match(MySQLParser::TO_SYMBOL);
    setState(2874);
    tableName();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateTableStatementContext ------------------------------------------------------------------

MySQLParser::TruncateTableStatementContext::TruncateTableStatementContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TruncateTableStatementContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::TruncateTableStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::TruncateTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

size_t MySQLParser::TruncateTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTruncateTableStatement;
}

void MySQLParser::TruncateTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncateTableStatement(this);
}

void MySQLParser::TruncateTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncateTableStatement(this);
}

std::any MySQLParser::TruncateTableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTruncateTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TruncateTableStatementContext *MySQLParser::truncateTableStatement() {
  TruncateTableStatementContext *_localctx = _tracker.createInstance<TruncateTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 224, MySQLParser::RuleTruncateTableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2876);
    match(MySQLParser::TRUNCATE_SYMBOL);
    setState(2878);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
      case 1: {
        setState(2877);
        match(MySQLParser::TABLE_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(2880);
    tableRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

MySQLParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ImportStatementContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ImportStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ImportStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext *MySQLParser::ImportStatementContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}

size_t MySQLParser::ImportStatementContext::getRuleIndex() const {
  return MySQLParser::RuleImportStatement;
}

void MySQLParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void MySQLParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

std::any MySQLParser::ImportStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitImportStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ImportStatementContext *MySQLParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 226, MySQLParser::RuleImportStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2882);
    match(MySQLParser::IMPORT_SYMBOL);
    setState(2883);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2884);
    match(MySQLParser::FROM_SYMBOL);
    setState(2885);
    textStringLiteralList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallStatementContext ------------------------------------------------------------------

MySQLParser::CallStatementContext::CallStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CallStatementContext::CALL_SYMBOL() {
  return getToken(MySQLParser::CALL_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext *MySQLParser::CallStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode *MySQLParser::CallStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CallStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::CallStatementContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

size_t MySQLParser::CallStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCallStatement;
}

void MySQLParser::CallStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallStatement(this);
}

void MySQLParser::CallStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallStatement(this);
}

std::any MySQLParser::CallStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCallStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CallStatementContext *MySQLParser::callStatement() {
  CallStatementContext *_localctx = _tracker.createInstance<CallStatementContext>(_ctx, getState());
  enterRule(_localctx, 228, MySQLParser::RuleCallStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2887);
    match(MySQLParser::CALL_SYMBOL);
    setState(2888);
    procedureRef();
    setState(2894);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2889);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2891);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
        case 1: {
          setState(2890);
          exprList();
          break;
        }

        default:
          break;
      }
      setState(2893);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

MySQLParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DeleteStatementContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext *MySQLParser::DeleteStatementContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::TableReferenceListContext *MySQLParser::DeleteStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::WithClauseContext *MySQLParser::DeleteStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

std::vector<MySQLParser::DeleteStatementOptionContext *> MySQLParser::DeleteStatementContext::deleteStatementOption() {
  return getRuleContexts<MySQLParser::DeleteStatementOptionContext>();
}

MySQLParser::DeleteStatementOptionContext *MySQLParser::DeleteStatementContext::deleteStatementOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteStatementOptionContext>(i);
}

tree::TerminalNode *MySQLParser::DeleteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::DeleteStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WhereClauseContext *MySQLParser::DeleteStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::TableAliasContext *MySQLParser::DeleteStatementContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::PartitionDeleteContext *MySQLParser::DeleteStatementContext::partitionDelete() {
  return getRuleContext<MySQLParser::PartitionDeleteContext>(0);
}

MySQLParser::OrderClauseContext *MySQLParser::DeleteStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext *MySQLParser::DeleteStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}

size_t MySQLParser::DeleteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatement;
}

void MySQLParser::DeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatement(this);
}

void MySQLParser::DeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatement(this);
}

std::any MySQLParser::DeleteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDeleteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteStatementContext *MySQLParser::deleteStatement() {
  DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 230, MySQLParser::RuleDeleteStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2897);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(2896);
      withClause();
    }
    setState(2899);
    match(MySQLParser::DELETE_SYMBOL);
    setState(2903);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2900);
        deleteStatementOption();
      }
      setState(2905);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx);
    }
    setState(2938);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 230, _ctx)) {
      case 1: {
        setState(2906);
        match(MySQLParser::FROM_SYMBOL);
        setState(2930);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
          case 1: {
            setState(2907);
            tableAliasRefList();
            setState(2908);
            match(MySQLParser::USING_SYMBOL);
            setState(2909);
            tableReferenceList();
            setState(2911);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::WHERE_SYMBOL) {
              setState(2910);
              whereClause();
            }
            break;
          }

          case 2: {
            setState(2913);
            tableRef();
            setState(2916);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 223, _ctx)) {
              case 1: {
                setState(2914);

                if (!(serverVersion >= 80017))
                  throw FailedPredicateException(this, "serverVersion >= 80017");
                setState(2915);
                tableAlias();
                break;
              }

              default:
                break;
            }
            setState(2919);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::PARTITION_SYMBOL) {
              setState(2918);
              partitionDelete();
            }
            setState(2922);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::WHERE_SYMBOL) {
              setState(2921);
              whereClause();
            }
            setState(2925);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::ORDER_SYMBOL) {
              setState(2924);
              orderClause();
            }
            setState(2928);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::LIMIT_SYMBOL) {
              setState(2927);
              simpleLimitClause();
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(2932);
        tableAliasRefList();
        setState(2933);
        match(MySQLParser::FROM_SYMBOL);
        setState(2934);
        tableReferenceList();
        setState(2936);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WHERE_SYMBOL) {
          setState(2935);
          whereClause();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDeleteContext ------------------------------------------------------------------

MySQLParser::PartitionDeleteContext::PartitionDeleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionDeleteContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDeleteContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::PartitionDeleteContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionDeleteContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::PartitionDeleteContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDelete;
}

void MySQLParser::PartitionDeleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDelete(this);
}

void MySQLParser::PartitionDeleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDelete(this);
}

std::any MySQLParser::PartitionDeleteContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDelete(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDeleteContext *MySQLParser::partitionDelete() {
  PartitionDeleteContext *_localctx = _tracker.createInstance<PartitionDeleteContext>(_ctx, getState());
  enterRule(_localctx, 232, MySQLParser::RulePartitionDelete);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2940);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(2941);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2942);
    identifierList();
    setState(2943);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementOptionContext ------------------------------------------------------------------

MySQLParser::DeleteStatementOptionContext::DeleteStatementOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DeleteStatementOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteStatementOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteStatementOptionContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

size_t MySQLParser::DeleteStatementOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatementOption;
}

void MySQLParser::DeleteStatementOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatementOption(this);
}

void MySQLParser::DeleteStatementOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatementOption(this);
}

std::any MySQLParser::DeleteStatementOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDeleteStatementOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteStatementOptionContext *MySQLParser::deleteStatementOption() {
  DeleteStatementOptionContext *_localctx = _tracker.createInstance<DeleteStatementOptionContext>(_ctx, getState());
  enterRule(_localctx, 234, MySQLParser::RuleDeleteStatementOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2945);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::IGNORE_SYMBOL

          || _la == MySQLParser::LOW_PRIORITY_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

MySQLParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DoStatementContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::SelectItemListContext *MySQLParser::DoStatementContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}

size_t MySQLParser::DoStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDoStatement;
}

void MySQLParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}

void MySQLParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}

std::any MySQLParser::DoStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDoStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DoStatementContext *MySQLParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 236, MySQLParser::RuleDoStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2947);
    match(MySQLParser::DO_SYMBOL);
    setState(2948);
    selectItemList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerStatementContext ------------------------------------------------------------------

MySQLParser::HandlerStatementContext::HandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HandlerStatementContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::HandlerStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::HandlerStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerStatementContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerStatementContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

MySQLParser::HandlerReadOrScanContext *MySQLParser::HandlerStatementContext::handlerReadOrScan() {
  return getRuleContext<MySQLParser::HandlerReadOrScanContext>(0);
}

MySQLParser::TableAliasContext *MySQLParser::HandlerStatementContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::WhereClauseContext *MySQLParser::HandlerStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::LimitClauseContext *MySQLParser::HandlerStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

size_t MySQLParser::HandlerStatementContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerStatement;
}

void MySQLParser::HandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerStatement(this);
}

void MySQLParser::HandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerStatement(this);
}

std::any MySQLParser::HandlerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHandlerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerStatementContext *MySQLParser::handlerStatement() {
  HandlerStatementContext *_localctx = _tracker.createInstance<HandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 238, MySQLParser::RuleHandlerStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2950);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(2968);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
      case 1: {
        setState(2951);
        tableRef();
        setState(2952);
        match(MySQLParser::OPEN_SYMBOL);
        setState(2954);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 231, _ctx)) {
          case 1: {
            setState(2953);
            tableAlias();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(2956);
        identifier();
        setState(2966);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::CLOSE_SYMBOL: {
            setState(2957);
            match(MySQLParser::CLOSE_SYMBOL);
            break;
          }

          case MySQLParser::READ_SYMBOL: {
            setState(2958);
            match(MySQLParser::READ_SYMBOL);
            setState(2959);
            handlerReadOrScan();
            setState(2961);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::WHERE_SYMBOL) {
              setState(2960);
              whereClause();
            }
            setState(2964);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::LIMIT_SYMBOL) {
              setState(2963);
              limitClause();
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadOrScanContext ------------------------------------------------------------------

MySQLParser::HandlerReadOrScanContext::HandlerReadOrScanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::HandlerReadOrScanContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ValuesContext *MySQLParser::HandlerReadOrScanContext::values() {
  return getRuleContext<MySQLParser::ValuesContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::HandlerReadOrScanContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}

size_t MySQLParser::HandlerReadOrScanContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerReadOrScan;
}

void MySQLParser::HandlerReadOrScanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadOrScan(this);
}

void MySQLParser::HandlerReadOrScanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadOrScan(this);
}

std::any MySQLParser::HandlerReadOrScanContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHandlerReadOrScan(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerReadOrScanContext *MySQLParser::handlerReadOrScan() {
  HandlerReadOrScanContext *_localctx = _tracker.createInstance<HandlerReadOrScanContext>(_ctx, getState());
  enterRule(_localctx, 240, MySQLParser::RuleHandlerReadOrScan);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(2980);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 237, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(2970);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(2971);
        identifier();
        setState(2978);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::FIRST_SYMBOL:
          case MySQLParser::LAST_SYMBOL:
          case MySQLParser::NEXT_SYMBOL:
          case MySQLParser::PREV_SYMBOL: {
            setState(2972);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL

                  || _la == MySQLParser::PREV_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          case MySQLParser::EQUAL_OPERATOR:
          case MySQLParser::GREATER_OR_EQUAL_OPERATOR:
          case MySQLParser::GREATER_THAN_OPERATOR:
          case MySQLParser::LESS_OR_EQUAL_OPERATOR:
          case MySQLParser::LESS_THAN_OPERATOR: {
            setState(2973);
            _la = _input->LA(1);
            if (!(((((_la - 750) & ~0x3fULL) == 0) && ((1ULL << (_la - 750)) & 121) != 0))) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(2974);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(2975);
            values();
            setState(2976);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertStatementContext ------------------------------------------------------------------

MySQLParser::InsertStatementContext::InsertStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::InsertStatementContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::InsertStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext *MySQLParser::InsertStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode *MySQLParser::InsertStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext *MySQLParser::InsertStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext *MySQLParser::InsertStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

MySQLParser::InsertLockOptionContext *MySQLParser::InsertStatementContext::insertLockOption() {
  return getRuleContext<MySQLParser::InsertLockOptionContext>(0);
}

tree::TerminalNode *MySQLParser::InsertStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext *MySQLParser::InsertStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::InsertUpdateListContext *MySQLParser::InsertStatementContext::insertUpdateList() {
  return getRuleContext<MySQLParser::InsertUpdateListContext>(0);
}

MySQLParser::ValuesReferenceContext *MySQLParser::InsertStatementContext::valuesReference() {
  return getRuleContext<MySQLParser::ValuesReferenceContext>(0);
}

size_t MySQLParser::InsertStatementContext::getRuleIndex() const {
  return MySQLParser::RuleInsertStatement;
}

void MySQLParser::InsertStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertStatement(this);
}

void MySQLParser::InsertStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertStatement(this);
}

std::any MySQLParser::InsertStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertStatementContext *MySQLParser::insertStatement() {
  InsertStatementContext *_localctx = _tracker.createInstance<InsertStatementContext>(_ctx, getState());
  enterRule(_localctx, 242, MySQLParser::RuleInsertStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2982);
    match(MySQLParser::INSERT_SYMBOL);
    setState(2984);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 238, _ctx)) {
      case 1: {
        setState(2983);
        insertLockOption();
        break;
      }

      default:
        break;
    }
    setState(2987);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 239, _ctx)) {
      case 1: {
        setState(2986);
        match(MySQLParser::IGNORE_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(2990);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
      case 1: {
        setState(2989);
        match(MySQLParser::INTO_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(2992);
    tableRef();
    setState(2994);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 241, _ctx)) {
      case 1: {
        setState(2993);
        usePartition();
        break;
      }

      default:
        break;
    }
    setState(3008);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
      case 1: {
        setState(2996);
        insertFromConstructor();
        setState(2999);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
          case 1: {
            setState(2997);

            if (!(serverVersion >= 80018))
              throw FailedPredicateException(this, " serverVersion >= 80018");
            setState(2998);
            valuesReference();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(3001);
        match(MySQLParser::SET_SYMBOL);
        setState(3002);
        updateList();
        setState(3005);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
          case 1: {
            setState(3003);

            if (!(serverVersion >= 80018))
              throw FailedPredicateException(this, " serverVersion >= 80018");
            setState(3004);
            valuesReference();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        setState(3007);
        insertQueryExpression();
        break;
      }

      default:
        break;
    }
    setState(3011);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(3010);
      insertUpdateList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertLockOptionContext ------------------------------------------------------------------

MySQLParser::InsertLockOptionContext::InsertLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::InsertLockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertLockOptionContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertLockOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}

size_t MySQLParser::InsertLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertLockOption;
}

void MySQLParser::InsertLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertLockOption(this);
}

void MySQLParser::InsertLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertLockOption(this);
}

std::any MySQLParser::InsertLockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertLockOptionContext *MySQLParser::insertLockOption() {
  InsertLockOptionContext *_localctx = _tracker.createInstance<InsertLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 244, MySQLParser::RuleInsertLockOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3013);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELAYED_SYMBOL || _la == MySQLParser::HIGH_PRIORITY_SYMBOL ||
          _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertFromConstructorContext ------------------------------------------------------------------

MySQLParser::InsertFromConstructorContext::InsertFromConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InsertValuesContext *MySQLParser::InsertFromConstructorContext::insertValues() {
  return getRuleContext<MySQLParser::InsertValuesContext>(0);
}

tree::TerminalNode *MySQLParser::InsertFromConstructorContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertFromConstructorContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext *MySQLParser::InsertFromConstructorContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}

size_t MySQLParser::InsertFromConstructorContext::getRuleIndex() const {
  return MySQLParser::RuleInsertFromConstructor;
}

void MySQLParser::InsertFromConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertFromConstructor(this);
}

void MySQLParser::InsertFromConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertFromConstructor(this);
}

std::any MySQLParser::InsertFromConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertFromConstructor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertFromConstructorContext *MySQLParser::insertFromConstructor() {
  InsertFromConstructorContext *_localctx = _tracker.createInstance<InsertFromConstructorContext>(_ctx, getState());
  enterRule(_localctx, 246, MySQLParser::RuleInsertFromConstructor);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3020);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3015);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(3017);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
        case 1: {
          setState(3016);
          fields();
          break;
        }

        default:
          break;
      }
      setState(3019);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
    setState(3022);
    insertValues();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsContext ------------------------------------------------------------------

MySQLParser::FieldsContext::FieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::InsertIdentifierContext *> MySQLParser::FieldsContext::insertIdentifier() {
  return getRuleContexts<MySQLParser::InsertIdentifierContext>();
}

MySQLParser::InsertIdentifierContext *MySQLParser::FieldsContext::insertIdentifier(size_t i) {
  return getRuleContext<MySQLParser::InsertIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::FieldsContext::getRuleIndex() const {
  return MySQLParser::RuleFields;
}

void MySQLParser::FieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFields(this);
}

void MySQLParser::FieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFields(this);
}

std::any MySQLParser::FieldsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFields(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldsContext *MySQLParser::fields() {
  FieldsContext *_localctx = _tracker.createInstance<FieldsContext>(_ctx, getState());
  enterRule(_localctx, 248, MySQLParser::RuleFields);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3024);
    insertIdentifier();
    setState(3029);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3025);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3026);
      insertIdentifier();
      setState(3031);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertValuesContext ------------------------------------------------------------------

MySQLParser::InsertValuesContext::InsertValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ValueListContext *MySQLParser::InsertValuesContext::valueList() {
  return getRuleContext<MySQLParser::ValueListContext>(0);
}

tree::TerminalNode *MySQLParser::InsertValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertValuesContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

size_t MySQLParser::InsertValuesContext::getRuleIndex() const {
  return MySQLParser::RuleInsertValues;
}

void MySQLParser::InsertValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertValues(this);
}

void MySQLParser::InsertValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertValues(this);
}

std::any MySQLParser::InsertValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertValues(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertValuesContext *MySQLParser::insertValues() {
  InsertValuesContext *_localctx = _tracker.createInstance<InsertValuesContext>(_ctx, getState());
  enterRule(_localctx, 250, MySQLParser::RuleInsertValues);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3032);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::VALUES_SYMBOL

          || _la == MySQLParser::VALUE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3033);
    valueList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertQueryExpressionContext ------------------------------------------------------------------

MySQLParser::InsertQueryExpressionContext::InsertQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext *MySQLParser::InsertQueryExpressionContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::InsertQueryExpressionContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::QueryExpressionWithOptLockingClausesContext *
MySQLParser::InsertQueryExpressionContext::queryExpressionWithOptLockingClauses() {
  return getRuleContext<MySQLParser::QueryExpressionWithOptLockingClausesContext>(0);
}

tree::TerminalNode *MySQLParser::InsertQueryExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertQueryExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext *MySQLParser::InsertQueryExpressionContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}

size_t MySQLParser::InsertQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertQueryExpression;
}

void MySQLParser::InsertQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertQueryExpression(this);
}

void MySQLParser::InsertQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertQueryExpression(this);
}

std::any MySQLParser::InsertQueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertQueryExpressionContext *MySQLParser::insertQueryExpression() {
  InsertQueryExpressionContext *_localctx = _tracker.createInstance<InsertQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 252, MySQLParser::RuleInsertQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3045);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 251, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3035);
        queryExpression();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3036);
        queryExpressionParens();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3042);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 250, _ctx)) {
          case 1: {
            setState(3037);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(3039);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
              case 1: {
                setState(3038);
                fields();
                break;
              }

              default:
                break;
            }
            setState(3041);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(3044);
        queryExpressionWithOptLockingClauses();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueListContext ------------------------------------------------------------------

MySQLParser::ValueListContext::ValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::OPEN_PAR_SYMBOL() {
  return getTokens(MySQLParser::OPEN_PAR_SYMBOL);
}

tree::TerminalNode *MySQLParser::ValueListContext::OPEN_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL() {
  return getTokens(MySQLParser::CLOSE_PAR_SYMBOL);
}

tree::TerminalNode *MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, i);
}

std::vector<MySQLParser::ValuesContext *> MySQLParser::ValueListContext::values() {
  return getRuleContexts<MySQLParser::ValuesContext>();
}

MySQLParser::ValuesContext *MySQLParser::ValueListContext::values(size_t i) {
  return getRuleContext<MySQLParser::ValuesContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ValueListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ValueListContext::getRuleIndex() const {
  return MySQLParser::RuleValueList;
}

void MySQLParser::ValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueList(this);
}

void MySQLParser::ValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueList(this);
}

std::any MySQLParser::ValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitValueList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ValueListContext *MySQLParser::valueList() {
  ValueListContext *_localctx = _tracker.createInstance<ValueListContext>(_ctx, getState());
  enterRule(_localctx, 254, MySQLParser::RuleValueList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3047);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3049);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(3048);
        values();
        break;
      }

      default:
        break;
    }
    setState(3051);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(3060);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3052);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3053);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3055);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
          case 1: {
            setState(3054);
            values();
            break;
          }

          default:
            break;
        }
        setState(3057);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
      }
      setState(3062);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesContext ------------------------------------------------------------------

MySQLParser::ValuesContext::ValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ValuesContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ValuesContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::DEFAULT_SYMBOL() {
  return getTokens(MySQLParser::DEFAULT_SYMBOL);
}

tree::TerminalNode *MySQLParser::ValuesContext::DEFAULT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DEFAULT_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ValuesContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ValuesContext::getRuleIndex() const {
  return MySQLParser::RuleValues;
}

void MySQLParser::ValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues(this);
}

void MySQLParser::ValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues(this);
}

std::any MySQLParser::ValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitValues(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ValuesContext *MySQLParser::values() {
  ValuesContext *_localctx = _tracker.createInstance<ValuesContext>(_ctx, getState());
  enterRule(_localctx, 256, MySQLParser::RuleValues);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3065);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
      case 1: {
        setState(3063);
        expr(0);
        break;
      }

      case 2: {
        setState(3064);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3074);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3067);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3070);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 256, _ctx)) {
        case 1: {
          setState(3068);
          expr(0);
          break;
        }

        case 2: {
          setState(3069);
          match(MySQLParser::DEFAULT_SYMBOL);
          break;
        }

        default:
          break;
      }
      setState(3076);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesReferenceContext ------------------------------------------------------------------

MySQLParser::ValuesReferenceContext::ValuesReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ValuesReferenceContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ValuesReferenceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::ValuesReferenceContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

size_t MySQLParser::ValuesReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleValuesReference;
}

void MySQLParser::ValuesReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValuesReference(this);
}

void MySQLParser::ValuesReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValuesReference(this);
}

std::any MySQLParser::ValuesReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitValuesReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ValuesReferenceContext *MySQLParser::valuesReference() {
  ValuesReferenceContext *_localctx = _tracker.createInstance<ValuesReferenceContext>(_ctx, getState());
  enterRule(_localctx, 258, MySQLParser::RuleValuesReference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3077);
    match(MySQLParser::AS_SYMBOL);
    setState(3078);
    identifier();
    setState(3080);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3079);
      columnInternalRefList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertUpdateListContext ------------------------------------------------------------------

MySQLParser::InsertUpdateListContext::InsertUpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::InsertUpdateListContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertUpdateListContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertUpdateListContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InsertUpdateListContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::UpdateListContext *MySQLParser::InsertUpdateListContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

size_t MySQLParser::InsertUpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleInsertUpdateList;
}

void MySQLParser::InsertUpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertUpdateList(this);
}

void MySQLParser::InsertUpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertUpdateList(this);
}

std::any MySQLParser::InsertUpdateListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertUpdateList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertUpdateListContext *MySQLParser::insertUpdateList() {
  InsertUpdateListContext *_localctx = _tracker.createInstance<InsertUpdateListContext>(_ctx, getState());
  enterRule(_localctx, 260, MySQLParser::RuleInsertUpdateList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3082);
    match(MySQLParser::ON_SYMBOL);
    setState(3083);
    match(MySQLParser::DUPLICATE_SYMBOL);
    setState(3084);
    match(MySQLParser::KEY_SYMBOL);
    setState(3085);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(3086);
    updateList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadStatementContext ------------------------------------------------------------------

MySQLParser::LoadStatementContext::LoadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LoadStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

MySQLParser::DataOrXmlContext *MySQLParser::LoadStatementContext::dataOrXml() {
  return getRuleContext<MySQLParser::DataOrXmlContext>(0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::INFILE_SYMBOL() {
  return getToken(MySQLParser::INFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::LoadStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::LoadStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LoadDataFileTailContext *MySQLParser::LoadStatementContext::loadDataFileTail() {
  return getRuleContext<MySQLParser::LoadDataFileTailContext>(0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

MySQLParser::UsePartitionContext *MySQLParser::LoadStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::CharsetClauseContext *MySQLParser::LoadStatementContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::XmlRowsIdentifiedByContext *MySQLParser::LoadStatementContext::xmlRowsIdentifiedBy() {
  return getRuleContext<MySQLParser::XmlRowsIdentifiedByContext>(0);
}

MySQLParser::FieldsClauseContext *MySQLParser::LoadStatementContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext *MySQLParser::LoadStatementContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

size_t MySQLParser::LoadStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLoadStatement;
}

void MySQLParser::LoadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadStatement(this);
}

void MySQLParser::LoadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadStatement(this);
}

std::any MySQLParser::LoadStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLoadStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadStatementContext *MySQLParser::loadStatement() {
  LoadStatementContext *_localctx = _tracker.createInstance<LoadStatementContext>(_ctx, getState());
  enterRule(_localctx, 262, MySQLParser::RuleLoadStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3088);
    match(MySQLParser::LOAD_SYMBOL);
    setState(3089);
    dataOrXml();
    setState(3091);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL) {
      setState(3090);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3094);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LOCAL_SYMBOL) {
      setState(3093);
      match(MySQLParser::LOCAL_SYMBOL);
    }
    setState(3096);
    match(MySQLParser::INFILE_SYMBOL);
    setState(3097);
    textLiteral();
    setState(3099);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL) {
      setState(3098);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3101);
    match(MySQLParser::INTO_SYMBOL);
    setState(3102);
    match(MySQLParser::TABLE_SYMBOL);
    setState(3103);
    tableRef();
    setState(3105);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PARTITION_SYMBOL) {
      setState(3104);
      usePartition();
    }
    setState(3108);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CHARSET_SYMBOL

        || _la == MySQLParser::CHAR_SYMBOL) {
      setState(3107);
      charsetClause();
    }
    setState(3111);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ROWS_SYMBOL) {
      setState(3110);
      xmlRowsIdentifiedBy();
    }
    setState(3114);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLUMNS_SYMBOL) {
      setState(3113);
      fieldsClause();
    }
    setState(3117);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINES_SYMBOL) {
      setState(3116);
      linesClause();
    }
    setState(3119);
    loadDataFileTail();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataOrXmlContext ------------------------------------------------------------------

MySQLParser::DataOrXmlContext::DataOrXmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DataOrXmlContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataOrXmlContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

size_t MySQLParser::DataOrXmlContext::getRuleIndex() const {
  return MySQLParser::RuleDataOrXml;
}

void MySQLParser::DataOrXmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataOrXml(this);
}

void MySQLParser::DataOrXmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataOrXml(this);
}

std::any MySQLParser::DataOrXmlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDataOrXml(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataOrXmlContext *MySQLParser::dataOrXml() {
  DataOrXmlContext *_localctx = _tracker.createInstance<DataOrXmlContext>(_ctx, getState());
  enterRule(_localctx, 264, MySQLParser::RuleDataOrXml);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3121);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::XML_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XmlRowsIdentifiedByContext ------------------------------------------------------------------

MySQLParser::XmlRowsIdentifiedByContext::XmlRowsIdentifiedByContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::XmlRowsIdentifiedByContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XmlRowsIdentifiedByContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XmlRowsIdentifiedByContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::XmlRowsIdentifiedByContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::XmlRowsIdentifiedByContext::getRuleIndex() const {
  return MySQLParser::RuleXmlRowsIdentifiedBy;
}

void MySQLParser::XmlRowsIdentifiedByContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXmlRowsIdentifiedBy(this);
}

void MySQLParser::XmlRowsIdentifiedByContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXmlRowsIdentifiedBy(this);
}

std::any MySQLParser::XmlRowsIdentifiedByContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitXmlRowsIdentifiedBy(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XmlRowsIdentifiedByContext *MySQLParser::xmlRowsIdentifiedBy() {
  XmlRowsIdentifiedByContext *_localctx = _tracker.createInstance<XmlRowsIdentifiedByContext>(_ctx, getState());
  enterRule(_localctx, 266, MySQLParser::RuleXmlRowsIdentifiedBy);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3123);
    match(MySQLParser::ROWS_SYMBOL);
    setState(3124);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(3125);
    match(MySQLParser::BY_SYMBOL);
    setState(3126);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTailContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTailContext::LoadDataFileTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LoadDataFileTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadDataFileTailContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::LoadDataFileTargetListContext *MySQLParser::LoadDataFileTailContext::loadDataFileTargetList() {
  return getRuleContext<MySQLParser::LoadDataFileTargetListContext>(0);
}

tree::TerminalNode *MySQLParser::LoadDataFileTailContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext *MySQLParser::LoadDataFileTailContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

tree::TerminalNode *MySQLParser::LoadDataFileTailContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadDataFileTailContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

size_t MySQLParser::LoadDataFileTailContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTail;
}

void MySQLParser::LoadDataFileTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTail(this);
}

void MySQLParser::LoadDataFileTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTail(this);
}

std::any MySQLParser::LoadDataFileTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLoadDataFileTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadDataFileTailContext *MySQLParser::loadDataFileTail() {
  LoadDataFileTailContext *_localctx = _tracker.createInstance<LoadDataFileTailContext>(_ctx, getState());
  enterRule(_localctx, 268, MySQLParser::RuleLoadDataFileTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3131);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(3128);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(3129);
      match(MySQLParser::INT_NUMBER);
      setState(3130);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LINES_SYMBOL || _la == MySQLParser::ROWS_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(3134);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3133);
      loadDataFileTargetList();
    }
    setState(3138);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(3136);
      match(MySQLParser::SET_SYMBOL);
      setState(3137);
      updateList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTargetListContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTargetListContext::LoadDataFileTargetListContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LoadDataFileTargetListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LoadDataFileTargetListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldOrVariableListContext *MySQLParser::LoadDataFileTargetListContext::fieldOrVariableList() {
  return getRuleContext<MySQLParser::FieldOrVariableListContext>(0);
}

size_t MySQLParser::LoadDataFileTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTargetList;
}

void MySQLParser::LoadDataFileTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTargetList(this);
}

void MySQLParser::LoadDataFileTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTargetList(this);
}

std::any MySQLParser::LoadDataFileTargetListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLoadDataFileTargetList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoadDataFileTargetListContext *MySQLParser::loadDataFileTargetList() {
  LoadDataFileTargetListContext *_localctx = _tracker.createInstance<LoadDataFileTargetListContext>(_ctx, getState());
  enterRule(_localctx, 270, MySQLParser::RuleLoadDataFileTargetList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3140);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3142);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 270, _ctx)) {
      case 1: {
        setState(3141);
        fieldOrVariableList();
        break;
      }

      default:
        break;
    }
    setState(3144);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOrVariableListContext ------------------------------------------------------------------

MySQLParser::FieldOrVariableListContext::FieldOrVariableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ColumnRefContext *> MySQLParser::FieldOrVariableListContext::columnRef() {
  return getRuleContexts<MySQLParser::ColumnRefContext>();
}

MySQLParser::ColumnRefContext *MySQLParser::FieldOrVariableListContext::columnRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::AT_SIGN_SYMBOL() {
  return getTokens(MySQLParser::AT_SIGN_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOrVariableListContext::AT_SIGN_SYMBOL(size_t i) {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, i);
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::FieldOrVariableListContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext *MySQLParser::FieldOrVariableListContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::AT_AT_SIGN_SYMBOL() {
  return getTokens(MySQLParser::AT_AT_SIGN_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOrVariableListContext::AT_AT_SIGN_SYMBOL(size_t i) {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::AT_TEXT_SUFFIX() {
  return getTokens(MySQLParser::AT_TEXT_SUFFIX);
}

tree::TerminalNode *MySQLParser::FieldOrVariableListContext::AT_TEXT_SUFFIX(size_t i) {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, i);
}

size_t MySQLParser::FieldOrVariableListContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOrVariableList;
}

void MySQLParser::FieldOrVariableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOrVariableList(this);
}

void MySQLParser::FieldOrVariableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOrVariableList(this);
}

std::any MySQLParser::FieldOrVariableListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldOrVariableList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldOrVariableListContext *MySQLParser::fieldOrVariableList() {
  FieldOrVariableListContext *_localctx = _tracker.createInstance<FieldOrVariableListContext>(_ctx, getState());
  enterRule(_localctx, 272, MySQLParser::RuleFieldOrVariableList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3150);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
      case 1: {
        setState(3146);
        columnRef();
        break;
      }

      case 2: {
        setState(3147);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(3148);
        textOrIdentifier();
        break;
      }

      case 3: {
        setState(3149);
        match(MySQLParser::AT_AT_SIGN_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3162);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3152);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3158);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
        case 1: {
          setState(3153);
          columnRef();
          break;
        }

        case 2: {
          setState(3154);
          match(MySQLParser::AT_SIGN_SYMBOL);
          setState(3155);
          textOrIdentifier();
          break;
        }

        case 3: {
          setState(3156);
          match(MySQLParser::AT_TEXT_SUFFIX);
          break;
        }

        case 4: {
          setState(3157);
          match(MySQLParser::AT_AT_SIGN_SYMBOL);
          break;
        }

        default:
          break;
      }
      setState(3164);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceStatementContext ------------------------------------------------------------------

MySQLParser::ReplaceStatementContext::ReplaceStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplaceStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ReplaceStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext *MySQLParser::ReplaceStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode *MySQLParser::ReplaceStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext *MySQLParser::ReplaceStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext *MySQLParser::ReplaceStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

tree::TerminalNode *MySQLParser::ReplaceStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext *MySQLParser::ReplaceStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

tree::TerminalNode *MySQLParser::ReplaceStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplaceStatementContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}

size_t MySQLParser::ReplaceStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplaceStatement;
}

void MySQLParser::ReplaceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceStatement(this);
}

void MySQLParser::ReplaceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceStatement(this);
}

std::any MySQLParser::ReplaceStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplaceStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplaceStatementContext *MySQLParser::replaceStatement() {
  ReplaceStatementContext *_localctx = _tracker.createInstance<ReplaceStatementContext>(_ctx, getState());
  enterRule(_localctx, 274, MySQLParser::RuleReplaceStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3165);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(3167);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 274, _ctx)) {
      case 1: {
        setState(3166);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DELAYED_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }
    setState(3170);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
      case 1: {
        setState(3169);
        match(MySQLParser::INTO_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3172);
    tableRef();
    setState(3174);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
      case 1: {
        setState(3173);
        usePartition();
        break;
      }

      default:
        break;
    }
    setState(3180);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
      case 1: {
        setState(3176);
        insertFromConstructor();
        break;
      }

      case 2: {
        setState(3177);
        match(MySQLParser::SET_SYMBOL);
        setState(3178);
        updateList();
        break;
      }

      case 3: {
        setState(3179);
        insertQueryExpression();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementContext ------------------------------------------------------------------

MySQLParser::SelectStatementContext::SelectStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext *MySQLParser::SelectStatementContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::LockingClauseListContext *MySQLParser::SelectStatementContext::lockingClauseList() {
  return getRuleContext<MySQLParser::LockingClauseListContext>(0);
}

MySQLParser::SelectStatementWithIntoContext *MySQLParser::SelectStatementContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}

size_t MySQLParser::SelectStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatement;
}

void MySQLParser::SelectStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatement(this);
}

void MySQLParser::SelectStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatement(this);
}

std::any MySQLParser::SelectStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectStatementContext *MySQLParser::selectStatement() {
  SelectStatementContext *_localctx = _tracker.createInstance<SelectStatementContext>(_ctx, getState());
  enterRule(_localctx, 276, MySQLParser::RuleSelectStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3187);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3182);
        queryExpression();
        setState(3184);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
          setState(3183);
          lockingClauseList();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3186);
        selectStatementWithInto();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementWithIntoContext ------------------------------------------------------------------

MySQLParser::SelectStatementWithIntoContext::SelectStatementWithIntoContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SelectStatementWithIntoContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SelectStatementWithIntoContext *MySQLParser::SelectStatementWithIntoContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}

tree::TerminalNode *MySQLParser::SelectStatementWithIntoContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionContext *MySQLParser::SelectStatementWithIntoContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::IntoClauseContext *MySQLParser::SelectStatementWithIntoContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}

MySQLParser::LockingClauseListContext *MySQLParser::SelectStatementWithIntoContext::lockingClauseList() {
  return getRuleContext<MySQLParser::LockingClauseListContext>(0);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::SelectStatementWithIntoContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

size_t MySQLParser::SelectStatementWithIntoContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatementWithInto;
}

void MySQLParser::SelectStatementWithIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatementWithInto(this);
}

void MySQLParser::SelectStatementWithIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatementWithInto(this);
}

std::any MySQLParser::SelectStatementWithIntoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectStatementWithInto(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectStatementWithIntoContext *MySQLParser::selectStatementWithInto() {
  SelectStatementWithIntoContext *_localctx = _tracker.createInstance<SelectStatementWithIntoContext>(_ctx, getState());
  enterRule(_localctx, 278, MySQLParser::RuleSelectStatementWithInto);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3206);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3189);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3190);
        selectStatementWithInto();
        setState(3191);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3193);
        queryExpression();
        setState(3194);
        intoClause();
        setState(3196);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
          setState(3195);
          lockingClauseList();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3198);
        queryExpression();
        setState(3199);
        lockingClauseList();
        setState(3200);
        intoClause();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3202);

        if (!(serverVersion >= 80024 && serverVersion < 80031))
          throw FailedPredicateException(this, "serverVersion >= 80024 && serverVersion < 80031");
        setState(3203);
        queryExpressionParens();
        setState(3204);
        intoClause();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

MySQLParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionBodyContext *MySQLParser::QueryExpressionContext::queryExpressionBody() {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(0);
}

MySQLParser::WithClauseContext *MySQLParser::QueryExpressionContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

MySQLParser::OrderClauseContext *MySQLParser::QueryExpressionContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::LimitClauseContext *MySQLParser::QueryExpressionContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

size_t MySQLParser::QueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpression;
}

void MySQLParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void MySQLParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}

std::any MySQLParser::QueryExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionContext *MySQLParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 280, MySQLParser::RuleQueryExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3209);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
      case 1: {
        setState(3208);
        withClause();
        break;
      }

      default:
        break;
    }
    setState(3211);
    queryExpressionBody();
    setState(3213);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
      case 1: {
        setState(3212);
        orderClause();
        break;
      }

      default:
        break;
    }
    setState(3216);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
      case 1: {
        setState(3215);
        limitClause();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionBodyContext ------------------------------------------------------------------

MySQLParser::QueryExpressionBodyContext::QueryExpressionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryPrimaryContext *MySQLParser::QueryExpressionBodyContext::queryPrimary() {
  return getRuleContext<MySQLParser::QueryPrimaryContext>(0);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::QueryExpressionBodyContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

std::vector<MySQLParser::QueryExpressionBodyContext *> MySQLParser::QueryExpressionBodyContext::queryExpressionBody() {
  return getRuleContexts<MySQLParser::QueryExpressionBodyContext>();
}

MySQLParser::QueryExpressionBodyContext *MySQLParser::QueryExpressionBodyContext::queryExpressionBody(size_t i) {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::QueryExpressionBodyContext::UNION_SYMBOL() {
  return getTokens(MySQLParser::UNION_SYMBOL);
}

tree::TerminalNode *MySQLParser::QueryExpressionBodyContext::UNION_SYMBOL(size_t i) {
  return getToken(MySQLParser::UNION_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::QueryExpressionBodyContext::EXCEPT_SYMBOL() {
  return getTokens(MySQLParser::EXCEPT_SYMBOL);
}

tree::TerminalNode *MySQLParser::QueryExpressionBodyContext::EXCEPT_SYMBOL(size_t i) {
  return getToken(MySQLParser::EXCEPT_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::QueryExpressionBodyContext::INTERSECT_SYMBOL() {
  return getTokens(MySQLParser::INTERSECT_SYMBOL);
}

tree::TerminalNode *MySQLParser::QueryExpressionBodyContext::INTERSECT_SYMBOL(size_t i) {
  return getToken(MySQLParser::INTERSECT_SYMBOL, i);
}

std::vector<MySQLParser::UnionOptionContext *> MySQLParser::QueryExpressionBodyContext::unionOption() {
  return getRuleContexts<MySQLParser::UnionOptionContext>();
}

MySQLParser::UnionOptionContext *MySQLParser::QueryExpressionBodyContext::unionOption(size_t i) {
  return getRuleContext<MySQLParser::UnionOptionContext>(i);
}

size_t MySQLParser::QueryExpressionBodyContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionBody;
}

void MySQLParser::QueryExpressionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionBody(this);
}

void MySQLParser::QueryExpressionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionBody(this);
}

std::any MySQLParser::QueryExpressionBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryExpressionBody(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionBodyContext *MySQLParser::queryExpressionBody() {
  QueryExpressionBodyContext *_localctx = _tracker.createInstance<QueryExpressionBodyContext>(_ctx, getState());
  enterRule(_localctx, 282, MySQLParser::RuleQueryExpressionBody);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3220);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 285, _ctx)) {
      case 1: {
        setState(3218);
        queryPrimary();
        break;
      }

      case 2: {
        setState(3219);
        queryExpressionParens();
        break;
      }

      default:
        break;
    }
    setState(3233);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3225);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx)) {
          case 1: {
            setState(3222);
            match(MySQLParser::UNION_SYMBOL);
            break;
          }

          case 2: {
            setState(3223);

            if (!(serverVersion >= 80031))
              throw FailedPredicateException(this, "serverVersion >= 80031");
            setState(3224);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::EXCEPT_SYMBOL || _la == MySQLParser::INTERSECT_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          default:
            break;
        }
        setState(3228);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx)) {
          case 1: {
            setState(3227);
            unionOption();
            break;
          }

          default:
            break;
        }
        setState(3230);
        queryExpressionBody();
      }
      setState(3235);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 288, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionParensContext::QueryExpressionParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::QueryExpressionParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QueryExpressionParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::QueryExpressionParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::QueryExpressionWithOptLockingClausesContext *
MySQLParser::QueryExpressionParensContext::queryExpressionWithOptLockingClauses() {
  return getRuleContext<MySQLParser::QueryExpressionWithOptLockingClausesContext>(0);
}

size_t MySQLParser::QueryExpressionParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionParens;
}

void MySQLParser::QueryExpressionParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionParens(this);
}

void MySQLParser::QueryExpressionParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionParens(this);
}

std::any MySQLParser::QueryExpressionParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryExpressionParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryExpressionParensContext *MySQLParser::queryExpressionParens() {
  QueryExpressionParensContext *_localctx = _tracker.createInstance<QueryExpressionParensContext>(_ctx, getState());
  enterRule(_localctx, 284, MySQLParser::RuleQueryExpressionParens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3236);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3239);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 289, _ctx)) {
      case 1: {
        setState(3237);
        queryExpressionParens();
        break;
      }

      case 2: {
        setState(3238);
        queryExpressionWithOptLockingClauses();
        break;
      }

      default:
        break;
    }
    setState(3241);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryPrimaryContext ------------------------------------------------------------------

MySQLParser::QueryPrimaryContext::QueryPrimaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecificationContext *MySQLParser::QueryPrimaryContext::querySpecification() {
  return getRuleContext<MySQLParser::QuerySpecificationContext>(0);
}

MySQLParser::TableValueConstructorContext *MySQLParser::QueryPrimaryContext::tableValueConstructor() {
  return getRuleContext<MySQLParser::TableValueConstructorContext>(0);
}

MySQLParser::ExplicitTableContext *MySQLParser::QueryPrimaryContext::explicitTable() {
  return getRuleContext<MySQLParser::ExplicitTableContext>(0);
}

size_t MySQLParser::QueryPrimaryContext::getRuleIndex() const {
  return MySQLParser::RuleQueryPrimary;
}

void MySQLParser::QueryPrimaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryPrimary(this);
}

void MySQLParser::QueryPrimaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryPrimary(this);
}

std::any MySQLParser::QueryPrimaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQueryPrimary(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QueryPrimaryContext *MySQLParser::queryPrimary() {
  QueryPrimaryContext *_localctx = _tracker.createInstance<QueryPrimaryContext>(_ctx, getState());
  enterRule(_localctx, 286, MySQLParser::RuleQueryPrimary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3248);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3243);
        querySpecification();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3244);

        if (!(serverVersion >= 80019))
          throw FailedPredicateException(this, "serverVersion >= 80019");
        setState(3245);
        tableValueConstructor();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3246);

        if (!(serverVersion >= 80019))
          throw FailedPredicateException(this, "serverVersion >= 80019");
        setState(3247);
        explicitTable();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

MySQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::QuerySpecificationContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

MySQLParser::SelectItemListContext *MySQLParser::QuerySpecificationContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}

std::vector<MySQLParser::SelectOptionContext *> MySQLParser::QuerySpecificationContext::selectOption() {
  return getRuleContexts<MySQLParser::SelectOptionContext>();
}

MySQLParser::SelectOptionContext *MySQLParser::QuerySpecificationContext::selectOption(size_t i) {
  return getRuleContext<MySQLParser::SelectOptionContext>(i);
}

MySQLParser::IntoClauseContext *MySQLParser::QuerySpecificationContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}

MySQLParser::FromClauseContext *MySQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<MySQLParser::FromClauseContext>(0);
}

MySQLParser::WhereClauseContext *MySQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::GroupByClauseContext *MySQLParser::QuerySpecificationContext::groupByClause() {
  return getRuleContext<MySQLParser::GroupByClauseContext>(0);
}

MySQLParser::HavingClauseContext *MySQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<MySQLParser::HavingClauseContext>(0);
}

MySQLParser::WindowClauseContext *MySQLParser::QuerySpecificationContext::windowClause() {
  return getRuleContext<MySQLParser::WindowClauseContext>(0);
}

size_t MySQLParser::QuerySpecificationContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecification;
}

void MySQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void MySQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}

std::any MySQLParser::QuerySpecificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQuerySpecification(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QuerySpecificationContext *MySQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 288, MySQLParser::RuleQuerySpecification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3250);
    match(MySQLParser::SELECT_SYMBOL);
    setState(3254);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3251);
        selectOption();
      }
      setState(3256);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 291, _ctx);
    }
    setState(3257);
    selectItemList();
    setState(3259);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 292, _ctx)) {
      case 1: {
        setState(3258);
        intoClause();
        break;
      }

      default:
        break;
    }
    setState(3262);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 293, _ctx)) {
      case 1: {
        setState(3261);
        fromClause();
        break;
      }

      default:
        break;
    }
    setState(3265);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 294, _ctx)) {
      case 1: {
        setState(3264);
        whereClause();
        break;
      }

      default:
        break;
    }
    setState(3268);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 295, _ctx)) {
      case 1: {
        setState(3267);
        groupByClause();
        break;
      }

      default:
        break;
    }
    setState(3271);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx)) {
      case 1: {
        setState(3270);
        havingClause();
        break;
      }

      default:
        break;
    }
    setState(3274);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
      case 1: {
        setState(3273);
        windowClause();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionParensContext *MySQLParser::SubqueryContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

size_t MySQLParser::SubqueryContext::getRuleIndex() const {
  return MySQLParser::RuleSubquery;
}

void MySQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void MySQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

std::any MySQLParser::SubqueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSubquery(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubqueryContext *MySQLParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 290, MySQLParser::RuleSubquery);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3276);
    queryExpressionParens();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecOptionContext ------------------------------------------------------------------

MySQLParser::QuerySpecOptionContext::QuerySpecOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::SQL_SMALL_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_SMALL_RESULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::SQL_BIG_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BIG_RESULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::QuerySpecOptionContext::SQL_CALC_FOUND_ROWS_SYMBOL() {
  return getToken(MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL, 0);
}

size_t MySQLParser::QuerySpecOptionContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecOption;
}

void MySQLParser::QuerySpecOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecOption(this);
}

void MySQLParser::QuerySpecOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecOption(this);
}

std::any MySQLParser::QuerySpecOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQuerySpecOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QuerySpecOptionContext *MySQLParser::querySpecOption() {
  QuerySpecOptionContext *_localctx = _tracker.createInstance<QuerySpecOptionContext>(_ctx, getState());
  enterRule(_localctx, 292, MySQLParser::RuleQuerySpecOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3278);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL ||
          _la == MySQLParser::HIGH_PRIORITY_SYMBOL ||
          ((((_la - 531) & ~0x3fULL) == 0) && ((1ULL << (_la - 531)) & 16777259) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext ------------------------------------------------------------------

MySQLParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionsContext *MySQLParser::LimitClauseContext::limitOptions() {
  return getRuleContext<MySQLParser::LimitOptionsContext>(0);
}

size_t MySQLParser::LimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLimitClause;
}

void MySQLParser::LimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClause(this);
}

void MySQLParser::LimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClause(this);
}

std::any MySQLParser::LimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitClauseContext *MySQLParser::limitClause() {
  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 294, MySQLParser::RuleLimitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3280);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(3281);
    limitOptions();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleLimitClauseContext ------------------------------------------------------------------

MySQLParser::SimpleLimitClauseContext::SimpleLimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SimpleLimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionContext *MySQLParser::SimpleLimitClauseContext::limitOption() {
  return getRuleContext<MySQLParser::LimitOptionContext>(0);
}

size_t MySQLParser::SimpleLimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleLimitClause;
}

void MySQLParser::SimpleLimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleLimitClause(this);
}

void MySQLParser::SimpleLimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleLimitClause(this);
}

std::any MySQLParser::SimpleLimitClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleLimitClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleLimitClauseContext *MySQLParser::simpleLimitClause() {
  SimpleLimitClauseContext *_localctx = _tracker.createInstance<SimpleLimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 296, MySQLParser::RuleSimpleLimitClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3283);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(3284);
    limitOption();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionsContext ------------------------------------------------------------------

MySQLParser::LimitOptionsContext::LimitOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LimitOptionContext *> MySQLParser::LimitOptionsContext::limitOption() {
  return getRuleContexts<MySQLParser::LimitOptionContext>();
}

MySQLParser::LimitOptionContext *MySQLParser::LimitOptionsContext::limitOption(size_t i) {
  return getRuleContext<MySQLParser::LimitOptionContext>(i);
}

tree::TerminalNode *MySQLParser::LimitOptionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LimitOptionsContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

size_t MySQLParser::LimitOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOptions;
}

void MySQLParser::LimitOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOptions(this);
}

void MySQLParser::LimitOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOptions(this);
}

std::any MySQLParser::LimitOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLimitOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitOptionsContext *MySQLParser::limitOptions() {
  LimitOptionsContext *_localctx = _tracker.createInstance<LimitOptionsContext>(_ctx, getState());
  enterRule(_localctx, 298, MySQLParser::RuleLimitOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3286);
    limitOption();
    setState(3289);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx)) {
      case 1: {
        setState(3287);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::OFFSET_SYMBOL || _la == MySQLParser::COMMA_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3288);
        limitOption();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionContext ------------------------------------------------------------------

MySQLParser::LimitOptionContext::LimitOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::LimitOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::LimitOptionContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode *MySQLParser::LimitOptionContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::LimitOptionContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::LimitOptionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

size_t MySQLParser::LimitOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOption;
}

void MySQLParser::LimitOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOption(this);
}

void MySQLParser::LimitOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOption(this);
}

std::any MySQLParser::LimitOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLimitOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LimitOptionContext *MySQLParser::limitOption() {
  LimitOptionContext *_localctx = _tracker.createInstance<LimitOptionContext>(_ctx, getState());
  enterRule(_localctx, 300, MySQLParser::RuleLimitOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3293);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3291);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3292);
        _la = _input->LA(1);
        if (!(((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 1099511627783) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntoClauseContext ------------------------------------------------------------------

MySQLParser::IntoClauseContext::IntoClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IntoClauseContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntoClauseContext::OUTFILE_SYMBOL() {
  return getToken(MySQLParser::OUTFILE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::IntoClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::IntoClauseContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::IntoClauseContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext *MySQLParser::IntoClauseContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::IntoClauseContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext *MySQLParser::IntoClauseContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

MySQLParser::CharsetClauseContext *MySQLParser::IntoClauseContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::FieldsClauseContext *MySQLParser::IntoClauseContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext *MySQLParser::IntoClauseContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::IntoClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::IntoClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::IntoClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIntoClause;
}

void MySQLParser::IntoClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntoClause(this);
}

void MySQLParser::IntoClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntoClause(this);
}

std::any MySQLParser::IntoClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIntoClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntoClauseContext *MySQLParser::intoClause() {
  IntoClauseContext *_localctx = _tracker.createInstance<IntoClauseContext>(_ctx, getState());
  enterRule(_localctx, 302, MySQLParser::RuleIntoClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3295);
    match(MySQLParser::INTO_SYMBOL);
    setState(3323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
      case 1: {
        setState(3296);
        match(MySQLParser::OUTFILE_SYMBOL);
        setState(3297);
        textStringLiteral();
        setState(3299);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
          case 1: {
            setState(3298);
            charsetClause();
            break;
          }

          default:
            break;
        }
        setState(3302);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
          case 1: {
            setState(3301);
            fieldsClause();
            break;
          }

          default:
            break;
        }
        setState(3305);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
          case 1: {
            setState(3304);
            linesClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(3307);
        match(MySQLParser::DUMPFILE_SYMBOL);
        setState(3308);
        textStringLiteral();
        break;
      }

      case 3: {
        setState(3311);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
          case 1: {
            setState(3309);
            textOrIdentifier();
            break;
          }

          case 2: {
            setState(3310);
            userVariable();
            break;
          }

          default:
            break;
        }
        setState(3320);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3313);
            match(MySQLParser::COMMA_SYMBOL);
            setState(3316);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
              case 1: {
                setState(3314);
                textOrIdentifier();
                break;
              }

              case 2: {
                setState(3315);
                userVariable();
                break;
              }

              default:
                break;
            }
          }
          setState(3322);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureAnalyseClauseContext ------------------------------------------------------------------

MySQLParser::ProcedureAnalyseClauseContext::ProcedureAnalyseClauseContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ProcedureAnalyseClauseContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProcedureAnalyseClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProcedureAnalyseClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode *MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode *MySQLParser::ProcedureAnalyseClauseContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

size_t MySQLParser::ProcedureAnalyseClauseContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureAnalyseClause;
}

void MySQLParser::ProcedureAnalyseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureAnalyseClause(this);
}

void MySQLParser::ProcedureAnalyseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureAnalyseClause(this);
}

std::any MySQLParser::ProcedureAnalyseClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProcedureAnalyseClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureAnalyseClauseContext *MySQLParser::procedureAnalyseClause() {
  ProcedureAnalyseClauseContext *_localctx = _tracker.createInstance<ProcedureAnalyseClauseContext>(_ctx, getState());
  enterRule(_localctx, 304, MySQLParser::RuleProcedureAnalyseClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3325);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(3326);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INT_NUMBER) {
      setState(3327);
      match(MySQLParser::INT_NUMBER);
      setState(3330);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3328);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3329);
        match(MySQLParser::INT_NUMBER);
      }
    }
    setState(3334);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

MySQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HavingClauseContext::HAVING_SYMBOL() {
  return getToken(MySQLParser::HAVING_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::HavingClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::HavingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleHavingClause;
}

void MySQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void MySQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}

std::any MySQLParser::HavingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHavingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HavingClauseContext *MySQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 306, MySQLParser::RuleHavingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3336);
    match(MySQLParser::HAVING_SYMBOL);
    setState(3337);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

MySQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowClauseContext::WINDOW_SYMBOL() {
  return getToken(MySQLParser::WINDOW_SYMBOL, 0);
}

std::vector<MySQLParser::WindowDefinitionContext *> MySQLParser::WindowClauseContext::windowDefinition() {
  return getRuleContexts<MySQLParser::WindowDefinitionContext>();
}

MySQLParser::WindowDefinitionContext *MySQLParser::WindowClauseContext::windowDefinition(size_t i) {
  return getRuleContext<MySQLParser::WindowDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WindowClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::WindowClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::WindowClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowClause;
}

void MySQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void MySQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}

std::any MySQLParser::WindowClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowClauseContext *MySQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 308, MySQLParser::RuleWindowClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3339);
    match(MySQLParser::WINDOW_SYMBOL);
    setState(3340);
    windowDefinition();
    setState(3345);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3341);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3342);
        windowDefinition();
      }
      setState(3347);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowDefinitionContext ------------------------------------------------------------------

MySQLParser::WindowDefinitionContext::WindowDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext *MySQLParser::WindowDefinitionContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode *MySQLParser::WindowDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::WindowSpecContext *MySQLParser::WindowDefinitionContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}

size_t MySQLParser::WindowDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowDefinition;
}

void MySQLParser::WindowDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowDefinition(this);
}

void MySQLParser::WindowDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowDefinition(this);
}

std::any MySQLParser::WindowDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowDefinitionContext *MySQLParser::windowDefinition() {
  WindowDefinitionContext *_localctx = _tracker.createInstance<WindowDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 310, MySQLParser::RuleWindowDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3348);
    windowName();
    setState(3349);
    match(MySQLParser::AS_SYMBOL);
    setState(3350);
    windowSpec();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

MySQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowSpecContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::WindowSpecDetailsContext *MySQLParser::WindowSpecContext::windowSpecDetails() {
  return getRuleContext<MySQLParser::WindowSpecDetailsContext>(0);
}

tree::TerminalNode *MySQLParser::WindowSpecContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::WindowSpecContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpec;
}

void MySQLParser::WindowSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpec(this);
}

void MySQLParser::WindowSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpec(this);
}

std::any MySQLParser::WindowSpecContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowSpec(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowSpecContext *MySQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 312, MySQLParser::RuleWindowSpec);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3352);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3353);
    windowSpecDetails();
    setState(3354);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecDetailsContext ------------------------------------------------------------------

MySQLParser::WindowSpecDetailsContext::WindowSpecDetailsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext *MySQLParser::WindowSpecDetailsContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode *MySQLParser::WindowSpecDetailsContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowSpecDetailsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext *MySQLParser::WindowSpecDetailsContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OrderClauseContext *MySQLParser::WindowSpecDetailsContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::WindowFrameClauseContext *MySQLParser::WindowSpecDetailsContext::windowFrameClause() {
  return getRuleContext<MySQLParser::WindowFrameClauseContext>(0);
}

size_t MySQLParser::WindowSpecDetailsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpecDetails;
}

void MySQLParser::WindowSpecDetailsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpecDetails(this);
}

void MySQLParser::WindowSpecDetailsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpecDetails(this);
}

std::any MySQLParser::WindowSpecDetailsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowSpecDetails(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowSpecDetailsContext *MySQLParser::windowSpecDetails() {
  WindowSpecDetailsContext *_localctx = _tracker.createInstance<WindowSpecDetailsContext>(_ctx, getState());
  enterRule(_localctx, 314, MySQLParser::RuleWindowSpecDetails);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3357);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
      case 1: {
        setState(3356);
        windowName();
        break;
      }

      default:
        break;
    }
    setState(3362);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PARTITION_SYMBOL) {
      setState(3359);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(3360);
      match(MySQLParser::BY_SYMBOL);
      setState(3361);
      orderList();
    }
    setState(3365);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3364);
      orderClause();
    }
    setState(3368);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RANGE_SYMBOL

        || _la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL) {
      setState(3367);
      windowFrameClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameClauseContext ------------------------------------------------------------------

MySQLParser::WindowFrameClauseContext::WindowFrameClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameUnitsContext *MySQLParser::WindowFrameClauseContext::windowFrameUnits() {
  return getRuleContext<MySQLParser::WindowFrameUnitsContext>(0);
}

MySQLParser::WindowFrameExtentContext *MySQLParser::WindowFrameClauseContext::windowFrameExtent() {
  return getRuleContext<MySQLParser::WindowFrameExtentContext>(0);
}

MySQLParser::WindowFrameExclusionContext *MySQLParser::WindowFrameClauseContext::windowFrameExclusion() {
  return getRuleContext<MySQLParser::WindowFrameExclusionContext>(0);
}

size_t MySQLParser::WindowFrameClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameClause;
}

void MySQLParser::WindowFrameClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameClause(this);
}

void MySQLParser::WindowFrameClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameClause(this);
}

std::any MySQLParser::WindowFrameClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameClauseContext *MySQLParser::windowFrameClause() {
  WindowFrameClauseContext *_localctx = _tracker.createInstance<WindowFrameClauseContext>(_ctx, getState());
  enterRule(_localctx, 316, MySQLParser::RuleWindowFrameClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3370);
    windowFrameUnits();
    setState(3371);
    windowFrameExtent();
    setState(3373);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXCLUDE_SYMBOL) {
      setState(3372);
      windowFrameExclusion();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameUnitsContext ------------------------------------------------------------------

MySQLParser::WindowFrameUnitsContext::WindowFrameUnitsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowFrameUnitsContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameUnitsContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameUnitsContext::GROUPS_SYMBOL() {
  return getToken(MySQLParser::GROUPS_SYMBOL, 0);
}

size_t MySQLParser::WindowFrameUnitsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameUnits;
}

void MySQLParser::WindowFrameUnitsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameUnits(this);
}

void MySQLParser::WindowFrameUnitsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameUnits(this);
}

std::any MySQLParser::WindowFrameUnitsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameUnits(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameUnitsContext *MySQLParser::windowFrameUnits() {
  WindowFrameUnitsContext *_localctx = _tracker.createInstance<WindowFrameUnitsContext>(_ctx, getState());
  enterRule(_localctx, 318, MySQLParser::RuleWindowFrameUnits);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3375);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::RANGE_SYMBOL

          || _la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExtentContext ------------------------------------------------------------------

MySQLParser::WindowFrameExtentContext::WindowFrameExtentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext *MySQLParser::WindowFrameExtentContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

MySQLParser::WindowFrameBetweenContext *MySQLParser::WindowFrameExtentContext::windowFrameBetween() {
  return getRuleContext<MySQLParser::WindowFrameBetweenContext>(0);
}

size_t MySQLParser::WindowFrameExtentContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExtent;
}

void MySQLParser::WindowFrameExtentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExtent(this);
}

void MySQLParser::WindowFrameExtentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExtent(this);
}

std::any MySQLParser::WindowFrameExtentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameExtent(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameExtentContext *MySQLParser::windowFrameExtent() {
  WindowFrameExtentContext *_localctx = _tracker.createInstance<WindowFrameExtentContext>(_ctx, getState());
  enterRule(_localctx, 320, MySQLParser::RuleWindowFrameExtent);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3379);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CURRENT_SYMBOL:
      case MySQLParser::INTERVAL_SYMBOL:
      case MySQLParser::UNBOUNDED_SYMBOL:
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::PARAM_MARKER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(3377);
        windowFrameStart();
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3378);
        windowFrameBetween();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameStartContext ------------------------------------------------------------------

MySQLParser::WindowFrameStartContext::WindowFrameStartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::WindowFrameStartContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::WindowFrameStartContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext *MySQLParser::WindowFrameStartContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameStartContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

size_t MySQLParser::WindowFrameStartContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameStart;
}

void MySQLParser::WindowFrameStartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameStart(this);
}

void MySQLParser::WindowFrameStartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameStart(this);
}

std::any MySQLParser::WindowFrameStartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameStart(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameStartContext *MySQLParser::windowFrameStart() {
  WindowFrameStartContext *_localctx = _tracker.createInstance<WindowFrameStartContext>(_ctx, getState());
  enterRule(_localctx, 322, MySQLParser::RuleWindowFrameStart);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3395);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNBOUNDED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3381);
        match(MySQLParser::UNBOUNDED_SYMBOL);
        setState(3382);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(3383);
        ulonglong_number();
        setState(3384);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::PARAM_MARKER: {
        enterOuterAlt(_localctx, 3);
        setState(3386);
        match(MySQLParser::PARAM_MARKER);
        setState(3387);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INTERVAL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3388);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(3389);
        expr(0);
        setState(3390);
        interval();
        setState(3391);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::CURRENT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3393);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3394);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBetweenContext ------------------------------------------------------------------

MySQLParser::WindowFrameBetweenContext::WindowFrameBetweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowFrameBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

std::vector<MySQLParser::WindowFrameBoundContext *> MySQLParser::WindowFrameBetweenContext::windowFrameBound() {
  return getRuleContexts<MySQLParser::WindowFrameBoundContext>();
}

MySQLParser::WindowFrameBoundContext *MySQLParser::WindowFrameBetweenContext::windowFrameBound(size_t i) {
  return getRuleContext<MySQLParser::WindowFrameBoundContext>(i);
}

tree::TerminalNode *MySQLParser::WindowFrameBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

size_t MySQLParser::WindowFrameBetweenContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBetween;
}

void MySQLParser::WindowFrameBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBetween(this);
}

void MySQLParser::WindowFrameBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBetween(this);
}

std::any MySQLParser::WindowFrameBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameBetween(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameBetweenContext *MySQLParser::windowFrameBetween() {
  WindowFrameBetweenContext *_localctx = _tracker.createInstance<WindowFrameBetweenContext>(_ctx, getState());
  enterRule(_localctx, 324, MySQLParser::RuleWindowFrameBetween);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3397);
    match(MySQLParser::BETWEEN_SYMBOL);
    setState(3398);
    windowFrameBound();
    setState(3399);
    match(MySQLParser::AND_SYMBOL);
    setState(3400);
    windowFrameBound();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBoundContext ------------------------------------------------------------------

MySQLParser::WindowFrameBoundContext::WindowFrameBoundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext *MySQLParser::WindowFrameBoundContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFrameBoundContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameBoundContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::WindowFrameBoundContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFrameBoundContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameBoundContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::WindowFrameBoundContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext *MySQLParser::WindowFrameBoundContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

size_t MySQLParser::WindowFrameBoundContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBound;
}

void MySQLParser::WindowFrameBoundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBound(this);
}

void MySQLParser::WindowFrameBoundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBound(this);
}

std::any MySQLParser::WindowFrameBoundContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameBound(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameBoundContext *MySQLParser::windowFrameBound() {
  WindowFrameBoundContext *_localctx = _tracker.createInstance<WindowFrameBoundContext>(_ctx, getState());
  enterRule(_localctx, 326, MySQLParser::RuleWindowFrameBound);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3415);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3402);
        windowFrameStart();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3403);
        match(MySQLParser::UNBOUNDED_SYMBOL);
        setState(3404);
        match(MySQLParser::FOLLOWING_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3405);
        ulonglong_number();
        setState(3406);
        match(MySQLParser::FOLLOWING_SYMBOL);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3408);
        match(MySQLParser::PARAM_MARKER);
        setState(3409);
        match(MySQLParser::FOLLOWING_SYMBOL);
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3410);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(3411);
        expr(0);
        setState(3412);
        interval();
        setState(3413);
        match(MySQLParser::FOLLOWING_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExclusionContext ------------------------------------------------------------------

MySQLParser::WindowFrameExclusionContext::WindowFrameExclusionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFrameExclusionContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

size_t MySQLParser::WindowFrameExclusionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExclusion;
}

void MySQLParser::WindowFrameExclusionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExclusion(this);
}

void MySQLParser::WindowFrameExclusionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExclusion(this);
}

std::any MySQLParser::WindowFrameExclusionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFrameExclusion(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFrameExclusionContext *MySQLParser::windowFrameExclusion() {
  WindowFrameExclusionContext *_localctx = _tracker.createInstance<WindowFrameExclusionContext>(_ctx, getState());
  enterRule(_localctx, 328, MySQLParser::RuleWindowFrameExclusion);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3417);
    match(MySQLParser::EXCLUDE_SYMBOL);
    setState(3424);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CURRENT_SYMBOL: {
        setState(3418);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3419);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3420);
        match(MySQLParser::GROUP_SYMBOL);
        break;
      }

      case MySQLParser::TIES_SYMBOL: {
        setState(3421);
        match(MySQLParser::TIES_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        setState(3422);
        match(MySQLParser::NO_SYMBOL);
        setState(3423);
        match(MySQLParser::OTHERS_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithClauseContext ------------------------------------------------------------------

MySQLParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WithClauseContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::CommonTableExpressionContext *> MySQLParser::WithClauseContext::commonTableExpression() {
  return getRuleContexts<MySQLParser::CommonTableExpressionContext>();
}

MySQLParser::CommonTableExpressionContext *MySQLParser::WithClauseContext::commonTableExpression(size_t i) {
  return getRuleContext<MySQLParser::CommonTableExpressionContext>(i);
}

tree::TerminalNode *MySQLParser::WithClauseContext::RECURSIVE_SYMBOL() {
  return getToken(MySQLParser::RECURSIVE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::WithClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::WithClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::WithClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWithClause;
}

void MySQLParser::WithClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithClause(this);
}

void MySQLParser::WithClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithClause(this);
}

std::any MySQLParser::WithClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWithClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WithClauseContext *MySQLParser::withClause() {
  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());
  enterRule(_localctx, 330, MySQLParser::RuleWithClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3426);
    match(MySQLParser::WITH_SYMBOL);
    setState(3428);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 319, _ctx)) {
      case 1: {
        setState(3427);
        match(MySQLParser::RECURSIVE_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3430);
    commonTableExpression();
    setState(3435);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3431);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3432);
        commonTableExpression();
      }
      setState(3437);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 320, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonTableExpressionContext ------------------------------------------------------------------

MySQLParser::CommonTableExpressionContext::CommonTableExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::CommonTableExpressionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CommonTableExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::SubqueryContext *MySQLParser::CommonTableExpressionContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::CommonTableExpressionContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

size_t MySQLParser::CommonTableExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonTableExpression;
}

void MySQLParser::CommonTableExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonTableExpression(this);
}

void MySQLParser::CommonTableExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonTableExpression(this);
}

std::any MySQLParser::CommonTableExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCommonTableExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CommonTableExpressionContext *MySQLParser::commonTableExpression() {
  CommonTableExpressionContext *_localctx = _tracker.createInstance<CommonTableExpressionContext>(_ctx, getState());
  enterRule(_localctx, 332, MySQLParser::RuleCommonTableExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3438);
    identifier();
    setState(3440);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3439);
      columnInternalRefList();
    }
    setState(3442);
    match(MySQLParser::AS_SYMBOL);
    setState(3443);
    subquery();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByClauseContext ------------------------------------------------------------------

MySQLParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupByClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupByClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext *MySQLParser::GroupByClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OlapOptionContext *MySQLParser::GroupByClauseContext::olapOption() {
  return getRuleContext<MySQLParser::OlapOptionContext>(0);
}

size_t MySQLParser::GroupByClauseContext::getRuleIndex() const {
  return MySQLParser::RuleGroupByClause;
}

void MySQLParser::GroupByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByClause(this);
}

void MySQLParser::GroupByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByClause(this);
}

std::any MySQLParser::GroupByClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupByClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupByClauseContext *MySQLParser::groupByClause() {
  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
  enterRule(_localctx, 334, MySQLParser::RuleGroupByClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3445);
    match(MySQLParser::GROUP_SYMBOL);
    setState(3446);
    match(MySQLParser::BY_SYMBOL);
    setState(3447);
    orderList();
    setState(3449);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 322, _ctx)) {
      case 1: {
        setState(3448);
        olapOption();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OlapOptionContext ------------------------------------------------------------------

MySQLParser::OlapOptionContext::OlapOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::OlapOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OlapOptionContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

size_t MySQLParser::OlapOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOlapOption;
}

void MySQLParser::OlapOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOlapOption(this);
}

void MySQLParser::OlapOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOlapOption(this);
}

std::any MySQLParser::OlapOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOlapOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OlapOptionContext *MySQLParser::olapOption() {
  OlapOptionContext *_localctx = _tracker.createInstance<OlapOptionContext>(_ctx, getState());
  enterRule(_localctx, 336, MySQLParser::RuleOlapOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3451);
    match(MySQLParser::WITH_SYMBOL);
    setState(3452);
    match(MySQLParser::ROLLUP_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderClauseContext ------------------------------------------------------------------

MySQLParser::OrderClauseContext::OrderClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::OrderClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OrderClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext *MySQLParser::OrderClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

size_t MySQLParser::OrderClauseContext::getRuleIndex() const {
  return MySQLParser::RuleOrderClause;
}

void MySQLParser::OrderClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderClause(this);
}

void MySQLParser::OrderClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderClause(this);
}

std::any MySQLParser::OrderClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOrderClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderClauseContext *MySQLParser::orderClause() {
  OrderClauseContext *_localctx = _tracker.createInstance<OrderClauseContext>(_ctx, getState());
  enterRule(_localctx, 338, MySQLParser::RuleOrderClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3454);
    match(MySQLParser::ORDER_SYMBOL);
    setState(3455);
    match(MySQLParser::BY_SYMBOL);
    setState(3456);
    orderList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectionContext ------------------------------------------------------------------

MySQLParser::DirectionContext::DirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DirectionContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DirectionContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

size_t MySQLParser::DirectionContext::getRuleIndex() const {
  return MySQLParser::RuleDirection;
}

void MySQLParser::DirectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirection(this);
}

void MySQLParser::DirectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirection(this);
}

std::any MySQLParser::DirectionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDirection(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DirectionContext *MySQLParser::direction() {
  DirectionContext *_localctx = _tracker.createInstance<DirectionContext>(_ctx, getState());
  enterRule(_localctx, 340, MySQLParser::RuleDirection);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3458);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

MySQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FromClauseContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FromClauseContext::DUAL_SYMBOL() {
  return getToken(MySQLParser::DUAL_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext *MySQLParser::FromClauseContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

size_t MySQLParser::FromClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFromClause;
}

void MySQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void MySQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}

std::any MySQLParser::FromClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFromClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FromClauseContext *MySQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 342, MySQLParser::RuleFromClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3460);
    match(MySQLParser::FROM_SYMBOL);
    setState(3463);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 323, _ctx)) {
      case 1: {
        setState(3461);
        match(MySQLParser::DUAL_SYMBOL);
        break;
      }

      case 2: {
        setState(3462);
        tableReferenceList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListContext ------------------------------------------------------------------

MySQLParser::TableReferenceListContext::TableReferenceListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableReferenceContext *> MySQLParser::TableReferenceListContext::tableReference() {
  return getRuleContexts<MySQLParser::TableReferenceContext>();
}

MySQLParser::TableReferenceContext *MySQLParser::TableReferenceListContext::tableReference(size_t i) {
  return getRuleContext<MySQLParser::TableReferenceContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableReferenceListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableReferenceListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TableReferenceListContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceList;
}

void MySQLParser::TableReferenceListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceList(this);
}

void MySQLParser::TableReferenceListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceList(this);
}

std::any MySQLParser::TableReferenceListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableReferenceList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceListContext *MySQLParser::tableReferenceList() {
  TableReferenceListContext *_localctx = _tracker.createInstance<TableReferenceListContext>(_ctx, getState());
  enterRule(_localctx, 344, MySQLParser::RuleTableReferenceList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3465);
    tableReference();
    setState(3470);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3466);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3467);
        tableReference();
      }
      setState(3472);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableValueConstructorContext ------------------------------------------------------------------

MySQLParser::TableValueConstructorContext::TableValueConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TableValueConstructorContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

std::vector<MySQLParser::RowValueExplicitContext *> MySQLParser::TableValueConstructorContext::rowValueExplicit() {
  return getRuleContexts<MySQLParser::RowValueExplicitContext>();
}

MySQLParser::RowValueExplicitContext *MySQLParser::TableValueConstructorContext::rowValueExplicit(size_t i) {
  return getRuleContext<MySQLParser::RowValueExplicitContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableValueConstructorContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableValueConstructorContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TableValueConstructorContext::getRuleIndex() const {
  return MySQLParser::RuleTableValueConstructor;
}

void MySQLParser::TableValueConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableValueConstructor(this);
}

void MySQLParser::TableValueConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableValueConstructor(this);
}

std::any MySQLParser::TableValueConstructorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableValueConstructor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableValueConstructorContext *MySQLParser::tableValueConstructor() {
  TableValueConstructorContext *_localctx = _tracker.createInstance<TableValueConstructorContext>(_ctx, getState());
  enterRule(_localctx, 346, MySQLParser::RuleTableValueConstructor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3473);
    match(MySQLParser::VALUES_SYMBOL);
    setState(3474);
    rowValueExplicit();
    setState(3479);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3475);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3476);
        rowValueExplicit();
      }
      setState(3481);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 325, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplicitTableContext ------------------------------------------------------------------

MySQLParser::ExplicitTableContext::ExplicitTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ExplicitTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ExplicitTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

size_t MySQLParser::ExplicitTableContext::getRuleIndex() const {
  return MySQLParser::RuleExplicitTable;
}

void MySQLParser::ExplicitTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplicitTable(this);
}

void MySQLParser::ExplicitTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplicitTable(this);
}

std::any MySQLParser::ExplicitTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExplicitTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExplicitTableContext *MySQLParser::explicitTable() {
  ExplicitTableContext *_localctx = _tracker.createInstance<ExplicitTableContext>(_ctx, getState());
  enterRule(_localctx, 348, MySQLParser::RuleExplicitTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3482);
    match(MySQLParser::TABLE_SYMBOL);
    setState(3483);
    tableRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RowValueExplicitContext ------------------------------------------------------------------

MySQLParser::RowValueExplicitContext::RowValueExplicitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RowValueExplicitContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RowValueExplicitContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RowValueExplicitContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ValuesContext *MySQLParser::RowValueExplicitContext::values() {
  return getRuleContext<MySQLParser::ValuesContext>(0);
}

size_t MySQLParser::RowValueExplicitContext::getRuleIndex() const {
  return MySQLParser::RuleRowValueExplicit;
}

void MySQLParser::RowValueExplicitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRowValueExplicit(this);
}

void MySQLParser::RowValueExplicitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRowValueExplicit(this);
}

std::any MySQLParser::RowValueExplicitContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRowValueExplicit(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RowValueExplicitContext *MySQLParser::rowValueExplicit() {
  RowValueExplicitContext *_localctx = _tracker.createInstance<RowValueExplicitContext>(_ctx, getState());
  enterRule(_localctx, 350, MySQLParser::RuleRowValueExplicit);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3485);
    match(MySQLParser::ROW_SYMBOL);
    setState(3486);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3488);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx)) {
      case 1: {
        setState(3487);
        values();
        break;
      }

      default:
        break;
    }
    setState(3490);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectOptionContext ------------------------------------------------------------------

MySQLParser::SelectOptionContext::SelectOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecOptionContext *MySQLParser::SelectOptionContext::querySpecOption() {
  return getRuleContext<MySQLParser::QuerySpecOptionContext>(0);
}

tree::TerminalNode *MySQLParser::SelectOptionContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

size_t MySQLParser::SelectOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSelectOption;
}

void MySQLParser::SelectOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectOption(this);
}

void MySQLParser::SelectOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectOption(this);
}

std::any MySQLParser::SelectOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectOptionContext *MySQLParser::selectOption() {
  SelectOptionContext *_localctx = _tracker.createInstance<SelectOptionContext>(_ctx, getState());
  enterRule(_localctx, 352, MySQLParser::RuleSelectOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3494);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALL_SYMBOL:
      case MySQLParser::DISTINCT_SYMBOL:
      case MySQLParser::HIGH_PRIORITY_SYMBOL:
      case MySQLParser::SQL_BIG_RESULT_SYMBOL:
      case MySQLParser::SQL_BUFFER_RESULT_SYMBOL:
      case MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL:
      case MySQLParser::SQL_SMALL_RESULT_SYMBOL:
      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3492);
        querySpecOption();
        break;
      }

      case MySQLParser::SQL_NO_CACHE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3493);
        match(MySQLParser::SQL_NO_CACHE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockingClauseListContext ------------------------------------------------------------------

MySQLParser::LockingClauseListContext::LockingClauseListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LockingClauseContext *> MySQLParser::LockingClauseListContext::lockingClause() {
  return getRuleContexts<MySQLParser::LockingClauseContext>();
}

MySQLParser::LockingClauseContext *MySQLParser::LockingClauseListContext::lockingClause(size_t i) {
  return getRuleContext<MySQLParser::LockingClauseContext>(i);
}

size_t MySQLParser::LockingClauseListContext::getRuleIndex() const {
  return MySQLParser::RuleLockingClauseList;
}

void MySQLParser::LockingClauseListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockingClauseList(this);
}

void MySQLParser::LockingClauseListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockingClauseList(this);
}

std::any MySQLParser::LockingClauseListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockingClauseList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockingClauseListContext *MySQLParser::lockingClauseList() {
  LockingClauseListContext *_localctx = _tracker.createInstance<LockingClauseListContext>(_ctx, getState());
  enterRule(_localctx, 354, MySQLParser::RuleLockingClauseList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3497);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(3496);
      lockingClause();
      setState(3499);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockingClauseContext ------------------------------------------------------------------

MySQLParser::LockingClauseContext::LockingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LockingClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::LockStrenghContext *MySQLParser::LockingClauseContext::lockStrengh() {
  return getRuleContext<MySQLParser::LockStrenghContext>(0);
}

tree::TerminalNode *MySQLParser::LockingClauseContext::OF_SYMBOL() {
  return getToken(MySQLParser::OF_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext *MySQLParser::LockingClauseContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::LockedRowActionContext *MySQLParser::LockingClauseContext::lockedRowAction() {
  return getRuleContext<MySQLParser::LockedRowActionContext>(0);
}

tree::TerminalNode *MySQLParser::LockingClauseContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockingClauseContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockingClauseContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockingClauseContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

size_t MySQLParser::LockingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLockingClause;
}

void MySQLParser::LockingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockingClause(this);
}

void MySQLParser::LockingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockingClause(this);
}

std::any MySQLParser::LockingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockingClauseContext *MySQLParser::lockingClause() {
  LockingClauseContext *_localctx = _tracker.createInstance<LockingClauseContext>(_ctx, getState());
  enterRule(_localctx, 356, MySQLParser::RuleLockingClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3514);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3501);
        match(MySQLParser::FOR_SYMBOL);
        setState(3502);
        lockStrengh();
        setState(3505);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OF_SYMBOL) {
          setState(3503);
          match(MySQLParser::OF_SYMBOL);
          setState(3504);
          tableAliasRefList();
        }
        setState(3508);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SKIP_SYMBOL

            || _la == MySQLParser::NOWAIT_SYMBOL) {
          setState(3507);
          lockedRowAction();
        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3510);
        match(MySQLParser::LOCK_SYMBOL);
        setState(3511);
        match(MySQLParser::IN_SYMBOL);
        setState(3512);
        match(MySQLParser::SHARE_SYMBOL);
        setState(3513);
        match(MySQLParser::MODE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStrenghContext ------------------------------------------------------------------

MySQLParser::LockStrenghContext::LockStrenghContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LockStrenghContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockStrenghContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

size_t MySQLParser::LockStrenghContext::getRuleIndex() const {
  return MySQLParser::RuleLockStrengh;
}

void MySQLParser::LockStrenghContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStrengh(this);
}

void MySQLParser::LockStrenghContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStrengh(this);
}

std::any MySQLParser::LockStrenghContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockStrengh(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockStrenghContext *MySQLParser::lockStrengh() {
  LockStrenghContext *_localctx = _tracker.createInstance<LockStrenghContext>(_ctx, getState());
  enterRule(_localctx, 358, MySQLParser::RuleLockStrengh);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3516);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::SHARE_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockedRowActionContext ------------------------------------------------------------------

MySQLParser::LockedRowActionContext::LockedRowActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LockedRowActionContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockedRowActionContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockedRowActionContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

size_t MySQLParser::LockedRowActionContext::getRuleIndex() const {
  return MySQLParser::RuleLockedRowAction;
}

void MySQLParser::LockedRowActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockedRowAction(this);
}

void MySQLParser::LockedRowActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockedRowAction(this);
}

std::any MySQLParser::LockedRowActionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockedRowAction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockedRowActionContext *MySQLParser::lockedRowAction() {
  LockedRowActionContext *_localctx = _tracker.createInstance<LockedRowActionContext>(_ctx, getState());
  enterRule(_localctx, 360, MySQLParser::RuleLockedRowAction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3521);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SKIP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3518);
        match(MySQLParser::SKIP_SYMBOL);
        setState(3519);
        match(MySQLParser::LOCKED_SYMBOL);
        break;
      }

      case MySQLParser::NOWAIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3520);
        match(MySQLParser::NOWAIT_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemListContext ------------------------------------------------------------------

MySQLParser::SelectItemListContext::SelectItemListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SelectItemContext *> MySQLParser::SelectItemListContext::selectItem() {
  return getRuleContexts<MySQLParser::SelectItemContext>();
}

MySQLParser::SelectItemContext *MySQLParser::SelectItemListContext::selectItem(size_t i) {
  return getRuleContext<MySQLParser::SelectItemContext>(i);
}

tree::TerminalNode *MySQLParser::SelectItemListContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SelectItemListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::SelectItemListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::SelectItemListContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItemList;
}

void MySQLParser::SelectItemListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItemList(this);
}

void MySQLParser::SelectItemListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItemList(this);
}

std::any MySQLParser::SelectItemListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectItemList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectItemListContext *MySQLParser::selectItemList() {
  SelectItemListContext *_localctx = _tracker.createInstance<SelectItemListContext>(_ctx, getState());
  enterRule(_localctx, 362, MySQLParser::RuleSelectItemList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3525);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
      case 1: {
        setState(3523);
        selectItem();
        break;
      }

      case 2: {
        setState(3524);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(3531);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3527);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3528);
        selectItem();
      }
      setState(3533);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemContext ------------------------------------------------------------------

MySQLParser::SelectItemContext::SelectItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableWildContext *MySQLParser::SelectItemContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}

MySQLParser::ExprContext *MySQLParser::SelectItemContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext *MySQLParser::SelectItemContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}

size_t MySQLParser::SelectItemContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItem;
}

void MySQLParser::SelectItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItem(this);
}

void MySQLParser::SelectItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItem(this);
}

std::any MySQLParser::SelectItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectItemContext *MySQLParser::selectItem() {
  SelectItemContext *_localctx = _tracker.createInstance<SelectItemContext>(_ctx, getState());
  enterRule(_localctx, 364, MySQLParser::RuleSelectItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 336, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3534);
        tableWild();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3535);
        expr(0);
        setState(3537);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
          case 1: {
            setState(3536);
            selectAlias();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectAliasContext ------------------------------------------------------------------

MySQLParser::SelectAliasContext::SelectAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::SelectAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::SelectAliasContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::SelectAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

size_t MySQLParser::SelectAliasContext::getRuleIndex() const {
  return MySQLParser::RuleSelectAlias;
}

void MySQLParser::SelectAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectAlias(this);
}

void MySQLParser::SelectAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectAlias(this);
}

std::any MySQLParser::SelectAliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSelectAlias(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SelectAliasContext *MySQLParser::selectAlias() {
  SelectAliasContext *_localctx = _tracker.createInstance<SelectAliasContext>(_ctx, getState());
  enterRule(_localctx, 366, MySQLParser::RuleSelectAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3542);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
      case 1: {
        setState(3541);
        match(MySQLParser::AS_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3546);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 338, _ctx)) {
      case 1: {
        setState(3544);
        identifier();
        break;
      }

      case 2: {
        setState(3545);
        textStringLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

MySQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WhereClauseContext::WHERE_SYMBOL() {
  return getToken(MySQLParser::WHERE_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::WhereClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::WhereClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWhereClause;
}

void MySQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void MySQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}

std::any MySQLParser::WhereClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWhereClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhereClauseContext *MySQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 368, MySQLParser::RuleWhereClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3548);
    match(MySQLParser::WHERE_SYMBOL);
    setState(3549);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceContext ------------------------------------------------------------------

MySQLParser::TableReferenceContext::TableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext *MySQLParser::TableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

tree::TerminalNode *MySQLParser::TableReferenceContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::EscapedTableReferenceContext *MySQLParser::TableReferenceContext::escapedTableReference() {
  return getRuleContext<MySQLParser::EscapedTableReferenceContext>(0);
}

tree::TerminalNode *MySQLParser::TableReferenceContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::TableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext *MySQLParser::TableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}

MySQLParser::IdentifierContext *MySQLParser::TableReferenceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::TableReferenceContext::OJ_SYMBOL() {
  return getToken(MySQLParser::OJ_SYMBOL, 0);
}

size_t MySQLParser::TableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleTableReference;
}

void MySQLParser::TableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReference(this);
}

void MySQLParser::TableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReference(this);
}

std::any MySQLParser::TableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceContext *MySQLParser::tableReference() {
  TableReferenceContext *_localctx = _tracker.createInstance<TableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 370, MySQLParser::RuleTableReference);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3561);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx)) {
      case 1: {
        setState(3551);
        tableFactor();
        break;
      }

      case 2: {
        setState(3552);
        match(MySQLParser::OPEN_CURLY_SYMBOL);
        setState(3556);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
          case 1: {
            setState(3553);

            if (!(serverVersion < 80017))
              throw FailedPredicateException(this, "serverVersion < 80017");
            setState(3554);
            identifier();
            break;
          }

          case 2: {
            setState(3555);
            match(MySQLParser::OJ_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(3558);
        escapedTableReference();
        setState(3559);
        match(MySQLParser::CLOSE_CURLY_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3566);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3563);
        joinedTable();
      }
      setState(3568);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscapedTableReferenceContext ------------------------------------------------------------------

MySQLParser::EscapedTableReferenceContext::EscapedTableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext *MySQLParser::EscapedTableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::EscapedTableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext *MySQLParser::EscapedTableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}

size_t MySQLParser::EscapedTableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleEscapedTableReference;
}

void MySQLParser::EscapedTableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscapedTableReference(this);
}

void MySQLParser::EscapedTableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscapedTableReference(this);
}

std::any MySQLParser::EscapedTableReferenceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEscapedTableReference(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EscapedTableReferenceContext *MySQLParser::escapedTableReference() {
  EscapedTableReferenceContext *_localctx = _tracker.createInstance<EscapedTableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 372, MySQLParser::RuleEscapedTableReference);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3569);
    tableFactor();
    setState(3573);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::CROSS_SYMBOL ||
           ((((_la - 239) & ~0x3fULL) == 0) && ((1ULL << (_la - 239)) & 8594128897) != 0) ||
           _la == MySQLParser::NATURAL_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL ||
           _la == MySQLParser::STRAIGHT_JOIN_SYMBOL) {
      setState(3570);
      joinedTable();
      setState(3575);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinedTableContext ------------------------------------------------------------------

MySQLParser::JoinedTableContext::JoinedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InnerJoinTypeContext *MySQLParser::JoinedTableContext::innerJoinType() {
  return getRuleContext<MySQLParser::InnerJoinTypeContext>(0);
}

MySQLParser::TableReferenceContext *MySQLParser::JoinedTableContext::tableReference() {
  return getRuleContext<MySQLParser::TableReferenceContext>(0);
}

tree::TerminalNode *MySQLParser::JoinedTableContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::JoinedTableContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::JoinedTableContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext *MySQLParser::JoinedTableContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

MySQLParser::OuterJoinTypeContext *MySQLParser::JoinedTableContext::outerJoinType() {
  return getRuleContext<MySQLParser::OuterJoinTypeContext>(0);
}

MySQLParser::NaturalJoinTypeContext *MySQLParser::JoinedTableContext::naturalJoinType() {
  return getRuleContext<MySQLParser::NaturalJoinTypeContext>(0);
}

MySQLParser::TableFactorContext *MySQLParser::JoinedTableContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

size_t MySQLParser::JoinedTableContext::getRuleIndex() const {
  return MySQLParser::RuleJoinedTable;
}

void MySQLParser::JoinedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinedTable(this);
}

void MySQLParser::JoinedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinedTable(this);
}

std::any MySQLParser::JoinedTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJoinedTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JoinedTableContext *MySQLParser::joinedTable() {
  JoinedTableContext *_localctx = _tracker.createInstance<JoinedTableContext>(_ctx, getState());
  enterRule(_localctx, 374, MySQLParser::RuleJoinedTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3595);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL:
      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3576);
        innerJoinType();
        setState(3577);
        tableReference();
        setState(3582);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
          case 1: {
            setState(3578);
            match(MySQLParser::ON_SYMBOL);
            setState(3579);
            expr(0);
            break;
          }

          case 2: {
            setState(3580);
            match(MySQLParser::USING_SYMBOL);
            setState(3581);
            identifierListWithParentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::LEFT_SYMBOL:
      case MySQLParser::RIGHT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3584);
        outerJoinType();
        setState(3585);
        tableReference();
        setState(3590);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ON_SYMBOL: {
            setState(3586);
            match(MySQLParser::ON_SYMBOL);
            setState(3587);
            expr(0);
            break;
          }

          case MySQLParser::USING_SYMBOL: {
            setState(3588);
            match(MySQLParser::USING_SYMBOL);
            setState(3589);
            identifierListWithParentheses();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::NATURAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3592);
        naturalJoinType();
        setState(3593);
        tableFactor();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NaturalJoinTypeContext ------------------------------------------------------------------

MySQLParser::NaturalJoinTypeContext::NaturalJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NaturalJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}

size_t MySQLParser::NaturalJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleNaturalJoinType;
}

void MySQLParser::NaturalJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNaturalJoinType(this);
}

void MySQLParser::NaturalJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNaturalJoinType(this);
}

std::any MySQLParser::NaturalJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNaturalJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NaturalJoinTypeContext *MySQLParser::naturalJoinType() {
  NaturalJoinTypeContext *_localctx = _tracker.createInstance<NaturalJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 376, MySQLParser::RuleNaturalJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3608);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 348, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3597);
        match(MySQLParser::NATURAL_SYMBOL);
        setState(3599);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::INNER_SYMBOL) {
          setState(3598);
          match(MySQLParser::INNER_SYMBOL);
        }
        setState(3601);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3602);
        match(MySQLParser::NATURAL_SYMBOL);
        setState(3603);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3605);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OUTER_SYMBOL) {
          setState(3604);
          match(MySQLParser::OUTER_SYMBOL);
        }
        setState(3607);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerJoinTypeContext ------------------------------------------------------------------

MySQLParser::InnerJoinTypeContext::InnerJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::InnerJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InnerJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InnerJoinTypeContext::CROSS_SYMBOL() {
  return getToken(MySQLParser::CROSS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InnerJoinTypeContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}

size_t MySQLParser::InnerJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleInnerJoinType;
}

void MySQLParser::InnerJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerJoinType(this);
}

void MySQLParser::InnerJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerJoinType(this);
}

std::any MySQLParser::InnerJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInnerJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InnerJoinTypeContext *MySQLParser::innerJoinType() {
  InnerJoinTypeContext *_localctx = _tracker.createInstance<InnerJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 378, MySQLParser::RuleInnerJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3615);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3611);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CROSS_SYMBOL || _la == MySQLParser::INNER_SYMBOL) {
          setState(3610);
          antlrcpp::downCast<InnerJoinTypeContext *>(_localctx)->type = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::CROSS_SYMBOL || _la == MySQLParser::INNER_SYMBOL)) {
            antlrcpp::downCast<InnerJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
          } else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3613);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3614);
        antlrcpp::downCast<InnerJoinTypeContext *>(_localctx)->type = match(MySQLParser::STRAIGHT_JOIN_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OuterJoinTypeContext ------------------------------------------------------------------

MySQLParser::OuterJoinTypeContext::OuterJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::OuterJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OuterJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OuterJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OuterJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}

size_t MySQLParser::OuterJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOuterJoinType;
}

void MySQLParser::OuterJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOuterJoinType(this);
}

void MySQLParser::OuterJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOuterJoinType(this);
}

std::any MySQLParser::OuterJoinTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOuterJoinType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OuterJoinTypeContext *MySQLParser::outerJoinType() {
  OuterJoinTypeContext *_localctx = _tracker.createInstance<OuterJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 380, MySQLParser::RuleOuterJoinType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3617);
    antlrcpp::downCast<OuterJoinTypeContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
      antlrcpp::downCast<OuterJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3619);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OUTER_SYMBOL) {
      setState(3618);
      match(MySQLParser::OUTER_SYMBOL);
    }
    setState(3621);
    match(MySQLParser::JOIN_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFactorContext ------------------------------------------------------------------

MySQLParser::TableFactorContext::TableFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SingleTableContext *MySQLParser::TableFactorContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext *MySQLParser::TableFactorContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}

MySQLParser::DerivedTableContext *MySQLParser::TableFactorContext::derivedTable() {
  return getRuleContext<MySQLParser::DerivedTableContext>(0);
}

MySQLParser::TableReferenceListParensContext *MySQLParser::TableFactorContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}

MySQLParser::TableFunctionContext *MySQLParser::TableFactorContext::tableFunction() {
  return getRuleContext<MySQLParser::TableFunctionContext>(0);
}

size_t MySQLParser::TableFactorContext::getRuleIndex() const {
  return MySQLParser::RuleTableFactor;
}

void MySQLParser::TableFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFactor(this);
}

void MySQLParser::TableFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFactor(this);
}

std::any MySQLParser::TableFactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableFactor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableFactorContext *MySQLParser::tableFactor() {
  TableFactorContext *_localctx = _tracker.createInstance<TableFactorContext>(_ctx, getState());
  enterRule(_localctx, 382, MySQLParser::RuleTableFactor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3629);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 352, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3623);
        singleTable();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3624);
        singleTableParens();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3625);
        derivedTable();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(3626);
        tableReferenceListParens();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(3627);

        if (!(serverVersion >= 80004))
          throw FailedPredicateException(this, "serverVersion >= 80004");
        setState(3628);
        tableFunction();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableContext ------------------------------------------------------------------

MySQLParser::SingleTableContext::SingleTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::SingleTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::UsePartitionContext *MySQLParser::SingleTableContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::TableAliasContext *MySQLParser::SingleTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::IndexHintListContext *MySQLParser::SingleTableContext::indexHintList() {
  return getRuleContext<MySQLParser::IndexHintListContext>(0);
}

size_t MySQLParser::SingleTableContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTable;
}

void MySQLParser::SingleTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTable(this);
}

void MySQLParser::SingleTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTable(this);
}

std::any MySQLParser::SingleTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSingleTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SingleTableContext *MySQLParser::singleTable() {
  SingleTableContext *_localctx = _tracker.createInstance<SingleTableContext>(_ctx, getState());
  enterRule(_localctx, 384, MySQLParser::RuleSingleTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3631);
    tableRef();
    setState(3633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 353, _ctx)) {
      case 1: {
        setState(3632);
        usePartition();
        break;
      }

      default:
        break;
    }
    setState(3636);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
      case 1: {
        setState(3635);
        tableAlias();
        break;
      }

      default:
        break;
    }
    setState(3639);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 355, _ctx)) {
      case 1: {
        setState(3638);
        indexHintList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableParensContext ------------------------------------------------------------------

MySQLParser::SingleTableParensContext::SingleTableParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SingleTableParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SingleTableParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SingleTableContext *MySQLParser::SingleTableParensContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext *MySQLParser::SingleTableParensContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}

size_t MySQLParser::SingleTableParensContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTableParens;
}

void MySQLParser::SingleTableParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTableParens(this);
}

void MySQLParser::SingleTableParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTableParens(this);
}

std::any MySQLParser::SingleTableParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSingleTableParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SingleTableParensContext *MySQLParser::singleTableParens() {
  SingleTableParensContext *_localctx = _tracker.createInstance<SingleTableParensContext>(_ctx, getState());
  enterRule(_localctx, 386, MySQLParser::RuleSingleTableParens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3641);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3644);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 356, _ctx)) {
      case 1: {
        setState(3642);
        singleTable();
        break;
      }

      case 2: {
        setState(3643);
        singleTableParens();
        break;
      }

      default:
        break;
    }
    setState(3646);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivedTableContext ------------------------------------------------------------------

MySQLParser::DerivedTableContext::DerivedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SubqueryContext *MySQLParser::DerivedTableContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::TableAliasContext *MySQLParser::DerivedTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::DerivedTableContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode *MySQLParser::DerivedTableContext::LATERAL_SYMBOL() {
  return getToken(MySQLParser::LATERAL_SYMBOL, 0);
}

size_t MySQLParser::DerivedTableContext::getRuleIndex() const {
  return MySQLParser::RuleDerivedTable;
}

void MySQLParser::DerivedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivedTable(this);
}

void MySQLParser::DerivedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivedTable(this);
}

std::any MySQLParser::DerivedTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDerivedTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DerivedTableContext *MySQLParser::derivedTable() {
  DerivedTableContext *_localctx = _tracker.createInstance<DerivedTableContext>(_ctx, getState());
  enterRule(_localctx, 388, MySQLParser::RuleDerivedTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3664);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 361, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3648);
        subquery();
        setState(3650);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 357, _ctx)) {
          case 1: {
            setState(3649);
            tableAlias();
            break;
          }

          default:
            break;
        }
        setState(3653);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
          case 1: {
            setState(3652);
            columnInternalRefList();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3655);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(3656);
        match(MySQLParser::LATERAL_SYMBOL);
        setState(3657);
        subquery();
        setState(3659);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx)) {
          case 1: {
            setState(3658);
            tableAlias();
            break;
          }

          default:
            break;
        }
        setState(3662);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
          case 1: {
            setState(3661);
            columnInternalRefList();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListParensContext ------------------------------------------------------------------

MySQLParser::TableReferenceListParensContext::TableReferenceListParensContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TableReferenceListParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableReferenceListParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext *MySQLParser::TableReferenceListParensContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::TableReferenceListParensContext *MySQLParser::TableReferenceListParensContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}

size_t MySQLParser::TableReferenceListParensContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceListParens;
}

void MySQLParser::TableReferenceListParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceListParens(this);
}

void MySQLParser::TableReferenceListParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceListParens(this);
}

std::any MySQLParser::TableReferenceListParensContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableReferenceListParens(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableReferenceListParensContext *MySQLParser::tableReferenceListParens() {
  TableReferenceListParensContext *_localctx =
    _tracker.createInstance<TableReferenceListParensContext>(_ctx, getState());
  enterRule(_localctx, 390, MySQLParser::RuleTableReferenceListParens);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3666);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3669);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
      case 1: {
        setState(3667);
        tableReferenceList();
        break;
      }

      case 2: {
        setState(3668);
        tableReferenceListParens();
        break;
      }

      default:
        break;
    }
    setState(3671);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFunctionContext ------------------------------------------------------------------

MySQLParser::TableFunctionContext::TableFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TableFunctionContext::JSON_TABLE_SYMBOL() {
  return getToken(MySQLParser::JSON_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::TableFunctionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::TableFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::TableFunctionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::ColumnsClauseContext *MySQLParser::TableFunctionContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}

tree::TerminalNode *MySQLParser::TableFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableAliasContext *MySQLParser::TableFunctionContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

size_t MySQLParser::TableFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTableFunction;
}

void MySQLParser::TableFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFunction(this);
}

void MySQLParser::TableFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFunction(this);
}

std::any MySQLParser::TableFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableFunctionContext *MySQLParser::tableFunction() {
  TableFunctionContext *_localctx = _tracker.createInstance<TableFunctionContext>(_ctx, getState());
  enterRule(_localctx, 392, MySQLParser::RuleTableFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3673);
    match(MySQLParser::JSON_TABLE_SYMBOL);
    setState(3674);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3675);
    expr(0);
    setState(3676);
    match(MySQLParser::COMMA_SYMBOL);
    setState(3677);
    textStringLiteral();
    setState(3678);
    columnsClause();
    setState(3679);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(3681);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
      case 1: {
        setState(3680);
        tableAlias();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnsClauseContext ------------------------------------------------------------------

MySQLParser::ColumnsClauseContext::ColumnsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ColumnsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnsClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::JtColumnContext *> MySQLParser::ColumnsClauseContext::jtColumn() {
  return getRuleContexts<MySQLParser::JtColumnContext>();
}

MySQLParser::JtColumnContext *MySQLParser::ColumnsClauseContext::jtColumn(size_t i) {
  return getRuleContext<MySQLParser::JtColumnContext>(i);
}

tree::TerminalNode *MySQLParser::ColumnsClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnsClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ColumnsClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ColumnsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleColumnsClause;
}

void MySQLParser::ColumnsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnsClause(this);
}

void MySQLParser::ColumnsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnsClause(this);
}

std::any MySQLParser::ColumnsClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnsClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnsClauseContext *MySQLParser::columnsClause() {
  ColumnsClauseContext *_localctx = _tracker.createInstance<ColumnsClauseContext>(_ctx, getState());
  enterRule(_localctx, 394, MySQLParser::RuleColumnsClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3683);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(3684);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3685);
    jtColumn();
    setState(3690);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3686);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3687);
      jtColumn();
      setState(3692);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3693);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JtColumnContext ------------------------------------------------------------------

MySQLParser::JtColumnContext::JtColumnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::JtColumnContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::JtColumnContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::JtColumnContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

MySQLParser::DataTypeContext *MySQLParser::JtColumnContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode *MySQLParser::JtColumnContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::JtColumnContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::CollateContext *MySQLParser::JtColumnContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode *MySQLParser::JtColumnContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::OnEmptyOrErrorJsonTableContext *MySQLParser::JtColumnContext::onEmptyOrErrorJsonTable() {
  return getRuleContext<MySQLParser::OnEmptyOrErrorJsonTableContext>(0);
}

tree::TerminalNode *MySQLParser::JtColumnContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

MySQLParser::ColumnsClauseContext *MySQLParser::JtColumnContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}

size_t MySQLParser::JtColumnContext::getRuleIndex() const {
  return MySQLParser::RuleJtColumn;
}

void MySQLParser::JtColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJtColumn(this);
}

void MySQLParser::JtColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJtColumn(this);
}

std::any MySQLParser::JtColumnContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJtColumn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JtColumnContext *MySQLParser::jtColumn() {
  JtColumnContext *_localctx = _tracker.createInstance<JtColumnContext>(_ctx, getState());
  enterRule(_localctx, 396, MySQLParser::RuleJtColumn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3718);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3695);
        identifier();
        setState(3696);
        match(MySQLParser::FOR_SYMBOL);
        setState(3697);
        match(MySQLParser::ORDINALITY_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3699);
        identifier();
        setState(3700);
        dataType();
        setState(3703);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
          case 1: {
            setState(3701);

            if (!(serverVersion >= 80014))
              throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(3702);
            collate();
            break;
          }

          default:
            break;
        }
        setState(3706);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXISTS_SYMBOL) {
          setState(3705);
          match(MySQLParser::EXISTS_SYMBOL);
        }
        setState(3708);
        match(MySQLParser::PATH_SYMBOL);
        setState(3709);
        textStringLiteral();
        setState(3711);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DEFAULT_SYMBOL

            || _la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
          setState(3710);
          onEmptyOrErrorJsonTable();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3713);
        match(MySQLParser::NESTED_SYMBOL);
        setState(3714);
        match(MySQLParser::PATH_SYMBOL);
        setState(3715);
        textStringLiteral();
        setState(3716);
        columnsClause();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyOrErrorContext ------------------------------------------------------------------

MySQLParser::OnEmptyOrErrorContext::OnEmptyOrErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OnEmptyContext *MySQLParser::OnEmptyOrErrorContext::onEmpty() {
  return getRuleContext<MySQLParser::OnEmptyContext>(0);
}

MySQLParser::OnErrorContext *MySQLParser::OnEmptyOrErrorContext::onError() {
  return getRuleContext<MySQLParser::OnErrorContext>(0);
}

size_t MySQLParser::OnEmptyOrErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmptyOrError;
}

void MySQLParser::OnEmptyOrErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmptyOrError(this);
}

void MySQLParser::OnEmptyOrErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmptyOrError(this);
}

std::any MySQLParser::OnEmptyOrErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOnEmptyOrError(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnEmptyOrErrorContext *MySQLParser::onEmptyOrError() {
  OnEmptyOrErrorContext *_localctx = _tracker.createInstance<OnEmptyOrErrorContext>(_ctx, getState());
  enterRule(_localctx, 398, MySQLParser::RuleOnEmptyOrError);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3725);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 370, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3720);
        onEmpty();
        setState(3722);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DEFAULT_SYMBOL

            || _la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
          setState(3721);
          onError();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3724);
        onError();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyOrErrorJsonTableContext ------------------------------------------------------------------

MySQLParser::OnEmptyOrErrorJsonTableContext::OnEmptyOrErrorJsonTableContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OnEmptyOrErrorContext *MySQLParser::OnEmptyOrErrorJsonTableContext::onEmptyOrError() {
  return getRuleContext<MySQLParser::OnEmptyOrErrorContext>(0);
}

MySQLParser::OnErrorContext *MySQLParser::OnEmptyOrErrorJsonTableContext::onError() {
  return getRuleContext<MySQLParser::OnErrorContext>(0);
}

MySQLParser::OnEmptyContext *MySQLParser::OnEmptyOrErrorJsonTableContext::onEmpty() {
  return getRuleContext<MySQLParser::OnEmptyContext>(0);
}

size_t MySQLParser::OnEmptyOrErrorJsonTableContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmptyOrErrorJsonTable;
}

void MySQLParser::OnEmptyOrErrorJsonTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmptyOrErrorJsonTable(this);
}

void MySQLParser::OnEmptyOrErrorJsonTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmptyOrErrorJsonTable(this);
}

std::any MySQLParser::OnEmptyOrErrorJsonTableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOnEmptyOrErrorJsonTable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnEmptyOrErrorJsonTableContext *MySQLParser::onEmptyOrErrorJsonTable() {
  OnEmptyOrErrorJsonTableContext *_localctx = _tracker.createInstance<OnEmptyOrErrorJsonTableContext>(_ctx, getState());
  enterRule(_localctx, 400, MySQLParser::RuleOnEmptyOrErrorJsonTable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3731);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3727);
        onEmptyOrError();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3728);
        onError();
        setState(3729);
        onEmpty();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyContext ------------------------------------------------------------------

MySQLParser::OnEmptyContext::OnEmptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JsonOnResponseContext *MySQLParser::OnEmptyContext::jsonOnResponse() {
  return getRuleContext<MySQLParser::JsonOnResponseContext>(0);
}

tree::TerminalNode *MySQLParser::OnEmptyContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OnEmptyContext::EMPTY_SYMBOL() {
  return getToken(MySQLParser::EMPTY_SYMBOL, 0);
}

size_t MySQLParser::OnEmptyContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmpty;
}

void MySQLParser::OnEmptyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmpty(this);
}

void MySQLParser::OnEmptyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmpty(this);
}

std::any MySQLParser::OnEmptyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOnEmpty(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnEmptyContext *MySQLParser::onEmpty() {
  OnEmptyContext *_localctx = _tracker.createInstance<OnEmptyContext>(_ctx, getState());
  enterRule(_localctx, 402, MySQLParser::RuleOnEmpty);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3733);
    jsonOnResponse();
    setState(3734);
    match(MySQLParser::ON_SYMBOL);
    setState(3735);
    match(MySQLParser::EMPTY_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorContext ------------------------------------------------------------------

MySQLParser::OnErrorContext::OnErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JsonOnResponseContext *MySQLParser::OnErrorContext::jsonOnResponse() {
  return getRuleContext<MySQLParser::JsonOnResponseContext>(0);
}

tree::TerminalNode *MySQLParser::OnErrorContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OnErrorContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

size_t MySQLParser::OnErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnError;
}

void MySQLParser::OnErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnError(this);
}

void MySQLParser::OnErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnError(this);
}

std::any MySQLParser::OnErrorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOnError(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnErrorContext *MySQLParser::onError() {
  OnErrorContext *_localctx = _tracker.createInstance<OnErrorContext>(_ctx, getState());
  enterRule(_localctx, 404, MySQLParser::RuleOnError);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3737);
    jsonOnResponse();
    setState(3738);
    match(MySQLParser::ON_SYMBOL);
    setState(3739);
    match(MySQLParser::ERROR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOnResponseContext ------------------------------------------------------------------

MySQLParser::JsonOnResponseContext::JsonOnResponseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::JsonOnResponseContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::JsonOnResponseContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::JsonOnResponseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::JsonOnResponseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::JsonOnResponseContext::getRuleIndex() const {
  return MySQLParser::RuleJsonOnResponse;
}

void MySQLParser::JsonOnResponseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOnResponse(this);
}

void MySQLParser::JsonOnResponseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOnResponse(this);
}

std::any MySQLParser::JsonOnResponseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJsonOnResponse(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonOnResponseContext *MySQLParser::jsonOnResponse() {
  JsonOnResponseContext *_localctx = _tracker.createInstance<JsonOnResponseContext>(_ctx, getState());
  enterRule(_localctx, 406, MySQLParser::RuleJsonOnResponse);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3745);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ERROR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3741);
        match(MySQLParser::ERROR_SYMBOL);
        break;
      }

      case MySQLParser::NULL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3742);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3743);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(3744);
        textStringLiteral();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOptionContext ------------------------------------------------------------------

MySQLParser::UnionOptionContext::UnionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UnionOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UnionOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

size_t MySQLParser::UnionOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUnionOption;
}

void MySQLParser::UnionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionOption(this);
}

void MySQLParser::UnionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionOption(this);
}

std::any MySQLParser::UnionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUnionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnionOptionContext *MySQLParser::unionOption() {
  UnionOptionContext *_localctx = _tracker.createInstance<UnionOptionContext>(_ctx, getState());
  enterRule(_localctx, 408, MySQLParser::RuleUnionOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3747);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

MySQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::TableAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::TableAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableAliasContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::TableAliasContext::getRuleIndex() const {
  return MySQLParser::RuleTableAlias;
}

void MySQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void MySQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}

std::any MySQLParser::TableAliasContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableAlias(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAliasContext *MySQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 410, MySQLParser::RuleTableAlias);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3752);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 373, _ctx)) {
      case 1: {
        setState(3749);
        match(MySQLParser::AS_SYMBOL);
        break;
      }

      case 2: {
        setState(3750);

        if (!(serverVersion < 80017))
          throw FailedPredicateException(this, "serverVersion < 80017");
        setState(3751);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(3754);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintListContext ------------------------------------------------------------------

MySQLParser::IndexHintListContext::IndexHintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexHintContext *> MySQLParser::IndexHintListContext::indexHint() {
  return getRuleContexts<MySQLParser::IndexHintContext>();
}

MySQLParser::IndexHintContext *MySQLParser::IndexHintListContext::indexHint(size_t i) {
  return getRuleContext<MySQLParser::IndexHintContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexHintListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::IndexHintListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::IndexHintListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintList;
}

void MySQLParser::IndexHintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintList(this);
}

void MySQLParser::IndexHintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintList(this);
}

std::any MySQLParser::IndexHintListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexHintList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintListContext *MySQLParser::indexHintList() {
  IndexHintListContext *_localctx = _tracker.createInstance<IndexHintListContext>(_ctx, getState());
  enterRule(_localctx, 412, MySQLParser::RuleIndexHintList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3756);
    indexHint();
    setState(3761);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3757);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3758);
        indexHint();
      }
      setState(3763);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintContext ------------------------------------------------------------------

MySQLParser::IndexHintContext::IndexHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexHintTypeContext *MySQLParser::IndexHintContext::indexHintType() {
  return getRuleContext<MySQLParser::IndexHintTypeContext>(0);
}

MySQLParser::KeyOrIndexContext *MySQLParser::IndexHintContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode *MySQLParser::IndexHintContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IndexListContext *MySQLParser::IndexHintContext::indexList() {
  return getRuleContext<MySQLParser::IndexListContext>(0);
}

tree::TerminalNode *MySQLParser::IndexHintContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::IndexHintClauseContext *MySQLParser::IndexHintContext::indexHintClause() {
  return getRuleContext<MySQLParser::IndexHintClauseContext>(0);
}

tree::TerminalNode *MySQLParser::IndexHintContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

size_t MySQLParser::IndexHintContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHint;
}

void MySQLParser::IndexHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHint(this);
}

void MySQLParser::IndexHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHint(this);
}

std::any MySQLParser::IndexHintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexHint(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintContext *MySQLParser::indexHint() {
  IndexHintContext *_localctx = _tracker.createInstance<IndexHintContext>(_ctx, getState());
  enterRule(_localctx, 414, MySQLParser::RuleIndexHint);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3784);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FORCE_SYMBOL:
      case MySQLParser::IGNORE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3764);
        indexHintType();
        setState(3765);
        keyOrIndex();
        setState(3767);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3766);
          indexHintClause();
        }
        setState(3769);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3770);
        indexList();
        setState(3771);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::USE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3773);
        match(MySQLParser::USE_SYMBOL);
        setState(3774);
        keyOrIndex();
        setState(3776);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3775);
          indexHintClause();
        }
        setState(3778);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3780);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
          case 1: {
            setState(3779);
            indexList();
            break;
          }

          default:
            break;
        }
        setState(3782);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintTypeContext ------------------------------------------------------------------

MySQLParser::IndexHintTypeContext::IndexHintTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IndexHintTypeContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexHintTypeContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

size_t MySQLParser::IndexHintTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintType;
}

void MySQLParser::IndexHintTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintType(this);
}

void MySQLParser::IndexHintTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintType(this);
}

std::any MySQLParser::IndexHintTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexHintType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintTypeContext *MySQLParser::indexHintType() {
  IndexHintTypeContext *_localctx = _tracker.createInstance<IndexHintTypeContext>(_ctx, getState());
  enterRule(_localctx, 416, MySQLParser::RuleIndexHintType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3786);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FORCE_SYMBOL

          || _la == MySQLParser::IGNORE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyOrIndexContext ------------------------------------------------------------------

MySQLParser::KeyOrIndexContext::KeyOrIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::KeyOrIndexContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::KeyOrIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

size_t MySQLParser::KeyOrIndexContext::getRuleIndex() const {
  return MySQLParser::RuleKeyOrIndex;
}

void MySQLParser::KeyOrIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyOrIndex(this);
}

void MySQLParser::KeyOrIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyOrIndex(this);
}

std::any MySQLParser::KeyOrIndexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyOrIndex(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyOrIndexContext *MySQLParser::keyOrIndex() {
  KeyOrIndexContext *_localctx = _tracker.createInstance<KeyOrIndexContext>(_ctx, getState());
  enterRule(_localctx, 418, MySQLParser::RuleKeyOrIndex);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3788);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INDEX_SYMBOL

          || _la == MySQLParser::KEY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintKeyTypeContext ------------------------------------------------------------------

MySQLParser::ConstraintKeyTypeContext::ConstraintKeyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConstraintKeyTypeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ConstraintKeyTypeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ConstraintKeyTypeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext *MySQLParser::ConstraintKeyTypeContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

size_t MySQLParser::ConstraintKeyTypeContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintKeyType;
}

void MySQLParser::ConstraintKeyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintKeyType(this);
}

void MySQLParser::ConstraintKeyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintKeyType(this);
}

std::any MySQLParser::ConstraintKeyTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConstraintKeyType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConstraintKeyTypeContext *MySQLParser::constraintKeyType() {
  ConstraintKeyTypeContext *_localctx = _tracker.createInstance<ConstraintKeyTypeContext>(_ctx, getState());
  enterRule(_localctx, 420, MySQLParser::RuleConstraintKeyType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3796);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3790);
        match(MySQLParser::PRIMARY_SYMBOL);
        setState(3791);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3792);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(3794);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::INDEX_SYMBOL

            || _la == MySQLParser::KEY_SYMBOL) {
          setState(3793);
          keyOrIndex();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintClauseContext ------------------------------------------------------------------

MySQLParser::IndexHintClauseContext::IndexHintClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IndexHintClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexHintClauseContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexHintClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexHintClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexHintClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

size_t MySQLParser::IndexHintClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintClause;
}

void MySQLParser::IndexHintClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintClause(this);
}

void MySQLParser::IndexHintClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintClause(this);
}

std::any MySQLParser::IndexHintClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexHintClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexHintClauseContext *MySQLParser::indexHintClause() {
  IndexHintClauseContext *_localctx = _tracker.createInstance<IndexHintClauseContext>(_ctx, getState());
  enterRule(_localctx, 422, MySQLParser::RuleIndexHintClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3798);
    match(MySQLParser::FOR_SYMBOL);
    setState(3804);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JOIN_SYMBOL: {
        setState(3799);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::ORDER_SYMBOL: {
        setState(3800);
        match(MySQLParser::ORDER_SYMBOL);
        setState(3801);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3802);
        match(MySQLParser::GROUP_SYMBOL);
        setState(3803);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListContext ------------------------------------------------------------------

MySQLParser::IndexListContext::IndexListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexListElementContext *> MySQLParser::IndexListContext::indexListElement() {
  return getRuleContexts<MySQLParser::IndexListElementContext>();
}

MySQLParser::IndexListElementContext *MySQLParser::IndexListContext::indexListElement(size_t i) {
  return getRuleContext<MySQLParser::IndexListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::IndexListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::IndexListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexList;
}

void MySQLParser::IndexListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexList(this);
}

void MySQLParser::IndexListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexList(this);
}

std::any MySQLParser::IndexListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexListContext *MySQLParser::indexList() {
  IndexListContext *_localctx = _tracker.createInstance<IndexListContext>(_ctx, getState());
  enterRule(_localctx, 424, MySQLParser::RuleIndexList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3806);
    indexListElement();
    setState(3811);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3807);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3808);
      indexListElement();
      setState(3813);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListElementContext ------------------------------------------------------------------

MySQLParser::IndexListElementContext::IndexListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::IndexListElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::IndexListElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

size_t MySQLParser::IndexListElementContext::getRuleIndex() const {
  return MySQLParser::RuleIndexListElement;
}

void MySQLParser::IndexListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexListElement(this);
}

void MySQLParser::IndexListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexListElement(this);
}

std::any MySQLParser::IndexListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexListElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexListElementContext *MySQLParser::indexListElement() {
  IndexListElementContext *_localctx = _tracker.createInstance<IndexListElementContext>(_ctx, getState());
  enterRule(_localctx, 426, MySQLParser::RuleIndexListElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3816);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3814);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3815);
        match(MySQLParser::PRIMARY_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStatementContext ------------------------------------------------------------------

MySQLParser::UpdateStatementContext::UpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UpdateStatementContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext *MySQLParser::UpdateStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

tree::TerminalNode *MySQLParser::UpdateStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext *MySQLParser::UpdateStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::WithClauseContext *MySQLParser::UpdateStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

tree::TerminalNode *MySQLParser::UpdateStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UpdateStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

MySQLParser::WhereClauseContext *MySQLParser::UpdateStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::OrderClauseContext *MySQLParser::UpdateStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext *MySQLParser::UpdateStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}

size_t MySQLParser::UpdateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateStatement;
}

void MySQLParser::UpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateStatement(this);
}

void MySQLParser::UpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateStatement(this);
}

std::any MySQLParser::UpdateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUpdateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateStatementContext *MySQLParser::updateStatement() {
  UpdateStatementContext *_localctx = _tracker.createInstance<UpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 428, MySQLParser::RuleUpdateStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3819);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(3818);
      withClause();
    }
    setState(3821);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(3823);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 385, _ctx)) {
      case 1: {
        setState(3822);
        match(MySQLParser::LOW_PRIORITY_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3826);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 386, _ctx)) {
      case 1: {
        setState(3825);
        match(MySQLParser::IGNORE_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(3828);
    tableReferenceList();
    setState(3829);
    match(MySQLParser::SET_SYMBOL);
    setState(3830);
    updateList();
    setState(3832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WHERE_SYMBOL) {
      setState(3831);
      whereClause();
    }
    setState(3835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3834);
      orderClause();
    }
    setState(3838);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(3837);
      simpleLimitClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionOrLockingStatementContext
//------------------------------------------------------------------

MySQLParser::TransactionOrLockingStatementContext::TransactionOrLockingStatementContext(ParserRuleContext *parent,
                                                                                        size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TransactionStatementContext *MySQLParser::TransactionOrLockingStatementContext::transactionStatement() {
  return getRuleContext<MySQLParser::TransactionStatementContext>(0);
}

MySQLParser::SavepointStatementContext *MySQLParser::TransactionOrLockingStatementContext::savepointStatement() {
  return getRuleContext<MySQLParser::SavepointStatementContext>(0);
}

MySQLParser::LockStatementContext *MySQLParser::TransactionOrLockingStatementContext::lockStatement() {
  return getRuleContext<MySQLParser::LockStatementContext>(0);
}

MySQLParser::XaStatementContext *MySQLParser::TransactionOrLockingStatementContext::xaStatement() {
  return getRuleContext<MySQLParser::XaStatementContext>(0);
}

size_t MySQLParser::TransactionOrLockingStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionOrLockingStatement;
}

void MySQLParser::TransactionOrLockingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionOrLockingStatement(this);
}

void MySQLParser::TransactionOrLockingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionOrLockingStatement(this);
}

std::any MySQLParser::TransactionOrLockingStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTransactionOrLockingStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionOrLockingStatementContext *MySQLParser::transactionOrLockingStatement() {
  TransactionOrLockingStatementContext *_localctx =
    _tracker.createInstance<TransactionOrLockingStatementContext>(_ctx, getState());
  enterRule(_localctx, 430, MySQLParser::RuleTransactionOrLockingStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3844);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMIT_SYMBOL:
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3840);
        transactionStatement();
        break;
      }

      case MySQLParser::RELEASE_SYMBOL:
      case MySQLParser::ROLLBACK_SYMBOL:
      case MySQLParser::SAVEPOINT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3841);
        savepointStatement();
        break;
      }

      case MySQLParser::LOCK_SYMBOL:
      case MySQLParser::UNLOCK_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3842);
        lockStatement();
        break;
      }

      case MySQLParser::XA_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3843);
        xaStatement();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionStatementContext ------------------------------------------------------------------

MySQLParser::TransactionStatementContext::TransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

std::vector<MySQLParser::StartTransactionOptionListContext *>
MySQLParser::TransactionStatementContext::startTransactionOptionList() {
  return getRuleContexts<MySQLParser::StartTransactionOptionListContext>();
}

MySQLParser::StartTransactionOptionListContext *MySQLParser::TransactionStatementContext::startTransactionOptionList(
  size_t i) {
  return getRuleContext<MySQLParser::StartTransactionOptionListContext>(i);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::TransactionStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode *MySQLParser::TransactionStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}

size_t MySQLParser::TransactionStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionStatement;
}

void MySQLParser::TransactionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionStatement(this);
}

void MySQLParser::TransactionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionStatement(this);
}

std::any MySQLParser::TransactionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTransactionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionStatementContext *MySQLParser::transactionStatement() {
  TransactionStatementContext *_localctx = _tracker.createInstance<TransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 432, MySQLParser::RuleTransactionStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3871);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3846);
        match(MySQLParser::START_SYMBOL);
        setState(3847);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(3851);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::READ_SYMBOL || _la == MySQLParser::WITH_SYMBOL) {
          setState(3848);
          startTransactionOptionList();
          setState(3853);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3854);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3856);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3855);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3863);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(3858);
          match(MySQLParser::AND_SYMBOL);
          setState(3860);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3859);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3862);
          match(MySQLParser::CHAIN_SYMBOL);
        }
        setState(3869);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
          setState(3866);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3865);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3868);
          match(MySQLParser::RELEASE_SYMBOL);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginWorkContext ------------------------------------------------------------------

MySQLParser::BeginWorkContext::BeginWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::BeginWorkContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::BeginWorkContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

size_t MySQLParser::BeginWorkContext::getRuleIndex() const {
  return MySQLParser::RuleBeginWork;
}

void MySQLParser::BeginWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginWork(this);
}

void MySQLParser::BeginWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginWork(this);
}

std::any MySQLParser::BeginWorkContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitBeginWork(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BeginWorkContext *MySQLParser::beginWork() {
  BeginWorkContext *_localctx = _tracker.createInstance<BeginWorkContext>(_ctx, getState());
  enterRule(_localctx, 434, MySQLParser::RuleBeginWork);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3873);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(3875);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WORK_SYMBOL) {
      setState(3874);
      match(MySQLParser::WORK_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartTransactionOptionListContext ------------------------------------------------------------------

MySQLParser::StartTransactionOptionListContext::StartTransactionOptionListContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartTransactionOptionListContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

size_t MySQLParser::StartTransactionOptionListContext::getRuleIndex() const {
  return MySQLParser::RuleStartTransactionOptionList;
}

void MySQLParser::StartTransactionOptionListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartTransactionOptionList(this);
}

void MySQLParser::StartTransactionOptionListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartTransactionOptionList(this);
}

std::any MySQLParser::StartTransactionOptionListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStartTransactionOptionList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StartTransactionOptionListContext *MySQLParser::startTransactionOptionList() {
  StartTransactionOptionListContext *_localctx =
    _tracker.createInstance<StartTransactionOptionListContext>(_ctx, getState());
  enterRule(_localctx, 436, MySQLParser::RuleStartTransactionOptionList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3882);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::WITH_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3877);
        match(MySQLParser::WITH_SYMBOL);
        setState(3878);
        match(MySQLParser::CONSISTENT_SYMBOL);
        setState(3879);
        match(MySQLParser::SNAPSHOT_SYMBOL);
        break;
      }

      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3880);
        match(MySQLParser::READ_SYMBOL);
        setState(3881);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepointStatementContext ------------------------------------------------------------------

MySQLParser::SavepointStatementContext::SavepointStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::SavepointStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SavepointStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode *MySQLParser::SavepointStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}

size_t MySQLParser::SavepointStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSavepointStatement;
}

void MySQLParser::SavepointStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepointStatement(this);
}

void MySQLParser::SavepointStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepointStatement(this);
}

std::any MySQLParser::SavepointStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSavepointStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SavepointStatementContext *MySQLParser::savepointStatement() {
  SavepointStatementContext *_localctx = _tracker.createInstance<SavepointStatementContext>(_ctx, getState());
  enterRule(_localctx, 438, MySQLParser::RuleSavepointStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3913);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SAVEPOINT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3884);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3885);
        identifier();
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3886);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3888);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3887);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3908);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TO_SYMBOL: {
            setState(3890);
            match(MySQLParser::TO_SYMBOL);
            setState(3892);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 401, _ctx)) {
              case 1: {
                setState(3891);
                match(MySQLParser::SAVEPOINT_SYMBOL);
                break;
              }

              default:
                break;
            }
            setState(3894);
            identifier();
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::AND_SYMBOL:
          case MySQLParser::NO_SYMBOL:
          case MySQLParser::RELEASE_SYMBOL:
          case MySQLParser::SEMICOLON_SYMBOL: {
            setState(3900);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::AND_SYMBOL) {
              setState(3895);
              match(MySQLParser::AND_SYMBOL);
              setState(3897);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3896);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3899);
              match(MySQLParser::CHAIN_SYMBOL);
            }
            setState(3906);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
              setState(3903);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3902);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3905);
              match(MySQLParser::RELEASE_SYMBOL);
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::RELEASE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3910);
        match(MySQLParser::RELEASE_SYMBOL);
        setState(3911);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3912);
        identifier();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStatementContext ------------------------------------------------------------------

MySQLParser::LockStatementContext::LockStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LockStatementContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

std::vector<MySQLParser::LockItemContext *> MySQLParser::LockStatementContext::lockItem() {
  return getRuleContexts<MySQLParser::LockItemContext>();
}

MySQLParser::LockItemContext *MySQLParser::LockStatementContext::lockItem(size_t i) {
  return getRuleContext<MySQLParser::LockItemContext>(i);
}

tree::TerminalNode *MySQLParser::LockStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::LockStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::LockStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::LockStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockStatementContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockStatementContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}

size_t MySQLParser::LockStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLockStatement;
}

void MySQLParser::LockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStatement(this);
}

void MySQLParser::LockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStatement(this);
}

std::any MySQLParser::LockStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockStatementContext *MySQLParser::lockStatement() {
  LockStatementContext *_localctx = _tracker.createInstance<LockStatementContext>(_ctx, getState());
  enterRule(_localctx, 440, MySQLParser::RuleLockStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3931);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3915);
        match(MySQLParser::LOCK_SYMBOL);
        setState(3916);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::TABLES_SYMBOL

              || _la == MySQLParser::TABLE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3917);
        lockItem();
        setState(3922);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(3918);
          match(MySQLParser::COMMA_SYMBOL);
          setState(3919);
          lockItem();
          setState(3924);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(3925);
        match(MySQLParser::LOCK_SYMBOL);
        setState(3926);
        match(MySQLParser::INSTANCE_SYMBOL);
        setState(3927);
        match(MySQLParser::FOR_SYMBOL);
        setState(3928);
        match(MySQLParser::BACKUP_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(3929);
        match(MySQLParser::UNLOCK_SYMBOL);
        setState(3930);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INSTANCE_SYMBOL || _la == MySQLParser::TABLES_SYMBOL

              || _la == MySQLParser::TABLE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockItemContext ------------------------------------------------------------------

MySQLParser::LockItemContext::LockItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::LockItemContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LockOptionContext *MySQLParser::LockItemContext::lockOption() {
  return getRuleContext<MySQLParser::LockOptionContext>(0);
}

MySQLParser::TableAliasContext *MySQLParser::LockItemContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

size_t MySQLParser::LockItemContext::getRuleIndex() const {
  return MySQLParser::RuleLockItem;
}

void MySQLParser::LockItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockItem(this);
}

void MySQLParser::LockItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockItem(this);
}

std::any MySQLParser::LockItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockItemContext *MySQLParser::lockItem() {
  LockItemContext *_localctx = _tracker.createInstance<LockItemContext>(_ctx, getState());
  enterRule(_localctx, 442, MySQLParser::RuleLockItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3933);
    tableRef();
    setState(3935);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 410, _ctx)) {
      case 1: {
        setState(3934);
        tableAlias();
        break;
      }

      default:
        break;
    }
    setState(3937);
    lockOption();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockOptionContext ------------------------------------------------------------------

MySQLParser::LockOptionContext::LockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LockOptionContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockOptionContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

size_t MySQLParser::LockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLockOption;
}

void MySQLParser::LockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockOption(this);
}

void MySQLParser::LockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockOption(this);
}

std::any MySQLParser::LockOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLockOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LockOptionContext *MySQLParser::lockOption() {
  LockOptionContext *_localctx = _tracker.createInstance<LockOptionContext>(_ctx, getState());
  enterRule(_localctx, 444, MySQLParser::RuleLockOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(3947);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3939);
        match(MySQLParser::READ_SYMBOL);
        setState(3941);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL) {
          setState(3940);
          match(MySQLParser::LOCAL_SYMBOL);
        }
        break;
      }

      case MySQLParser::LOW_PRIORITY_SYMBOL:
      case MySQLParser::WRITE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3944);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOW_PRIORITY_SYMBOL) {
          setState(3943);
          match(MySQLParser::LOW_PRIORITY_SYMBOL);
        }
        setState(3946);
        match(MySQLParser::WRITE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaStatementContext ------------------------------------------------------------------

MySQLParser::XaStatementContext::XaStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::XaStatementContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

MySQLParser::XidContext *MySQLParser::XaStatementContext::xid() {
  return getRuleContext<MySQLParser::XidContext>(0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

MySQLParser::XaConvertContext *MySQLParser::XaStatementContext::xaConvert() {
  return getRuleContext<MySQLParser::XaConvertContext>(0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaStatementContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

size_t MySQLParser::XaStatementContext::getRuleIndex() const {
  return MySQLParser::RuleXaStatement;
}

void MySQLParser::XaStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaStatement(this);
}

void MySQLParser::XaStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaStatement(this);
}

std::any MySQLParser::XaStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitXaStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XaStatementContext *MySQLParser::xaStatement() {
  XaStatementContext *_localctx = _tracker.createInstance<XaStatementContext>(_ctx, getState());
  enterRule(_localctx, 446, MySQLParser::RuleXaStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3949);
    match(MySQLParser::XA_SYMBOL);
    setState(3978);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BEGIN_SYMBOL:
      case MySQLParser::START_SYMBOL: {
        setState(3950);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BEGIN_SYMBOL || _la == MySQLParser::START_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3951);
        xid();
        setState(3953);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::JOIN_SYMBOL || _la == MySQLParser::RESUME_SYMBOL) {
          setState(3952);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::JOIN_SYMBOL || _la == MySQLParser::RESUME_SYMBOL)) {
            _errHandler->recoverInline(this);
          } else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::END_SYMBOL: {
        setState(3955);
        match(MySQLParser::END_SYMBOL);
        setState(3956);
        xid();
        setState(3962);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SUSPEND_SYMBOL) {
          setState(3957);
          match(MySQLParser::SUSPEND_SYMBOL);
          setState(3960);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::FOR_SYMBOL) {
            setState(3958);
            match(MySQLParser::FOR_SYMBOL);
            setState(3959);
            match(MySQLParser::MIGRATE_SYMBOL);
          }
        }
        break;
      }

      case MySQLParser::PREPARE_SYMBOL: {
        setState(3964);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(3965);
        xid();
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        setState(3966);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3967);
        xid();
        setState(3970);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ONE_SYMBOL) {
          setState(3968);
          match(MySQLParser::ONE_SYMBOL);
          setState(3969);
          match(MySQLParser::PHASE_SYMBOL);
        }
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        setState(3972);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3973);
        xid();
        break;
      }

      case MySQLParser::RECOVER_SYMBOL: {
        setState(3974);
        match(MySQLParser::RECOVER_SYMBOL);
        setState(3976);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CONVERT_SYMBOL) {
          setState(3975);
          xaConvert();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaConvertContext ------------------------------------------------------------------

MySQLParser::XaConvertContext::XaConvertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::XaConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::XaConvertContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

size_t MySQLParser::XaConvertContext::getRuleIndex() const {
  return MySQLParser::RuleXaConvert;
}

void MySQLParser::XaConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaConvert(this);
}

void MySQLParser::XaConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaConvert(this);
}

std::any MySQLParser::XaConvertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitXaConvert(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XaConvertContext *MySQLParser::xaConvert() {
  XaConvertContext *_localctx = _tracker.createInstance<XaConvertContext>(_ctx, getState());
  enterRule(_localctx, 448, MySQLParser::RuleXaConvert);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3980);
    match(MySQLParser::CONVERT_SYMBOL);
    setState(3981);
    match(MySQLParser::XID_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XidContext ------------------------------------------------------------------

MySQLParser::XidContext::XidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::XidContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext *MySQLParser::XidContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::XidContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::XidContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulong_numberContext *MySQLParser::XidContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

size_t MySQLParser::XidContext::getRuleIndex() const {
  return MySQLParser::RuleXid;
}

void MySQLParser::XidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXid(this);
}

void MySQLParser::XidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXid(this);
}

std::any MySQLParser::XidContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitXid(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::XidContext *MySQLParser::xid() {
  XidContext *_localctx = _tracker.createInstance<XidContext>(_ctx, getState());
  enterRule(_localctx, 450, MySQLParser::RuleXid);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3983);
    textString();
    setState(3990);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3984);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3985);
      textString();
      setState(3988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3986);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3987);
        ulong_number();
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationStatementContext ------------------------------------------------------------------

MySQLParser::ReplicationStatementContext::ReplicationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::PURGE_SYMBOL() {
  return getToken(MySQLParser::PURGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::ReplicationStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ReplicationStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ChangeSourceContext *MySQLParser::ReplicationStatementContext::changeSource() {
  return getRuleContext<MySQLParser::ChangeSourceContext>(0);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

std::vector<MySQLParser::ResetOptionContext *> MySQLParser::ReplicationStatementContext::resetOption() {
  return getRuleContexts<MySQLParser::ResetOptionContext>();
}

MySQLParser::ResetOptionContext *MySQLParser::ReplicationStatementContext::resetOption(size_t i) {
  return getRuleContext<MySQLParser::ResetOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ReplicationStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::ReplicationStatementContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

MySQLParser::IfExistsContext *MySQLParser::ReplicationStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

MySQLParser::IdentifierContext *MySQLParser::ReplicationStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::StartReplicaStatementContext *MySQLParser::ReplicationStatementContext::startReplicaStatement() {
  return getRuleContext<MySQLParser::StartReplicaStatementContext>(0);
}

MySQLParser::StopReplicaStatementContext *MySQLParser::ReplicationStatementContext::stopReplicaStatement() {
  return getRuleContext<MySQLParser::StopReplicaStatementContext>(0);
}

MySQLParser::ChangeReplicationContext *MySQLParser::ReplicationStatementContext::changeReplication() {
  return getRuleContext<MySQLParser::ChangeReplicationContext>(0);
}

MySQLParser::ReplicationLoadContext *MySQLParser::ReplicationStatementContext::replicationLoad() {
  return getRuleContext<MySQLParser::ReplicationLoadContext>(0);
}

MySQLParser::GroupReplicationContext *MySQLParser::ReplicationStatementContext::groupReplication() {
  return getRuleContext<MySQLParser::GroupReplicationContext>(0);
}

size_t MySQLParser::ReplicationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationStatement;
}

void MySQLParser::ReplicationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationStatement(this);
}

void MySQLParser::ReplicationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationStatement(this);
}

std::any MySQLParser::ReplicationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplicationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicationStatementContext *MySQLParser::replicationStatement() {
  ReplicationStatementContext *_localctx = _tracker.createInstance<ReplicationStatementContext>(_ctx, getState());
  enterRule(_localctx, 452, MySQLParser::RuleReplicationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4023);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 425, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(3992);
        match(MySQLParser::PURGE_SYMBOL);
        setState(3993);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BINARY_SYMBOL || _la == MySQLParser::MASTER_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3994);
        match(MySQLParser::LOGS_SYMBOL);
        setState(3999);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TO_SYMBOL: {
            setState(3995);
            match(MySQLParser::TO_SYMBOL);
            setState(3996);
            textLiteral();
            break;
          }

          case MySQLParser::BEFORE_SYMBOL: {
            setState(3997);
            match(MySQLParser::BEFORE_SYMBOL);
            setState(3998);
            expr(0);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4001);
        changeSource();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4002);
        match(MySQLParser::RESET_SYMBOL);
        setState(4003);
        resetOption();
        setState(4008);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4004);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4005);
          resetOption();
          setState(4010);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(4011);
        match(MySQLParser::RESET_SYMBOL);
        setState(4012);
        match(MySQLParser::PERSIST_SYMBOL);
        setState(4016);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IF_SYMBOL) {
          setState(4013);
          ifExists();
          setState(4014);
          identifier();
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(4018);
        startReplicaStatement();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(4019);
        stopReplicaStatement();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(4020);
        changeReplication();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(4021);
        replicationLoad();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(4022);
        groupReplication();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetOptionContext ------------------------------------------------------------------

MySQLParser::ResetOptionContext::ResetOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ResetOptionContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

MySQLParser::SourceResetOptionsContext *MySQLParser::ResetOptionContext::sourceResetOptions() {
  return getRuleContext<MySQLParser::SourceResetOptionsContext>(0);
}

MySQLParser::ReplicaContext *MySQLParser::ResetOptionContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

tree::TerminalNode *MySQLParser::ResetOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::ChannelContext *MySQLParser::ResetOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ResetOptionContext::getRuleIndex() const {
  return MySQLParser::RuleResetOption;
}

void MySQLParser::ResetOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetOption(this);
}

void MySQLParser::ResetOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetOption(this);
}

std::any MySQLParser::ResetOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResetOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResetOptionContext *MySQLParser::resetOption() {
  ResetOptionContext *_localctx = _tracker.createInstance<ResetOptionContext>(_ctx, getState());
  enterRule(_localctx, 454, MySQLParser::RuleResetOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4036);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4025);
        match(MySQLParser::MASTER_SYMBOL);
        setState(4027);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::TO_SYMBOL) {
          setState(4026);
          sourceResetOptions();
        }
        break;
      }

      case MySQLParser::SLAVE_SYMBOL:
      case MySQLParser::REPLICA_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4029);
        replica();
        setState(4031);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL) {
          setState(4030);
          match(MySQLParser::ALL_SYMBOL);
        }
        setState(4034);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(4033);
          channel();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceResetOptionsContext ------------------------------------------------------------------

MySQLParser::SourceResetOptionsContext::SourceResetOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SourceResetOptionsContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::SourceResetOptionsContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

size_t MySQLParser::SourceResetOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSourceResetOptions;
}

void MySQLParser::SourceResetOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceResetOptions(this);
}

void MySQLParser::SourceResetOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceResetOptions(this);
}

std::any MySQLParser::SourceResetOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceResetOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceResetOptionsContext *MySQLParser::sourceResetOptions() {
  SourceResetOptionsContext *_localctx = _tracker.createInstance<SourceResetOptionsContext>(_ctx, getState());
  enterRule(_localctx, 456, MySQLParser::RuleSourceResetOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4038);
    match(MySQLParser::TO_SYMBOL);
    setState(4039);
    real_ulonglong_number();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationLoadContext ------------------------------------------------------------------

MySQLParser::ReplicationLoadContext::ReplicationLoadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplicationLoadContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationLoadContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationLoadContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationLoadContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicationLoadContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ReplicationLoadContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

size_t MySQLParser::ReplicationLoadContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationLoad;
}

void MySQLParser::ReplicationLoadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationLoad(this);
}

void MySQLParser::ReplicationLoadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationLoad(this);
}

std::any MySQLParser::ReplicationLoadContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplicationLoad(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicationLoadContext *MySQLParser::replicationLoad() {
  ReplicationLoadContext *_localctx = _tracker.createInstance<ReplicationLoadContext>(_ctx, getState());
  enterRule(_localctx, 458, MySQLParser::RuleReplicationLoad);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4041);
    match(MySQLParser::LOAD_SYMBOL);
    setState(4045);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATA_SYMBOL: {
        setState(4042);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::TABLE_SYMBOL: {
        setState(4043);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4044);
        tableRef();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(4047);
    match(MySQLParser::FROM_SYMBOL);
    setState(4048);
    match(MySQLParser::MASTER_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceContext ------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceContext::ChangeReplicationSourceContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSource;
}

void MySQLParser::ChangeReplicationSourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSource(this);
}

void MySQLParser::ChangeReplicationSourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSource(this);
}

std::any MySQLParser::ChangeReplicationSourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSource(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceContext *MySQLParser::changeReplicationSource() {
  ChangeReplicationSourceContext *_localctx = _tracker.createInstance<ChangeReplicationSourceContext>(_ctx, getState());
  enterRule(_localctx, 460, MySQLParser::RuleChangeReplicationSource);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4054);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 431, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4050);
        match(MySQLParser::MASTER_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4051);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(4052);
        match(MySQLParser::REPLICATION_SYMBOL);
        setState(4053);
        match(MySQLParser::SOURCE_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeSourceContext ------------------------------------------------------------------

MySQLParser::ChangeSourceContext::ChangeSourceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeSourceContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

MySQLParser::ChangeReplicationSourceContext *MySQLParser::ChangeSourceContext::changeReplicationSource() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceContext>(0);
}

tree::TerminalNode *MySQLParser::ChangeSourceContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::SourceDefinitionsContext *MySQLParser::ChangeSourceContext::sourceDefinitions() {
  return getRuleContext<MySQLParser::SourceDefinitionsContext>(0);
}

MySQLParser::ChannelContext *MySQLParser::ChangeSourceContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ChangeSourceContext::getRuleIndex() const {
  return MySQLParser::RuleChangeSource;
}

void MySQLParser::ChangeSourceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeSource(this);
}

void MySQLParser::ChangeSourceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeSource(this);
}

std::any MySQLParser::ChangeSourceContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeSource(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeSourceContext *MySQLParser::changeSource() {
  ChangeSourceContext *_localctx = _tracker.createInstance<ChangeSourceContext>(_ctx, getState());
  enterRule(_localctx, 462, MySQLParser::RuleChangeSource);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4056);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(4057);
    changeReplicationSource();
    setState(4058);
    match(MySQLParser::TO_SYMBOL);
    setState(4059);
    sourceDefinitions();
    setState(4061);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4060);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceDefinitionsContext ------------------------------------------------------------------

MySQLParser::SourceDefinitionsContext::SourceDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SourceDefinitionContext *> MySQLParser::SourceDefinitionsContext::sourceDefinition() {
  return getRuleContexts<MySQLParser::SourceDefinitionContext>();
}

MySQLParser::SourceDefinitionContext *MySQLParser::SourceDefinitionsContext::sourceDefinition(size_t i) {
  return getRuleContext<MySQLParser::SourceDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SourceDefinitionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::SourceDefinitionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::SourceDefinitionsContext::getRuleIndex() const {
  return MySQLParser::RuleSourceDefinitions;
}

void MySQLParser::SourceDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceDefinitions(this);
}

void MySQLParser::SourceDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceDefinitions(this);
}

std::any MySQLParser::SourceDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceDefinitionsContext *MySQLParser::sourceDefinitions() {
  SourceDefinitionsContext *_localctx = _tracker.createInstance<SourceDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 464, MySQLParser::RuleSourceDefinitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4063);
    sourceDefinition();
    setState(4068);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4064);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4065);
      sourceDefinition();
      setState(4070);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceDefinitionContext ------------------------------------------------------------------

MySQLParser::SourceDefinitionContext::SourceDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ChangeReplicationSourceHostContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceHost() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceHostContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::SourceDefinitionContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::NETWORK_NAMESPACE_SYMBOL() {
  return getToken(MySQLParser::NETWORK_NAMESPACE_SYMBOL, 0);
}

MySQLParser::ChangeReplicationSourceBindContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceBind() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceBindContext>(0);
}

MySQLParser::ChangeReplicationSourceUserContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceUser() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceUserContext>(0);
}

MySQLParser::ChangeReplicationSourcePasswordContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourcePassword() {
  return getRuleContext<MySQLParser::ChangeReplicationSourcePasswordContext>(0);
}

MySQLParser::ChangeReplicationSourcePortContext *MySQLParser::SourceDefinitionContext::changeReplicationSourcePort() {
  return getRuleContext<MySQLParser::ChangeReplicationSourcePortContext>(0);
}

MySQLParser::Ulong_numberContext *MySQLParser::SourceDefinitionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

MySQLParser::ChangeReplicationSourceConnectRetryContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceConnectRetry() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceConnectRetryContext>(0);
}

MySQLParser::ChangeReplicationSourceRetryCountContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceRetryCount() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceRetryCountContext>(0);
}

MySQLParser::ChangeReplicationSourceDelayContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceDelay() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceDelayContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceSSL() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCAContext *MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCA() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCAContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCApathContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCApath() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCApathContext>(0);
}

MySQLParser::ChangeReplicationSourceTLSVersionContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceTLSVersion() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceTLSVersionContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCertContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCert() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCertContext>(0);
}

MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceTLSCiphersuites() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext>(0);
}

MySQLParser::SourceTlsCiphersuitesDefContext *MySQLParser::SourceDefinitionContext::sourceTlsCiphersuitesDef() {
  return getRuleContext<MySQLParser::SourceTlsCiphersuitesDefContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCipherContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCipher() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCipherContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLKeyContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLKey() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLKeyContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLVerifyServerCert() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCLRContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCLR() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCLRContext>(0);
}

MySQLParser::TextLiteralContext *MySQLParser::SourceDefinitionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::ChangeReplicationSourceSSLCLRpathContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceSSLCLRpath() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceSSLCLRpathContext>(0);
}

MySQLParser::ChangeReplicationSourcePublicKeyContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourcePublicKey() {
  return getRuleContext<MySQLParser::ChangeReplicationSourcePublicKeyContext>(0);
}

MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceGetSourcePublicKey() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext>(0);
}

MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceHeartbeatPeriod() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

MySQLParser::ServerIdListContext *MySQLParser::SourceDefinitionContext::serverIdList() {
  return getRuleContext<MySQLParser::ServerIdListContext>(0);
}

MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceCompressionAlgorithm() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext>(0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::SourceDefinitionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceZstdCompressionLevel() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext>(0);
}

MySQLParser::ChangeReplicationSourceAutoPositionContext *
MySQLParser::SourceDefinitionContext::changeReplicationSourceAutoPosition() {
  return getRuleContext<MySQLParser::ChangeReplicationSourceAutoPositionContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::PRIVILEGE_CHECKS_USER_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGE_CHECKS_USER_SYMBOL, 0);
}

MySQLParser::PrivilegeCheckDefContext *MySQLParser::SourceDefinitionContext::privilegeCheckDef() {
  return getRuleContext<MySQLParser::PrivilegeCheckDefContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::REQUIRE_ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0);
}

MySQLParser::TablePrimaryKeyCheckDefContext *MySQLParser::SourceDefinitionContext::tablePrimaryKeyCheckDef() {
  return getRuleContext<MySQLParser::TablePrimaryKeyCheckDefContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::SourceDefinitionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL() {
  return getToken(MySQLParser::ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL, 0);
}

MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext *
MySQLParser::SourceDefinitionContext::assignGtidsToAnonymousTransactionsDefinition() {
  return getRuleContext<MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext>(0);
}

tree::TerminalNode *MySQLParser::SourceDefinitionContext::GTID_ONLY_SYMBOL() {
  return getToken(MySQLParser::GTID_ONLY_SYMBOL, 0);
}

MySQLParser::SourceFileDefContext *MySQLParser::SourceDefinitionContext::sourceFileDef() {
  return getRuleContext<MySQLParser::SourceFileDefContext>(0);
}

size_t MySQLParser::SourceDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleSourceDefinition;
}

void MySQLParser::SourceDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceDefinition(this);
}

void MySQLParser::SourceDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceDefinition(this);
}

std::any MySQLParser::SourceDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceDefinitionContext *MySQLParser::sourceDefinition() {
  SourceDefinitionContext *_localctx = _tracker.createInstance<SourceDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 466, MySQLParser::RuleSourceDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4199);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 434, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4071);
        changeReplicationSourceHost();
        setState(4072);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4073);
        textStringNoLinebreak();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4075);
        match(MySQLParser::NETWORK_NAMESPACE_SYMBOL);
        setState(4076);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4077);
        textStringNoLinebreak();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4078);
        changeReplicationSourceBind();
        setState(4079);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4080);
        textStringNoLinebreak();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(4082);
        changeReplicationSourceUser();
        setState(4083);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4084);
        textStringNoLinebreak();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(4086);
        changeReplicationSourcePassword();
        setState(4087);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4088);
        textStringNoLinebreak();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(4090);
        changeReplicationSourcePort();
        setState(4091);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4092);
        ulong_number();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(4094);
        changeReplicationSourceConnectRetry();
        setState(4095);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4096);
        ulong_number();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(4098);
        changeReplicationSourceRetryCount();
        setState(4099);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4100);
        ulong_number();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(4102);
        changeReplicationSourceDelay();
        setState(4103);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4104);
        ulong_number();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(4106);
        changeReplicationSourceSSL();
        setState(4107);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4108);
        ulong_number();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(4110);
        changeReplicationSourceSSLCA();
        setState(4111);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4112);
        textStringNoLinebreak();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(4114);
        changeReplicationSourceSSLCApath();
        setState(4115);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4116);
        textStringNoLinebreak();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(4118);
        changeReplicationSourceTLSVersion();
        setState(4119);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4120);
        textStringNoLinebreak();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(4122);
        changeReplicationSourceSSLCert();
        setState(4123);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4124);
        textStringNoLinebreak();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(4126);
        changeReplicationSourceTLSCiphersuites();
        setState(4127);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4128);
        sourceTlsCiphersuitesDef();
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(4130);
        changeReplicationSourceSSLCipher();
        setState(4131);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4132);
        textStringNoLinebreak();
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(4134);
        changeReplicationSourceSSLKey();
        setState(4135);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4136);
        textStringNoLinebreak();
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(4138);
        changeReplicationSourceSSLVerifyServerCert();
        setState(4139);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4140);
        ulong_number();
        break;
      }

      case 19: {
        enterOuterAlt(_localctx, 19);
        setState(4142);
        changeReplicationSourceSSLCLR();
        setState(4143);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4144);
        textLiteral();
        break;
      }

      case 20: {
        enterOuterAlt(_localctx, 20);
        setState(4146);
        changeReplicationSourceSSLCLRpath();
        setState(4147);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4148);
        textStringNoLinebreak();
        break;
      }

      case 21: {
        enterOuterAlt(_localctx, 21);
        setState(4150);
        changeReplicationSourcePublicKey();
        setState(4151);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4152);
        textStringNoLinebreak();
        break;
      }

      case 22: {
        enterOuterAlt(_localctx, 22);
        setState(4154);
        changeReplicationSourceGetSourcePublicKey();
        setState(4155);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4156);
        ulong_number();
        break;
      }

      case 23: {
        enterOuterAlt(_localctx, 23);
        setState(4158);
        changeReplicationSourceHeartbeatPeriod();
        setState(4159);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4160);
        ulong_number();
        break;
      }

      case 24: {
        enterOuterAlt(_localctx, 24);
        setState(4162);
        match(MySQLParser::IGNORE_SERVER_IDS_SYMBOL);
        setState(4163);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4164);
        serverIdList();
        break;
      }

      case 25: {
        enterOuterAlt(_localctx, 25);
        setState(4165);
        changeReplicationSourceCompressionAlgorithm();
        setState(4166);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4167);
        textStringLiteral();
        break;
      }

      case 26: {
        enterOuterAlt(_localctx, 26);
        setState(4169);
        changeReplicationSourceZstdCompressionLevel();
        setState(4170);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4171);
        ulong_number();
        break;
      }

      case 27: {
        enterOuterAlt(_localctx, 27);
        setState(4173);
        changeReplicationSourceAutoPosition();
        setState(4174);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4175);
        ulong_number();
        break;
      }

      case 28: {
        enterOuterAlt(_localctx, 28);
        setState(4177);
        match(MySQLParser::PRIVILEGE_CHECKS_USER_SYMBOL);
        setState(4178);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4179);
        privilegeCheckDef();
        break;
      }

      case 29: {
        enterOuterAlt(_localctx, 29);
        setState(4180);
        match(MySQLParser::REQUIRE_ROW_FORMAT_SYMBOL);
        setState(4181);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4182);
        ulong_number();
        break;
      }

      case 30: {
        enterOuterAlt(_localctx, 30);
        setState(4183);
        match(MySQLParser::REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL);
        setState(4184);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4185);
        tablePrimaryKeyCheckDef();
        break;
      }

      case 31: {
        enterOuterAlt(_localctx, 31);
        setState(4186);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(4187);
        match(MySQLParser::SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL);
        setState(4188);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4189);
        real_ulong_number();
        break;
      }

      case 32: {
        enterOuterAlt(_localctx, 32);
        setState(4190);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(4191);
        match(MySQLParser::ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL);
        setState(4192);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4193);
        assignGtidsToAnonymousTransactionsDefinition();
        break;
      }

      case 33: {
        enterOuterAlt(_localctx, 33);
        setState(4194);

        if (!(serverVersion >= 80027))
          throw FailedPredicateException(this, "serverVersion >= 80027");
        setState(4195);
        match(MySQLParser::GTID_ONLY_SYMBOL);
        setState(4196);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4197);
        real_ulong_number();
        break;
      }

      case 34: {
        enterOuterAlt(_localctx, 34);
        setState(4198);
        sourceFileDef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceAutoPositionContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceAutoPositionContext::ChangeReplicationSourceAutoPositionContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceAutoPositionContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceAutoPositionContext::SOURCE_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::SOURCE_AUTO_POSITION_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceAutoPositionContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceAutoPosition;
}

void MySQLParser::ChangeReplicationSourceAutoPositionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceAutoPosition(this);
}

void MySQLParser::ChangeReplicationSourceAutoPositionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceAutoPosition(this);
}

std::any MySQLParser::ChangeReplicationSourceAutoPositionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceAutoPosition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceAutoPositionContext *MySQLParser::changeReplicationSourceAutoPosition() {
  ChangeReplicationSourceAutoPositionContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceAutoPositionContext>(_ctx, getState());
  enterRule(_localctx, 468, MySQLParser::RuleChangeReplicationSourceAutoPosition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4201);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_AUTO_POSITION_SYMBOL || _la == MySQLParser::SOURCE_AUTO_POSITION_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceHostContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceHostContext::ChangeReplicationSourceHostContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceHostContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceHostContext::SOURCE_HOST_SYMBOL() {
  return getToken(MySQLParser::SOURCE_HOST_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceHostContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceHost;
}

void MySQLParser::ChangeReplicationSourceHostContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceHost(this);
}

void MySQLParser::ChangeReplicationSourceHostContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceHost(this);
}

std::any MySQLParser::ChangeReplicationSourceHostContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceHost(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceHostContext *MySQLParser::changeReplicationSourceHost() {
  ChangeReplicationSourceHostContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceHostContext>(_ctx, getState());
  enterRule(_localctx, 470, MySQLParser::RuleChangeReplicationSourceHost);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4203);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_HOST_SYMBOL || _la == MySQLParser::SOURCE_HOST_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceBindContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceBindContext::ChangeReplicationSourceBindContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceBindContext::MASTER_BIND_SYMBOL() {
  return getToken(MySQLParser::MASTER_BIND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceBindContext::SOURCE_BIND_SYMBOL() {
  return getToken(MySQLParser::SOURCE_BIND_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceBindContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceBind;
}

void MySQLParser::ChangeReplicationSourceBindContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceBind(this);
}

void MySQLParser::ChangeReplicationSourceBindContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceBind(this);
}

std::any MySQLParser::ChangeReplicationSourceBindContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceBind(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceBindContext *MySQLParser::changeReplicationSourceBind() {
  ChangeReplicationSourceBindContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceBindContext>(_ctx, getState());
  enterRule(_localctx, 472, MySQLParser::RuleChangeReplicationSourceBind);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4205);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_BIND_SYMBOL || _la == MySQLParser::SOURCE_BIND_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceUserContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceUserContext::ChangeReplicationSourceUserContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceUserContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceUserContext::SOURCE_USER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_USER_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceUserContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceUser;
}

void MySQLParser::ChangeReplicationSourceUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceUser(this);
}

void MySQLParser::ChangeReplicationSourceUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceUser(this);
}

std::any MySQLParser::ChangeReplicationSourceUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceUserContext *MySQLParser::changeReplicationSourceUser() {
  ChangeReplicationSourceUserContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceUserContext>(_ctx, getState());
  enterRule(_localctx, 474, MySQLParser::RuleChangeReplicationSourceUser);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4207);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_USER_SYMBOL || _la == MySQLParser::SOURCE_USER_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourcePasswordContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourcePasswordContext::ChangeReplicationSourcePasswordContext(ParserRuleContext *parent,
                                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePasswordContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePasswordContext::SOURCE_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PASSWORD_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourcePasswordContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourcePassword;
}

void MySQLParser::ChangeReplicationSourcePasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourcePassword(this);
}

void MySQLParser::ChangeReplicationSourcePasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourcePassword(this);
}

std::any MySQLParser::ChangeReplicationSourcePasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourcePassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourcePasswordContext *MySQLParser::changeReplicationSourcePassword() {
  ChangeReplicationSourcePasswordContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourcePasswordContext>(_ctx, getState());
  enterRule(_localctx, 476, MySQLParser::RuleChangeReplicationSourcePassword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4209);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_PASSWORD_SYMBOL || _la == MySQLParser::SOURCE_PASSWORD_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourcePortContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourcePortContext::ChangeReplicationSourcePortContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePortContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePortContext::SOURCE_PORT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PORT_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourcePortContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourcePort;
}

void MySQLParser::ChangeReplicationSourcePortContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourcePort(this);
}

void MySQLParser::ChangeReplicationSourcePortContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourcePort(this);
}

std::any MySQLParser::ChangeReplicationSourcePortContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourcePort(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourcePortContext *MySQLParser::changeReplicationSourcePort() {
  ChangeReplicationSourcePortContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourcePortContext>(_ctx, getState());
  enterRule(_localctx, 478, MySQLParser::RuleChangeReplicationSourcePort);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4211);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_PORT_SYMBOL || _la == MySQLParser::SOURCE_PORT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceConnectRetryContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceConnectRetryContext::ChangeReplicationSourceConnectRetryContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceConnectRetryContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceConnectRetryContext::SOURCE_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_CONNECT_RETRY_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceConnectRetryContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceConnectRetry;
}

void MySQLParser::ChangeReplicationSourceConnectRetryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceConnectRetry(this);
}

void MySQLParser::ChangeReplicationSourceConnectRetryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceConnectRetry(this);
}

std::any MySQLParser::ChangeReplicationSourceConnectRetryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceConnectRetry(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceConnectRetryContext *MySQLParser::changeReplicationSourceConnectRetry() {
  ChangeReplicationSourceConnectRetryContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceConnectRetryContext>(_ctx, getState());
  enterRule(_localctx, 480, MySQLParser::RuleChangeReplicationSourceConnectRetry);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4213);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_CONNECT_RETRY_SYMBOL || _la == MySQLParser::SOURCE_CONNECT_RETRY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceRetryCountContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceRetryCountContext::ChangeReplicationSourceRetryCountContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceRetryCountContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceRetryCountContext::SOURCE_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_RETRY_COUNT_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceRetryCountContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceRetryCount;
}

void MySQLParser::ChangeReplicationSourceRetryCountContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceRetryCount(this);
}

void MySQLParser::ChangeReplicationSourceRetryCountContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceRetryCount(this);
}

std::any MySQLParser::ChangeReplicationSourceRetryCountContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceRetryCount(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceRetryCountContext *MySQLParser::changeReplicationSourceRetryCount() {
  ChangeReplicationSourceRetryCountContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceRetryCountContext>(_ctx, getState());
  enterRule(_localctx, 482, MySQLParser::RuleChangeReplicationSourceRetryCount);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4215);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_RETRY_COUNT_SYMBOL || _la == MySQLParser::SOURCE_RETRY_COUNT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceDelayContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceDelayContext::ChangeReplicationSourceDelayContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceDelayContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceDelayContext::SOURCE_DELAY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_DELAY_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceDelayContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceDelay;
}

void MySQLParser::ChangeReplicationSourceDelayContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceDelay(this);
}

void MySQLParser::ChangeReplicationSourceDelayContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceDelay(this);
}

std::any MySQLParser::ChangeReplicationSourceDelayContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceDelay(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceDelayContext *MySQLParser::changeReplicationSourceDelay() {
  ChangeReplicationSourceDelayContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceDelayContext>(_ctx, getState());
  enterRule(_localctx, 484, MySQLParser::RuleChangeReplicationSourceDelay);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4217);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_DELAY_SYMBOL || _la == MySQLParser::SOURCE_DELAY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLContext ------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLContext::ChangeReplicationSourceSSLContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLContext::SOURCE_SSL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSL;
}

void MySQLParser::ChangeReplicationSourceSSLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSL(this);
}

void MySQLParser::ChangeReplicationSourceSSLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSL(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSL(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLContext *MySQLParser::changeReplicationSourceSSL() {
  ChangeReplicationSourceSSLContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLContext>(_ctx, getState());
  enterRule(_localctx, 486, MySQLParser::RuleChangeReplicationSourceSSL);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4219);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_SYMBOL || _la == MySQLParser::SOURCE_SSL_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCAContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCAContext::ChangeReplicationSourceSSLCAContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCAContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCAContext::SOURCE_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CA_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCAContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCA;
}

void MySQLParser::ChangeReplicationSourceSSLCAContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCA(this);
}

void MySQLParser::ChangeReplicationSourceSSLCAContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCA(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCAContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCA(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCAContext *MySQLParser::changeReplicationSourceSSLCA() {
  ChangeReplicationSourceSSLCAContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCAContext>(_ctx, getState());
  enterRule(_localctx, 488, MySQLParser::RuleChangeReplicationSourceSSLCA);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4221);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CA_SYMBOL || _la == MySQLParser::SOURCE_SSL_CA_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCApathContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCApathContext::ChangeReplicationSourceSSLCApathContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCApathContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCApathContext::SOURCE_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CAPATH_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCApathContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCApath;
}

void MySQLParser::ChangeReplicationSourceSSLCApathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCApath(this);
}

void MySQLParser::ChangeReplicationSourceSSLCApathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCApath(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCApathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCApath(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCApathContext *MySQLParser::changeReplicationSourceSSLCApath() {
  ChangeReplicationSourceSSLCApathContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCApathContext>(_ctx, getState());
  enterRule(_localctx, 490, MySQLParser::RuleChangeReplicationSourceSSLCApath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4223);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CAPATH_SYMBOL || _la == MySQLParser::SOURCE_SSL_CAPATH_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCipherContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCipherContext::ChangeReplicationSourceSSLCipherContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCipherContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCipherContext::SOURCE_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CIPHER_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCipherContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCipher;
}

void MySQLParser::ChangeReplicationSourceSSLCipherContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCipher(this);
}

void MySQLParser::ChangeReplicationSourceSSLCipherContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCipher(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCipherContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCipher(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCipherContext *MySQLParser::changeReplicationSourceSSLCipher() {
  ChangeReplicationSourceSSLCipherContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCipherContext>(_ctx, getState());
  enterRule(_localctx, 492, MySQLParser::RuleChangeReplicationSourceSSLCipher);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4225);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CIPHER_SYMBOL || _la == MySQLParser::SOURCE_SSL_CIPHER_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCLRContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCLRContext::ChangeReplicationSourceSSLCLRContext(ParserRuleContext *parent,
                                                                                        size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCLRContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCLRContext::SOURCE_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CRL_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCLRContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCLR;
}

void MySQLParser::ChangeReplicationSourceSSLCLRContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCLR(this);
}

void MySQLParser::ChangeReplicationSourceSSLCLRContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCLR(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCLRContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCLR(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCLRContext *MySQLParser::changeReplicationSourceSSLCLR() {
  ChangeReplicationSourceSSLCLRContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCLRContext>(_ctx, getState());
  enterRule(_localctx, 494, MySQLParser::RuleChangeReplicationSourceSSLCLR);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4227);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CRL_SYMBOL || _la == MySQLParser::SOURCE_SSL_CRL_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCLRpathContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCLRpathContext::ChangeReplicationSourceSSLCLRpathContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCLRpathContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCLRpathContext::SOURCE_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CRLPATH_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCLRpathContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCLRpath;
}

void MySQLParser::ChangeReplicationSourceSSLCLRpathContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCLRpath(this);
}

void MySQLParser::ChangeReplicationSourceSSLCLRpathContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCLRpath(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCLRpathContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCLRpath(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCLRpathContext *MySQLParser::changeReplicationSourceSSLCLRpath() {
  ChangeReplicationSourceSSLCLRpathContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCLRpathContext>(_ctx, getState());
  enterRule(_localctx, 496, MySQLParser::RuleChangeReplicationSourceSSLCLRpath);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4229);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CRLPATH_SYMBOL || _la == MySQLParser::SOURCE_SSL_CRLPATH_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLKeyContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLKeyContext::ChangeReplicationSourceSSLKeyContext(ParserRuleContext *parent,
                                                                                        size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLKeyContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLKeyContext::SOURCE_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_KEY_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLKeyContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLKey;
}

void MySQLParser::ChangeReplicationSourceSSLKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLKey(this);
}

void MySQLParser::ChangeReplicationSourceSSLKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLKey(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLKey(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLKeyContext *MySQLParser::changeReplicationSourceSSLKey() {
  ChangeReplicationSourceSSLKeyContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLKeyContext>(_ctx, getState());
  enterRule(_localctx, 498, MySQLParser::RuleChangeReplicationSourceSSLKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4231);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_KEY_SYMBOL || _la == MySQLParser::SOURCE_SSL_KEY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLVerifyServerCertContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::ChangeReplicationSourceSSLVerifyServerCertContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0);
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLVerifyServerCert;
}

void MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLVerifyServerCert(this);
}

void MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLVerifyServerCert(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLVerifyServerCert(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLVerifyServerCertContext *
MySQLParser::changeReplicationSourceSSLVerifyServerCert() {
  ChangeReplicationSourceSSLVerifyServerCertContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLVerifyServerCertContext>(_ctx, getState());
  enterRule(_localctx, 500, MySQLParser::RuleChangeReplicationSourceSSLVerifyServerCert);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4233);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL ||
          _la == MySQLParser::SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceTLSVersionContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceTLSVersionContext::ChangeReplicationSourceTLSVersionContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceTLSVersionContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceTLSVersionContext::SOURCE_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::SOURCE_TLS_VERSION_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceTLSVersionContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceTLSVersion;
}

void MySQLParser::ChangeReplicationSourceTLSVersionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceTLSVersion(this);
}

void MySQLParser::ChangeReplicationSourceTLSVersionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceTLSVersion(this);
}

std::any MySQLParser::ChangeReplicationSourceTLSVersionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceTLSVersion(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceTLSVersionContext *MySQLParser::changeReplicationSourceTLSVersion() {
  ChangeReplicationSourceTLSVersionContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceTLSVersionContext>(_ctx, getState());
  enterRule(_localctx, 502, MySQLParser::RuleChangeReplicationSourceTLSVersion);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4235);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_TLS_VERSION_SYMBOL || _la == MySQLParser::SOURCE_TLS_VERSION_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceTLSCiphersuitesContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::ChangeReplicationSourceTLSCiphersuitesContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::MASTER_TLS_CIPHERSUITES_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_CIPHERSUITES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::SOURCE_TLS_CIPHERSUITES_SYMBOL() {
  return getToken(MySQLParser::SOURCE_TLS_CIPHERSUITES_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceTLSCiphersuites;
}

void MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceTLSCiphersuites(this);
}

void MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceTLSCiphersuites(this);
}

std::any MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceTLSCiphersuites(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceTLSCiphersuitesContext *MySQLParser::changeReplicationSourceTLSCiphersuites() {
  ChangeReplicationSourceTLSCiphersuitesContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceTLSCiphersuitesContext>(_ctx, getState());
  enterRule(_localctx, 504, MySQLParser::RuleChangeReplicationSourceTLSCiphersuites);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4237);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_TLS_CIPHERSUITES_SYMBOL || _la == MySQLParser::SOURCE_TLS_CIPHERSUITES_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceSSLCertContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceSSLCertContext::ChangeReplicationSourceSSLCertContext(ParserRuleContext *parent,
                                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCertContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceSSLCertContext::SOURCE_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CERT_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceSSLCertContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceSSLCert;
}

void MySQLParser::ChangeReplicationSourceSSLCertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceSSLCert(this);
}

void MySQLParser::ChangeReplicationSourceSSLCertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceSSLCert(this);
}

std::any MySQLParser::ChangeReplicationSourceSSLCertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceSSLCert(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceSSLCertContext *MySQLParser::changeReplicationSourceSSLCert() {
  ChangeReplicationSourceSSLCertContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceSSLCertContext>(_ctx, getState());
  enterRule(_localctx, 506, MySQLParser::RuleChangeReplicationSourceSSLCert);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4239);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_SSL_CERT_SYMBOL || _la == MySQLParser::SOURCE_SSL_CERT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourcePublicKeyContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourcePublicKeyContext::ChangeReplicationSourcePublicKeyContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePublicKeyContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourcePublicKeyContext::SOURCE_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PUBLIC_KEY_PATH_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourcePublicKeyContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourcePublicKey;
}

void MySQLParser::ChangeReplicationSourcePublicKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourcePublicKey(this);
}

void MySQLParser::ChangeReplicationSourcePublicKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourcePublicKey(this);
}

std::any MySQLParser::ChangeReplicationSourcePublicKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourcePublicKey(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourcePublicKeyContext *MySQLParser::changeReplicationSourcePublicKey() {
  ChangeReplicationSourcePublicKeyContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourcePublicKeyContext>(_ctx, getState());
  enterRule(_localctx, 508, MySQLParser::RuleChangeReplicationSourcePublicKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4241);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL || _la == MySQLParser::SOURCE_PUBLIC_KEY_PATH_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceGetSourcePublicKeyContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::ChangeReplicationSourceGetSourcePublicKeyContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::GET_MASTER_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::GET_SOURCE_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_SOURCE_PUBLIC_KEY_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceGetSourcePublicKey;
}

void MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceGetSourcePublicKey(this);
}

void MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceGetSourcePublicKey(this);
}

std::any MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceGetSourcePublicKey(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceGetSourcePublicKeyContext *
MySQLParser::changeReplicationSourceGetSourcePublicKey() {
  ChangeReplicationSourceGetSourcePublicKeyContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceGetSourcePublicKeyContext>(_ctx, getState());
  enterRule(_localctx, 510, MySQLParser::RuleChangeReplicationSourceGetSourcePublicKey);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4243);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL || _la == MySQLParser::GET_SOURCE_PUBLIC_KEY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceHeartbeatPeriodContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::ChangeReplicationSourceHeartbeatPeriodContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::SOURCE_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::SOURCE_HEARTBEAT_PERIOD_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceHeartbeatPeriod;
}

void MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceHeartbeatPeriod(this);
}

void MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceHeartbeatPeriod(this);
}

std::any MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceHeartbeatPeriod(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceHeartbeatPeriodContext *MySQLParser::changeReplicationSourceHeartbeatPeriod() {
  ChangeReplicationSourceHeartbeatPeriodContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceHeartbeatPeriodContext>(_ctx, getState());
  enterRule(_localctx, 512, MySQLParser::RuleChangeReplicationSourceHeartbeatPeriod);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4245);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL || _la == MySQLParser::SOURCE_HEARTBEAT_PERIOD_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceCompressionAlgorithmContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::ChangeReplicationSourceCompressionAlgorithmContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::MASTER_COMPRESSION_ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::MASTER_COMPRESSION_ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::SOURCE_COMPRESSION_ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::SOURCE_COMPRESSION_ALGORITHM_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceCompressionAlgorithm;
}

void MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceCompressionAlgorithm(this);
}

void MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceCompressionAlgorithm(this);
}

std::any MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceCompressionAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceCompressionAlgorithmContext *
MySQLParser::changeReplicationSourceCompressionAlgorithm() {
  ChangeReplicationSourceCompressionAlgorithmContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceCompressionAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 514, MySQLParser::RuleChangeReplicationSourceCompressionAlgorithm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4247);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_COMPRESSION_ALGORITHM_SYMBOL ||
          _la == MySQLParser::SOURCE_COMPRESSION_ALGORITHM_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationSourceZstdCompressionLevelContext
//------------------------------------------------------------------

MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::ChangeReplicationSourceZstdCompressionLevelContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() {
  return getToken(MySQLParser::MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0);
}

tree::TerminalNode *
MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0);
}

size_t MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplicationSourceZstdCompressionLevel;
}

void MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplicationSourceZstdCompressionLevel(this);
}

void MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplicationSourceZstdCompressionLevel(this);
}

std::any MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplicationSourceZstdCompressionLevel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationSourceZstdCompressionLevelContext *
MySQLParser::changeReplicationSourceZstdCompressionLevel() {
  ChangeReplicationSourceZstdCompressionLevelContext *_localctx =
    _tracker.createInstance<ChangeReplicationSourceZstdCompressionLevelContext>(_ctx, getState());
  enterRule(_localctx, 516, MySQLParser::RuleChangeReplicationSourceZstdCompressionLevel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4249);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL ||
          _la == MySQLParser::SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrivilegeCheckDefContext ------------------------------------------------------------------

MySQLParser::PrivilegeCheckDefContext::PrivilegeCheckDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserIdentifierOrTextContext *MySQLParser::PrivilegeCheckDefContext::userIdentifierOrText() {
  return getRuleContext<MySQLParser::UserIdentifierOrTextContext>(0);
}

tree::TerminalNode *MySQLParser::PrivilegeCheckDefContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

size_t MySQLParser::PrivilegeCheckDefContext::getRuleIndex() const {
  return MySQLParser::RulePrivilegeCheckDef;
}

void MySQLParser::PrivilegeCheckDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrivilegeCheckDef(this);
}

void MySQLParser::PrivilegeCheckDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrivilegeCheckDef(this);
}

std::any MySQLParser::PrivilegeCheckDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrivilegeCheckDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PrivilegeCheckDefContext *MySQLParser::privilegeCheckDef() {
  PrivilegeCheckDefContext *_localctx = _tracker.createInstance<PrivilegeCheckDefContext>(_ctx, getState());
  enterRule(_localctx, 518, MySQLParser::RulePrivilegeCheckDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4253);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4251);
        userIdentifierOrText();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4252);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablePrimaryKeyCheckDefContext ------------------------------------------------------------------

MySQLParser::TablePrimaryKeyCheckDefContext::TablePrimaryKeyCheckDefContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TablePrimaryKeyCheckDefContext::STREAM_SYMBOL() {
  return getToken(MySQLParser::STREAM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TablePrimaryKeyCheckDefContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TablePrimaryKeyCheckDefContext::OFF_SYMBOL() {
  return getToken(MySQLParser::OFF_SYMBOL, 0);
}

size_t MySQLParser::TablePrimaryKeyCheckDefContext::getRuleIndex() const {
  return MySQLParser::RuleTablePrimaryKeyCheckDef;
}

void MySQLParser::TablePrimaryKeyCheckDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablePrimaryKeyCheckDef(this);
}

void MySQLParser::TablePrimaryKeyCheckDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablePrimaryKeyCheckDef(this);
}

std::any MySQLParser::TablePrimaryKeyCheckDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTablePrimaryKeyCheckDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablePrimaryKeyCheckDefContext *MySQLParser::tablePrimaryKeyCheckDef() {
  TablePrimaryKeyCheckDefContext *_localctx = _tracker.createInstance<TablePrimaryKeyCheckDefContext>(_ctx, getState());
  enterRule(_localctx, 520, MySQLParser::RuleTablePrimaryKeyCheckDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4255);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ON_SYMBOL || _la == MySQLParser::STREAM_SYMBOL

          || _la == MySQLParser::OFF_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignGtidsToAnonymousTransactionsDefinitionContext
//------------------------------------------------------------------

MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::AssignGtidsToAnonymousTransactionsDefinitionContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::OFF_SYMBOL() {
  return getToken(MySQLParser::OFF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *
MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleAssignGtidsToAnonymousTransactionsDefinition;
}

void MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignGtidsToAnonymousTransactionsDefinition(this);
}

void MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignGtidsToAnonymousTransactionsDefinition(this);
}

std::any MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAssignGtidsToAnonymousTransactionsDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AssignGtidsToAnonymousTransactionsDefinitionContext *
MySQLParser::assignGtidsToAnonymousTransactionsDefinition() {
  AssignGtidsToAnonymousTransactionsDefinitionContext *_localctx =
    _tracker.createInstance<AssignGtidsToAnonymousTransactionsDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 522, MySQLParser::RuleAssignGtidsToAnonymousTransactionsDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4260);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4257);
        match(MySQLParser::OFF_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4258);
        match(MySQLParser::LOCAL_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4259);
        textStringLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceTlsCiphersuitesDefContext ------------------------------------------------------------------

MySQLParser::SourceTlsCiphersuitesDefContext::SourceTlsCiphersuitesDefContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::SourceTlsCiphersuitesDefContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode *MySQLParser::SourceTlsCiphersuitesDefContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

size_t MySQLParser::SourceTlsCiphersuitesDefContext::getRuleIndex() const {
  return MySQLParser::RuleSourceTlsCiphersuitesDef;
}

void MySQLParser::SourceTlsCiphersuitesDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceTlsCiphersuitesDef(this);
}

void MySQLParser::SourceTlsCiphersuitesDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceTlsCiphersuitesDef(this);
}

std::any MySQLParser::SourceTlsCiphersuitesDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceTlsCiphersuitesDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceTlsCiphersuitesDefContext *MySQLParser::sourceTlsCiphersuitesDef() {
  SourceTlsCiphersuitesDefContext *_localctx =
    _tracker.createInstance<SourceTlsCiphersuitesDefContext>(_ctx, getState());
  enterRule(_localctx, 524, MySQLParser::RuleSourceTlsCiphersuitesDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4264);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4262);
        textStringNoLinebreak();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4263);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceFileDefContext ------------------------------------------------------------------

MySQLParser::SourceFileDefContext::SourceFileDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SourceLogFileContext *MySQLParser::SourceFileDefContext::sourceLogFile() {
  return getRuleContext<MySQLParser::SourceLogFileContext>(0);
}

tree::TerminalNode *MySQLParser::SourceFileDefContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::SourceFileDefContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

MySQLParser::SourceLogPosContext *MySQLParser::SourceFileDefContext::sourceLogPos() {
  return getRuleContext<MySQLParser::SourceLogPosContext>(0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::SourceFileDefContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::SourceFileDefContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SourceFileDefContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::SourceFileDefContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

size_t MySQLParser::SourceFileDefContext::getRuleIndex() const {
  return MySQLParser::RuleSourceFileDef;
}

void MySQLParser::SourceFileDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceFileDef(this);
}

void MySQLParser::SourceFileDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceFileDef(this);
}

std::any MySQLParser::SourceFileDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceFileDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceFileDefContext *MySQLParser::sourceFileDef() {
  SourceFileDefContext *_localctx = _tracker.createInstance<SourceFileDefContext>(_ctx, getState());
  enterRule(_localctx, 526, MySQLParser::RuleSourceFileDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4280);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_LOG_FILE_SYMBOL:
      case MySQLParser::SOURCE_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4266);
        sourceLogFile();
        setState(4267);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4268);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_LOG_POS_SYMBOL:
      case MySQLParser::SOURCE_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4270);
        sourceLogPos();
        setState(4271);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4272);
        ulonglong_number();
        break;
      }

      case MySQLParser::RELAY_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4274);
        match(MySQLParser::RELAY_LOG_FILE_SYMBOL);
        setState(4275);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4276);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::RELAY_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4277);
        match(MySQLParser::RELAY_LOG_POS_SYMBOL);
        setState(4278);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4279);
        ulong_number();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceLogFileContext ------------------------------------------------------------------

MySQLParser::SourceLogFileContext::SourceLogFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SourceLogFileContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SourceLogFileContext::SOURCE_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_LOG_FILE_SYMBOL, 0);
}

size_t MySQLParser::SourceLogFileContext::getRuleIndex() const {
  return MySQLParser::RuleSourceLogFile;
}

void MySQLParser::SourceLogFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceLogFile(this);
}

void MySQLParser::SourceLogFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceLogFile(this);
}

std::any MySQLParser::SourceLogFileContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceLogFile(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceLogFileContext *MySQLParser::sourceLogFile() {
  SourceLogFileContext *_localctx = _tracker.createInstance<SourceLogFileContext>(_ctx, getState());
  enterRule(_localctx, 528, MySQLParser::RuleSourceLogFile);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4282);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_LOG_FILE_SYMBOL || _la == MySQLParser::SOURCE_LOG_FILE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SourceLogPosContext ------------------------------------------------------------------

MySQLParser::SourceLogPosContext::SourceLogPosContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SourceLogPosContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SourceLogPosContext::SOURCE_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::SOURCE_LOG_POS_SYMBOL, 0);
}

size_t MySQLParser::SourceLogPosContext::getRuleIndex() const {
  return MySQLParser::RuleSourceLogPos;
}

void MySQLParser::SourceLogPosContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSourceLogPos(this);
}

void MySQLParser::SourceLogPosContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSourceLogPos(this);
}

std::any MySQLParser::SourceLogPosContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSourceLogPos(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SourceLogPosContext *MySQLParser::sourceLogPos() {
  SourceLogPosContext *_localctx = _tracker.createInstance<SourceLogPosContext>(_ctx, getState());
  enterRule(_localctx, 530, MySQLParser::RuleSourceLogPos);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4284);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MASTER_LOG_POS_SYMBOL || _la == MySQLParser::SOURCE_LOG_POS_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerIdListContext ------------------------------------------------------------------

MySQLParser::ServerIdListContext::ServerIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ServerIdListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ServerIdListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ServerIdListContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext *MySQLParser::ServerIdListContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ServerIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ServerIdListContext::getRuleIndex() const {
  return MySQLParser::RuleServerIdList;
}

void MySQLParser::ServerIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerIdList(this);
}

void MySQLParser::ServerIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerIdList(this);
}

std::any MySQLParser::ServerIdListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitServerIdList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerIdListContext *MySQLParser::serverIdList() {
  ServerIdListContext *_localctx = _tracker.createInstance<ServerIdListContext>(_ctx, getState());
  enterRule(_localctx, 532, MySQLParser::RuleServerIdList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4286);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(4295);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 28587302322183) != 0)) {
      setState(4287);
      ulong_number();
      setState(4292);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(4288);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4289);
        ulong_number();
        setState(4294);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(4297);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationContext ------------------------------------------------------------------

MySQLParser::ChangeReplicationContext::ChangeReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChangeReplicationContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChangeReplicationContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

std::vector<MySQLParser::FilterDefinitionContext *> MySQLParser::ChangeReplicationContext::filterDefinition() {
  return getRuleContexts<MySQLParser::FilterDefinitionContext>();
}

MySQLParser::FilterDefinitionContext *MySQLParser::ChangeReplicationContext::filterDefinition(size_t i) {
  return getRuleContext<MySQLParser::FilterDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ChangeReplicationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ChangeReplicationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ChannelContext *MySQLParser::ChangeReplicationContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ChangeReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplication;
}

void MySQLParser::ChangeReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplication(this);
}

void MySQLParser::ChangeReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplication(this);
}

std::any MySQLParser::ChangeReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChangeReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChangeReplicationContext *MySQLParser::changeReplication() {
  ChangeReplicationContext *_localctx = _tracker.createInstance<ChangeReplicationContext>(_ctx, getState());
  enterRule(_localctx, 534, MySQLParser::RuleChangeReplication);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4299);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(4300);
    match(MySQLParser::REPLICATION_SYMBOL);
    setState(4301);
    match(MySQLParser::FILTER_SYMBOL);
    setState(4302);
    filterDefinition();
    setState(4307);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4303);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4304);
      filterDefinition();
      setState(4309);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(4311);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4310);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDefinitionContext ------------------------------------------------------------------

MySQLParser::FilterDefinitionContext::FilterDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FilterDbListContext *MySQLParser::FilterDefinitionContext::filterDbList() {
  return getRuleContext<MySQLParser::FilterDbListContext>(0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterTableListContext *MySQLParser::FilterDefinitionContext::filterTableList() {
  return getRuleContext<MySQLParser::FilterTableListContext>(0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterStringListContext *MySQLParser::FilterDefinitionContext::filterStringList() {
  return getRuleContext<MySQLParser::FilterStringListContext>(0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FilterDefinitionContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

MySQLParser::FilterDbPairListContext *MySQLParser::FilterDefinitionContext::filterDbPairList() {
  return getRuleContext<MySQLParser::FilterDbPairListContext>(0);
}

size_t MySQLParser::FilterDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDefinition;
}

void MySQLParser::FilterDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDefinition(this);
}

void MySQLParser::FilterDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDefinition(this);
}

std::any MySQLParser::FilterDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDefinitionContext *MySQLParser::filterDefinition() {
  FilterDefinitionContext *_localctx = _tracker.createInstance<FilterDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 536, MySQLParser::RuleFilterDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4362);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPLICATE_DO_DB_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4313);
        match(MySQLParser::REPLICATE_DO_DB_SYMBOL);
        setState(4314);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4315);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4317);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx)) {
          case 1: {
            setState(4316);
            filterDbList();
            break;
          }

          default:
            break;
        }
        setState(4319);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4320);
        match(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL);
        setState(4321);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4322);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4324);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 444, _ctx)) {
          case 1: {
            setState(4323);
            filterDbList();
            break;
          }

          default:
            break;
        }
        setState(4326);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4327);
        match(MySQLParser::REPLICATE_DO_TABLE_SYMBOL);
        setState(4328);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4329);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4331);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 445, _ctx)) {
          case 1: {
            setState(4330);
            filterTableList();
            break;
          }

          default:
            break;
        }
        setState(4333);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4334);
        match(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL);
        setState(4335);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4336);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4338);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 446, _ctx)) {
          case 1: {
            setState(4337);
            filterTableList();
            break;
          }

          default:
            break;
        }
        setState(4340);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4341);
        match(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL);
        setState(4342);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4343);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4345);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 447, _ctx)) {
          case 1: {
            setState(4344);
            filterStringList();
            break;
          }

          default:
            break;
        }
        setState(4347);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(4348);
        match(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL);
        setState(4349);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4350);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4352);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx)) {
          case 1: {
            setState(4351);
            filterStringList();
            break;
          }

          default:
            break;
        }
        setState(4354);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(4355);
        match(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL);
        setState(4356);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4357);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(4359);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
          setState(4358);
          filterDbPairList();
        }
        setState(4361);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbListContext ------------------------------------------------------------------

MySQLParser::FilterDbListContext::FilterDbListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::FilterDbListContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext *MySQLParser::FilterDbListContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FilterDbListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::FilterDbListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbList;
}

void MySQLParser::FilterDbListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbList(this);
}

void MySQLParser::FilterDbListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbList(this);
}

std::any MySQLParser::FilterDbListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterDbList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDbListContext *MySQLParser::filterDbList() {
  FilterDbListContext *_localctx = _tracker.createInstance<FilterDbListContext>(_ctx, getState());
  enterRule(_localctx, 538, MySQLParser::RuleFilterDbList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4364);
    schemaRef();
    setState(4369);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4365);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4366);
      schemaRef();
      setState(4371);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableListContext ------------------------------------------------------------------

MySQLParser::FilterTableListContext::FilterTableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterTableRefContext *> MySQLParser::FilterTableListContext::filterTableRef() {
  return getRuleContexts<MySQLParser::FilterTableRefContext>();
}

MySQLParser::FilterTableRefContext *MySQLParser::FilterTableListContext::filterTableRef(size_t i) {
  return getRuleContext<MySQLParser::FilterTableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterTableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FilterTableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::FilterTableListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableList;
}

void MySQLParser::FilterTableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableList(this);
}

void MySQLParser::FilterTableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableList(this);
}

std::any MySQLParser::FilterTableListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterTableList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterTableListContext *MySQLParser::filterTableList() {
  FilterTableListContext *_localctx = _tracker.createInstance<FilterTableListContext>(_ctx, getState());
  enterRule(_localctx, 540, MySQLParser::RuleFilterTableList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4372);
    filterTableRef();
    setState(4377);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4373);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4374);
      filterTableRef();
      setState(4379);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterStringListContext ------------------------------------------------------------------

MySQLParser::FilterStringListContext::FilterStringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterWildDbTableStringContext *>
MySQLParser::FilterStringListContext::filterWildDbTableString() {
  return getRuleContexts<MySQLParser::FilterWildDbTableStringContext>();
}

MySQLParser::FilterWildDbTableStringContext *MySQLParser::FilterStringListContext::filterWildDbTableString(size_t i) {
  return getRuleContext<MySQLParser::FilterWildDbTableStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterStringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FilterStringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::FilterStringListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterStringList;
}

void MySQLParser::FilterStringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterStringList(this);
}

void MySQLParser::FilterStringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterStringList(this);
}

std::any MySQLParser::FilterStringListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterStringList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterStringListContext *MySQLParser::filterStringList() {
  FilterStringListContext *_localctx = _tracker.createInstance<FilterStringListContext>(_ctx, getState());
  enterRule(_localctx, 542, MySQLParser::RuleFilterStringList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4380);
    filterWildDbTableString();
    setState(4385);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4381);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4382);
      filterWildDbTableString();
      setState(4387);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterWildDbTableStringContext ------------------------------------------------------------------

MySQLParser::FilterWildDbTableStringContext::FilterWildDbTableStringContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::FilterWildDbTableStringContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

size_t MySQLParser::FilterWildDbTableStringContext::getRuleIndex() const {
  return MySQLParser::RuleFilterWildDbTableString;
}

void MySQLParser::FilterWildDbTableStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterWildDbTableString(this);
}

void MySQLParser::FilterWildDbTableStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterWildDbTableString(this);
}

std::any MySQLParser::FilterWildDbTableStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterWildDbTableString(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterWildDbTableStringContext *MySQLParser::filterWildDbTableString() {
  FilterWildDbTableStringContext *_localctx = _tracker.createInstance<FilterWildDbTableStringContext>(_ctx, getState());
  enterRule(_localctx, 544, MySQLParser::RuleFilterWildDbTableString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4388);
    textStringNoLinebreak();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbPairListContext ------------------------------------------------------------------

MySQLParser::FilterDbPairListContext::FilterDbPairListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaIdentifierPairContext *> MySQLParser::FilterDbPairListContext::schemaIdentifierPair() {
  return getRuleContexts<MySQLParser::SchemaIdentifierPairContext>();
}

MySQLParser::SchemaIdentifierPairContext *MySQLParser::FilterDbPairListContext::schemaIdentifierPair(size_t i) {
  return getRuleContext<MySQLParser::SchemaIdentifierPairContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbPairListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::FilterDbPairListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::FilterDbPairListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbPairList;
}

void MySQLParser::FilterDbPairListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbPairList(this);
}

void MySQLParser::FilterDbPairListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbPairList(this);
}

std::any MySQLParser::FilterDbPairListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterDbPairList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterDbPairListContext *MySQLParser::filterDbPairList() {
  FilterDbPairListContext *_localctx = _tracker.createInstance<FilterDbPairListContext>(_ctx, getState());
  enterRule(_localctx, 546, MySQLParser::RuleFilterDbPairList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4390);
    schemaIdentifierPair();
    setState(4395);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4391);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4392);
      schemaIdentifierPair();
      setState(4397);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartReplicaStatementContext ------------------------------------------------------------------

MySQLParser::StartReplicaStatementContext::StartReplicaStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StartReplicaStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::StartReplicaStatementContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

MySQLParser::ReplicaThreadOptionsContext *MySQLParser::StartReplicaStatementContext::replicaThreadOptions() {
  return getRuleContext<MySQLParser::ReplicaThreadOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::StartReplicaStatementContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::ReplicaUntilContext *MySQLParser::StartReplicaStatementContext::replicaUntil() {
  return getRuleContext<MySQLParser::ReplicaUntilContext>(0);
}

MySQLParser::UserOptionContext *MySQLParser::StartReplicaStatementContext::userOption() {
  return getRuleContext<MySQLParser::UserOptionContext>(0);
}

MySQLParser::PasswordOptionContext *MySQLParser::StartReplicaStatementContext::passwordOption() {
  return getRuleContext<MySQLParser::PasswordOptionContext>(0);
}

MySQLParser::DefaultAuthOptionContext *MySQLParser::StartReplicaStatementContext::defaultAuthOption() {
  return getRuleContext<MySQLParser::DefaultAuthOptionContext>(0);
}

MySQLParser::PluginDirOptionContext *MySQLParser::StartReplicaStatementContext::pluginDirOption() {
  return getRuleContext<MySQLParser::PluginDirOptionContext>(0);
}

MySQLParser::ChannelContext *MySQLParser::StartReplicaStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::StartReplicaStatementContext::getRuleIndex() const {
  return MySQLParser::RuleStartReplicaStatement;
}

void MySQLParser::StartReplicaStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartReplicaStatement(this);
}

void MySQLParser::StartReplicaStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartReplicaStatement(this);
}

std::any MySQLParser::StartReplicaStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStartReplicaStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StartReplicaStatementContext *MySQLParser::startReplicaStatement() {
  StartReplicaStatementContext *_localctx = _tracker.createInstance<StartReplicaStatementContext>(_ctx, getState());
  enterRule(_localctx, 548, MySQLParser::RuleStartReplicaStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4398);
    match(MySQLParser::START_SYMBOL);
    setState(4399);
    replica();
    setState(4401);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RELAY_THREAD_SYMBOL || _la == MySQLParser::SQL_THREAD_SYMBOL) {
      setState(4400);
      replicaThreadOptions();
    }
    setState(4405);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::UNTIL_SYMBOL) {
      setState(4403);
      match(MySQLParser::UNTIL_SYMBOL);
      setState(4404);
      replicaUntil();
    }
    setState(4408);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::USER_SYMBOL) {
      setState(4407);
      userOption();
    }
    setState(4411);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PASSWORD_SYMBOL) {
      setState(4410);
      passwordOption();
    }
    setState(4414);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_AUTH_SYMBOL) {
      setState(4413);
      defaultAuthOption();
    }
    setState(4417);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PLUGIN_DIR_SYMBOL) {
      setState(4416);
      pluginDirOption();
    }
    setState(4420);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4419);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StopReplicaStatementContext ------------------------------------------------------------------

MySQLParser::StopReplicaStatementContext::StopReplicaStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StopReplicaStatementContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::StopReplicaStatementContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

MySQLParser::ReplicaThreadOptionsContext *MySQLParser::StopReplicaStatementContext::replicaThreadOptions() {
  return getRuleContext<MySQLParser::ReplicaThreadOptionsContext>(0);
}

MySQLParser::ChannelContext *MySQLParser::StopReplicaStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::StopReplicaStatementContext::getRuleIndex() const {
  return MySQLParser::RuleStopReplicaStatement;
}

void MySQLParser::StopReplicaStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStopReplicaStatement(this);
}

void MySQLParser::StopReplicaStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStopReplicaStatement(this);
}

std::any MySQLParser::StopReplicaStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStopReplicaStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StopReplicaStatementContext *MySQLParser::stopReplicaStatement() {
  StopReplicaStatementContext *_localctx = _tracker.createInstance<StopReplicaStatementContext>(_ctx, getState());
  enterRule(_localctx, 550, MySQLParser::RuleStopReplicaStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4422);
    match(MySQLParser::STOP_SYMBOL);
    setState(4423);
    replica();
    setState(4425);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RELAY_THREAD_SYMBOL || _la == MySQLParser::SQL_THREAD_SYMBOL) {
      setState(4424);
      replicaThreadOptions();
    }
    setState(4428);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4427);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicaUntilContext ------------------------------------------------------------------

MySQLParser::ReplicaUntilContext::ReplicaUntilContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SourceFileDefContext *> MySQLParser::ReplicaUntilContext::sourceFileDef() {
  return getRuleContexts<MySQLParser::SourceFileDefContext>();
}

MySQLParser::SourceFileDefContext *MySQLParser::ReplicaUntilContext::sourceFileDef(size_t i) {
  return getRuleContext<MySQLParser::SourceFileDefContext>(i);
}

tree::TerminalNode *MySQLParser::ReplicaUntilContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext *MySQLParser::ReplicaUntilContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::ReplicaUntilContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicaUntilContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicaUntilContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ReplicaUntilContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ReplicaUntilContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ReplicaUntilContext::getRuleIndex() const {
  return MySQLParser::RuleReplicaUntil;
}

void MySQLParser::ReplicaUntilContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicaUntil(this);
}

void MySQLParser::ReplicaUntilContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicaUntil(this);
}

std::any MySQLParser::ReplicaUntilContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplicaUntil(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicaUntilContext *MySQLParser::replicaUntil() {
  ReplicaUntilContext *_localctx = _tracker.createInstance<ReplicaUntilContext>(_ctx, getState());
  enterRule(_localctx, 552, MySQLParser::RuleReplicaUntil);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4435);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_LOG_FILE_SYMBOL:
      case MySQLParser::MASTER_LOG_POS_SYMBOL:
      case MySQLParser::RELAY_LOG_FILE_SYMBOL:
      case MySQLParser::RELAY_LOG_POS_SYMBOL:
      case MySQLParser::SOURCE_LOG_FILE_SYMBOL:
      case MySQLParser::SOURCE_LOG_POS_SYMBOL: {
        setState(4430);
        sourceFileDef();
        break;
      }

      case MySQLParser::SQL_AFTER_GTIDS_SYMBOL:
      case MySQLParser::SQL_BEFORE_GTIDS_SYMBOL: {
        setState(4431);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::SQL_AFTER_GTIDS_SYMBOL

              || _la == MySQLParser::SQL_BEFORE_GTIDS_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4432);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4433);
        textString();
        break;
      }

      case MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL: {
        setState(4434);
        match(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(4441);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4437);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4438);
      sourceFileDef();
      setState(4443);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserOptionContext ------------------------------------------------------------------

MySQLParser::UserOptionContext::UserOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UserOptionContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext *MySQLParser::UserOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::UserOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUserOption;
}

void MySQLParser::UserOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserOption(this);
}

void MySQLParser::UserOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserOption(this);
}

std::any MySQLParser::UserOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserOptionContext *MySQLParser::userOption() {
  UserOptionContext *_localctx = _tracker.createInstance<UserOptionContext>(_ctx, getState());
  enterRule(_localctx, 554, MySQLParser::RuleUserOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4444);
    match(MySQLParser::USER_SYMBOL);
    setState(4445);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4446);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PasswordOptionContext ------------------------------------------------------------------

MySQLParser::PasswordOptionContext::PasswordOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PasswordOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PasswordOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext *MySQLParser::PasswordOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::PasswordOptionContext::getRuleIndex() const {
  return MySQLParser::RulePasswordOption;
}

void MySQLParser::PasswordOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPasswordOption(this);
}

void MySQLParser::PasswordOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPasswordOption(this);
}

std::any MySQLParser::PasswordOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPasswordOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PasswordOptionContext *MySQLParser::passwordOption() {
  PasswordOptionContext *_localctx = _tracker.createInstance<PasswordOptionContext>(_ctx, getState());
  enterRule(_localctx, 556, MySQLParser::RulePasswordOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4448);
    match(MySQLParser::PASSWORD_SYMBOL);
    setState(4449);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4450);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultAuthOptionContext ------------------------------------------------------------------

MySQLParser::DefaultAuthOptionContext::DefaultAuthOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DefaultAuthOptionContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefaultAuthOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext *MySQLParser::DefaultAuthOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::DefaultAuthOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultAuthOption;
}

void MySQLParser::DefaultAuthOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultAuthOption(this);
}

void MySQLParser::DefaultAuthOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultAuthOption(this);
}

std::any MySQLParser::DefaultAuthOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefaultAuthOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultAuthOptionContext *MySQLParser::defaultAuthOption() {
  DefaultAuthOptionContext *_localctx = _tracker.createInstance<DefaultAuthOptionContext>(_ctx, getState());
  enterRule(_localctx, 558, MySQLParser::RuleDefaultAuthOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4452);
    match(MySQLParser::DEFAULT_AUTH_SYMBOL);
    setState(4453);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4454);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PluginDirOptionContext ------------------------------------------------------------------

MySQLParser::PluginDirOptionContext::PluginDirOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PluginDirOptionContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PluginDirOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext *MySQLParser::PluginDirOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::PluginDirOptionContext::getRuleIndex() const {
  return MySQLParser::RulePluginDirOption;
}

void MySQLParser::PluginDirOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginDirOption(this);
}

void MySQLParser::PluginDirOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginDirOption(this);
}

std::any MySQLParser::PluginDirOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPluginDirOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PluginDirOptionContext *MySQLParser::pluginDirOption() {
  PluginDirOptionContext *_localctx = _tracker.createInstance<PluginDirOptionContext>(_ctx, getState());
  enterRule(_localctx, 560, MySQLParser::RulePluginDirOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4456);
    match(MySQLParser::PLUGIN_DIR_SYMBOL);
    setState(4457);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4458);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicaThreadOptionsContext ------------------------------------------------------------------

MySQLParser::ReplicaThreadOptionsContext::ReplicaThreadOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ReplicaThreadOptionContext *> MySQLParser::ReplicaThreadOptionsContext::replicaThreadOption() {
  return getRuleContexts<MySQLParser::ReplicaThreadOptionContext>();
}

MySQLParser::ReplicaThreadOptionContext *MySQLParser::ReplicaThreadOptionsContext::replicaThreadOption(size_t i) {
  return getRuleContext<MySQLParser::ReplicaThreadOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ReplicaThreadOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ReplicaThreadOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ReplicaThreadOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleReplicaThreadOptions;
}

void MySQLParser::ReplicaThreadOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicaThreadOptions(this);
}

void MySQLParser::ReplicaThreadOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicaThreadOptions(this);
}

std::any MySQLParser::ReplicaThreadOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplicaThreadOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicaThreadOptionsContext *MySQLParser::replicaThreadOptions() {
  ReplicaThreadOptionsContext *_localctx = _tracker.createInstance<ReplicaThreadOptionsContext>(_ctx, getState());
  enterRule(_localctx, 562, MySQLParser::RuleReplicaThreadOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4460);
    replicaThreadOption();
    setState(4465);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4461);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4462);
      replicaThreadOption();
      setState(4467);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicaThreadOptionContext ------------------------------------------------------------------

MySQLParser::ReplicaThreadOptionContext::ReplicaThreadOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplicaThreadOptionContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicaThreadOptionContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

size_t MySQLParser::ReplicaThreadOptionContext::getRuleIndex() const {
  return MySQLParser::RuleReplicaThreadOption;
}

void MySQLParser::ReplicaThreadOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicaThreadOption(this);
}

void MySQLParser::ReplicaThreadOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicaThreadOption(this);
}

std::any MySQLParser::ReplicaThreadOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplicaThreadOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicaThreadOptionContext *MySQLParser::replicaThreadOption() {
  ReplicaThreadOptionContext *_localctx = _tracker.createInstance<ReplicaThreadOptionContext>(_ctx, getState());
  enterRule(_localctx, 564, MySQLParser::RuleReplicaThreadOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4468);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::RELAY_THREAD_SYMBOL || _la == MySQLParser::SQL_THREAD_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationContext ------------------------------------------------------------------

MySQLParser::GroupReplicationContext::GroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupReplicationContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupReplicationContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupReplicationContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

MySQLParser::GroupReplicationStartOptionsContext *MySQLParser::GroupReplicationContext::groupReplicationStartOptions() {
  return getRuleContext<MySQLParser::GroupReplicationStartOptionsContext>(0);
}

size_t MySQLParser::GroupReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplication;
}

void MySQLParser::GroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplication(this);
}

void MySQLParser::GroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplication(this);
}

std::any MySQLParser::GroupReplicationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplication(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationContext *MySQLParser::groupReplication() {
  GroupReplicationContext *_localctx = _tracker.createInstance<GroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 566, MySQLParser::RuleGroupReplication);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4475);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        setState(4470);
        match(MySQLParser::START_SYMBOL);
        setState(4472);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DEFAULT_AUTH_SYMBOL || _la == MySQLParser::PASSWORD_SYMBOL ||
            _la == MySQLParser::USER_SYMBOL) {
          setState(4471);
          groupReplicationStartOptions();
        }
        break;
      }

      case MySQLParser::STOP_SYMBOL: {
        setState(4474);
        match(MySQLParser::STOP_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(4477);
    match(MySQLParser::GROUP_REPLICATION_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationStartOptionsContext
//------------------------------------------------------------------

MySQLParser::GroupReplicationStartOptionsContext::GroupReplicationStartOptionsContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::GroupReplicationStartOptionContext *>
MySQLParser::GroupReplicationStartOptionsContext::groupReplicationStartOption() {
  return getRuleContexts<MySQLParser::GroupReplicationStartOptionContext>();
}

MySQLParser::GroupReplicationStartOptionContext *
MySQLParser::GroupReplicationStartOptionsContext::groupReplicationStartOption(size_t i) {
  return getRuleContext<MySQLParser::GroupReplicationStartOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::GroupReplicationStartOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::GroupReplicationStartOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::GroupReplicationStartOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplicationStartOptions;
}

void MySQLParser::GroupReplicationStartOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplicationStartOptions(this);
}

void MySQLParser::GroupReplicationStartOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplicationStartOptions(this);
}

std::any MySQLParser::GroupReplicationStartOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplicationStartOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationStartOptionsContext *MySQLParser::groupReplicationStartOptions() {
  GroupReplicationStartOptionsContext *_localctx =
    _tracker.createInstance<GroupReplicationStartOptionsContext>(_ctx, getState());
  enterRule(_localctx, 568, MySQLParser::RuleGroupReplicationStartOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4479);
    groupReplicationStartOption();
    setState(4484);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4480);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4481);
      groupReplicationStartOption();
      setState(4486);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationStartOptionContext
//------------------------------------------------------------------

MySQLParser::GroupReplicationStartOptionContext::GroupReplicationStartOptionContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::GroupReplicationUserContext *MySQLParser::GroupReplicationStartOptionContext::groupReplicationUser() {
  return getRuleContext<MySQLParser::GroupReplicationUserContext>(0);
}

MySQLParser::GroupReplicationPasswordContext *
MySQLParser::GroupReplicationStartOptionContext::groupReplicationPassword() {
  return getRuleContext<MySQLParser::GroupReplicationPasswordContext>(0);
}

MySQLParser::GroupReplicationPluginAuthContext *
MySQLParser::GroupReplicationStartOptionContext::groupReplicationPluginAuth() {
  return getRuleContext<MySQLParser::GroupReplicationPluginAuthContext>(0);
}

size_t MySQLParser::GroupReplicationStartOptionContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplicationStartOption;
}

void MySQLParser::GroupReplicationStartOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplicationStartOption(this);
}

void MySQLParser::GroupReplicationStartOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplicationStartOption(this);
}

std::any MySQLParser::GroupReplicationStartOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplicationStartOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationStartOptionContext *MySQLParser::groupReplicationStartOption() {
  GroupReplicationStartOptionContext *_localctx =
    _tracker.createInstance<GroupReplicationStartOptionContext>(_ctx, getState());
  enterRule(_localctx, 570, MySQLParser::RuleGroupReplicationStartOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4490);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::USER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4487);
        groupReplicationUser();
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4488);
        groupReplicationPassword();
        break;
      }

      case MySQLParser::DEFAULT_AUTH_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4489);
        groupReplicationPluginAuth();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationUserContext ------------------------------------------------------------------

MySQLParser::GroupReplicationUserContext::GroupReplicationUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupReplicationUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupReplicationUserContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::GroupReplicationUserContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

size_t MySQLParser::GroupReplicationUserContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplicationUser;
}

void MySQLParser::GroupReplicationUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplicationUser(this);
}

void MySQLParser::GroupReplicationUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplicationUser(this);
}

std::any MySQLParser::GroupReplicationUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplicationUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationUserContext *MySQLParser::groupReplicationUser() {
  GroupReplicationUserContext *_localctx = _tracker.createInstance<GroupReplicationUserContext>(_ctx, getState());
  enterRule(_localctx, 572, MySQLParser::RuleGroupReplicationUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4492);
    match(MySQLParser::USER_SYMBOL);
    setState(4493);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4494);
    textStringNoLinebreak();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationPasswordContext ------------------------------------------------------------------

MySQLParser::GroupReplicationPasswordContext::GroupReplicationPasswordContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupReplicationPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupReplicationPasswordContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::GroupReplicationPasswordContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

size_t MySQLParser::GroupReplicationPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplicationPassword;
}

void MySQLParser::GroupReplicationPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplicationPassword(this);
}

void MySQLParser::GroupReplicationPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplicationPassword(this);
}

std::any MySQLParser::GroupReplicationPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplicationPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationPasswordContext *MySQLParser::groupReplicationPassword() {
  GroupReplicationPasswordContext *_localctx =
    _tracker.createInstance<GroupReplicationPasswordContext>(_ctx, getState());
  enterRule(_localctx, 574, MySQLParser::RuleGroupReplicationPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4496);
    match(MySQLParser::PASSWORD_SYMBOL);
    setState(4497);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4498);
    textStringNoLinebreak();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationPluginAuthContext ------------------------------------------------------------------

MySQLParser::GroupReplicationPluginAuthContext::GroupReplicationPluginAuthContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupReplicationPluginAuthContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupReplicationPluginAuthContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::GroupReplicationPluginAuthContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

size_t MySQLParser::GroupReplicationPluginAuthContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplicationPluginAuth;
}

void MySQLParser::GroupReplicationPluginAuthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplicationPluginAuth(this);
}

void MySQLParser::GroupReplicationPluginAuthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplicationPluginAuth(this);
}

std::any MySQLParser::GroupReplicationPluginAuthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupReplicationPluginAuth(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupReplicationPluginAuthContext *MySQLParser::groupReplicationPluginAuth() {
  GroupReplicationPluginAuthContext *_localctx =
    _tracker.createInstance<GroupReplicationPluginAuthContext>(_ctx, getState());
  enterRule(_localctx, 576, MySQLParser::RuleGroupReplicationPluginAuth);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4500);
    match(MySQLParser::DEFAULT_AUTH_SYMBOL);
    setState(4501);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(4502);
    textStringNoLinebreak();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicaContext ------------------------------------------------------------------

MySQLParser::ReplicaContext::ReplicaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplicaContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReplicaContext::REPLICA_SYMBOL() {
  return getToken(MySQLParser::REPLICA_SYMBOL, 0);
}

size_t MySQLParser::ReplicaContext::getRuleIndex() const {
  return MySQLParser::RuleReplica;
}

void MySQLParser::ReplicaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplica(this);
}

void MySQLParser::ReplicaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplica(this);
}

std::any MySQLParser::ReplicaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplica(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplicaContext *MySQLParser::replica() {
  ReplicaContext *_localctx = _tracker.createInstance<ReplicaContext>(_ctx, getState());
  enterRule(_localctx, 578, MySQLParser::RuleReplica);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4504);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::SLAVE_SYMBOL || _la == MySQLParser::REPLICA_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparedStatementContext ------------------------------------------------------------------

MySQLParser::PreparedStatementContext::PreparedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::PreparedStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::PreparedStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PreparedStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::PreparedStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::UserVariableContext *MySQLParser::PreparedStatementContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExecuteStatementContext *MySQLParser::PreparedStatementContext::executeStatement() {
  return getRuleContext<MySQLParser::ExecuteStatementContext>(0);
}

tree::TerminalNode *MySQLParser::PreparedStatementContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PreparedStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

size_t MySQLParser::PreparedStatementContext::getRuleIndex() const {
  return MySQLParser::RulePreparedStatement;
}

void MySQLParser::PreparedStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparedStatement(this);
}

void MySQLParser::PreparedStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparedStatement(this);
}

std::any MySQLParser::PreparedStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPreparedStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreparedStatementContext *MySQLParser::preparedStatement() {
  PreparedStatementContext *_localctx = _tracker.createInstance<PreparedStatementContext>(_ctx, getState());
  enterRule(_localctx, 580, MySQLParser::RulePreparedStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4517);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PREPARE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4506);
        antlrcpp::downCast<PreparedStatementContext *>(_localctx)->type = match(MySQLParser::PREPARE_SYMBOL);
        setState(4507);
        identifier();
        setState(4508);
        match(MySQLParser::FROM_SYMBOL);
        setState(4511);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx)) {
          case 1: {
            setState(4509);
            textLiteral();
            break;
          }

          case 2: {
            setState(4510);
            userVariable();
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::EXECUTE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4513);
        executeStatement();
        break;
      }

      case MySQLParser::DEALLOCATE_SYMBOL:
      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4514);
        antlrcpp::downCast<PreparedStatementContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEALLOCATE_SYMBOL

              || _la == MySQLParser::DROP_SYMBOL)) {
          antlrcpp::downCast<PreparedStatementContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4515);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(4516);
        identifier();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteStatementContext ------------------------------------------------------------------

MySQLParser::ExecuteStatementContext::ExecuteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ExecuteStatementContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ExecuteStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::ExecuteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::ExecuteVarListContext *MySQLParser::ExecuteStatementContext::executeVarList() {
  return getRuleContext<MySQLParser::ExecuteVarListContext>(0);
}

size_t MySQLParser::ExecuteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteStatement;
}

void MySQLParser::ExecuteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteStatement(this);
}

void MySQLParser::ExecuteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteStatement(this);
}

std::any MySQLParser::ExecuteStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExecuteStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExecuteStatementContext *MySQLParser::executeStatement() {
  ExecuteStatementContext *_localctx = _tracker.createInstance<ExecuteStatementContext>(_ctx, getState());
  enterRule(_localctx, 582, MySQLParser::RuleExecuteStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4519);
    match(MySQLParser::EXECUTE_SYMBOL);
    setState(4520);
    identifier();
    setState(4523);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::USING_SYMBOL) {
      setState(4521);
      match(MySQLParser::USING_SYMBOL);
      setState(4522);
      executeVarList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteVarListContext ------------------------------------------------------------------

MySQLParser::ExecuteVarListContext::ExecuteVarListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::ExecuteVarListContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext *MySQLParser::ExecuteVarListContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExecuteVarListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ExecuteVarListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ExecuteVarListContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteVarList;
}

void MySQLParser::ExecuteVarListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteVarList(this);
}

void MySQLParser::ExecuteVarListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteVarList(this);
}

std::any MySQLParser::ExecuteVarListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExecuteVarList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExecuteVarListContext *MySQLParser::executeVarList() {
  ExecuteVarListContext *_localctx = _tracker.createInstance<ExecuteVarListContext>(_ctx, getState());
  enterRule(_localctx, 584, MySQLParser::RuleExecuteVarList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4525);
    userVariable();
    setState(4530);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4526);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4527);
      userVariable();
      setState(4532);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneStatementContext ------------------------------------------------------------------

MySQLParser::CloneStatementContext::CloneStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CloneStatementContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::CloneStatementContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::CloneStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::CloneStatementContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::EqualContext *MySQLParser::CloneStatementContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CloneStatementContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

MySQLParser::DataDirSSLContext *MySQLParser::CloneStatementContext::dataDirSSL() {
  return getRuleContext<MySQLParser::DataDirSSLContext>(0);
}

size_t MySQLParser::CloneStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCloneStatement;
}

void MySQLParser::CloneStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneStatement(this);
}

void MySQLParser::CloneStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneStatement(this);
}

std::any MySQLParser::CloneStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCloneStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CloneStatementContext *MySQLParser::cloneStatement() {
  CloneStatementContext *_localctx = _tracker.createInstance<CloneStatementContext>(_ctx, getState());
  enterRule(_localctx, 586, MySQLParser::RuleCloneStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4533);
    match(MySQLParser::CLONE_SYMBOL);
    setState(4558);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 478, _ctx)) {
      case 1: {
        setState(4534);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(4535);
        match(MySQLParser::DATA_SYMBOL);
        setState(4536);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(4538);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx)) {
          case 1: {
            setState(4537);
            equal();
            break;
          }

          default:
            break;
        }
        setState(4540);
        textStringLiteral();
        break;
      }

      case 2: {
        setState(4541);
        match(MySQLParser::REMOTE_SYMBOL);
        setState(4544);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(4542);
          match(MySQLParser::FOR_SYMBOL);
          setState(4543);
          match(MySQLParser::REPLICATION_SYMBOL);
        }
        break;
      }

      case 3: {
        setState(4546);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4547);
        match(MySQLParser::INSTANCE_SYMBOL);
        setState(4548);
        match(MySQLParser::FROM_SYMBOL);
        setState(4549);
        user();
        setState(4550);
        match(MySQLParser::COLON_SYMBOL);
        setState(4551);
        ulong_number();
        setState(4552);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(4553);
        match(MySQLParser::BY_SYMBOL);
        setState(4554);
        textStringLiteral();
        setState(4556);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::REQUIRE_SYMBOL) {
          setState(4555);
          dataDirSSL();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataDirSSLContext ------------------------------------------------------------------

MySQLParser::DataDirSSLContext::DataDirSSLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SslContext *MySQLParser::DataDirSSLContext::ssl() {
  return getRuleContext<MySQLParser::SslContext>(0);
}

tree::TerminalNode *MySQLParser::DataDirSSLContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataDirSSLContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::DataDirSSLContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::EqualContext *MySQLParser::DataDirSSLContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

size_t MySQLParser::DataDirSSLContext::getRuleIndex() const {
  return MySQLParser::RuleDataDirSSL;
}

void MySQLParser::DataDirSSLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataDirSSL(this);
}

void MySQLParser::DataDirSSLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataDirSSL(this);
}

std::any MySQLParser::DataDirSSLContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDataDirSSL(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataDirSSLContext *MySQLParser::dataDirSSL() {
  DataDirSSLContext *_localctx = _tracker.createInstance<DataDirSSLContext>(_ctx, getState());
  enterRule(_localctx, 588, MySQLParser::RuleDataDirSSL);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4570);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REQUIRE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4560);
        ssl();
        break;
      }

      case MySQLParser::DATA_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4561);
        match(MySQLParser::DATA_SYMBOL);
        setState(4562);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(4564);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 479, _ctx)) {
          case 1: {
            setState(4563);
            equal();
            break;
          }

          default:
            break;
        }
        setState(4566);
        textStringLiteral();
        setState(4568);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REQUIRE_SYMBOL) {
          setState(4567);
          ssl();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SslContext ------------------------------------------------------------------

MySQLParser::SslContext::SslContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SslContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SslContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SslContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

size_t MySQLParser::SslContext::getRuleIndex() const {
  return MySQLParser::RuleSsl;
}

void MySQLParser::SslContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSsl(this);
}

void MySQLParser::SslContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSsl(this);
}

std::any MySQLParser::SslContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSsl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SslContext *MySQLParser::ssl() {
  SslContext *_localctx = _tracker.createInstance<SslContext>(_ctx, getState());
  enterRule(_localctx, 590, MySQLParser::RuleSsl);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4572);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4574);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::NO_SYMBOL) {
      setState(4573);
      match(MySQLParser::NO_SYMBOL);
    }
    setState(4576);
    match(MySQLParser::SSL_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountManagementStatementContext ------------------------------------------------------------------

MySQLParser::AccountManagementStatementContext::AccountManagementStatementContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterUserStatementContext *MySQLParser::AccountManagementStatementContext::alterUserStatement() {
  return getRuleContext<MySQLParser::AlterUserStatementContext>(0);
}

MySQLParser::CreateUserStatementContext *MySQLParser::AccountManagementStatementContext::createUserStatement() {
  return getRuleContext<MySQLParser::CreateUserStatementContext>(0);
}

MySQLParser::DropUserStatementContext *MySQLParser::AccountManagementStatementContext::dropUserStatement() {
  return getRuleContext<MySQLParser::DropUserStatementContext>(0);
}

MySQLParser::GrantStatementContext *MySQLParser::AccountManagementStatementContext::grantStatement() {
  return getRuleContext<MySQLParser::GrantStatementContext>(0);
}

MySQLParser::RenameUserStatementContext *MySQLParser::AccountManagementStatementContext::renameUserStatement() {
  return getRuleContext<MySQLParser::RenameUserStatementContext>(0);
}

MySQLParser::RevokeStatementContext *MySQLParser::AccountManagementStatementContext::revokeStatement() {
  return getRuleContext<MySQLParser::RevokeStatementContext>(0);
}

MySQLParser::SetRoleStatementContext *MySQLParser::AccountManagementStatementContext::setRoleStatement() {
  return getRuleContext<MySQLParser::SetRoleStatementContext>(0);
}

size_t MySQLParser::AccountManagementStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAccountManagementStatement;
}

void MySQLParser::AccountManagementStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountManagementStatement(this);
}

void MySQLParser::AccountManagementStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountManagementStatement(this);
}

std::any MySQLParser::AccountManagementStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAccountManagementStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AccountManagementStatementContext *MySQLParser::accountManagementStatement() {
  AccountManagementStatementContext *_localctx =
    _tracker.createInstance<AccountManagementStatementContext>(_ctx, getState());
  enterRule(_localctx, 592, MySQLParser::RuleAccountManagementStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4585);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALTER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4578);
        alterUserStatement();
        break;
      }

      case MySQLParser::CREATE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4579);
        createUserStatement();
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4580);
        dropUserStatement();
        break;
      }

      case MySQLParser::GRANT_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4581);
        grantStatement();
        break;
      }

      case MySQLParser::RENAME_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4582);
        renameUserStatement();
        break;
      }

      case MySQLParser::REVOKE_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(4583);
        revokeStatement();
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(4584);
        setRoleStatement();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserStatementContext ------------------------------------------------------------------

MySQLParser::AlterUserStatementContext::AlterUserStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::CreateUserTailContext *MySQLParser::AlterUserStatementContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::UserFunctionContext *MySQLParser::AlterUserStatementContext::userFunction() {
  return getRuleContext<MySQLParser::UserFunctionContext>(0);
}

MySQLParser::UserContext *MySQLParser::AlterUserStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::AlterUserStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

MySQLParser::CreateUserListContext *MySQLParser::AlterUserStatementContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::AlterUserListContext *MySQLParser::AlterUserStatementContext::alterUserList() {
  return getRuleContext<MySQLParser::AlterUserListContext>(0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::IdentifiedByRandomPasswordContext *MySQLParser::AlterUserStatementContext::identifiedByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedByRandomPasswordContext>(0);
}

MySQLParser::IdentifiedByPasswordContext *MySQLParser::AlterUserStatementContext::identifiedByPassword() {
  return getRuleContext<MySQLParser::IdentifiedByPasswordContext>(0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterUserStatementContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::AlterUserStatementContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::ReplacePasswordContext *MySQLParser::AlterUserStatementContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext *MySQLParser::AlterUserStatementContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

MySQLParser::UserRegistrationContext *MySQLParser::AlterUserStatementContext::userRegistration() {
  return getRuleContext<MySQLParser::UserRegistrationContext>(0);
}

size_t MySQLParser::AlterUserStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserStatement;
}

void MySQLParser::AlterUserStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserStatement(this);
}

void MySQLParser::AlterUserStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserStatement(this);
}

std::any MySQLParser::AlterUserStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterUserStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserStatementContext *MySQLParser::alterUserStatement() {
  AlterUserStatementContext *_localctx = _tracker.createInstance<AlterUserStatementContext>(_ctx, getState());
  enterRule(_localctx, 594, MySQLParser::RuleAlterUserStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4587);
    match(MySQLParser::ALTER_SYMBOL);
    setState(4588);
    match(MySQLParser::USER_SYMBOL);
    setState(4590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
      case 1: {
        setState(4589);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(4632);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 494, _ctx)) {
      case 1: {
        setState(4596);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 485, _ctx)) {
          case 1: {
            setState(4592);

            if (!(serverVersion < 80014))
              throw FailedPredicateException(this, "serverVersion < 80014");
            setState(4593);
            createUserList();
            break;
          }

          case 2: {
            setState(4594);

            if (!(serverVersion >= 80014))
              throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(4595);
            alterUserList();
            break;
          }

          default:
            break;
        }
        setState(4598);
        createUserTail();
        break;
      }

      case 2: {
        setState(4600);
        userFunction();
        setState(4617);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::IDENTIFIED_SYMBOL: {
            setState(4603);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 486, _ctx)) {
              case 1: {
                setState(4601);
                identifiedByRandomPassword();
                break;
              }

              case 2: {
                setState(4602);
                identifiedByPassword();
                break;
              }

              default:
                break;
            }
            setState(4606);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::REPLACE_SYMBOL) {
              setState(4605);
              replacePassword();
            }
            setState(4609);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::RETAIN_SYMBOL) {
              setState(4608);
              retainCurrentPassword();
            }
            break;
          }

          case MySQLParser::DISCARD_SYMBOL: {
            setState(4611);
            match(MySQLParser::DISCARD_SYMBOL);
            setState(4612);
            match(MySQLParser::OLD_SYMBOL);
            setState(4613);
            match(MySQLParser::PASSWORD_SYMBOL);
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::INT_NUMBER:
          case MySQLParser::LONG_NUMBER:
          case MySQLParser::ULONGLONG_NUMBER:
          case MySQLParser::SEMICOLON_SYMBOL:
          case MySQLParser::DECIMAL_NUMBER:
          case MySQLParser::FLOAT_NUMBER: {
            setState(4615);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 26388279066631) != 0)) {
              setState(4614);
              userRegistration();
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 3: {
        setState(4619);
        user();
        setState(4630);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::DEFAULT_SYMBOL: {
            setState(4620);
            match(MySQLParser::DEFAULT_SYMBOL);
            setState(4621);
            match(MySQLParser::ROLE_SYMBOL);
            setState(4625);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
              case 1: {
                setState(4622);
                match(MySQLParser::ALL_SYMBOL);
                break;
              }

              case 2: {
                setState(4623);
                match(MySQLParser::NONE_SYMBOL);
                break;
              }

              case 3: {
                setState(4624);
                roleList();
                break;
              }

              default:
                break;
            }
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::INT_NUMBER:
          case MySQLParser::LONG_NUMBER:
          case MySQLParser::ULONGLONG_NUMBER:
          case MySQLParser::SEMICOLON_SYMBOL:
          case MySQLParser::DECIMAL_NUMBER:
          case MySQLParser::FLOAT_NUMBER: {
            setState(4628);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 26388279066631) != 0)) {
              setState(4627);
              userRegistration();
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserListContext ------------------------------------------------------------------

MySQLParser::AlterUserListContext::AlterUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterUserContext *> MySQLParser::AlterUserListContext::alterUser() {
  return getRuleContexts<MySQLParser::AlterUserContext>();
}

MySQLParser::AlterUserContext *MySQLParser::AlterUserListContext::alterUser(size_t i) {
  return getRuleContext<MySQLParser::AlterUserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::AlterUserListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserList;
}

void MySQLParser::AlterUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserList(this);
}

void MySQLParser::AlterUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserList(this);
}

std::any MySQLParser::AlterUserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserListContext *MySQLParser::alterUserList() {
  AlterUserListContext *_localctx = _tracker.createInstance<AlterUserListContext>(_ctx, getState());
  enterRule(_localctx, 596, MySQLParser::RuleAlterUserList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4634);
    alterUser();
    setState(4639);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4635);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4636);
        alterUser();
      }
      setState(4641);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserContext ------------------------------------------------------------------

MySQLParser::AlterUserContext::AlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OldAlterUserContext *MySQLParser::AlterUserContext::oldAlterUser() {
  return getRuleContext<MySQLParser::OldAlterUserContext>(0);
}

MySQLParser::UserContext *MySQLParser::AlterUserContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::IdentifiedByPasswordContext *MySQLParser::AlterUserContext::identifiedByPassword() {
  return getRuleContext<MySQLParser::IdentifiedByPasswordContext>(0);
}

MySQLParser::IdentifiedByRandomPasswordContext *MySQLParser::AlterUserContext::identifiedByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedByRandomPasswordContext>(0);
}

MySQLParser::IdentifiedWithPluginContext *MySQLParser::AlterUserContext::identifiedWithPlugin() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginContext>(0);
}

MySQLParser::IdentifiedWithPluginAsAuthContext *MySQLParser::AlterUserContext::identifiedWithPluginAsAuth() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginAsAuthContext>(0);
}

MySQLParser::IdentifiedWithPluginByPasswordContext *MySQLParser::AlterUserContext::identifiedWithPluginByPassword() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginByPasswordContext>(0);
}

MySQLParser::IdentifiedWithPluginByRandomPasswordContext *
MySQLParser::AlterUserContext::identifiedWithPluginByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginByRandomPasswordContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserContext::ADD_SYMBOL() {
  return getTokens(MySQLParser::ADD_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterUserContext::ADD_SYMBOL(size_t i) {
  return getToken(MySQLParser::ADD_SYMBOL, i);
}

std::vector<MySQLParser::FactorContext *> MySQLParser::AlterUserContext::factor() {
  return getRuleContexts<MySQLParser::FactorContext>();
}

MySQLParser::FactorContext *MySQLParser::AlterUserContext::factor(size_t i) {
  return getRuleContext<MySQLParser::FactorContext>(i);
}

std::vector<MySQLParser::IdentificationContext *> MySQLParser::AlterUserContext::identification() {
  return getRuleContexts<MySQLParser::IdentificationContext>();
}

MySQLParser::IdentificationContext *MySQLParser::AlterUserContext::identification(size_t i) {
  return getRuleContext<MySQLParser::IdentificationContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserContext::MODIFY_SYMBOL() {
  return getTokens(MySQLParser::MODIFY_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterUserContext::MODIFY_SYMBOL(size_t i) {
  return getToken(MySQLParser::MODIFY_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserContext::DROP_SYMBOL() {
  return getTokens(MySQLParser::DROP_SYMBOL);
}

tree::TerminalNode *MySQLParser::AlterUserContext::DROP_SYMBOL(size_t i) {
  return getToken(MySQLParser::DROP_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::AlterUserContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::AlterUserContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::RetainCurrentPasswordContext *MySQLParser::AlterUserContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

MySQLParser::DiscardOldPasswordContext *MySQLParser::AlterUserContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

size_t MySQLParser::AlterUserContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUser;
}

void MySQLParser::AlterUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUser(this);
}

void MySQLParser::AlterUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUser(this);
}

std::any MySQLParser::AlterUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterUserContext *MySQLParser::alterUser() {
  AlterUserContext *_localctx = _tracker.createInstance<AlterUserContext>(_ctx, getState());
  enterRule(_localctx, 598, MySQLParser::RuleAlterUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4717);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 512, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4642);

        if (!(serverVersion < 80025))
          throw FailedPredicateException(this, "serverVersion < 80025");
        setState(4643);
        oldAlterUser();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4644);

        if (!(serverVersion >= 80025))
          throw FailedPredicateException(this, "serverVersion >= 80025");

        setState(4645);
        user();
        setState(4715);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 511, _ctx)) {
          case 1: {
            setState(4646);
            identifiedByPassword();
            setState(4655);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 498, _ctx)) {
              case 1: {
                setState(4647);
                match(MySQLParser::REPLACE_SYMBOL);
                setState(4648);
                textStringLiteral();
                setState(4650);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 496, _ctx)) {
                  case 1: {
                    setState(4649);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              case 2: {
                setState(4653);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 497, _ctx)) {
                  case 1: {
                    setState(4652);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              default:
                break;
            }
            break;
          }

          case 2: {
            setState(4657);
            identifiedByRandomPassword();
            setState(4666);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 501, _ctx)) {
              case 1: {
                setState(4659);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
                  case 1: {
                    setState(4658);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              case 2: {
                setState(4661);
                match(MySQLParser::REPLACE_SYMBOL);
                setState(4662);
                textStringLiteral();
                setState(4664);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx)) {
                  case 1: {
                    setState(4663);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              default:
                break;
            }
            break;
          }

          case 3: {
            setState(4668);
            identifiedWithPlugin();
            break;
          }

          case 4: {
            setState(4669);
            identifiedWithPluginAsAuth();
            setState(4671);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 502, _ctx)) {
              case 1: {
                setState(4670);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 5: {
            setState(4673);
            identifiedWithPluginByPassword();
            setState(4682);
            _errHandler->sync(this);
            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 505, _ctx)) {
              case 1: {
                setState(4674);
                match(MySQLParser::REPLACE_SYMBOL);
                setState(4675);
                textStringLiteral();
                setState(4677);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 503, _ctx)) {
                  case 1: {
                    setState(4676);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              case 2: {
                setState(4680);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 504, _ctx)) {
                  case 1: {
                    setState(4679);
                    retainCurrentPassword();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              default:
                break;
            }
            break;
          }

          case 6: {
            setState(4684);
            identifiedWithPluginByRandomPassword();
            setState(4686);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 506, _ctx)) {
              case 1: {
                setState(4685);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 7: {
            setState(4689);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 507, _ctx)) {
              case 1: {
                setState(4688);
                discardOldPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 8: {
            setState(4691);
            match(MySQLParser::ADD_SYMBOL);
            setState(4692);
            factor();
            setState(4693);
            identification();
            setState(4698);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 508, _ctx)) {
              case 1: {
                setState(4694);
                match(MySQLParser::ADD_SYMBOL);
                setState(4695);
                factor();
                setState(4696);
                identification();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 9: {
            setState(4700);
            match(MySQLParser::MODIFY_SYMBOL);
            setState(4701);
            factor();
            setState(4702);
            identification();
            setState(4707);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
              case 1: {
                setState(4703);
                match(MySQLParser::MODIFY_SYMBOL);
                setState(4704);
                factor();
                setState(4705);
                identification();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 10: {
            setState(4709);
            match(MySQLParser::DROP_SYMBOL);
            setState(4710);
            factor();
            setState(4713);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 510, _ctx)) {
              case 1: {
                setState(4711);
                match(MySQLParser::DROP_SYMBOL);
                setState(4712);
                factor();
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OldAlterUserContext ------------------------------------------------------------------

MySQLParser::OldAlterUserContext::OldAlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext *MySQLParser::OldAlterUserContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::OldAlterUserContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext *MySQLParser::OldAlterUserContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::RANDOM_SYMBOL() {
  return getToken(MySQLParser::RANDOM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

MySQLParser::RetainCurrentPasswordContext *MySQLParser::OldAlterUserContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::OldAlterUserContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::OldAlterUserContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringHashContext *MySQLParser::OldAlterUserContext::textStringHash() {
  return getRuleContext<MySQLParser::TextStringHashContext>(0);
}

MySQLParser::DiscardOldPasswordContext *MySQLParser::OldAlterUserContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

size_t MySQLParser::OldAlterUserContext::getRuleIndex() const {
  return MySQLParser::RuleOldAlterUser;
}

void MySQLParser::OldAlterUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOldAlterUser(this);
}

void MySQLParser::OldAlterUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOldAlterUser(this);
}

std::any MySQLParser::OldAlterUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOldAlterUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OldAlterUserContext *MySQLParser::oldAlterUser() {
  OldAlterUserContext *_localctx = _tracker.createInstance<OldAlterUserContext>(_ctx, getState());
  enterRule(_localctx, 600, MySQLParser::RuleOldAlterUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4776);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 524, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4719);
        user();
        setState(4720);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(4721);
        match(MySQLParser::BY_SYMBOL);
        setState(4741);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
          case 1: {
            setState(4722);
            textString();
            setState(4723);
            match(MySQLParser::REPLACE_SYMBOL);
            setState(4724);
            textString();
            setState(4726);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 513, _ctx)) {
              case 1: {
                setState(4725);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 2: {
            setState(4728);
            textString();
            setState(4730);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 514, _ctx)) {
              case 1: {
                setState(4729);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 3: {
            setState(4732);
            match(MySQLParser::RANDOM_SYMBOL);
            setState(4733);
            match(MySQLParser::PASSWORD_SYMBOL);
            setState(4736);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
              case 1: {
                setState(4734);
                match(MySQLParser::REPLACE_SYMBOL);
                setState(4735);
                textString();
                break;
              }

              default:
                break;
            }
            setState(4739);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx)) {
              case 1: {
                setState(4738);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4743);
        user();
        setState(4744);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(4745);
        match(MySQLParser::WITH_SYMBOL);

        setState(4746);
        textOrIdentifier();
        setState(4770);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 522, _ctx)) {
          case 1: {
            setState(4747);
            match(MySQLParser::BY_SYMBOL);
            setState(4748);
            textString();
            setState(4749);
            match(MySQLParser::REPLACE_SYMBOL);
            setState(4750);
            textString();
            setState(4752);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 518, _ctx)) {
              case 1: {
                setState(4751);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 2: {
            setState(4754);
            match(MySQLParser::AS_SYMBOL);
            setState(4755);
            textStringHash();
            setState(4757);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 519, _ctx)) {
              case 1: {
                setState(4756);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 3: {
            setState(4759);
            match(MySQLParser::BY_SYMBOL);
            setState(4760);
            textString();
            setState(4762);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 520, _ctx)) {
              case 1: {
                setState(4761);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          case 4: {
            setState(4764);
            match(MySQLParser::BY_SYMBOL);
            setState(4765);
            match(MySQLParser::RANDOM_SYMBOL);
            setState(4766);
            match(MySQLParser::PASSWORD_SYMBOL);
            setState(4768);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 521, _ctx)) {
              case 1: {
                setState(4767);
                retainCurrentPassword();
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(4772);
        user();
        setState(4774);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 523, _ctx)) {
          case 1: {
            setState(4773);
            discardOldPassword();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserFunctionContext ------------------------------------------------------------------

MySQLParser::UserFunctionContext::UserFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UserFunctionContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext *MySQLParser::UserFunctionContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

size_t MySQLParser::UserFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleUserFunction;
}

void MySQLParser::UserFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserFunction(this);
}

void MySQLParser::UserFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserFunction(this);
}

std::any MySQLParser::UserFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserFunctionContext *MySQLParser::userFunction() {
  UserFunctionContext *_localctx = _tracker.createInstance<UserFunctionContext>(_ctx, getState());
  enterRule(_localctx, 602, MySQLParser::RuleUserFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4778);
    match(MySQLParser::USER_SYMBOL);
    setState(4779);
    parentheses();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserStatementContext ------------------------------------------------------------------

MySQLParser::CreateUserStatementContext::CreateUserStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateUserStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateUserStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::CreateUserListContext *MySQLParser::CreateUserStatementContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::CreateUserTailContext *MySQLParser::CreateUserStatementContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::CreateUserStatementContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

MySQLParser::DefaultRoleClauseContext *MySQLParser::CreateUserStatementContext::defaultRoleClause() {
  return getRuleContext<MySQLParser::DefaultRoleClauseContext>(0);
}

size_t MySQLParser::CreateUserStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserStatement;
}

void MySQLParser::CreateUserStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserStatement(this);
}

void MySQLParser::CreateUserStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserStatement(this);
}

std::any MySQLParser::CreateUserStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUserStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserStatementContext *MySQLParser::createUserStatement() {
  CreateUserStatementContext *_localctx = _tracker.createInstance<CreateUserStatementContext>(_ctx, getState());
  enterRule(_localctx, 604, MySQLParser::RuleCreateUserStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4781);
    match(MySQLParser::CREATE_SYMBOL);
    setState(4782);
    match(MySQLParser::USER_SYMBOL);
    setState(4784);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
      case 1: {
        setState(4783);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(4786);
    createUserList();
    setState(4788);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 526, _ctx)) {
      case 1: {
        setState(4787);
        defaultRoleClause();
        break;
      }

      default:
        break;
    }
    setState(4790);
    createUserTail();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserTailContext ------------------------------------------------------------------

MySQLParser::CreateUserTailContext::CreateUserTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext *MySQLParser::CreateUserTailContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}

MySQLParser::ConnectOptionsContext *MySQLParser::CreateUserTailContext::connectOptions() {
  return getRuleContext<MySQLParser::ConnectOptionsContext>(0);
}

std::vector<MySQLParser::AccountLockPasswordExpireOptionsContext *>
MySQLParser::CreateUserTailContext::accountLockPasswordExpireOptions() {
  return getRuleContexts<MySQLParser::AccountLockPasswordExpireOptionsContext>();
}

MySQLParser::AccountLockPasswordExpireOptionsContext *
MySQLParser::CreateUserTailContext::accountLockPasswordExpireOptions(size_t i) {
  return getRuleContext<MySQLParser::AccountLockPasswordExpireOptionsContext>(i);
}

MySQLParser::UserAttributesContext *MySQLParser::CreateUserTailContext::userAttributes() {
  return getRuleContext<MySQLParser::UserAttributesContext>(0);
}

size_t MySQLParser::CreateUserTailContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserTail;
}

void MySQLParser::CreateUserTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserTail(this);
}

void MySQLParser::CreateUserTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserTail(this);
}

std::any MySQLParser::CreateUserTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUserTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserTailContext *MySQLParser::createUserTail() {
  CreateUserTailContext *_localctx = _tracker.createInstance<CreateUserTailContext>(_ctx, getState());
  enterRule(_localctx, 606, MySQLParser::RuleCreateUserTail);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4793);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 527, _ctx)) {
      case 1: {
        setState(4792);
        requireClause();
        break;
      }

      default:
        break;
    }
    setState(4796);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 528, _ctx)) {
      case 1: {
        setState(4795);
        connectOptions();
        break;
      }

      default:
        break;
    }
    setState(4801);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4798);
        accountLockPasswordExpireOptions();
      }
      setState(4803);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx);
    }
    setState(4806);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 530, _ctx)) {
      case 1: {
        setState(4804);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(4805);
        userAttributes();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserAttributesContext ------------------------------------------------------------------

MySQLParser::UserAttributesContext::UserAttributesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UserAttributesContext::ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ATTRIBUTE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::UserAttributesContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::UserAttributesContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

size_t MySQLParser::UserAttributesContext::getRuleIndex() const {
  return MySQLParser::RuleUserAttributes;
}

void MySQLParser::UserAttributesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserAttributes(this);
}

void MySQLParser::UserAttributesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserAttributes(this);
}

std::any MySQLParser::UserAttributesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserAttributes(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserAttributesContext *MySQLParser::userAttributes() {
  UserAttributesContext *_localctx = _tracker.createInstance<UserAttributesContext>(_ctx, getState());
  enterRule(_localctx, 608, MySQLParser::RuleUserAttributes);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4812);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ATTRIBUTE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4808);
        match(MySQLParser::ATTRIBUTE_SYMBOL);
        setState(4809);
        textStringLiteral();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4810);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(4811);
        textStringLiteral();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultRoleClauseContext ------------------------------------------------------------------

MySQLParser::DefaultRoleClauseContext::DefaultRoleClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DefaultRoleClauseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefaultRoleClauseContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::DefaultRoleClauseContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

size_t MySQLParser::DefaultRoleClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultRoleClause;
}

void MySQLParser::DefaultRoleClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultRoleClause(this);
}

void MySQLParser::DefaultRoleClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultRoleClause(this);
}

std::any MySQLParser::DefaultRoleClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefaultRoleClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultRoleClauseContext *MySQLParser::defaultRoleClause() {
  DefaultRoleClauseContext *_localctx = _tracker.createInstance<DefaultRoleClauseContext>(_ctx, getState());
  enterRule(_localctx, 610, MySQLParser::RuleDefaultRoleClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4814);
    match(MySQLParser::DEFAULT_SYMBOL);
    setState(4815);
    match(MySQLParser::ROLE_SYMBOL);
    setState(4816);
    roleList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireClauseContext ------------------------------------------------------------------

MySQLParser::RequireClauseContext::RequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RequireClauseContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

MySQLParser::RequireListContext *MySQLParser::RequireClauseContext::requireList() {
  return getRuleContext<MySQLParser::RequireListContext>(0);
}

tree::TerminalNode *MySQLParser::RequireClauseContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RequireClauseContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RequireClauseContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

size_t MySQLParser::RequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleRequireClause;
}

void MySQLParser::RequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireClause(this);
}

void MySQLParser::RequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireClause(this);
}

std::any MySQLParser::RequireClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRequireClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireClauseContext *MySQLParser::requireClause() {
  RequireClauseContext *_localctx = _tracker.createInstance<RequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 612, MySQLParser::RuleRequireClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4818);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4821);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL:
      case MySQLParser::ISSUER_SYMBOL:
      case MySQLParser::SUBJECT_SYMBOL: {
        setState(4819);
        requireList();
        break;
      }

      case MySQLParser::NONE_SYMBOL:
      case MySQLParser::SSL_SYMBOL:
      case MySQLParser::X509_SYMBOL: {
        setState(4820);
        antlrcpp::downCast<RequireClauseContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::NONE_SYMBOL || _la == MySQLParser::SSL_SYMBOL || _la == MySQLParser::X509_SYMBOL)) {
          antlrcpp::downCast<RequireClauseContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectOptionsContext ------------------------------------------------------------------

MySQLParser::ConnectOptionsContext::ConnectOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConnectOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
}

tree::TerminalNode *MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, i);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ConnectOptionsContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext *MySQLParser::ConnectOptionsContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
}

tree::TerminalNode *MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
}

tree::TerminalNode *MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getTokens(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
}

tree::TerminalNode *MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, i);
}

size_t MySQLParser::ConnectOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleConnectOptions;
}

void MySQLParser::ConnectOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectOptions(this);
}

void MySQLParser::ConnectOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectOptions(this);
}

std::any MySQLParser::ConnectOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConnectOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConnectOptionsContext *MySQLParser::connectOptions() {
  ConnectOptionsContext *_localctx = _tracker.createInstance<ConnectOptionsContext>(_ctx, getState());
  enterRule(_localctx, 614, MySQLParser::RuleConnectOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4823);
    match(MySQLParser::WITH_SYMBOL);
    setState(4832);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(4832);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
              setState(4824);
              match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
              setState(4825);
              ulong_number();
              break;
            }

            case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
              setState(4826);
              match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
              setState(4827);
              ulong_number();
              break;
            }

            case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
              setState(4828);
              match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
              setState(4829);
              ulong_number();
              break;
            }

            case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
              setState(4830);
              match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
              setState(4831);
              ulong_number();
              break;
            }

            default:
              throw NoViableAltException(this);
          }
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(4834);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 534, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountLockPasswordExpireOptionsContext
//------------------------------------------------------------------

MySQLParser::AccountLockPasswordExpireOptionsContext::AccountLockPasswordExpireOptionsContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::AccountLockPasswordExpireOptionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::FAILED_LOGIN_ATTEMPTS_SYMBOL() {
  return getToken(MySQLParser::FAILED_LOGIN_ATTEMPTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::PASSWORD_LOCK_TIME_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_LOCK_TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AccountLockPasswordExpireOptionsContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

size_t MySQLParser::AccountLockPasswordExpireOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAccountLockPasswordExpireOptions;
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountLockPasswordExpireOptions(this);
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountLockPasswordExpireOptions(this);
}

std::any MySQLParser::AccountLockPasswordExpireOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAccountLockPasswordExpireOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AccountLockPasswordExpireOptionsContext *MySQLParser::accountLockPasswordExpireOptions() {
  AccountLockPasswordExpireOptionsContext *_localctx =
    _tracker.createInstance<AccountLockPasswordExpireOptionsContext>(_ctx, getState());
  enterRule(_localctx, 616, MySQLParser::RuleAccountLockPasswordExpireOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4876);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ACCOUNT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4836);
        match(MySQLParser::ACCOUNT_SYMBOL);
        setState(4837);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LOCK_SYMBOL || _la == MySQLParser::UNLOCK_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4838);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(4867);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
          case 1: {
            setState(4839);
            match(MySQLParser::EXPIRE_SYMBOL);
            setState(4846);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 535, _ctx)) {
              case 1: {
                setState(4840);
                match(MySQLParser::INTERVAL_SYMBOL);
                setState(4841);
                real_ulong_number();
                setState(4842);
                match(MySQLParser::DAY_SYMBOL);
                break;
              }

              case 2: {
                setState(4844);
                match(MySQLParser::NEVER_SYMBOL);
                break;
              }

              case 3: {
                setState(4845);
                match(MySQLParser::DEFAULT_SYMBOL);
                break;
              }

              default:
                break;
            }
            break;
          }

          case 2: {
            setState(4848);
            match(MySQLParser::HISTORY_SYMBOL);
            setState(4851);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::INT_NUMBER:
              case MySQLParser::LONG_NUMBER:
              case MySQLParser::ULONGLONG_NUMBER:
              case MySQLParser::HEX_NUMBER: {
                setState(4849);
                real_ulong_number();
                break;
              }

              case MySQLParser::DEFAULT_SYMBOL: {
                setState(4850);
                match(MySQLParser::DEFAULT_SYMBOL);
                break;
              }

              default:
                throw NoViableAltException(this);
            }
            break;
          }

          case 3: {
            setState(4853);
            match(MySQLParser::REUSE_SYMBOL);
            setState(4854);
            match(MySQLParser::INTERVAL_SYMBOL);
            setState(4859);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::INT_NUMBER:
              case MySQLParser::LONG_NUMBER:
              case MySQLParser::ULONGLONG_NUMBER:
              case MySQLParser::HEX_NUMBER: {
                setState(4855);
                real_ulong_number();
                setState(4856);
                match(MySQLParser::DAY_SYMBOL);
                break;
              }

              case MySQLParser::DEFAULT_SYMBOL: {
                setState(4858);
                match(MySQLParser::DEFAULT_SYMBOL);
                break;
              }

              default:
                throw NoViableAltException(this);
            }
            break;
          }

          case 4: {
            setState(4861);

            if (!(serverVersion >= 80014))
              throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(4862);
            match(MySQLParser::REQUIRE_SYMBOL);
            setState(4863);
            match(MySQLParser::CURRENT_SYMBOL);
            setState(4865);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
              case 1: {
                setState(4864);
                _la = _input->LA(1);
                if (!(_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::OPTIONAL_SYMBOL)) {
                  _errHandler->recoverInline(this);
                } else {
                  _errHandler->reportMatch(this);
                  consume();
                }
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::FAILED_LOGIN_ATTEMPTS_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4869);
        match(MySQLParser::FAILED_LOGIN_ATTEMPTS_SYMBOL);
        setState(4870);
        real_ulong_number();
        break;
      }

      case MySQLParser::PASSWORD_LOCK_TIME_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4871);
        match(MySQLParser::PASSWORD_LOCK_TIME_SYMBOL);
        setState(4874);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::INT_NUMBER:
          case MySQLParser::LONG_NUMBER:
          case MySQLParser::ULONGLONG_NUMBER:
          case MySQLParser::HEX_NUMBER: {
            setState(4872);
            real_ulong_number();
            break;
          }

          case MySQLParser::UNBOUNDED_SYMBOL: {
            setState(4873);
            match(MySQLParser::UNBOUNDED_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserAttributeContext ------------------------------------------------------------------

MySQLParser::UserAttributeContext::UserAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UserAttributeContext::ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ATTRIBUTE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::UserAttributeContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::UserAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

size_t MySQLParser::UserAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleUserAttribute;
}

void MySQLParser::UserAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserAttribute(this);
}

void MySQLParser::UserAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserAttribute(this);
}

std::any MySQLParser::UserAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserAttributeContext *MySQLParser::userAttribute() {
  UserAttributeContext *_localctx = _tracker.createInstance<UserAttributeContext>(_ctx, getState());
  enterRule(_localctx, 618, MySQLParser::RuleUserAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4883);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::EOF: {
        enterOuterAlt(_localctx, 1);

        break;
      }

      case MySQLParser::ATTRIBUTE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4879);
        match(MySQLParser::ATTRIBUTE_SYMBOL);
        setState(4880);
        textStringLiteral();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4881);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(4882);
        textStringLiteral();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserStatementContext ------------------------------------------------------------------

MySQLParser::DropUserStatementContext::DropUserStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropUserStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropUserStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::UserListContext *MySQLParser::DropUserStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::DropUserStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

size_t MySQLParser::DropUserStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDropUserStatement;
}

void MySQLParser::DropUserStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUserStatement(this);
}

void MySQLParser::DropUserStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUserStatement(this);
}

std::any MySQLParser::DropUserStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropUserStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropUserStatementContext *MySQLParser::dropUserStatement() {
  DropUserStatementContext *_localctx = _tracker.createInstance<DropUserStatementContext>(_ctx, getState());
  enterRule(_localctx, 620, MySQLParser::RuleDropUserStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4885);
    match(MySQLParser::DROP_SYMBOL);
    setState(4886);
    match(MySQLParser::USER_SYMBOL);
    setState(4888);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 543, _ctx)) {
      case 1: {
        setState(4887);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(4890);
    userList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantStatementContext ------------------------------------------------------------------

MySQLParser::GrantStatementContext::GrantStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantStatementContext::GRANT_SYMBOL() {
  return getTokens(MySQLParser::GRANT_SYMBOL);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::GRANT_SYMBOL(size_t i) {
  return getToken(MySQLParser::GRANT_SYMBOL, i);
}

MySQLParser::RoleOrPrivilegesListContext *MySQLParser::GrantStatementContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::UserListContext *MySQLParser::GrantStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext *MySQLParser::GrantStatementContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

MySQLParser::GrantTargetListContext *MySQLParser::GrantStatementContext::grantTargetList() {
  return getRuleContext<MySQLParser::GrantTargetListContext>(0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::GrantStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

MySQLParser::AclTypeContext *MySQLParser::GrantStatementContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}

MySQLParser::VersionedRequireClauseContext *MySQLParser::GrantStatementContext::versionedRequireClause() {
  return getRuleContext<MySQLParser::VersionedRequireClauseContext>(0);
}

MySQLParser::GrantOptionsContext *MySQLParser::GrantStatementContext::grantOptions() {
  return getRuleContext<MySQLParser::GrantOptionsContext>(0);
}

MySQLParser::GrantAsContext *MySQLParser::GrantStatementContext::grantAs() {
  return getRuleContext<MySQLParser::GrantAsContext>(0);
}

tree::TerminalNode *MySQLParser::GrantStatementContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

size_t MySQLParser::GrantStatementContext::getRuleIndex() const {
  return MySQLParser::RuleGrantStatement;
}

void MySQLParser::GrantStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantStatement(this);
}

void MySQLParser::GrantStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantStatement(this);
}

std::any MySQLParser::GrantStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantStatementContext *MySQLParser::grantStatement() {
  GrantStatementContext *_localctx = _tracker.createInstance<GrantStatementContext>(_ctx, getState());
  enterRule(_localctx, 622, MySQLParser::RuleGrantStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4892);
    match(MySQLParser::GRANT_SYMBOL);
    setState(4934);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx)) {
      case 1: {
        setState(4893);
        roleOrPrivilegesList();
        setState(4894);
        match(MySQLParser::TO_SYMBOL);
        setState(4895);
        userList();
        setState(4899);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(4896);
          match(MySQLParser::WITH_SYMBOL);
          setState(4897);
          match(MySQLParser::ADMIN_SYMBOL);
          setState(4898);
          match(MySQLParser::OPTION_SYMBOL);
        }
        break;
      }

      case 2: {
        setState(4906);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 546, _ctx)) {
          case 1: {
            setState(4901);
            roleOrPrivilegesList();
            break;
          }

          case 2: {
            setState(4902);
            match(MySQLParser::ALL_SYMBOL);
            setState(4904);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::PRIVILEGES_SYMBOL) {
              setState(4903);
              match(MySQLParser::PRIVILEGES_SYMBOL);
            }
            break;
          }

          default:
            break;
        }
        setState(4908);
        match(MySQLParser::ON_SYMBOL);
        setState(4910);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 547, _ctx)) {
          case 1: {
            setState(4909);
            aclType();
            break;
          }

          default:
            break;
        }
        setState(4912);
        grantIdentifier();
        setState(4913);
        match(MySQLParser::TO_SYMBOL);
        setState(4914);
        grantTargetList();
        setState(4916);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 548, _ctx)) {
          case 1: {
            setState(4915);
            versionedRequireClause();
            break;
          }

          default:
            break;
        }
        setState(4919);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(4918);
          grantOptions();
        }
        setState(4922);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AS_SYMBOL) {
          setState(4921);
          grantAs();
        }
        break;
      }

      case 3: {
        setState(4924);
        match(MySQLParser::PROXY_SYMBOL);
        setState(4925);
        match(MySQLParser::ON_SYMBOL);
        setState(4926);
        user();
        setState(4927);
        match(MySQLParser::TO_SYMBOL);
        setState(4928);
        grantTargetList();
        setState(4932);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(4929);
          match(MySQLParser::WITH_SYMBOL);
          setState(4930);
          match(MySQLParser::GRANT_SYMBOL);
          setState(4931);
          match(MySQLParser::OPTION_SYMBOL);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantTargetListContext ------------------------------------------------------------------

MySQLParser::GrantTargetListContext::GrantTargetListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateUserListContext *MySQLParser::GrantTargetListContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::UserListContext *MySQLParser::GrantTargetListContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

size_t MySQLParser::GrantTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleGrantTargetList;
}

void MySQLParser::GrantTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantTargetList(this);
}

void MySQLParser::GrantTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantTargetList(this);
}

std::any MySQLParser::GrantTargetListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantTargetList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantTargetListContext *MySQLParser::grantTargetList() {
  GrantTargetListContext *_localctx = _tracker.createInstance<GrantTargetListContext>(_ctx, getState());
  enterRule(_localctx, 624, MySQLParser::RuleGrantTargetList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(4940);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 553, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(4936);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(4937);
        createUserList();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(4938);

        if (!(serverVersion >= 80011))
          throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(4939);
        userList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionsContext ------------------------------------------------------------------

MySQLParser::GrantOptionsContext::GrantOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GrantOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::GrantOptionContext *> MySQLParser::GrantOptionsContext::grantOption() {
  return getRuleContexts<MySQLParser::GrantOptionContext>();
}

MySQLParser::GrantOptionContext *MySQLParser::GrantOptionsContext::grantOption(size_t i) {
  return getRuleContext<MySQLParser::GrantOptionContext>(i);
}

size_t MySQLParser::GrantOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOptions;
}

void MySQLParser::GrantOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOptions(this);
}

void MySQLParser::GrantOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOptions(this);
}

std::any MySQLParser::GrantOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantOptionsContext *MySQLParser::grantOptions() {
  GrantOptionsContext *_localctx = _tracker.createInstance<GrantOptionsContext>(_ctx, getState());
  enterRule(_localctx, 626, MySQLParser::RuleGrantOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4942);
    match(MySQLParser::WITH_SYMBOL);
    setState(4943);
    grantOption();
    setState(4948);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 554, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4944);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(4945);
        grantOption();
      }
      setState(4950);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 554, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptRoleListContext ------------------------------------------------------------------

MySQLParser::ExceptRoleListContext::ExceptRoleListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ExceptRoleListContext::EXCEPT_SYMBOL() {
  return getToken(MySQLParser::EXCEPT_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::ExceptRoleListContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

size_t MySQLParser::ExceptRoleListContext::getRuleIndex() const {
  return MySQLParser::RuleExceptRoleList;
}

void MySQLParser::ExceptRoleListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExceptRoleList(this);
}

void MySQLParser::ExceptRoleListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExceptRoleList(this);
}

std::any MySQLParser::ExceptRoleListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExceptRoleList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExceptRoleListContext *MySQLParser::exceptRoleList() {
  ExceptRoleListContext *_localctx = _tracker.createInstance<ExceptRoleListContext>(_ctx, getState());
  enterRule(_localctx, 628, MySQLParser::RuleExceptRoleList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4951);
    match(MySQLParser::EXCEPT_SYMBOL);
    setState(4952);
    roleList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithRolesContext ------------------------------------------------------------------

MySQLParser::WithRolesContext::WithRolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WithRolesContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WithRolesContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext *MySQLParser::WithRolesContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

tree::TerminalNode *MySQLParser::WithRolesContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WithRolesContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WithRolesContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExceptRoleListContext *MySQLParser::WithRolesContext::exceptRoleList() {
  return getRuleContext<MySQLParser::ExceptRoleListContext>(0);
}

size_t MySQLParser::WithRolesContext::getRuleIndex() const {
  return MySQLParser::RuleWithRoles;
}

void MySQLParser::WithRolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithRoles(this);
}

void MySQLParser::WithRolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithRoles(this);
}

std::any MySQLParser::WithRolesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWithRoles(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WithRolesContext *MySQLParser::withRoles() {
  WithRolesContext *_localctx = _tracker.createInstance<WithRolesContext>(_ctx, getState());
  enterRule(_localctx, 630, MySQLParser::RuleWithRoles);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4954);
    match(MySQLParser::WITH_SYMBOL);
    setState(4955);
    match(MySQLParser::ROLE_SYMBOL);
    setState(4963);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 556, _ctx)) {
      case 1: {
        setState(4956);
        roleList();
        break;
      }

      case 2: {
        setState(4957);
        match(MySQLParser::ALL_SYMBOL);
        setState(4959);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXCEPT_SYMBOL) {
          setState(4958);
          exceptRoleList();
        }
        break;
      }

      case 3: {
        setState(4961);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 4: {
        setState(4962);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantAsContext ------------------------------------------------------------------

MySQLParser::GrantAsContext::GrantAsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GrantAsContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantAsContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::WithRolesContext *MySQLParser::GrantAsContext::withRoles() {
  return getRuleContext<MySQLParser::WithRolesContext>(0);
}

size_t MySQLParser::GrantAsContext::getRuleIndex() const {
  return MySQLParser::RuleGrantAs;
}

void MySQLParser::GrantAsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantAs(this);
}

void MySQLParser::GrantAsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantAs(this);
}

std::any MySQLParser::GrantAsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantAs(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantAsContext *MySQLParser::grantAs() {
  GrantAsContext *_localctx = _tracker.createInstance<GrantAsContext>(_ctx, getState());
  enterRule(_localctx, 632, MySQLParser::RuleGrantAs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4965);
    match(MySQLParser::AS_SYMBOL);
    setState(4966);
    match(MySQLParser::USER_SYMBOL);
    setState(4968);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(4967);
      withRoles();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionedRequireClauseContext ------------------------------------------------------------------

MySQLParser::VersionedRequireClauseContext::VersionedRequireClauseContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext *MySQLParser::VersionedRequireClauseContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}

size_t MySQLParser::VersionedRequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleVersionedRequireClause;
}

void MySQLParser::VersionedRequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionedRequireClause(this);
}

void MySQLParser::VersionedRequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionedRequireClause(this);
}

std::any MySQLParser::VersionedRequireClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitVersionedRequireClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VersionedRequireClauseContext *MySQLParser::versionedRequireClause() {
  VersionedRequireClauseContext *_localctx = _tracker.createInstance<VersionedRequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 634, MySQLParser::RuleVersionedRequireClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4970);

    if (!(serverVersion < 80011))
      throw FailedPredicateException(this, "serverVersion < 80011");
    setState(4971);
    requireClause();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserStatementContext ------------------------------------------------------------------

MySQLParser::RenameUserStatementContext::RenameUserStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RenameUserStatementContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RenameUserStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

std::vector<MySQLParser::UserContext *> MySQLParser::RenameUserStatementContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext *MySQLParser::RenameUserStatementContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserStatementContext::TO_SYMBOL() {
  return getTokens(MySQLParser::TO_SYMBOL);
}

tree::TerminalNode *MySQLParser::RenameUserStatementContext::TO_SYMBOL(size_t i) {
  return getToken(MySQLParser::TO_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::RenameUserStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::RenameUserStatementContext::getRuleIndex() const {
  return MySQLParser::RuleRenameUserStatement;
}

void MySQLParser::RenameUserStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUserStatement(this);
}

void MySQLParser::RenameUserStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUserStatement(this);
}

std::any MySQLParser::RenameUserStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRenameUserStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RenameUserStatementContext *MySQLParser::renameUserStatement() {
  RenameUserStatementContext *_localctx = _tracker.createInstance<RenameUserStatementContext>(_ctx, getState());
  enterRule(_localctx, 636, MySQLParser::RuleRenameUserStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4973);
    match(MySQLParser::RENAME_SYMBOL);
    setState(4974);
    match(MySQLParser::USER_SYMBOL);
    setState(4975);
    user();
    setState(4976);
    match(MySQLParser::TO_SYMBOL);
    setState(4977);
    user();
    setState(4985);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4978);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4979);
      user();
      setState(4980);
      match(MySQLParser::TO_SYMBOL);
      setState(4981);
      user();
      setState(4987);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeStatementContext ------------------------------------------------------------------

MySQLParser::RevokeStatementContext::RevokeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::REVOKE_SYMBOL() {
  return getToken(MySQLParser::REVOKE_SYMBOL, 0);
}

MySQLParser::RoleOrPrivilegesListContext *MySQLParser::RevokeStatementContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserListContext *MySQLParser::RevokeStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext *MySQLParser::RevokeStatementContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::RevokeStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::IfExistsContext *MySQLParser::RevokeStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

MySQLParser::IgnoreUnknownUserContext *MySQLParser::RevokeStatementContext::ignoreUnknownUser() {
  return getRuleContext<MySQLParser::IgnoreUnknownUserContext>(0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

MySQLParser::AclTypeContext *MySQLParser::RevokeStatementContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}

tree::TerminalNode *MySQLParser::RevokeStatementContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

size_t MySQLParser::RevokeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleRevokeStatement;
}

void MySQLParser::RevokeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevokeStatement(this);
}

void MySQLParser::RevokeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevokeStatement(this);
}

std::any MySQLParser::RevokeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRevokeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RevokeStatementContext *MySQLParser::revokeStatement() {
  RevokeStatementContext *_localctx = _tracker.createInstance<RevokeStatementContext>(_ctx, getState());
  enterRule(_localctx, 638, MySQLParser::RuleRevokeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4988);
    match(MySQLParser::REVOKE_SYMBOL);
    setState(4991);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx)) {
      case 1: {
        setState(4989);

        if (!(serverVersion >= 80031))
          throw FailedPredicateException(this, "serverVersion >= 80031");
        setState(4990);
        ifExists();
        break;
      }

      default:
        break;
    }
    setState(5028);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
      case 1: {
        setState(4993);
        roleOrPrivilegesList();
        setState(4994);
        match(MySQLParser::FROM_SYMBOL);
        setState(4995);
        userList();
        break;
      }

      case 2: {
        setState(4997);
        roleOrPrivilegesList();
        setState(4998);
        match(MySQLParser::ON_SYMBOL);
        setState(5000);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 560, _ctx)) {
          case 1: {
            setState(4999);
            aclType();
            break;
          }

          default:
            break;
        }
        setState(5002);
        grantIdentifier();
        setState(5003);
        match(MySQLParser::FROM_SYMBOL);
        setState(5004);
        userList();
        break;
      }

      case 3: {
        setState(5006);
        match(MySQLParser::ALL_SYMBOL);
        setState(5008);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIVILEGES_SYMBOL) {
          setState(5007);
          match(MySQLParser::PRIVILEGES_SYMBOL);
        }
        setState(5018);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ON_SYMBOL: {
            setState(5010);
            match(MySQLParser::ON_SYMBOL);
            setState(5012);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 562, _ctx)) {
              case 1: {
                setState(5011);
                aclType();
                break;
              }

              default:
                break;
            }
            setState(5014);
            grantIdentifier();
            break;
          }

          case MySQLParser::COMMA_SYMBOL: {
            setState(5015);
            match(MySQLParser::COMMA_SYMBOL);
            setState(5016);
            match(MySQLParser::GRANT_SYMBOL);
            setState(5017);
            match(MySQLParser::OPTION_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        setState(5020);
        match(MySQLParser::FROM_SYMBOL);
        setState(5021);
        userList();
        break;
      }

      case 4: {
        setState(5022);
        match(MySQLParser::PROXY_SYMBOL);
        setState(5023);
        match(MySQLParser::ON_SYMBOL);
        setState(5024);
        user();
        setState(5025);
        match(MySQLParser::FROM_SYMBOL);
        setState(5026);
        userList();
        break;
      }

      default:
        break;
    }
    setState(5032);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 565, _ctx)) {
      case 1: {
        setState(5030);

        if (!(serverVersion >= 80031))
          throw FailedPredicateException(this, "serverVersion >= 80031");
        setState(5031);
        ignoreUnknownUser();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AclTypeContext ------------------------------------------------------------------

MySQLParser::AclTypeContext::AclTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AclTypeContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AclTypeContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AclTypeContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

size_t MySQLParser::AclTypeContext::getRuleIndex() const {
  return MySQLParser::RuleAclType;
}

void MySQLParser::AclTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAclType(this);
}

void MySQLParser::AclTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAclType(this);
}

std::any MySQLParser::AclTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAclType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AclTypeContext *MySQLParser::aclType() {
  AclTypeContext *_localctx = _tracker.createInstance<AclTypeContext>(_ctx, getState());
  enterRule(_localctx, 640, MySQLParser::RuleAclType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5034);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FUNCTION_SYMBOL || _la == MySQLParser::PROCEDURE_SYMBOL ||
          _la == MySQLParser::TABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegesListContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegesListContext::RoleOrPrivilegesListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleOrPrivilegeContext *> MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege() {
  return getRuleContexts<MySQLParser::RoleOrPrivilegeContext>();
}

MySQLParser::RoleOrPrivilegeContext *MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege(size_t i) {
  return getRuleContext<MySQLParser::RoleOrPrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::RoleOrPrivilegesListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilegesList;
}

void MySQLParser::RoleOrPrivilegesListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilegesList(this);
}

void MySQLParser::RoleOrPrivilegesListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilegesList(this);
}

std::any MySQLParser::RoleOrPrivilegesListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleOrPrivilegesList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrPrivilegesListContext *MySQLParser::roleOrPrivilegesList() {
  RoleOrPrivilegesListContext *_localctx = _tracker.createInstance<RoleOrPrivilegesListContext>(_ctx, getState());
  enterRule(_localctx, 642, MySQLParser::RuleRoleOrPrivilegesList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5036);
    roleOrPrivilege();
    setState(5041);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5037);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5038);
      roleOrPrivilege();
      setState(5043);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegeContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegeContext::RoleOrPrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext *MySQLParser::RoleOrPrivilegeContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::RoleOrPrivilegeContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::RoleOrPrivilegeContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::USAGE_SYMBOL() {
  return getToken(MySQLParser::USAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::RoleOrPrivilegeContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrPrivilegeContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

size_t MySQLParser::RoleOrPrivilegeContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilege;
}

void MySQLParser::RoleOrPrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilege(this);
}

void MySQLParser::RoleOrPrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilege(this);
}

std::any MySQLParser::RoleOrPrivilegeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleOrPrivilege(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrPrivilegeContext *MySQLParser::roleOrPrivilege() {
  RoleOrPrivilegeContext *_localctx = _tracker.createInstance<RoleOrPrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 644, MySQLParser::RuleRoleOrPrivilege);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5086);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 574, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5054);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 569, _ctx)) {
          case 1: {
            setState(5044);
            roleIdentifierOrText();
            setState(5046);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
              setState(5045);
              columnInternalRefList();
            }
            break;
          }

          case 2: {
            setState(5048);
            roleIdentifierOrText();
            setState(5052);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::AT_TEXT_SUFFIX: {
                setState(5049);
                match(MySQLParser::AT_TEXT_SUFFIX);
                break;
              }

              case MySQLParser::AT_SIGN_SYMBOL: {
                setState(5050);
                match(MySQLParser::AT_SIGN_SYMBOL);
                setState(5051);
                textOrIdentifier();
                break;
              }

              default:
                throw NoViableAltException(this);
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5056);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INSERT_SYMBOL || _la == MySQLParser::REFERENCES_SYMBOL

              || _la == MySQLParser::SELECT_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5058);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
          setState(5057);
          columnInternalRefList();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5060);
        _la = _input->LA(1);
        if (!(((((_la - 133) & ~0x3fULL) == 0) && ((1ULL << (_la - 133)) & 36030033969577985) != 0) ||
              _la == MySQLParser::INDEX_SYMBOL ||
              ((((_la - 423) & ~0x3fULL) == 0) && ((1ULL << (_la - 423)) & 268435473) != 0) ||
              _la == MySQLParser::SHUTDOWN_SYMBOL

              || _la == MySQLParser::SUPER_SYMBOL || _la == MySQLParser::TRIGGER_SYMBOL

              || _la == MySQLParser::USAGE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5061);
        match(MySQLParser::GRANT_SYMBOL);
        setState(5062);
        match(MySQLParser::OPTION_SYMBOL);
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(5063);
        match(MySQLParser::SHOW_SYMBOL);
        setState(5064);
        match(MySQLParser::DATABASES_SYMBOL);
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(5065);
        match(MySQLParser::CREATE_SYMBOL);
        setState(5069);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TEMPORARY_SYMBOL: {
            setState(5066);
            match(MySQLParser::TEMPORARY_SYMBOL);
            setState(5067);
            antlrcpp::downCast<RoleOrPrivilegeContext *>(_localctx)->object = match(MySQLParser::TABLES_SYMBOL);
            break;
          }

          case MySQLParser::ROUTINE_SYMBOL:
          case MySQLParser::TABLESPACE_SYMBOL:
          case MySQLParser::USER_SYMBOL:
          case MySQLParser::VIEW_SYMBOL: {
            setState(5068);
            antlrcpp::downCast<RoleOrPrivilegeContext *>(_localctx)->object = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::ROUTINE_SYMBOL || _la == MySQLParser::TABLESPACE_SYMBOL

                  || _la == MySQLParser::USER_SYMBOL || _la == MySQLParser::VIEW_SYMBOL)) {
              antlrcpp::downCast<RoleOrPrivilegeContext *>(_localctx)->object = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          case MySQLParser::FROM_SYMBOL:
          case MySQLParser::ON_SYMBOL:
          case MySQLParser::TO_SYMBOL:
          case MySQLParser::COMMA_SYMBOL: {
            break;
          }

          default:
            break;
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(5071);
        match(MySQLParser::LOCK_SYMBOL);
        setState(5072);
        match(MySQLParser::TABLES_SYMBOL);
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(5073);
        match(MySQLParser::REPLICATION_SYMBOL);
        setState(5076);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::CLIENT_SYMBOL: {
            setState(5074);
            match(MySQLParser::CLIENT_SYMBOL);
            break;
          }

          case MySQLParser::SLAVE_SYMBOL:
          case MySQLParser::REPLICA_SYMBOL: {
            setState(5075);
            replica();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(5078);
        match(MySQLParser::SHOW_SYMBOL);
        setState(5079);
        match(MySQLParser::VIEW_SYMBOL);
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(5080);
        match(MySQLParser::ALTER_SYMBOL);
        setState(5082);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ROUTINE_SYMBOL) {
          setState(5081);
          match(MySQLParser::ROUTINE_SYMBOL);
        }
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(5084);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CREATE_SYMBOL

              || _la == MySQLParser::DROP_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5085);
        match(MySQLParser::ROLE_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantIdentifierContext ------------------------------------------------------------------

MySQLParser::GrantIdentifierContext::GrantIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantIdentifierContext::MULT_OPERATOR() {
  return getTokens(MySQLParser::MULT_OPERATOR);
}

tree::TerminalNode *MySQLParser::GrantIdentifierContext::MULT_OPERATOR(size_t i) {
  return getToken(MySQLParser::MULT_OPERATOR, i);
}

tree::TerminalNode *MySQLParser::GrantIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::SchemaRefContext *MySQLParser::GrantIdentifierContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::TableRefContext *MySQLParser::GrantIdentifierContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

size_t MySQLParser::GrantIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleGrantIdentifier;
}

void MySQLParser::GrantIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantIdentifier(this);
}

void MySQLParser::GrantIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantIdentifier(this);
}

std::any MySQLParser::GrantIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantIdentifierContext *MySQLParser::grantIdentifier() {
  GrantIdentifierContext *_localctx = _tracker.createInstance<GrantIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 646, MySQLParser::RuleGrantIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5104);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 577, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5088);
        match(MySQLParser::MULT_OPERATOR);
        setState(5091);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(5089);
          match(MySQLParser::DOT_SYMBOL);
          setState(5090);
          match(MySQLParser::MULT_OPERATOR);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5093);
        schemaRef();
        setState(5096);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(5094);
          match(MySQLParser::DOT_SYMBOL);
          setState(5095);
          match(MySQLParser::MULT_OPERATOR);
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5098);
        tableRef();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5099);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(5100);
        schemaRef();
        setState(5101);
        match(MySQLParser::DOT_SYMBOL);
        setState(5102);
        tableRef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListContext ------------------------------------------------------------------

MySQLParser::RequireListContext::RequireListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RequireListElementContext *> MySQLParser::RequireListContext::requireListElement() {
  return getRuleContexts<MySQLParser::RequireListElementContext>();
}

MySQLParser::RequireListElementContext *MySQLParser::RequireListContext::requireListElement(size_t i) {
  return getRuleContext<MySQLParser::RequireListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RequireListContext::AND_SYMBOL() {
  return getTokens(MySQLParser::AND_SYMBOL);
}

tree::TerminalNode *MySQLParser::RequireListContext::AND_SYMBOL(size_t i) {
  return getToken(MySQLParser::AND_SYMBOL, i);
}

size_t MySQLParser::RequireListContext::getRuleIndex() const {
  return MySQLParser::RuleRequireList;
}

void MySQLParser::RequireListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireList(this);
}

void MySQLParser::RequireListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireList(this);
}

std::any MySQLParser::RequireListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRequireList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireListContext *MySQLParser::requireList() {
  RequireListContext *_localctx = _tracker.createInstance<RequireListContext>(_ctx, getState());
  enterRule(_localctx, 648, MySQLParser::RuleRequireList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5106);
    requireListElement();
    setState(5113);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5108);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(5107);
          match(MySQLParser::AND_SYMBOL);
        }
        setState(5110);
        requireListElement();
      }
      setState(5115);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 579, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListElementContext ------------------------------------------------------------------

MySQLParser::RequireListElementContext::RequireListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringContext *MySQLParser::RequireListElementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::RequireListElementContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RequireListElementContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RequireListElementContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

size_t MySQLParser::RequireListElementContext::getRuleIndex() const {
  return MySQLParser::RuleRequireListElement;
}

void MySQLParser::RequireListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireListElement(this);
}

void MySQLParser::RequireListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireListElement(this);
}

std::any MySQLParser::RequireListElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRequireListElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RequireListElementContext *MySQLParser::requireListElement() {
  RequireListElementContext *_localctx = _tracker.createInstance<RequireListElementContext>(_ctx, getState());
  enterRule(_localctx, 650, MySQLParser::RuleRequireListElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5122);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5116);
        antlrcpp::downCast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::CIPHER_SYMBOL);
        setState(5117);
        textString();
        break;
      }

      case MySQLParser::ISSUER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5118);
        antlrcpp::downCast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::ISSUER_SYMBOL);
        setState(5119);
        textString();
        break;
      }

      case MySQLParser::SUBJECT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5120);
        antlrcpp::downCast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::SUBJECT_SYMBOL);
        setState(5121);
        textString();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionContext ------------------------------------------------------------------

MySQLParser::GrantOptionContext::GrantOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GrantOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantOptionContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::GrantOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::GrantOptionContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantOptionContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantOptionContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GrantOptionContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

size_t MySQLParser::GrantOptionContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOption;
}

void MySQLParser::GrantOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOption(this);
}

void MySQLParser::GrantOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOption(this);
}

std::any MySQLParser::GrantOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGrantOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GrantOptionContext *MySQLParser::grantOption() {
  GrantOptionContext *_localctx = _tracker.createInstance<GrantOptionContext>(_ctx, getState());
  enterRule(_localctx, 652, MySQLParser::RuleGrantOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5137);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 582, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5124);
        antlrcpp::downCast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::GRANT_SYMBOL);
        setState(5125);
        match(MySQLParser::OPTION_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5126);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(5135);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
            setState(5127);
            antlrcpp::downCast<GrantOptionContext *>(_localctx)->option =
              match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
            setState(5128);
            ulong_number();
            break;
          }

          case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
            setState(5129);
            antlrcpp::downCast<GrantOptionContext *>(_localctx)->option =
              match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
            setState(5130);
            ulong_number();
            break;
          }

          case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
            setState(5131);
            antlrcpp::downCast<GrantOptionContext *>(_localctx)->option =
              match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
            setState(5132);
            ulong_number();
            break;
          }

          case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
            setState(5133);
            antlrcpp::downCast<GrantOptionContext *>(_localctx)->option =
              match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
            setState(5134);
            ulong_number();
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleStatementContext ------------------------------------------------------------------

MySQLParser::SetRoleStatementContext::SetRoleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

std::vector<MySQLParser::RoleListContext *> MySQLParser::SetRoleStatementContext::roleList() {
  return getRuleContexts<MySQLParser::RoleListContext>();
}

MySQLParser::RoleListContext *MySQLParser::SetRoleStatementContext::roleList(size_t i) {
  return getRuleContext<MySQLParser::RoleListContext>(i);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetRoleStatementContext::EXCEPT_SYMBOL() {
  return getToken(MySQLParser::EXCEPT_SYMBOL, 0);
}

size_t MySQLParser::SetRoleStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSetRoleStatement;
}

void MySQLParser::SetRoleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRoleStatement(this);
}

void MySQLParser::SetRoleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRoleStatement(this);
}

std::any MySQLParser::SetRoleStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetRoleStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetRoleStatementContext *MySQLParser::setRoleStatement() {
  SetRoleStatementContext *_localctx = _tracker.createInstance<SetRoleStatementContext>(_ctx, getState());
  enterRule(_localctx, 654, MySQLParser::RuleSetRoleStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5162);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 585, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5139);
        match(MySQLParser::SET_SYMBOL);
        setState(5140);
        match(MySQLParser::ROLE_SYMBOL);
        setState(5141);
        roleList();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5142);
        match(MySQLParser::SET_SYMBOL);
        setState(5143);
        match(MySQLParser::ROLE_SYMBOL);
        setState(5144);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::NONE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5145);
        match(MySQLParser::SET_SYMBOL);
        setState(5146);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(5147);
        match(MySQLParser::ROLE_SYMBOL);
        setState(5151);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
          case 1: {
            setState(5148);
            roleList();
            break;
          }

          case 2: {
            setState(5149);
            match(MySQLParser::NONE_SYMBOL);
            break;
          }

          case 3: {
            setState(5150);
            match(MySQLParser::ALL_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(5153);
        match(MySQLParser::TO_SYMBOL);
        setState(5154);
        roleList();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5155);
        match(MySQLParser::SET_SYMBOL);
        setState(5156);
        match(MySQLParser::ROLE_SYMBOL);
        setState(5157);
        match(MySQLParser::ALL_SYMBOL);
        setState(5160);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXCEPT_SYMBOL) {
          setState(5158);
          match(MySQLParser::EXCEPT_SYMBOL);
          setState(5159);
          roleList();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleListContext ------------------------------------------------------------------

MySQLParser::RoleListContext::RoleListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleContext *> MySQLParser::RoleListContext::role() {
  return getRuleContexts<MySQLParser::RoleContext>();
}

MySQLParser::RoleContext *MySQLParser::RoleListContext::role(size_t i) {
  return getRuleContext<MySQLParser::RoleContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::RoleListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::RoleListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleList;
}

void MySQLParser::RoleListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleList(this);
}

void MySQLParser::RoleListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleList(this);
}

std::any MySQLParser::RoleListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleListContext *MySQLParser::roleList() {
  RoleListContext *_localctx = _tracker.createInstance<RoleListContext>(_ctx, getState());
  enterRule(_localctx, 656, MySQLParser::RuleRoleList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5164);
    role();
    setState(5169);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 586, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(5165);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5166);
        role();
      }
      setState(5171);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 586, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleContext ------------------------------------------------------------------

MySQLParser::RoleContext::RoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext *MySQLParser::RoleContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

MySQLParser::UserVariableContext *MySQLParser::RoleContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

size_t MySQLParser::RoleContext::getRuleIndex() const {
  return MySQLParser::RuleRole;
}

void MySQLParser::RoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole(this);
}

void MySQLParser::RoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole(this);
}

std::any MySQLParser::RoleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRole(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleContext *MySQLParser::role() {
  RoleContext *_localctx = _tracker.createInstance<RoleContext>(_ctx, getState());
  enterRule(_localctx, 658, MySQLParser::RuleRole);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5172);
    roleIdentifierOrText();
    setState(5174);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 587, _ctx)) {
      case 1: {
        setState(5173);
        userVariable();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAdministrationStatementContext
//------------------------------------------------------------------

MySQLParser::TableAdministrationStatementContext::TableAdministrationStatementContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefListContext *MySQLParser::TableAdministrationStatementContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

MySQLParser::NoWriteToBinLogContext *MySQLParser::TableAdministrationStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

MySQLParser::HistogramContext *MySQLParser::TableAdministrationStatementContext::histogram() {
  return getRuleContext<MySQLParser::HistogramContext>(0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::TableAdministrationStatementContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext *MySQLParser::TableAdministrationStatementContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableAdministrationStatementContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::TableAdministrationStatementContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext *MySQLParser::TableAdministrationStatementContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}

size_t MySQLParser::TableAdministrationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTableAdministrationStatement;
}

void MySQLParser::TableAdministrationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAdministrationStatement(this);
}

void MySQLParser::TableAdministrationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAdministrationStatement(this);
}

std::any MySQLParser::TableAdministrationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableAdministrationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAdministrationStatementContext *MySQLParser::tableAdministrationStatement() {
  TableAdministrationStatementContext *_localctx =
    _tracker.createInstance<TableAdministrationStatementContext>(_ctx, getState());
  enterRule(_localctx, 660, MySQLParser::RuleTableAdministrationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5218);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ANALYZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5176);
        antlrcpp::downCast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::ANALYZE_SYMBOL);
        setState(5178);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(5177);
          noWriteToBinLog();
        }
        setState(5180);
        match(MySQLParser::TABLE_SYMBOL);
        setState(5181);
        tableRefList();
        setState(5183);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DROP_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL) {
          setState(5182);
          histogram();
        }
        break;
      }

      case MySQLParser::CHECK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5185);
        antlrcpp::downCast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::CHECK_SYMBOL);
        setState(5186);
        match(MySQLParser::TABLE_SYMBOL);
        setState(5187);
        tableRefList();
        setState(5191);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::CHANGED_SYMBOL ||
               ((((_la - 180) & ~0x3fULL) == 0) && ((1ULL << (_la - 180)) & 1048593) != 0) ||
               _la == MySQLParser::MEDIUM_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(5188);
          checkOption();
          setState(5193);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::CHECKSUM_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5194);
        antlrcpp::downCast<TableAdministrationStatementContext *>(_localctx)->type =
          match(MySQLParser::CHECKSUM_SYMBOL);
        setState(5195);
        match(MySQLParser::TABLE_SYMBOL);
        setState(5196);
        tableRefList();
        setState(5198);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(5197);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
            _errHandler->recoverInline(this);
          } else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::OPTIMIZE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5200);
        antlrcpp::downCast<TableAdministrationStatementContext *>(_localctx)->type =
          match(MySQLParser::OPTIMIZE_SYMBOL);
        setState(5202);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(5201);
          noWriteToBinLog();
        }
        setState(5204);
        match(MySQLParser::TABLE_SYMBOL);
        setState(5205);
        tableRefList();
        break;
      }

      case MySQLParser::REPAIR_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(5206);
        antlrcpp::downCast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::REPAIR_SYMBOL);
        setState(5208);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(5207);
          noWriteToBinLog();
        }
        setState(5210);
        match(MySQLParser::TABLE_SYMBOL);
        setState(5211);
        tableRefList();
        setState(5215);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL ||
               _la == MySQLParser::USE_FRM_SYMBOL) {
          setState(5212);
          repairType();
          setState(5217);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramContext ------------------------------------------------------------------

MySQLParser::HistogramContext::HistogramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HistogramContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::HistogramContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode *MySQLParser::HistogramContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HistogramContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::HistogramContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::HistogramContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

size_t MySQLParser::HistogramContext::getRuleIndex() const {
  return MySQLParser::RuleHistogram;
}

void MySQLParser::HistogramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHistogram(this);
}

void MySQLParser::HistogramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHistogram(this);
}

std::any MySQLParser::HistogramContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHistogram(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HistogramContext *MySQLParser::histogram() {
  HistogramContext *_localctx = _tracker.createInstance<HistogramContext>(_ctx, getState());
  enterRule(_localctx, 662, MySQLParser::RuleHistogram);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5237);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UPDATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5220);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(5221);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(5222);
        match(MySQLParser::ON_SYMBOL);
        setState(5223);
        identifierList();
        setState(5231);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 596, _ctx)) {
          case 1: {
            setState(5224);
            match(MySQLParser::WITH_SYMBOL);
            setState(5225);
            match(MySQLParser::INT_NUMBER);
            setState(5226);
            match(MySQLParser::BUCKETS_SYMBOL);
            break;
          }

          case 2: {
            setState(5227);

            if (!(serverVersion >= 80031))
              throw FailedPredicateException(this, "serverVersion >= 80031");
            setState(5228);
            match(MySQLParser::USING_SYMBOL);
            setState(5229);
            match(MySQLParser::DATA_SYMBOL);
            setState(5230);
            textStringLiteral();
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5233);
        match(MySQLParser::DROP_SYMBOL);
        setState(5234);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(5235);
        match(MySQLParser::ON_SYMBOL);
        setState(5236);
        identifierList();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOptionContext ------------------------------------------------------------------

MySQLParser::CheckOptionContext::CheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CheckOptionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CheckOptionContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

size_t MySQLParser::CheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOption;
}

void MySQLParser::CheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOption(this);
}

void MySQLParser::CheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOption(this);
}

std::any MySQLParser::CheckOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCheckOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckOptionContext *MySQLParser::checkOption() {
  CheckOptionContext *_localctx = _tracker.createInstance<CheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 664, MySQLParser::RuleCheckOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5242);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5239);
        match(MySQLParser::FOR_SYMBOL);
        setState(5240);
        match(MySQLParser::UPGRADE_SYMBOL);
        break;
      }

      case MySQLParser::CHANGED_SYMBOL:
      case MySQLParser::EXTENDED_SYMBOL:
      case MySQLParser::FAST_SYMBOL:
      case MySQLParser::MEDIUM_SYMBOL:
      case MySQLParser::QUICK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5241);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CHANGED_SYMBOL || _la == MySQLParser::EXTENDED_SYMBOL

              || _la == MySQLParser::FAST_SYMBOL || _la == MySQLParser::MEDIUM_SYMBOL ||
              _la == MySQLParser::QUICK_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTypeContext ------------------------------------------------------------------

MySQLParser::RepairTypeContext::RepairTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RepairTypeContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RepairTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RepairTypeContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

size_t MySQLParser::RepairTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRepairType;
}

void MySQLParser::RepairTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairType(this);
}

void MySQLParser::RepairTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairType(this);
}

std::any MySQLParser::RepairTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRepairType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RepairTypeContext *MySQLParser::repairType() {
  RepairTypeContext *_localctx = _tracker.createInstance<RepairTypeContext>(_ctx, getState());
  enterRule(_localctx, 666, MySQLParser::RuleRepairType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5244);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL ||
          _la == MySQLParser::USE_FRM_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallUninstallStatementContext ------------------------------------------------------------------

MySQLParser::InstallUninstallStatementContext::InstallUninstallStatementContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::InstallUninstallStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::InstallUninstallStatementContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext *MySQLParser::InstallUninstallStatementContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

MySQLParser::PluginRefContext *MySQLParser::InstallUninstallStatementContext::pluginRef() {
  return getRuleContext<MySQLParser::PluginRefContext>(0);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

std::vector<MySQLParser::ComponentRefContext *> MySQLParser::InstallUninstallStatementContext::componentRef() {
  return getRuleContexts<MySQLParser::ComponentRefContext>();
}

MySQLParser::ComponentRefContext *MySQLParser::InstallUninstallStatementContext::componentRef(size_t i) {
  return getRuleContext<MySQLParser::ComponentRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::InstallUninstallStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::InstallUninstallStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::InstallUninstallStatementContext::getRuleIndex() const {
  return MySQLParser::RuleInstallUninstallStatement;
}

void MySQLParser::InstallUninstallStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallUninstallStatement(this);
}

void MySQLParser::InstallUninstallStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallUninstallStatement(this);
}

std::any MySQLParser::InstallUninstallStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInstallUninstallStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InstallUninstallStatementContext *MySQLParser::installUninstallStatement() {
  InstallUninstallStatementContext *_localctx =
    _tracker.createInstance<InstallUninstallStatementContext>(_ctx, getState());
  enterRule(_localctx, 668, MySQLParser::RuleInstallUninstallStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5268);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5246);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
        setState(5247);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
        setState(5248);
        identifier();
        setState(5249);
        match(MySQLParser::SONAME_SYMBOL);
        setState(5250);
        textStringLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5252);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
        setState(5253);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
        setState(5254);
        textStringLiteralList();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5255);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->action =
          match(MySQLParser::UNINSTALL_SYMBOL);
        setState(5256);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
        setState(5257);
        pluginRef();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5258);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->action =
          match(MySQLParser::UNINSTALL_SYMBOL);
        setState(5259);
        antlrcpp::downCast<InstallUninstallStatementContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
        setState(5260);
        componentRef();
        setState(5265);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(5261);
          match(MySQLParser::COMMA_SYMBOL);
          setState(5262);
          componentRef();
          setState(5267);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetStatementContext ------------------------------------------------------------------

MySQLParser::SetStatementContext::SetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SetStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::StartOptionValueListContext *MySQLParser::SetStatementContext::startOptionValueList() {
  return getRuleContext<MySQLParser::StartOptionValueListContext>(0);
}

size_t MySQLParser::SetStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSetStatement;
}

void MySQLParser::SetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetStatement(this);
}

void MySQLParser::SetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetStatement(this);
}

std::any MySQLParser::SetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetStatementContext *MySQLParser::setStatement() {
  SetStatementContext *_localctx = _tracker.createInstance<SetStatementContext>(_ctx, getState());
  enterRule(_localctx, 670, MySQLParser::RuleSetStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5270);
    match(MySQLParser::SET_SYMBOL);
    setState(5271);
    startOptionValueList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartOptionValueListContext ------------------------------------------------------------------

MySQLParser::StartOptionValueListContext::StartOptionValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OptionValueNoOptionTypeContext *MySQLParser::StartOptionValueListContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}

MySQLParser::OptionValueListContinuedContext *MySQLParser::StartOptionValueListContext::optionValueListContinued() {
  return getRuleContext<MySQLParser::OptionValueListContinuedContext>(0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

MySQLParser::TransactionCharacteristicsContext *MySQLParser::StartOptionValueListContext::transactionCharacteristics() {
  return getRuleContext<MySQLParser::TransactionCharacteristicsContext>(0);
}

MySQLParser::OptionTypeContext *MySQLParser::StartOptionValueListContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::StartOptionValueListFollowingOptionTypeContext *
MySQLParser::StartOptionValueListContext::startOptionValueListFollowingOptionType() {
  return getRuleContext<MySQLParser::StartOptionValueListFollowingOptionTypeContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::StartOptionValueListContext::PASSWORD_SYMBOL() {
  return getTokens(MySQLParser::PASSWORD_SYMBOL);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::PASSWORD_SYMBOL(size_t i) {
  return getToken(MySQLParser::PASSWORD_SYMBOL, i);
}

MySQLParser::EqualContext *MySQLParser::StartOptionValueListContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::TextStringContext *MySQLParser::StartOptionValueListContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::StartOptionValueListContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::ReplacePasswordContext *MySQLParser::StartOptionValueListContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext *MySQLParser::StartOptionValueListContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListContext::RANDOM_SYMBOL() {
  return getToken(MySQLParser::RANDOM_SYMBOL, 0);
}

size_t MySQLParser::StartOptionValueListContext::getRuleIndex() const {
  return MySQLParser::RuleStartOptionValueList;
}

void MySQLParser::StartOptionValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartOptionValueList(this);
}

void MySQLParser::StartOptionValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartOptionValueList(this);
}

std::any MySQLParser::StartOptionValueListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStartOptionValueList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StartOptionValueListContext *MySQLParser::startOptionValueList() {
  StartOptionValueListContext *_localctx = _tracker.createInstance<StartOptionValueListContext>(_ctx, getState());
  enterRule(_localctx, 672, MySQLParser::RuleStartOptionValueList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5323);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 610, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5273);
        optionValueNoOptionType();
        setState(5274);
        optionValueListContinued();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5276);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(5277);
        transactionCharacteristics();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5278);
        optionType();
        setState(5279);
        startOptionValueListFollowingOptionType();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5281);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(5284);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(5282);
          match(MySQLParser::FOR_SYMBOL);
          setState(5283);
          user();
        }
        setState(5286);
        equal();
        setState(5307);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx)) {
          case 1: {
            setState(5287);
            textString();
            setState(5289);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::REPLACE_SYMBOL) {
              setState(5288);
              replacePassword();
            }
            setState(5292);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::RETAIN_SYMBOL) {
              setState(5291);
              retainCurrentPassword();
            }
            break;
          }

          case 2: {
            setState(5294);
            textString();
            setState(5296);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::REPLACE_SYMBOL) {
              setState(5295);
              replacePassword();
            }
            setState(5299);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::RETAIN_SYMBOL) {
              setState(5298);
              retainCurrentPassword();
            }
            break;
          }

          case 3: {
            setState(5301);

            if (!(serverVersion < 80014))
              throw FailedPredicateException(this, "serverVersion < 80014");
            setState(5302);
            match(MySQLParser::PASSWORD_SYMBOL);
            setState(5303);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(5304);
            textString();
            setState(5305);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(5309);

        if (!(serverVersion >= 80018))
          throw FailedPredicateException(this, "serverVersion >= 80018");
        setState(5310);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(5313);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(5311);
          match(MySQLParser::FOR_SYMBOL);
          setState(5312);
          user();
        }
        setState(5315);
        match(MySQLParser::TO_SYMBOL);
        setState(5316);
        match(MySQLParser::RANDOM_SYMBOL);
        setState(5318);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REPLACE_SYMBOL) {
          setState(5317);
          replacePassword();
        }
        setState(5321);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::RETAIN_SYMBOL) {
          setState(5320);
          retainCurrentPassword();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionCharacteristicsContext ------------------------------------------------------------------

MySQLParser::TransactionCharacteristicsContext::TransactionCharacteristicsContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TransactionAccessModeContext *MySQLParser::TransactionCharacteristicsContext::transactionAccessMode() {
  return getRuleContext<MySQLParser::TransactionAccessModeContext>(0);
}

MySQLParser::IsolationLevelContext *MySQLParser::TransactionCharacteristicsContext::isolationLevel() {
  return getRuleContext<MySQLParser::IsolationLevelContext>(0);
}

tree::TerminalNode *MySQLParser::TransactionCharacteristicsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

size_t MySQLParser::TransactionCharacteristicsContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionCharacteristics;
}

void MySQLParser::TransactionCharacteristicsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionCharacteristics(this);
}

void MySQLParser::TransactionCharacteristicsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionCharacteristics(this);
}

std::any MySQLParser::TransactionCharacteristicsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTransactionCharacteristics(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionCharacteristicsContext *MySQLParser::transactionCharacteristics() {
  TransactionCharacteristicsContext *_localctx =
    _tracker.createInstance<TransactionCharacteristicsContext>(_ctx, getState());
  enterRule(_localctx, 674, MySQLParser::RuleTransactionCharacteristics);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5334);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5325);
        transactionAccessMode();
        setState(5327);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ISOLATION_SYMBOL) {
          setState(5326);
          isolationLevel();
        }
        break;
      }

      case MySQLParser::ISOLATION_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5329);
        isolationLevel();
        setState(5332);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(5330);
          match(MySQLParser::COMMA_SYMBOL);
          setState(5331);
          transactionAccessMode();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionAccessModeContext ------------------------------------------------------------------

MySQLParser::TransactionAccessModeContext::TransactionAccessModeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TransactionAccessModeContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionAccessModeContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TransactionAccessModeContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

size_t MySQLParser::TransactionAccessModeContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionAccessMode;
}

void MySQLParser::TransactionAccessModeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionAccessMode(this);
}

void MySQLParser::TransactionAccessModeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionAccessMode(this);
}

std::any MySQLParser::TransactionAccessModeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTransactionAccessMode(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TransactionAccessModeContext *MySQLParser::transactionAccessMode() {
  TransactionAccessModeContext *_localctx = _tracker.createInstance<TransactionAccessModeContext>(_ctx, getState());
  enterRule(_localctx, 676, MySQLParser::RuleTransactionAccessMode);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5336);
    match(MySQLParser::READ_SYMBOL);
    setState(5337);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelContext ------------------------------------------------------------------

MySQLParser::IsolationLevelContext::IsolationLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IsolationLevelContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

size_t MySQLParser::IsolationLevelContext::getRuleIndex() const {
  return MySQLParser::RuleIsolationLevel;
}

void MySQLParser::IsolationLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevel(this);
}

void MySQLParser::IsolationLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevel(this);
}

std::any MySQLParser::IsolationLevelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIsolationLevel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IsolationLevelContext *MySQLParser::isolationLevel() {
  IsolationLevelContext *_localctx = _tracker.createInstance<IsolationLevelContext>(_ctx, getState());
  enterRule(_localctx, 678, MySQLParser::RuleIsolationLevel);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5339);
    match(MySQLParser::ISOLATION_SYMBOL);
    setState(5340);
    match(MySQLParser::LEVEL_SYMBOL);
    setState(5346);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPEATABLE_SYMBOL: {
        setState(5341);
        match(MySQLParser::REPEATABLE_SYMBOL);
        setState(5342);
        match(MySQLParser::READ_SYMBOL);
        break;
      }

      case MySQLParser::READ_SYMBOL: {
        setState(5343);
        match(MySQLParser::READ_SYMBOL);
        setState(5344);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::COMMITTED_SYMBOL || _la == MySQLParser::UNCOMMITTED_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::SERIALIZABLE_SYMBOL: {
        setState(5345);
        match(MySQLParser::SERIALIZABLE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueListContinuedContext ------------------------------------------------------------------

MySQLParser::OptionValueListContinuedContext::OptionValueListContinuedContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::OptionValueListContinuedContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::OptionValueListContinuedContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

std::vector<MySQLParser::OptionValueContext *> MySQLParser::OptionValueListContinuedContext::optionValue() {
  return getRuleContexts<MySQLParser::OptionValueContext>();
}

MySQLParser::OptionValueContext *MySQLParser::OptionValueListContinuedContext::optionValue(size_t i) {
  return getRuleContext<MySQLParser::OptionValueContext>(i);
}

size_t MySQLParser::OptionValueListContinuedContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueListContinued;
}

void MySQLParser::OptionValueListContinuedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueListContinued(this);
}

void MySQLParser::OptionValueListContinuedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueListContinued(this);
}

std::any MySQLParser::OptionValueListContinuedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOptionValueListContinued(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueListContinuedContext *MySQLParser::optionValueListContinued() {
  OptionValueListContinuedContext *_localctx =
    _tracker.createInstance<OptionValueListContinuedContext>(_ctx, getState());
  enterRule(_localctx, 680, MySQLParser::RuleOptionValueListContinued);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5352);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5348);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5349);
      optionValue();
      setState(5354);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueNoOptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionValueNoOptionTypeContext::OptionValueNoOptionTypeContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LvalueVariableContext *MySQLParser::OptionValueNoOptionTypeContext::lvalueVariable() {
  return getRuleContext<MySQLParser::LvalueVariableContext>(0);
}

MySQLParser::EqualContext *MySQLParser::OptionValueNoOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext *MySQLParser::OptionValueNoOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::CharsetClauseContext *MySQLParser::OptionValueNoOptionTypeContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::UserVariableContext *MySQLParser::OptionValueNoOptionTypeContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExprContext *MySQLParser::OptionValueNoOptionTypeContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::OptionValueNoOptionTypeContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::SetVarIdentTypeContext *MySQLParser::OptionValueNoOptionTypeContext::setVarIdentType() {
  return getRuleContext<MySQLParser::SetVarIdentTypeContext>(0);
}

tree::TerminalNode *MySQLParser::OptionValueNoOptionTypeContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

MySQLParser::CharsetNameContext *MySQLParser::OptionValueNoOptionTypeContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode *MySQLParser::OptionValueNoOptionTypeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::CollateContext *MySQLParser::OptionValueNoOptionTypeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

size_t MySQLParser::OptionValueNoOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueNoOptionType;
}

void MySQLParser::OptionValueNoOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueNoOptionType(this);
}

void MySQLParser::OptionValueNoOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueNoOptionType(this);
}

std::any MySQLParser::OptionValueNoOptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOptionValueNoOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueNoOptionTypeContext *MySQLParser::optionValueNoOptionType() {
  OptionValueNoOptionTypeContext *_localctx = _tracker.createInstance<OptionValueNoOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 682, MySQLParser::RuleOptionValueNoOptionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5384);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 619, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5355);
        lvalueVariable();
        setState(5356);
        equal();
        setState(5357);
        setExprOrDefault();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5359);
        charsetClause();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5360);
        userVariable();
        setState(5361);
        equal();
        setState(5362);
        expr(0);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5364);
        match(MySQLParser::AT_AT_SIGN_SYMBOL);
        setState(5366);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 616, _ctx)) {
          case 1: {
            setState(5365);
            setVarIdentType();
            break;
          }

          default:
            break;
        }
        setState(5368);
        lvalueVariable();
        setState(5369);
        equal();
        setState(5370);
        setExprOrDefault();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(5372);
        match(MySQLParser::NAMES_SYMBOL);
        setState(5382);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 618, _ctx)) {
          case 1: {
            setState(5373);
            equal();
            setState(5374);
            expr(0);
            break;
          }

          case 2: {
            setState(5376);
            charsetName();
            setState(5378);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::COLLATE_SYMBOL) {
              setState(5377);
              collate();
            }
            break;
          }

          case 3: {
            setState(5380);

            if (!(serverVersion >= 80011))
              throw FailedPredicateException(this, "serverVersion >= 80011");
            setState(5381);
            match(MySQLParser::DEFAULT_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueContext ------------------------------------------------------------------

MySQLParser::OptionValueContext::OptionValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OptionTypeContext *MySQLParser::OptionValueContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::LvalueVariableContext *MySQLParser::OptionValueContext::lvalueVariable() {
  return getRuleContext<MySQLParser::LvalueVariableContext>(0);
}

MySQLParser::EqualContext *MySQLParser::OptionValueContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext *MySQLParser::OptionValueContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::OptionValueNoOptionTypeContext *MySQLParser::OptionValueContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}

size_t MySQLParser::OptionValueContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValue;
}

void MySQLParser::OptionValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValue(this);
}

void MySQLParser::OptionValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValue(this);
}

std::any MySQLParser::OptionValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOptionValue(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueContext *MySQLParser::optionValue() {
  OptionValueContext *_localctx = _tracker.createInstance<OptionValueContext>(_ctx, getState());
  enterRule(_localctx, 684, MySQLParser::RuleOptionValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5392);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 620, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5386);
        optionType();
        setState(5387);
        lvalueVariable();
        setState(5388);
        equal();
        setState(5389);
        setExprOrDefault();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5391);
        optionValueNoOptionType();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetSystemVariableContext ------------------------------------------------------------------

MySQLParser::SetSystemVariableContext::SetSystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SetSystemVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::LvalueVariableContext *MySQLParser::SetSystemVariableContext::lvalueVariable() {
  return getRuleContext<MySQLParser::LvalueVariableContext>(0);
}

MySQLParser::SetVarIdentTypeContext *MySQLParser::SetSystemVariableContext::setVarIdentType() {
  return getRuleContext<MySQLParser::SetVarIdentTypeContext>(0);
}

size_t MySQLParser::SetSystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleSetSystemVariable;
}

void MySQLParser::SetSystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetSystemVariable(this);
}

void MySQLParser::SetSystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetSystemVariable(this);
}

std::any MySQLParser::SetSystemVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetSystemVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetSystemVariableContext *MySQLParser::setSystemVariable() {
  SetSystemVariableContext *_localctx = _tracker.createInstance<SetSystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 686, MySQLParser::RuleSetSystemVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5394);
    match(MySQLParser::AT_AT_SIGN_SYMBOL);
    setState(5396);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 621, _ctx)) {
      case 1: {
        setState(5395);
        setVarIdentType();
        break;
      }

      default:
        break;
    }
    setState(5398);
    lvalueVariable();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StartOptionValueListFollowingOptionTypeContext
//------------------------------------------------------------------

MySQLParser::StartOptionValueListFollowingOptionTypeContext::StartOptionValueListFollowingOptionTypeContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OptionValueFollowingOptionTypeContext *
MySQLParser::StartOptionValueListFollowingOptionTypeContext::optionValueFollowingOptionType() {
  return getRuleContext<MySQLParser::OptionValueFollowingOptionTypeContext>(0);
}

MySQLParser::OptionValueListContinuedContext *
MySQLParser::StartOptionValueListFollowingOptionTypeContext::optionValueListContinued() {
  return getRuleContext<MySQLParser::OptionValueListContinuedContext>(0);
}

tree::TerminalNode *MySQLParser::StartOptionValueListFollowingOptionTypeContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

MySQLParser::TransactionCharacteristicsContext *
MySQLParser::StartOptionValueListFollowingOptionTypeContext::transactionCharacteristics() {
  return getRuleContext<MySQLParser::TransactionCharacteristicsContext>(0);
}

size_t MySQLParser::StartOptionValueListFollowingOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleStartOptionValueListFollowingOptionType;
}

void MySQLParser::StartOptionValueListFollowingOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStartOptionValueListFollowingOptionType(this);
}

void MySQLParser::StartOptionValueListFollowingOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStartOptionValueListFollowingOptionType(this);
}

std::any MySQLParser::StartOptionValueListFollowingOptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStartOptionValueListFollowingOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StartOptionValueListFollowingOptionTypeContext *MySQLParser::startOptionValueListFollowingOptionType() {
  StartOptionValueListFollowingOptionTypeContext *_localctx =
    _tracker.createInstance<StartOptionValueListFollowingOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 688, MySQLParser::RuleStartOptionValueListFollowingOptionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5405);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 622, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5400);
        optionValueFollowingOptionType();
        setState(5401);
        optionValueListContinued();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5403);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(5404);
        transactionCharacteristics();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueFollowingOptionTypeContext
//------------------------------------------------------------------

MySQLParser::OptionValueFollowingOptionTypeContext::OptionValueFollowingOptionTypeContext(ParserRuleContext *parent,
                                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LvalueVariableContext *MySQLParser::OptionValueFollowingOptionTypeContext::lvalueVariable() {
  return getRuleContext<MySQLParser::LvalueVariableContext>(0);
}

MySQLParser::EqualContext *MySQLParser::OptionValueFollowingOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext *MySQLParser::OptionValueFollowingOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

size_t MySQLParser::OptionValueFollowingOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueFollowingOptionType;
}

void MySQLParser::OptionValueFollowingOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueFollowingOptionType(this);
}

void MySQLParser::OptionValueFollowingOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueFollowingOptionType(this);
}

std::any MySQLParser::OptionValueFollowingOptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOptionValueFollowingOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionValueFollowingOptionTypeContext *MySQLParser::optionValueFollowingOptionType() {
  OptionValueFollowingOptionTypeContext *_localctx =
    _tracker.createInstance<OptionValueFollowingOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 690, MySQLParser::RuleOptionValueFollowingOptionType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5407);
    lvalueVariable();
    setState(5408);
    equal();
    setState(5409);
    setExprOrDefault();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetExprOrDefaultContext ------------------------------------------------------------------

MySQLParser::SetExprOrDefaultContext::SetExprOrDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::SetExprOrDefaultContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetExprOrDefaultContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

size_t MySQLParser::SetExprOrDefaultContext::getRuleIndex() const {
  return MySQLParser::RuleSetExprOrDefault;
}

void MySQLParser::SetExprOrDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetExprOrDefault(this);
}

void MySQLParser::SetExprOrDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetExprOrDefault(this);
}

std::any MySQLParser::SetExprOrDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetExprOrDefault(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetExprOrDefaultContext *MySQLParser::setExprOrDefault() {
  SetExprOrDefaultContext *_localctx = _tracker.createInstance<SetExprOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 692, MySQLParser::RuleSetExprOrDefault);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5418);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 623, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5411);
        expr(0);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5412);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(5413);
        match(MySQLParser::ON_SYMBOL);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(5414);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(5415);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(5416);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(5417);
        match(MySQLParser::SYSTEM_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowDatabasesStatementContext ------------------------------------------------------------------

MySQLParser::ShowDatabasesStatementContext::ShowDatabasesStatementContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowDatabasesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowDatabasesStatementContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowDatabasesStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowDatabasesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowDatabasesStatement;
}

void MySQLParser::ShowDatabasesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowDatabasesStatement(this);
}

void MySQLParser::ShowDatabasesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowDatabasesStatement(this);
}

std::any MySQLParser::ShowDatabasesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowDatabasesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowDatabasesStatementContext *MySQLParser::showDatabasesStatement() {
  ShowDatabasesStatementContext *_localctx = _tracker.createInstance<ShowDatabasesStatementContext>(_ctx, getState());
  enterRule(_localctx, 694, MySQLParser::RuleShowDatabasesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5420);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5421);
    match(MySQLParser::DATABASES_SYMBOL);
    setState(5423);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5422);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTablesStatementContext ------------------------------------------------------------------

MySQLParser::ShowTablesStatementContext::ShowTablesStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowTablesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowTablesStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

MySQLParser::ShowCommandTypeContext *MySQLParser::ShowTablesStatementContext::showCommandType() {
  return getRuleContext<MySQLParser::ShowCommandTypeContext>(0);
}

MySQLParser::InDbContext *MySQLParser::ShowTablesStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowTablesStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowTablesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowTablesStatement;
}

void MySQLParser::ShowTablesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTablesStatement(this);
}

void MySQLParser::ShowTablesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTablesStatement(this);
}

std::any MySQLParser::ShowTablesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowTablesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowTablesStatementContext *MySQLParser::showTablesStatement() {
  ShowTablesStatementContext *_localctx = _tracker.createInstance<ShowTablesStatementContext>(_ctx, getState());
  enterRule(_localctx, 696, MySQLParser::RuleShowTablesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5425);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5427);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXTENDED_SYMBOL

        || _la == MySQLParser::FULL_SYMBOL) {
      setState(5426);
      showCommandType();
    }
    setState(5429);
    antlrcpp::downCast<ShowTablesStatementContext *>(_localctx)->value = match(MySQLParser::TABLES_SYMBOL);
    setState(5431);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5430);
      inDb();
    }
    setState(5434);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5433);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTriggersStatementContext ------------------------------------------------------------------

MySQLParser::ShowTriggersStatementContext::ShowTriggersStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowTriggersStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowTriggersStatementContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowTriggersStatementContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

MySQLParser::InDbContext *MySQLParser::ShowTriggersStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowTriggersStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowTriggersStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowTriggersStatement;
}

void MySQLParser::ShowTriggersStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTriggersStatement(this);
}

void MySQLParser::ShowTriggersStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTriggersStatement(this);
}

std::any MySQLParser::ShowTriggersStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowTriggersStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowTriggersStatementContext *MySQLParser::showTriggersStatement() {
  ShowTriggersStatementContext *_localctx = _tracker.createInstance<ShowTriggersStatementContext>(_ctx, getState());
  enterRule(_localctx, 698, MySQLParser::RuleShowTriggersStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5436);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5438);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FULL_SYMBOL) {
      setState(5437);
      match(MySQLParser::FULL_SYMBOL);
    }
    setState(5440);
    match(MySQLParser::TRIGGERS_SYMBOL);
    setState(5442);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5441);
      inDb();
    }
    setState(5445);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5444);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEventsStatementContext ------------------------------------------------------------------

MySQLParser::ShowEventsStatementContext::ShowEventsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowEventsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEventsStatementContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

MySQLParser::InDbContext *MySQLParser::ShowEventsStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowEventsStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowEventsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowEventsStatement;
}

void MySQLParser::ShowEventsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEventsStatement(this);
}

void MySQLParser::ShowEventsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEventsStatement(this);
}

std::any MySQLParser::ShowEventsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowEventsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowEventsStatementContext *MySQLParser::showEventsStatement() {
  ShowEventsStatementContext *_localctx = _tracker.createInstance<ShowEventsStatementContext>(_ctx, getState());
  enterRule(_localctx, 700, MySQLParser::RuleShowEventsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5447);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5448);
    match(MySQLParser::EVENTS_SYMBOL);
    setState(5450);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5449);
      inDb();
    }
    setState(5453);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5452);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowTableStatusStatementContext ------------------------------------------------------------------

MySQLParser::ShowTableStatusStatementContext::ShowTableStatusStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowTableStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowTableStatusStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowTableStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

MySQLParser::InDbContext *MySQLParser::ShowTableStatusStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowTableStatusStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowTableStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowTableStatusStatement;
}

void MySQLParser::ShowTableStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowTableStatusStatement(this);
}

void MySQLParser::ShowTableStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowTableStatusStatement(this);
}

std::any MySQLParser::ShowTableStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowTableStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowTableStatusStatementContext *MySQLParser::showTableStatusStatement() {
  ShowTableStatusStatementContext *_localctx =
    _tracker.createInstance<ShowTableStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 702, MySQLParser::RuleShowTableStatusStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5455);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5456);
    match(MySQLParser::TABLE_SYMBOL);
    setState(5457);
    match(MySQLParser::STATUS_SYMBOL);
    setState(5459);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5458);
      inDb();
    }
    setState(5462);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5461);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowOpenTablesStatementContext ------------------------------------------------------------------

MySQLParser::ShowOpenTablesStatementContext::ShowOpenTablesStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowOpenTablesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowOpenTablesStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowOpenTablesStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

MySQLParser::InDbContext *MySQLParser::ShowOpenTablesStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowOpenTablesStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowOpenTablesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowOpenTablesStatement;
}

void MySQLParser::ShowOpenTablesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowOpenTablesStatement(this);
}

void MySQLParser::ShowOpenTablesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowOpenTablesStatement(this);
}

std::any MySQLParser::ShowOpenTablesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowOpenTablesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowOpenTablesStatementContext *MySQLParser::showOpenTablesStatement() {
  ShowOpenTablesStatementContext *_localctx = _tracker.createInstance<ShowOpenTablesStatementContext>(_ctx, getState());
  enterRule(_localctx, 704, MySQLParser::RuleShowOpenTablesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5464);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5465);
    match(MySQLParser::OPEN_SYMBOL);
    setState(5466);
    match(MySQLParser::TABLES_SYMBOL);
    setState(5468);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5467);
      inDb();
    }
    setState(5471);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5470);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowPluginsStatementContext ------------------------------------------------------------------

MySQLParser::ShowPluginsStatementContext::ShowPluginsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowPluginsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowPluginsStatementContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

size_t MySQLParser::ShowPluginsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowPluginsStatement;
}

void MySQLParser::ShowPluginsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowPluginsStatement(this);
}

void MySQLParser::ShowPluginsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowPluginsStatement(this);
}

std::any MySQLParser::ShowPluginsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowPluginsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowPluginsStatementContext *MySQLParser::showPluginsStatement() {
  ShowPluginsStatementContext *_localctx = _tracker.createInstance<ShowPluginsStatementContext>(_ctx, getState());
  enterRule(_localctx, 706, MySQLParser::RuleShowPluginsStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5473);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5474);
    match(MySQLParser::PLUGINS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEngineLogsStatementContext ------------------------------------------------------------------

MySQLParser::ShowEngineLogsStatementContext::ShowEngineLogsStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowEngineLogsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEngineLogsStatementContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineOrAllContext *MySQLParser::ShowEngineLogsStatementContext::engineOrAll() {
  return getRuleContext<MySQLParser::EngineOrAllContext>(0);
}

tree::TerminalNode *MySQLParser::ShowEngineLogsStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

size_t MySQLParser::ShowEngineLogsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowEngineLogsStatement;
}

void MySQLParser::ShowEngineLogsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngineLogsStatement(this);
}

void MySQLParser::ShowEngineLogsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngineLogsStatement(this);
}

std::any MySQLParser::ShowEngineLogsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowEngineLogsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowEngineLogsStatementContext *MySQLParser::showEngineLogsStatement() {
  ShowEngineLogsStatementContext *_localctx = _tracker.createInstance<ShowEngineLogsStatementContext>(_ctx, getState());
  enterRule(_localctx, 708, MySQLParser::RuleShowEngineLogsStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5476);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5477);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(5478);
    engineOrAll();
    setState(5479);
    match(MySQLParser::LOGS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEngineMutexStatementContext ------------------------------------------------------------------

MySQLParser::ShowEngineMutexStatementContext::ShowEngineMutexStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowEngineMutexStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEngineMutexStatementContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineOrAllContext *MySQLParser::ShowEngineMutexStatementContext::engineOrAll() {
  return getRuleContext<MySQLParser::EngineOrAllContext>(0);
}

tree::TerminalNode *MySQLParser::ShowEngineMutexStatementContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

size_t MySQLParser::ShowEngineMutexStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowEngineMutexStatement;
}

void MySQLParser::ShowEngineMutexStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngineMutexStatement(this);
}

void MySQLParser::ShowEngineMutexStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngineMutexStatement(this);
}

std::any MySQLParser::ShowEngineMutexStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowEngineMutexStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowEngineMutexStatementContext *MySQLParser::showEngineMutexStatement() {
  ShowEngineMutexStatementContext *_localctx =
    _tracker.createInstance<ShowEngineMutexStatementContext>(_ctx, getState());
  enterRule(_localctx, 710, MySQLParser::RuleShowEngineMutexStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5481);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5482);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(5483);
    engineOrAll();
    setState(5484);
    match(MySQLParser::MUTEX_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEngineStatusStatementContext ------------------------------------------------------------------

MySQLParser::ShowEngineStatusStatementContext::ShowEngineStatusStatementContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowEngineStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEngineStatusStatementContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineOrAllContext *MySQLParser::ShowEngineStatusStatementContext::engineOrAll() {
  return getRuleContext<MySQLParser::EngineOrAllContext>(0);
}

tree::TerminalNode *MySQLParser::ShowEngineStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

size_t MySQLParser::ShowEngineStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowEngineStatusStatement;
}

void MySQLParser::ShowEngineStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEngineStatusStatement(this);
}

void MySQLParser::ShowEngineStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEngineStatusStatement(this);
}

std::any MySQLParser::ShowEngineStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowEngineStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowEngineStatusStatementContext *MySQLParser::showEngineStatusStatement() {
  ShowEngineStatusStatementContext *_localctx =
    _tracker.createInstance<ShowEngineStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 712, MySQLParser::RuleShowEngineStatusStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5486);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5487);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(5488);
    engineOrAll();
    setState(5489);
    match(MySQLParser::STATUS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowColumnsStatementContext ------------------------------------------------------------------

MySQLParser::ShowColumnsStatementContext::ShowColumnsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowColumnsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowColumnsStatementContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ShowColumnsStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::ShowColumnsStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowColumnsStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::ShowCommandTypeContext *MySQLParser::ShowColumnsStatementContext::showCommandType() {
  return getRuleContext<MySQLParser::ShowCommandTypeContext>(0);
}

MySQLParser::InDbContext *MySQLParser::ShowColumnsStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowColumnsStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowColumnsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowColumnsStatement;
}

void MySQLParser::ShowColumnsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowColumnsStatement(this);
}

void MySQLParser::ShowColumnsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowColumnsStatement(this);
}

std::any MySQLParser::ShowColumnsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowColumnsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowColumnsStatementContext *MySQLParser::showColumnsStatement() {
  ShowColumnsStatementContext *_localctx = _tracker.createInstance<ShowColumnsStatementContext>(_ctx, getState());
  enterRule(_localctx, 714, MySQLParser::RuleShowColumnsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5491);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5493);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXTENDED_SYMBOL

        || _la == MySQLParser::FULL_SYMBOL) {
      setState(5492);
      showCommandType();
    }
    setState(5495);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(5496);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FROM_SYMBOL

          || _la == MySQLParser::IN_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5497);
    tableRef();
    setState(5499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5498);
      inDb();
    }
    setState(5502);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5501);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowBinaryLogsStatementContext ------------------------------------------------------------------

MySQLParser::ShowBinaryLogsStatementContext::ShowBinaryLogsStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowBinaryLogsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinaryLogsStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinaryLogsStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinaryLogsStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

size_t MySQLParser::ShowBinaryLogsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowBinaryLogsStatement;
}

void MySQLParser::ShowBinaryLogsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowBinaryLogsStatement(this);
}

void MySQLParser::ShowBinaryLogsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowBinaryLogsStatement(this);
}

std::any MySQLParser::ShowBinaryLogsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowBinaryLogsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowBinaryLogsStatementContext *MySQLParser::showBinaryLogsStatement() {
  ShowBinaryLogsStatementContext *_localctx = _tracker.createInstance<ShowBinaryLogsStatementContext>(_ctx, getState());
  enterRule(_localctx, 716, MySQLParser::RuleShowBinaryLogsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5504);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5505);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BINARY_SYMBOL || _la == MySQLParser::MASTER_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5506);
    antlrcpp::downCast<ShowBinaryLogsStatementContext *>(_localctx)->value = match(MySQLParser::LOGS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowReplicasStatementContext ------------------------------------------------------------------

MySQLParser::ShowReplicasStatementContext::ShowReplicasStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowReplicasStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::ShowReplicasStatementContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

tree::TerminalNode *MySQLParser::ShowReplicasStatementContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowReplicasStatementContext::REPLICAS_SYMBOL() {
  return getToken(MySQLParser::REPLICAS_SYMBOL, 0);
}

size_t MySQLParser::ShowReplicasStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowReplicasStatement;
}

void MySQLParser::ShowReplicasStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowReplicasStatement(this);
}

void MySQLParser::ShowReplicasStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowReplicasStatement(this);
}

std::any MySQLParser::ShowReplicasStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowReplicasStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowReplicasStatementContext *MySQLParser::showReplicasStatement() {
  ShowReplicasStatementContext *_localctx = _tracker.createInstance<ShowReplicasStatementContext>(_ctx, getState());
  enterRule(_localctx, 718, MySQLParser::RuleShowReplicasStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5508);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5513);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SLAVE_SYMBOL:
      case MySQLParser::REPLICA_SYMBOL: {
        setState(5509);
        replica();
        setState(5510);
        match(MySQLParser::HOSTS_SYMBOL);
        break;
      }

      case MySQLParser::REPLICAS_SYMBOL: {
        setState(5512);
        match(MySQLParser::REPLICAS_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowBinlogEventsStatementContext ------------------------------------------------------------------

MySQLParser::ShowBinlogEventsStatementContext::ShowBinlogEventsStatementContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowBinlogEventsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinlogEventsStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinlogEventsStatementContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowBinlogEventsStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::ShowBinlogEventsStatementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::ShowBinlogEventsStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::ShowBinlogEventsStatementContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

MySQLParser::LimitClauseContext *MySQLParser::ShowBinlogEventsStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

MySQLParser::ChannelContext *MySQLParser::ShowBinlogEventsStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ShowBinlogEventsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowBinlogEventsStatement;
}

void MySQLParser::ShowBinlogEventsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowBinlogEventsStatement(this);
}

void MySQLParser::ShowBinlogEventsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowBinlogEventsStatement(this);
}

std::any MySQLParser::ShowBinlogEventsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowBinlogEventsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowBinlogEventsStatementContext *MySQLParser::showBinlogEventsStatement() {
  ShowBinlogEventsStatementContext *_localctx =
    _tracker.createInstance<ShowBinlogEventsStatementContext>(_ctx, getState());
  enterRule(_localctx, 720, MySQLParser::RuleShowBinlogEventsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5515);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5516);
    match(MySQLParser::BINLOG_SYMBOL);
    setState(5517);
    match(MySQLParser::EVENTS_SYMBOL);
    setState(5520);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IN_SYMBOL) {
      setState(5518);
      match(MySQLParser::IN_SYMBOL);
      setState(5519);
      textString();
    }
    setState(5524);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL) {
      setState(5522);
      match(MySQLParser::FROM_SYMBOL);
      setState(5523);
      ulonglong_number();
    }
    setState(5527);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(5526);
      limitClause();
    }
    setState(5530);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5529);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowRelaylogEventsStatementContext
//------------------------------------------------------------------

MySQLParser::ShowRelaylogEventsStatementContext::ShowRelaylogEventsStatementContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowRelaylogEventsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowRelaylogEventsStatementContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowRelaylogEventsStatementContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowRelaylogEventsStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::ShowRelaylogEventsStatementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::ShowRelaylogEventsStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::ShowRelaylogEventsStatementContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

MySQLParser::LimitClauseContext *MySQLParser::ShowRelaylogEventsStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

MySQLParser::ChannelContext *MySQLParser::ShowRelaylogEventsStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ShowRelaylogEventsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowRelaylogEventsStatement;
}

void MySQLParser::ShowRelaylogEventsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowRelaylogEventsStatement(this);
}

void MySQLParser::ShowRelaylogEventsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowRelaylogEventsStatement(this);
}

std::any MySQLParser::ShowRelaylogEventsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowRelaylogEventsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowRelaylogEventsStatementContext *MySQLParser::showRelaylogEventsStatement() {
  ShowRelaylogEventsStatementContext *_localctx =
    _tracker.createInstance<ShowRelaylogEventsStatementContext>(_ctx, getState());
  enterRule(_localctx, 722, MySQLParser::RuleShowRelaylogEventsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5532);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5533);
    match(MySQLParser::RELAYLOG_SYMBOL);
    setState(5534);
    match(MySQLParser::EVENTS_SYMBOL);
    setState(5537);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IN_SYMBOL) {
      setState(5535);
      match(MySQLParser::IN_SYMBOL);
      setState(5536);
      textString();
    }
    setState(5541);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL) {
      setState(5539);
      match(MySQLParser::FROM_SYMBOL);
      setState(5540);
      ulonglong_number();
    }
    setState(5544);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(5543);
      limitClause();
    }
    setState(5547);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5546);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowKeysStatementContext ------------------------------------------------------------------

MySQLParser::ShowKeysStatementContext::ShowKeysStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowKeysStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

MySQLParser::FromOrInContext *MySQLParser::ShowKeysStatementContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

MySQLParser::TableRefContext *MySQLParser::ShowKeysStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::ShowKeysStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowKeysStatementContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowKeysStatementContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowKeysStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

MySQLParser::InDbContext *MySQLParser::ShowKeysStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

MySQLParser::WhereClauseContext *MySQLParser::ShowKeysStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

size_t MySQLParser::ShowKeysStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowKeysStatement;
}

void MySQLParser::ShowKeysStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowKeysStatement(this);
}

void MySQLParser::ShowKeysStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowKeysStatement(this);
}

std::any MySQLParser::ShowKeysStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowKeysStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowKeysStatementContext *MySQLParser::showKeysStatement() {
  ShowKeysStatementContext *_localctx = _tracker.createInstance<ShowKeysStatementContext>(_ctx, getState());
  enterRule(_localctx, 724, MySQLParser::RuleShowKeysStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5549);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5551);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXTENDED_SYMBOL) {
      setState(5550);
      match(MySQLParser::EXTENDED_SYMBOL);
    }
    setState(5553);
    _la = _input->LA(1);
    if (!(((((_la - 235) & ~0x3fULL) == 0) && ((1ULL << (_la - 235)) & 268435459) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5554);
    fromOrIn();
    setState(5555);
    tableRef();
    setState(5557);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FROM_SYMBOL

        || _la == MySQLParser::IN_SYMBOL) {
      setState(5556);
      inDb();
    }
    setState(5560);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WHERE_SYMBOL) {
      setState(5559);
      whereClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowEnginesStatementContext ------------------------------------------------------------------

MySQLParser::ShowEnginesStatementContext::ShowEnginesStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowEnginesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEnginesStatementContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowEnginesStatementContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

size_t MySQLParser::ShowEnginesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowEnginesStatement;
}

void MySQLParser::ShowEnginesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowEnginesStatement(this);
}

void MySQLParser::ShowEnginesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowEnginesStatement(this);
}

std::any MySQLParser::ShowEnginesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowEnginesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowEnginesStatementContext *MySQLParser::showEnginesStatement() {
  ShowEnginesStatementContext *_localctx = _tracker.createInstance<ShowEnginesStatementContext>(_ctx, getState());
  enterRule(_localctx, 726, MySQLParser::RuleShowEnginesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5562);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5564);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::STORAGE_SYMBOL) {
      setState(5563);
      match(MySQLParser::STORAGE_SYMBOL);
    }
    setState(5566);
    antlrcpp::downCast<ShowEnginesStatementContext *>(_localctx)->value = match(MySQLParser::ENGINES_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCountWarningsStatementContext ------------------------------------------------------------------

MySQLParser::ShowCountWarningsStatementContext::ShowCountWarningsStatementContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountWarningsStatementContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

size_t MySQLParser::ShowCountWarningsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCountWarningsStatement;
}

void MySQLParser::ShowCountWarningsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCountWarningsStatement(this);
}

void MySQLParser::ShowCountWarningsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCountWarningsStatement(this);
}

std::any MySQLParser::ShowCountWarningsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCountWarningsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCountWarningsStatementContext *MySQLParser::showCountWarningsStatement() {
  ShowCountWarningsStatementContext *_localctx =
    _tracker.createInstance<ShowCountWarningsStatementContext>(_ctx, getState());
  enterRule(_localctx, 728, MySQLParser::RuleShowCountWarningsStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5568);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5569);
    match(MySQLParser::COUNT_SYMBOL);
    setState(5570);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5571);
    match(MySQLParser::MULT_OPERATOR);
    setState(5572);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(5573);
    match(MySQLParser::WARNINGS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCountErrorsStatementContext ------------------------------------------------------------------

MySQLParser::ShowCountErrorsStatementContext::ShowCountErrorsStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCountErrorsStatementContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

size_t MySQLParser::ShowCountErrorsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCountErrorsStatement;
}

void MySQLParser::ShowCountErrorsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCountErrorsStatement(this);
}

void MySQLParser::ShowCountErrorsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCountErrorsStatement(this);
}

std::any MySQLParser::ShowCountErrorsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCountErrorsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCountErrorsStatementContext *MySQLParser::showCountErrorsStatement() {
  ShowCountErrorsStatementContext *_localctx =
    _tracker.createInstance<ShowCountErrorsStatementContext>(_ctx, getState());
  enterRule(_localctx, 730, MySQLParser::RuleShowCountErrorsStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5575);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5576);
    match(MySQLParser::COUNT_SYMBOL);
    setState(5577);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5578);
    match(MySQLParser::MULT_OPERATOR);
    setState(5579);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(5580);
    match(MySQLParser::ERRORS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowWarningsStatementContext ------------------------------------------------------------------

MySQLParser::ShowWarningsStatementContext::ShowWarningsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowWarningsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowWarningsStatementContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

MySQLParser::LimitClauseContext *MySQLParser::ShowWarningsStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

size_t MySQLParser::ShowWarningsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowWarningsStatement;
}

void MySQLParser::ShowWarningsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowWarningsStatement(this);
}

void MySQLParser::ShowWarningsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowWarningsStatement(this);
}

std::any MySQLParser::ShowWarningsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowWarningsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowWarningsStatementContext *MySQLParser::showWarningsStatement() {
  ShowWarningsStatementContext *_localctx = _tracker.createInstance<ShowWarningsStatementContext>(_ctx, getState());
  enterRule(_localctx, 732, MySQLParser::RuleShowWarningsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5582);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5583);
    match(MySQLParser::WARNINGS_SYMBOL);
    setState(5585);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(5584);
      limitClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowErrorsStatementContext ------------------------------------------------------------------

MySQLParser::ShowErrorsStatementContext::ShowErrorsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowErrorsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowErrorsStatementContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

MySQLParser::LimitClauseContext *MySQLParser::ShowErrorsStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

size_t MySQLParser::ShowErrorsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowErrorsStatement;
}

void MySQLParser::ShowErrorsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowErrorsStatement(this);
}

void MySQLParser::ShowErrorsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowErrorsStatement(this);
}

std::any MySQLParser::ShowErrorsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowErrorsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowErrorsStatementContext *MySQLParser::showErrorsStatement() {
  ShowErrorsStatementContext *_localctx = _tracker.createInstance<ShowErrorsStatementContext>(_ctx, getState());
  enterRule(_localctx, 734, MySQLParser::RuleShowErrorsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5587);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5588);
    match(MySQLParser::ERRORS_SYMBOL);
    setState(5590);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(5589);
      limitClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfilesStatementContext ------------------------------------------------------------------

MySQLParser::ShowProfilesStatementContext::ShowProfilesStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowProfilesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProfilesStatementContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

size_t MySQLParser::ShowProfilesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowProfilesStatement;
}

void MySQLParser::ShowProfilesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfilesStatement(this);
}

void MySQLParser::ShowProfilesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfilesStatement(this);
}

std::any MySQLParser::ShowProfilesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowProfilesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowProfilesStatementContext *MySQLParser::showProfilesStatement() {
  ShowProfilesStatementContext *_localctx = _tracker.createInstance<ShowProfilesStatementContext>(_ctx, getState());
  enterRule(_localctx, 736, MySQLParser::RuleShowProfilesStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5592);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5593);
    match(MySQLParser::PROFILES_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProfileStatementContext ------------------------------------------------------------------

MySQLParser::ShowProfileStatementContext::ShowProfileStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowProfileStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProfileStatementContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

MySQLParser::ProfileDefinitionsContext *MySQLParser::ShowProfileStatementContext::profileDefinitions() {
  return getRuleContext<MySQLParser::ProfileDefinitionsContext>(0);
}

tree::TerminalNode *MySQLParser::ShowProfileStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProfileStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProfileStatementContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::LimitClauseContext *MySQLParser::ShowProfileStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

size_t MySQLParser::ShowProfileStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowProfileStatement;
}

void MySQLParser::ShowProfileStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProfileStatement(this);
}

void MySQLParser::ShowProfileStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProfileStatement(this);
}

std::any MySQLParser::ShowProfileStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowProfileStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowProfileStatementContext *MySQLParser::showProfileStatement() {
  ShowProfileStatementContext *_localctx = _tracker.createInstance<ShowProfileStatementContext>(_ctx, getState());
  enterRule(_localctx, 738, MySQLParser::RuleShowProfileStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5595);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5596);
    match(MySQLParser::PROFILE_SYMBOL);
    setState(5598);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALL_SYMBOL

        || _la == MySQLParser::BLOCK_SYMBOL || _la == MySQLParser::CONTEXT_SYMBOL

        || _la == MySQLParser::CPU_SYMBOL || _la == MySQLParser::IPC_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL ||
        _la == MySQLParser::PAGE_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

        || _la == MySQLParser::SWAPS_SYMBOL) {
      setState(5597);
      profileDefinitions();
    }
    setState(5603);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5600);
      match(MySQLParser::FOR_SYMBOL);
      setState(5601);
      match(MySQLParser::QUERY_SYMBOL);
      setState(5602);
      match(MySQLParser::INT_NUMBER);
    }
    setState(5606);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(5605);
      limitClause();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStatusStatementContext ------------------------------------------------------------------

MySQLParser::ShowStatusStatementContext::ShowStatusStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

MySQLParser::OptionTypeContext *MySQLParser::ShowStatusStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowStatusStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowStatusStatement;
}

void MySQLParser::ShowStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowStatusStatement(this);
}

void MySQLParser::ShowStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowStatusStatement(this);
}

std::any MySQLParser::ShowStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowStatusStatementContext *MySQLParser::showStatusStatement() {
  ShowStatusStatementContext *_localctx = _tracker.createInstance<ShowStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 740, MySQLParser::RuleShowStatusStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5608);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5610);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL ||
        _la == MySQLParser::PERSIST_SYMBOL

        || _la == MySQLParser::PERSIST_ONLY_SYMBOL) {
      setState(5609);
      optionType();
    }
    setState(5612);
    match(MySQLParser::STATUS_SYMBOL);
    setState(5614);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5613);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowProcessListStatementContext ------------------------------------------------------------------

MySQLParser::ShowProcessListStatementContext::ShowProcessListStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowProcessListStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProcessListStatementContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowProcessListStatementContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

size_t MySQLParser::ShowProcessListStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowProcessListStatement;
}

void MySQLParser::ShowProcessListStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowProcessListStatement(this);
}

void MySQLParser::ShowProcessListStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowProcessListStatement(this);
}

std::any MySQLParser::ShowProcessListStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowProcessListStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowProcessListStatementContext *MySQLParser::showProcessListStatement() {
  ShowProcessListStatementContext *_localctx =
    _tracker.createInstance<ShowProcessListStatementContext>(_ctx, getState());
  enterRule(_localctx, 742, MySQLParser::RuleShowProcessListStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5616);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5618);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FULL_SYMBOL) {
      setState(5617);
      match(MySQLParser::FULL_SYMBOL);
    }
    setState(5620);
    match(MySQLParser::PROCESSLIST_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowVariablesStatementContext ------------------------------------------------------------------

MySQLParser::ShowVariablesStatementContext::ShowVariablesStatementContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowVariablesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowVariablesStatementContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

MySQLParser::OptionTypeContext *MySQLParser::ShowVariablesStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowVariablesStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowVariablesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowVariablesStatement;
}

void MySQLParser::ShowVariablesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowVariablesStatement(this);
}

void MySQLParser::ShowVariablesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowVariablesStatement(this);
}

std::any MySQLParser::ShowVariablesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowVariablesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowVariablesStatementContext *MySQLParser::showVariablesStatement() {
  ShowVariablesStatementContext *_localctx = _tracker.createInstance<ShowVariablesStatementContext>(_ctx, getState());
  enterRule(_localctx, 744, MySQLParser::RuleShowVariablesStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5622);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5624);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL ||
        _la == MySQLParser::PERSIST_SYMBOL

        || _la == MySQLParser::PERSIST_ONLY_SYMBOL) {
      setState(5623);
      optionType();
    }
    setState(5626);
    match(MySQLParser::VARIABLES_SYMBOL);
    setState(5628);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5627);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCharacterSetStatementContext ------------------------------------------------------------------

MySQLParser::ShowCharacterSetStatementContext::ShowCharacterSetStatementContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCharacterSetStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

MySQLParser::CharsetContext *MySQLParser::ShowCharacterSetStatementContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowCharacterSetStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowCharacterSetStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCharacterSetStatement;
}

void MySQLParser::ShowCharacterSetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCharacterSetStatement(this);
}

void MySQLParser::ShowCharacterSetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCharacterSetStatement(this);
}

std::any MySQLParser::ShowCharacterSetStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCharacterSetStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCharacterSetStatementContext *MySQLParser::showCharacterSetStatement() {
  ShowCharacterSetStatementContext *_localctx =
    _tracker.createInstance<ShowCharacterSetStatementContext>(_ctx, getState());
  enterRule(_localctx, 746, MySQLParser::RuleShowCharacterSetStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5630);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5631);
    charset();
    setState(5633);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5632);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCollationStatementContext ------------------------------------------------------------------

MySQLParser::ShowCollationStatementContext::ShowCollationStatementContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCollationStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCollationStatementContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowCollationStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowCollationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCollationStatement;
}

void MySQLParser::ShowCollationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCollationStatement(this);
}

void MySQLParser::ShowCollationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCollationStatement(this);
}

std::any MySQLParser::ShowCollationStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCollationStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCollationStatementContext *MySQLParser::showCollationStatement() {
  ShowCollationStatementContext *_localctx = _tracker.createInstance<ShowCollationStatementContext>(_ctx, getState());
  enterRule(_localctx, 748, MySQLParser::RuleShowCollationStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5635);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5636);
    match(MySQLParser::COLLATION_SYMBOL);
    setState(5638);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5637);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowPrivilegesStatementContext ------------------------------------------------------------------

MySQLParser::ShowPrivilegesStatementContext::ShowPrivilegesStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowPrivilegesStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowPrivilegesStatementContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

size_t MySQLParser::ShowPrivilegesStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowPrivilegesStatement;
}

void MySQLParser::ShowPrivilegesStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowPrivilegesStatement(this);
}

void MySQLParser::ShowPrivilegesStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowPrivilegesStatement(this);
}

std::any MySQLParser::ShowPrivilegesStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowPrivilegesStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowPrivilegesStatementContext *MySQLParser::showPrivilegesStatement() {
  ShowPrivilegesStatementContext *_localctx = _tracker.createInstance<ShowPrivilegesStatementContext>(_ctx, getState());
  enterRule(_localctx, 750, MySQLParser::RuleShowPrivilegesStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5640);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5641);
    match(MySQLParser::PRIVILEGES_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowGrantsStatementContext ------------------------------------------------------------------

MySQLParser::ShowGrantsStatementContext::ShowGrantsStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowGrantsStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowGrantsStatementContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowGrantsStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::ShowGrantsStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode *MySQLParser::ShowGrantsStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::UserListContext *MySQLParser::ShowGrantsStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

size_t MySQLParser::ShowGrantsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowGrantsStatement;
}

void MySQLParser::ShowGrantsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowGrantsStatement(this);
}

void MySQLParser::ShowGrantsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowGrantsStatement(this);
}

std::any MySQLParser::ShowGrantsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowGrantsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowGrantsStatementContext *MySQLParser::showGrantsStatement() {
  ShowGrantsStatementContext *_localctx = _tracker.createInstance<ShowGrantsStatementContext>(_ctx, getState());
  enterRule(_localctx, 752, MySQLParser::RuleShowGrantsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5643);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5644);
    match(MySQLParser::GRANTS_SYMBOL);
    setState(5651);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5645);
      match(MySQLParser::FOR_SYMBOL);
      setState(5646);
      user();
      setState(5649);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::USING_SYMBOL) {
        setState(5647);
        match(MySQLParser::USING_SYMBOL);
        setState(5648);
        userList();
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateDatabaseStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateDatabaseStatementContext::ShowCreateDatabaseStatementContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateDatabaseStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateDatabaseStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateDatabaseStatementContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext *MySQLParser::ShowCreateDatabaseStatementContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::IfNotExistsContext *MySQLParser::ShowCreateDatabaseStatementContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

size_t MySQLParser::ShowCreateDatabaseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateDatabaseStatement;
}

void MySQLParser::ShowCreateDatabaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateDatabaseStatement(this);
}

void MySQLParser::ShowCreateDatabaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateDatabaseStatement(this);
}

std::any MySQLParser::ShowCreateDatabaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateDatabaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateDatabaseStatementContext *MySQLParser::showCreateDatabaseStatement() {
  ShowCreateDatabaseStatementContext *_localctx =
    _tracker.createInstance<ShowCreateDatabaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 754, MySQLParser::RuleShowCreateDatabaseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5653);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5654);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5655);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(5657);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 667, _ctx)) {
      case 1: {
        setState(5656);
        ifNotExists();
        break;
      }

      default:
        break;
    }
    setState(5659);
    schemaRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateTableStatementContext ------------------------------------------------------------------

MySQLParser::ShowCreateTableStatementContext::ShowCreateTableStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateTableStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateTableStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ShowCreateTableStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

size_t MySQLParser::ShowCreateTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateTableStatement;
}

void MySQLParser::ShowCreateTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateTableStatement(this);
}

void MySQLParser::ShowCreateTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateTableStatement(this);
}

std::any MySQLParser::ShowCreateTableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateTableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateTableStatementContext *MySQLParser::showCreateTableStatement() {
  ShowCreateTableStatementContext *_localctx =
    _tracker.createInstance<ShowCreateTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 756, MySQLParser::RuleShowCreateTableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5661);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5662);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5663);
    match(MySQLParser::TABLE_SYMBOL);
    setState(5664);
    tableRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateViewStatementContext ------------------------------------------------------------------

MySQLParser::ShowCreateViewStatementContext::ShowCreateViewStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateViewStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateViewStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateViewStatementContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefContext *MySQLParser::ShowCreateViewStatementContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

size_t MySQLParser::ShowCreateViewStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateViewStatement;
}

void MySQLParser::ShowCreateViewStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateViewStatement(this);
}

void MySQLParser::ShowCreateViewStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateViewStatement(this);
}

std::any MySQLParser::ShowCreateViewStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateViewStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateViewStatementContext *MySQLParser::showCreateViewStatement() {
  ShowCreateViewStatementContext *_localctx = _tracker.createInstance<ShowCreateViewStatementContext>(_ctx, getState());
  enterRule(_localctx, 758, MySQLParser::RuleShowCreateViewStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5666);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5667);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5668);
    match(MySQLParser::VIEW_SYMBOL);
    setState(5669);
    viewRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowMasterStatusStatementContext ------------------------------------------------------------------

MySQLParser::ShowMasterStatusStatementContext::ShowMasterStatusStatementContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowMasterStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowMasterStatusStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowMasterStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

size_t MySQLParser::ShowMasterStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowMasterStatusStatement;
}

void MySQLParser::ShowMasterStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowMasterStatusStatement(this);
}

void MySQLParser::ShowMasterStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowMasterStatusStatement(this);
}

std::any MySQLParser::ShowMasterStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowMasterStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowMasterStatusStatementContext *MySQLParser::showMasterStatusStatement() {
  ShowMasterStatusStatementContext *_localctx =
    _tracker.createInstance<ShowMasterStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 760, MySQLParser::RuleShowMasterStatusStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5671);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5672);
    match(MySQLParser::MASTER_SYMBOL);
    setState(5673);
    match(MySQLParser::STATUS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowReplicaStatusStatementContext ------------------------------------------------------------------

MySQLParser::ShowReplicaStatusStatementContext::ShowReplicaStatusStatementContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowReplicaStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

MySQLParser::ReplicaContext *MySQLParser::ShowReplicaStatusStatementContext::replica() {
  return getRuleContext<MySQLParser::ReplicaContext>(0);
}

tree::TerminalNode *MySQLParser::ShowReplicaStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

MySQLParser::ChannelContext *MySQLParser::ShowReplicaStatusStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

size_t MySQLParser::ShowReplicaStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowReplicaStatusStatement;
}

void MySQLParser::ShowReplicaStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowReplicaStatusStatement(this);
}

void MySQLParser::ShowReplicaStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowReplicaStatusStatement(this);
}

std::any MySQLParser::ShowReplicaStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowReplicaStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowReplicaStatusStatementContext *MySQLParser::showReplicaStatusStatement() {
  ShowReplicaStatusStatementContext *_localctx =
    _tracker.createInstance<ShowReplicaStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 762, MySQLParser::RuleShowReplicaStatusStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5675);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5676);
    replica();
    setState(5677);
    match(MySQLParser::STATUS_SYMBOL);
    setState(5679);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5678);
      channel();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateProcedureStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateProcedureStatementContext::ShowCreateProcedureStatementContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext *MySQLParser::ShowCreateProcedureStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

size_t MySQLParser::ShowCreateProcedureStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateProcedureStatement;
}

void MySQLParser::ShowCreateProcedureStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateProcedureStatement(this);
}

void MySQLParser::ShowCreateProcedureStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateProcedureStatement(this);
}

std::any MySQLParser::ShowCreateProcedureStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateProcedureStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateProcedureStatementContext *MySQLParser::showCreateProcedureStatement() {
  ShowCreateProcedureStatementContext *_localctx =
    _tracker.createInstance<ShowCreateProcedureStatementContext>(_ctx, getState());
  enterRule(_localctx, 764, MySQLParser::RuleShowCreateProcedureStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5681);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5682);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5683);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(5684);
    procedureRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateFunctionStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateFunctionStatementContext::ShowCreateFunctionStatementContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext *MySQLParser::ShowCreateFunctionStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

size_t MySQLParser::ShowCreateFunctionStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateFunctionStatement;
}

void MySQLParser::ShowCreateFunctionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateFunctionStatement(this);
}

void MySQLParser::ShowCreateFunctionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateFunctionStatement(this);
}

std::any MySQLParser::ShowCreateFunctionStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateFunctionStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateFunctionStatementContext *MySQLParser::showCreateFunctionStatement() {
  ShowCreateFunctionStatementContext *_localctx =
    _tracker.createInstance<ShowCreateFunctionStatementContext>(_ctx, getState());
  enterRule(_localctx, 766, MySQLParser::RuleShowCreateFunctionStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5686);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5687);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5688);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(5689);
    functionRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateTriggerStatementContext ------------------------------------------------------------------

MySQLParser::ShowCreateTriggerStatementContext::ShowCreateTriggerStatementContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateTriggerStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateTriggerStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateTriggerStatementContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerRefContext *MySQLParser::ShowCreateTriggerStatementContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

size_t MySQLParser::ShowCreateTriggerStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateTriggerStatement;
}

void MySQLParser::ShowCreateTriggerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateTriggerStatement(this);
}

void MySQLParser::ShowCreateTriggerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateTriggerStatement(this);
}

std::any MySQLParser::ShowCreateTriggerStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateTriggerStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateTriggerStatementContext *MySQLParser::showCreateTriggerStatement() {
  ShowCreateTriggerStatementContext *_localctx =
    _tracker.createInstance<ShowCreateTriggerStatementContext>(_ctx, getState());
  enterRule(_localctx, 768, MySQLParser::RuleShowCreateTriggerStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5691);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5692);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5693);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(5694);
    triggerRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateProcedureStatusStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateProcedureStatusStatementContext::ShowCreateProcedureStatusStatementContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatusStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatusStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowCreateProcedureStatusStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowCreateProcedureStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateProcedureStatusStatement;
}

void MySQLParser::ShowCreateProcedureStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateProcedureStatusStatement(this);
}

void MySQLParser::ShowCreateProcedureStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateProcedureStatusStatement(this);
}

std::any MySQLParser::ShowCreateProcedureStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateProcedureStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateProcedureStatusStatementContext *MySQLParser::showCreateProcedureStatusStatement() {
  ShowCreateProcedureStatusStatementContext *_localctx =
    _tracker.createInstance<ShowCreateProcedureStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 770, MySQLParser::RuleShowCreateProcedureStatusStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5696);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5697);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5698);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(5699);
    match(MySQLParser::STATUS_SYMBOL);
    setState(5701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5700);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateFunctionStatusStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateFunctionStatusStatementContext::ShowCreateFunctionStatusStatementContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatusStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatusStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatusStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionStatusStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

MySQLParser::LikeOrWhereContext *MySQLParser::ShowCreateFunctionStatusStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

size_t MySQLParser::ShowCreateFunctionStatusStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateFunctionStatusStatement;
}

void MySQLParser::ShowCreateFunctionStatusStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateFunctionStatusStatement(this);
}

void MySQLParser::ShowCreateFunctionStatusStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateFunctionStatusStatement(this);
}

std::any MySQLParser::ShowCreateFunctionStatusStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateFunctionStatusStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateFunctionStatusStatementContext *MySQLParser::showCreateFunctionStatusStatement() {
  ShowCreateFunctionStatusStatementContext *_localctx =
    _tracker.createInstance<ShowCreateFunctionStatusStatementContext>(_ctx, getState());
  enterRule(_localctx, 772, MySQLParser::RuleShowCreateFunctionStatusStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5703);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5704);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5705);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(5706);
    match(MySQLParser::STATUS_SYMBOL);
    setState(5708);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
      setState(5707);
      likeOrWhere();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateProcedureCodeStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateProcedureCodeStatementContext::ShowCreateProcedureCodeStatementContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureCodeStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureCodeStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureCodeStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateProcedureCodeStatementContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext *MySQLParser::ShowCreateProcedureCodeStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

size_t MySQLParser::ShowCreateProcedureCodeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateProcedureCodeStatement;
}

void MySQLParser::ShowCreateProcedureCodeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateProcedureCodeStatement(this);
}

void MySQLParser::ShowCreateProcedureCodeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateProcedureCodeStatement(this);
}

std::any MySQLParser::ShowCreateProcedureCodeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateProcedureCodeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateProcedureCodeStatementContext *MySQLParser::showCreateProcedureCodeStatement() {
  ShowCreateProcedureCodeStatementContext *_localctx =
    _tracker.createInstance<ShowCreateProcedureCodeStatementContext>(_ctx, getState());
  enterRule(_localctx, 774, MySQLParser::RuleShowCreateProcedureCodeStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5710);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5711);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5712);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(5713);
    match(MySQLParser::CODE_SYMBOL);
    setState(5714);
    procedureRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateFunctionCodeStatementContext
//------------------------------------------------------------------

MySQLParser::ShowCreateFunctionCodeStatementContext::ShowCreateFunctionCodeStatementContext(ParserRuleContext *parent,
                                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionCodeStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionCodeStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionCodeStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateFunctionCodeStatementContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

MySQLParser::FunctionRefContext *MySQLParser::ShowCreateFunctionCodeStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

size_t MySQLParser::ShowCreateFunctionCodeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateFunctionCodeStatement;
}

void MySQLParser::ShowCreateFunctionCodeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateFunctionCodeStatement(this);
}

void MySQLParser::ShowCreateFunctionCodeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateFunctionCodeStatement(this);
}

std::any MySQLParser::ShowCreateFunctionCodeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateFunctionCodeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateFunctionCodeStatementContext *MySQLParser::showCreateFunctionCodeStatement() {
  ShowCreateFunctionCodeStatementContext *_localctx =
    _tracker.createInstance<ShowCreateFunctionCodeStatementContext>(_ctx, getState());
  enterRule(_localctx, 776, MySQLParser::RuleShowCreateFunctionCodeStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5716);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5717);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5718);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(5719);
    match(MySQLParser::CODE_SYMBOL);
    setState(5720);
    functionRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateEventStatementContext ------------------------------------------------------------------

MySQLParser::ShowCreateEventStatementContext::ShowCreateEventStatementContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateEventStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateEventStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateEventStatementContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext *MySQLParser::ShowCreateEventStatementContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

size_t MySQLParser::ShowCreateEventStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateEventStatement;
}

void MySQLParser::ShowCreateEventStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateEventStatement(this);
}

void MySQLParser::ShowCreateEventStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateEventStatement(this);
}

std::any MySQLParser::ShowCreateEventStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateEventStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateEventStatementContext *MySQLParser::showCreateEventStatement() {
  ShowCreateEventStatementContext *_localctx =
    _tracker.createInstance<ShowCreateEventStatementContext>(_ctx, getState());
  enterRule(_localctx, 778, MySQLParser::RuleShowCreateEventStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5722);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5723);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5724);
    match(MySQLParser::EVENT_SYMBOL);
    setState(5725);
    eventRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCreateUserStatementContext ------------------------------------------------------------------

MySQLParser::ShowCreateUserStatementContext::ShowCreateUserStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCreateUserStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateUserStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCreateUserStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::UserContext *MySQLParser::ShowCreateUserStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

size_t MySQLParser::ShowCreateUserStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowCreateUserStatement;
}

void MySQLParser::ShowCreateUserStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCreateUserStatement(this);
}

void MySQLParser::ShowCreateUserStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCreateUserStatement(this);
}

std::any MySQLParser::ShowCreateUserStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCreateUserStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCreateUserStatementContext *MySQLParser::showCreateUserStatement() {
  ShowCreateUserStatementContext *_localctx = _tracker.createInstance<ShowCreateUserStatementContext>(_ctx, getState());
  enterRule(_localctx, 780, MySQLParser::RuleShowCreateUserStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5727);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5728);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5729);
    match(MySQLParser::USER_SYMBOL);
    setState(5730);
    user();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCommandTypeContext ------------------------------------------------------------------

MySQLParser::ShowCommandTypeContext::ShowCommandTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ShowCommandTypeContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ShowCommandTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

size_t MySQLParser::ShowCommandTypeContext::getRuleIndex() const {
  return MySQLParser::RuleShowCommandType;
}

void MySQLParser::ShowCommandTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCommandType(this);
}

void MySQLParser::ShowCommandTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCommandType(this);
}

std::any MySQLParser::ShowCommandTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitShowCommandType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ShowCommandTypeContext *MySQLParser::showCommandType() {
  ShowCommandTypeContext *_localctx = _tracker.createInstance<ShowCommandTypeContext>(_ctx, getState());
  enterRule(_localctx, 782, MySQLParser::RuleShowCommandType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5737);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FULL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5732);
        match(MySQLParser::FULL_SYMBOL);
        break;
      }

      case MySQLParser::EXTENDED_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5733);
        match(MySQLParser::EXTENDED_SYMBOL);
        setState(5735);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FULL_SYMBOL) {
          setState(5734);
          match(MySQLParser::FULL_SYMBOL);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineOrAllContext ------------------------------------------------------------------

MySQLParser::EngineOrAllContext::EngineOrAllContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::EngineRefContext *MySQLParser::EngineOrAllContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode *MySQLParser::EngineOrAllContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

size_t MySQLParser::EngineOrAllContext::getRuleIndex() const {
  return MySQLParser::RuleEngineOrAll;
}

void MySQLParser::EngineOrAllContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineOrAll(this);
}

void MySQLParser::EngineOrAllContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineOrAll(this);
}

std::any MySQLParser::EngineOrAllContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEngineOrAll(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EngineOrAllContext *MySQLParser::engineOrAll() {
  EngineOrAllContext *_localctx = _tracker.createInstance<EngineOrAllContext>(_ctx, getState());
  enterRule(_localctx, 784, MySQLParser::RuleEngineOrAll);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5741);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 673, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5739);
        engineRef();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5740);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromOrInContext ------------------------------------------------------------------

MySQLParser::FromOrInContext::FromOrInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FromOrInContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FromOrInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

size_t MySQLParser::FromOrInContext::getRuleIndex() const {
  return MySQLParser::RuleFromOrIn;
}

void MySQLParser::FromOrInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromOrIn(this);
}

void MySQLParser::FromOrInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromOrIn(this);
}

std::any MySQLParser::FromOrInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFromOrIn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FromOrInContext *MySQLParser::fromOrIn() {
  FromOrInContext *_localctx = _tracker.createInstance<FromOrInContext>(_ctx, getState());
  enterRule(_localctx, 786, MySQLParser::RuleFromOrIn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5743);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FROM_SYMBOL

          || _la == MySQLParser::IN_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InDbContext ------------------------------------------------------------------

MySQLParser::InDbContext::InDbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FromOrInContext *MySQLParser::InDbContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

MySQLParser::IdentifierContext *MySQLParser::InDbContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::InDbContext::getRuleIndex() const {
  return MySQLParser::RuleInDb;
}

void MySQLParser::InDbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInDb(this);
}

void MySQLParser::InDbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInDb(this);
}

std::any MySQLParser::InDbContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInDb(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InDbContext *MySQLParser::inDb() {
  InDbContext *_localctx = _tracker.createInstance<InDbContext>(_ctx, getState());
  enterRule(_localctx, 788, MySQLParser::RuleInDb);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5745);
    fromOrIn();
    setState(5746);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProfileDefinitionsContext ------------------------------------------------------------------

MySQLParser::ProfileDefinitionsContext::ProfileDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ProfileDefinitionContext *> MySQLParser::ProfileDefinitionsContext::profileDefinition() {
  return getRuleContexts<MySQLParser::ProfileDefinitionContext>();
}

MySQLParser::ProfileDefinitionContext *MySQLParser::ProfileDefinitionsContext::profileDefinition(size_t i) {
  return getRuleContext<MySQLParser::ProfileDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ProfileDefinitionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ProfileDefinitionsContext::getRuleIndex() const {
  return MySQLParser::RuleProfileDefinitions;
}

void MySQLParser::ProfileDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProfileDefinitions(this);
}

void MySQLParser::ProfileDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProfileDefinitions(this);
}

std::any MySQLParser::ProfileDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProfileDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProfileDefinitionsContext *MySQLParser::profileDefinitions() {
  ProfileDefinitionsContext *_localctx = _tracker.createInstance<ProfileDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 790, MySQLParser::RuleProfileDefinitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5748);
    profileDefinition();
    setState(5753);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5749);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5750);
      profileDefinition();
      setState(5755);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProfileDefinitionContext ------------------------------------------------------------------

MySQLParser::ProfileDefinitionContext::ProfileDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProfileDefinitionContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

size_t MySQLParser::ProfileDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleProfileDefinition;
}

void MySQLParser::ProfileDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProfileDefinition(this);
}

void MySQLParser::ProfileDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProfileDefinition(this);
}

std::any MySQLParser::ProfileDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProfileDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProfileDefinitionContext *MySQLParser::profileDefinition() {
  ProfileDefinitionContext *_localctx = _tracker.createInstance<ProfileDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 792, MySQLParser::RuleProfileDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5763);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BLOCK_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5756);
        match(MySQLParser::BLOCK_SYMBOL);
        setState(5757);
        match(MySQLParser::IO_SYMBOL);
        break;
      }

      case MySQLParser::CONTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5758);
        match(MySQLParser::CONTEXT_SYMBOL);
        setState(5759);
        match(MySQLParser::SWITCHES_SYMBOL);
        break;
      }

      case MySQLParser::PAGE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5760);
        match(MySQLParser::PAGE_SYMBOL);
        setState(5761);
        match(MySQLParser::FAULTS_SYMBOL);
        break;
      }

      case MySQLParser::ALL_SYMBOL:
      case MySQLParser::CPU_SYMBOL:
      case MySQLParser::IPC_SYMBOL:
      case MySQLParser::MEMORY_SYMBOL:
      case MySQLParser::SOURCE_SYMBOL:
      case MySQLParser::SWAPS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5762);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::CPU_SYMBOL || _la == MySQLParser::IPC_SYMBOL ||
              _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

              || _la == MySQLParser::SWAPS_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherAdministrativeStatementContext
//------------------------------------------------------------------

MySQLParser::OtherAdministrativeStatementContext::OtherAdministrativeStatementContext(ParserRuleContext *parent,
                                                                                      size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext *MySQLParser::OtherAdministrativeStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::KeyCacheListOrPartsContext *MySQLParser::OtherAdministrativeStatementContext::keyCacheListOrParts() {
  return getRuleContext<MySQLParser::KeyCacheListOrPartsContext>(0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::OtherAdministrativeStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

MySQLParser::FlushTablesContext *MySQLParser::OtherAdministrativeStatementContext::flushTables() {
  return getRuleContext<MySQLParser::FlushTablesContext>(0);
}

std::vector<MySQLParser::FlushOptionContext *> MySQLParser::OtherAdministrativeStatementContext::flushOption() {
  return getRuleContexts<MySQLParser::FlushOptionContext>();
}

MySQLParser::FlushOptionContext *MySQLParser::OtherAdministrativeStatementContext::flushOption(size_t i) {
  return getRuleContext<MySQLParser::FlushOptionContext>(i);
}

MySQLParser::NoWriteToBinLogContext *MySQLParser::OtherAdministrativeStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ExprContext *MySQLParser::OtherAdministrativeStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::KILL_SYMBOL() {
  return getToken(MySQLParser::KILL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::PreloadTailContext *MySQLParser::OtherAdministrativeStatementContext::preloadTail() {
  return getRuleContext<MySQLParser::PreloadTailContext>(0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OtherAdministrativeStatementContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

size_t MySQLParser::OtherAdministrativeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleOtherAdministrativeStatement;
}

void MySQLParser::OtherAdministrativeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherAdministrativeStatement(this);
}

void MySQLParser::OtherAdministrativeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherAdministrativeStatement(this);
}

std::any MySQLParser::OtherAdministrativeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOtherAdministrativeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OtherAdministrativeStatementContext *MySQLParser::otherAdministrativeStatement() {
  OtherAdministrativeStatementContext *_localctx =
    _tracker.createInstance<OtherAdministrativeStatementContext>(_ctx, getState());
  enterRule(_localctx, 794, MySQLParser::RuleOtherAdministrativeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5801);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BINLOG_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5765);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::BINLOG_SYMBOL);
        setState(5766);
        textLiteral();
        break;
      }

      case MySQLParser::CACHE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5767);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::CACHE_SYMBOL);
        setState(5768);
        match(MySQLParser::INDEX_SYMBOL);
        setState(5769);
        keyCacheListOrParts();
        setState(5770);
        match(MySQLParser::IN_SYMBOL);
        setState(5773);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 676, _ctx)) {
          case 1: {
            setState(5771);
            identifier();
            break;
          }

          case 2: {
            setState(5772);
            match(MySQLParser::DEFAULT_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::FLUSH_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5775);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::FLUSH_SYMBOL);
        setState(5777);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(5776);
          noWriteToBinLog();
        }
        setState(5788);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TABLES_SYMBOL:
          case MySQLParser::TABLE_SYMBOL: {
            setState(5779);
            flushTables();
            break;
          }

          case MySQLParser::BINARY_SYMBOL:
          case MySQLParser::ENGINE_SYMBOL:
          case MySQLParser::ERROR_SYMBOL:
          case MySQLParser::GENERAL_SYMBOL:
          case MySQLParser::HOSTS_SYMBOL:
          case MySQLParser::LOGS_SYMBOL:
          case MySQLParser::OPTIMIZER_COSTS_SYMBOL:
          case MySQLParser::PRIVILEGES_SYMBOL:
          case MySQLParser::RELAY_SYMBOL:
          case MySQLParser::SLOW_SYMBOL:
          case MySQLParser::STATUS_SYMBOL:
          case MySQLParser::USER_RESOURCES_SYMBOL: {
            setState(5780);
            flushOption();
            setState(5785);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySQLParser::COMMA_SYMBOL) {
              setState(5781);
              match(MySQLParser::COMMA_SYMBOL);
              setState(5782);
              flushOption();
              setState(5787);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::KILL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5790);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::KILL_SYMBOL);
        setState(5792);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx)) {
          case 1: {
            setState(5791);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::CONNECTION_SYMBOL || _la == MySQLParser::QUERY_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          default:
            break;
        }
        setState(5794);
        expr(0);
        break;
      }

      case MySQLParser::LOAD_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(5795);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::LOAD_SYMBOL);
        setState(5796);
        match(MySQLParser::INDEX_SYMBOL);
        setState(5797);
        match(MySQLParser::INTO_SYMBOL);
        setState(5798);
        match(MySQLParser::CACHE_SYMBOL);
        setState(5799);
        preloadTail();
        break;
      }

      case MySQLParser::SHUTDOWN_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(5800);
        antlrcpp::downCast<OtherAdministrativeStatementContext *>(_localctx)->type =
          match(MySQLParser::SHUTDOWN_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListOrPartsContext ------------------------------------------------------------------

MySQLParser::KeyCacheListOrPartsContext::KeyCacheListOrPartsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyCacheListContext *MySQLParser::KeyCacheListOrPartsContext::keyCacheList() {
  return getRuleContext<MySQLParser::KeyCacheListContext>(0);
}

MySQLParser::AssignToKeycachePartitionContext *MySQLParser::KeyCacheListOrPartsContext::assignToKeycachePartition() {
  return getRuleContext<MySQLParser::AssignToKeycachePartitionContext>(0);
}

size_t MySQLParser::KeyCacheListOrPartsContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheListOrParts;
}

void MySQLParser::KeyCacheListOrPartsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheListOrParts(this);
}

void MySQLParser::KeyCacheListOrPartsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheListOrParts(this);
}

std::any MySQLParser::KeyCacheListOrPartsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyCacheListOrParts(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyCacheListOrPartsContext *MySQLParser::keyCacheListOrParts() {
  KeyCacheListOrPartsContext *_localctx = _tracker.createInstance<KeyCacheListOrPartsContext>(_ctx, getState());
  enterRule(_localctx, 796, MySQLParser::RuleKeyCacheListOrParts);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5805);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 682, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5803);
        keyCacheList();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5804);
        assignToKeycachePartition();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListContext ------------------------------------------------------------------

MySQLParser::KeyCacheListContext::KeyCacheListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AssignToKeycacheContext *> MySQLParser::KeyCacheListContext::assignToKeycache() {
  return getRuleContexts<MySQLParser::AssignToKeycacheContext>();
}

MySQLParser::AssignToKeycacheContext *MySQLParser::KeyCacheListContext::assignToKeycache(size_t i) {
  return getRuleContext<MySQLParser::AssignToKeycacheContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyCacheListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::KeyCacheListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::KeyCacheListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheList;
}

void MySQLParser::KeyCacheListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheList(this);
}

void MySQLParser::KeyCacheListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheList(this);
}

std::any MySQLParser::KeyCacheListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyCacheList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyCacheListContext *MySQLParser::keyCacheList() {
  KeyCacheListContext *_localctx = _tracker.createInstance<KeyCacheListContext>(_ctx, getState());
  enterRule(_localctx, 798, MySQLParser::RuleKeyCacheList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5807);
    assignToKeycache();
    setState(5812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5808);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5809);
      assignToKeycache();
      setState(5814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycacheContext ------------------------------------------------------------------

MySQLParser::AssignToKeycacheContext::AssignToKeycacheContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::AssignToKeycacheContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext *MySQLParser::AssignToKeycacheContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

size_t MySQLParser::AssignToKeycacheContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycache;
}

void MySQLParser::AssignToKeycacheContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycache(this);
}

void MySQLParser::AssignToKeycacheContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycache(this);
}

std::any MySQLParser::AssignToKeycacheContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAssignToKeycache(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AssignToKeycacheContext *MySQLParser::assignToKeycache() {
  AssignToKeycacheContext *_localctx = _tracker.createInstance<AssignToKeycacheContext>(_ctx, getState());
  enterRule(_localctx, 800, MySQLParser::RuleAssignToKeycache);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5815);
    tableRef();
    setState(5817);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL) {
      setState(5816);
      cacheKeyList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycachePartitionContext ------------------------------------------------------------------

MySQLParser::AssignToKeycachePartitionContext::AssignToKeycachePartitionContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::AssignToKeycachePartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::AssignToKeycachePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AssignToKeycachePartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext *MySQLParser::AssignToKeycachePartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode *MySQLParser::AssignToKeycachePartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CacheKeyListContext *MySQLParser::AssignToKeycachePartitionContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

size_t MySQLParser::AssignToKeycachePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycachePartition;
}

void MySQLParser::AssignToKeycachePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycachePartition(this);
}

void MySQLParser::AssignToKeycachePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycachePartition(this);
}

std::any MySQLParser::AssignToKeycachePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAssignToKeycachePartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AssignToKeycachePartitionContext *MySQLParser::assignToKeycachePartition() {
  AssignToKeycachePartitionContext *_localctx =
    _tracker.createInstance<AssignToKeycachePartitionContext>(_ctx, getState());
  enterRule(_localctx, 802, MySQLParser::RuleAssignToKeycachePartition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5819);
    tableRef();
    setState(5820);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5821);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5822);
    allOrPartitionNameList();
    setState(5823);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(5825);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL) {
      setState(5824);
      cacheKeyList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CacheKeyListContext ------------------------------------------------------------------

MySQLParser::CacheKeyListContext::CacheKeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyOrIndexContext *MySQLParser::CacheKeyListContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode *MySQLParser::CacheKeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CacheKeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::KeyUsageListContext *MySQLParser::CacheKeyListContext::keyUsageList() {
  return getRuleContext<MySQLParser::KeyUsageListContext>(0);
}

size_t MySQLParser::CacheKeyListContext::getRuleIndex() const {
  return MySQLParser::RuleCacheKeyList;
}

void MySQLParser::CacheKeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCacheKeyList(this);
}

void MySQLParser::CacheKeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCacheKeyList(this);
}

std::any MySQLParser::CacheKeyListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCacheKeyList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CacheKeyListContext *MySQLParser::cacheKeyList() {
  CacheKeyListContext *_localctx = _tracker.createInstance<CacheKeyListContext>(_ctx, getState());
  enterRule(_localctx, 804, MySQLParser::RuleCacheKeyList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5827);
    keyOrIndex();
    setState(5828);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5830);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 686, _ctx)) {
      case 1: {
        setState(5829);
        keyUsageList();
        break;
      }

      default:
        break;
    }
    setState(5832);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageElementContext ------------------------------------------------------------------

MySQLParser::KeyUsageElementContext::KeyUsageElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::KeyUsageElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::KeyUsageElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

size_t MySQLParser::KeyUsageElementContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageElement;
}

void MySQLParser::KeyUsageElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageElement(this);
}

void MySQLParser::KeyUsageElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageElement(this);
}

std::any MySQLParser::KeyUsageElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyUsageElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyUsageElementContext *MySQLParser::keyUsageElement() {
  KeyUsageElementContext *_localctx = _tracker.createInstance<KeyUsageElementContext>(_ctx, getState());
  enterRule(_localctx, 806, MySQLParser::RuleKeyUsageElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5836);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 687, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5834);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5835);
        match(MySQLParser::PRIMARY_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageListContext ------------------------------------------------------------------

MySQLParser::KeyUsageListContext::KeyUsageListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::KeyUsageElementContext *> MySQLParser::KeyUsageListContext::keyUsageElement() {
  return getRuleContexts<MySQLParser::KeyUsageElementContext>();
}

MySQLParser::KeyUsageElementContext *MySQLParser::KeyUsageListContext::keyUsageElement(size_t i) {
  return getRuleContext<MySQLParser::KeyUsageElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyUsageListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::KeyUsageListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::KeyUsageListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageList;
}

void MySQLParser::KeyUsageListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageList(this);
}

void MySQLParser::KeyUsageListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageList(this);
}

std::any MySQLParser::KeyUsageListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyUsageList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyUsageListContext *MySQLParser::keyUsageList() {
  KeyUsageListContext *_localctx = _tracker.createInstance<KeyUsageListContext>(_ctx, getState());
  enterRule(_localctx, 808, MySQLParser::RuleKeyUsageList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5838);
    keyUsageElement();
    setState(5843);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5839);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5840);
      keyUsageElement();
      setState(5845);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushOptionContext ------------------------------------------------------------------

MySQLParser::FlushOptionContext::FlushOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FlushOptionContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

MySQLParser::LogTypeContext *MySQLParser::FlushOptionContext::logType() {
  return getRuleContext<MySQLParser::LogTypeContext>(0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

MySQLParser::ChannelContext *MySQLParser::FlushOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode *MySQLParser::FlushOptionContext::OPTIMIZER_COSTS_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZER_COSTS_SYMBOL, 0);
}

size_t MySQLParser::FlushOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFlushOption;
}

void MySQLParser::FlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushOption(this);
}

void MySQLParser::FlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushOption(this);
}

std::any MySQLParser::FlushOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFlushOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushOptionContext *MySQLParser::flushOption() {
  FlushOptionContext *_localctx = _tracker.createInstance<FlushOptionContext>(_ctx, getState());
  enterRule(_localctx, 810, MySQLParser::RuleFlushOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5857);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HOSTS_SYMBOL:
      case MySQLParser::PRIVILEGES_SYMBOL:
      case MySQLParser::STATUS_SYMBOL:
      case MySQLParser::USER_RESOURCES_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5846);
        antlrcpp::downCast<FlushOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::HOSTS_SYMBOL || _la == MySQLParser::PRIVILEGES_SYMBOL ||
              _la == MySQLParser::STATUS_SYMBOL || _la == MySQLParser::USER_RESOURCES_SYMBOL)) {
          antlrcpp::downCast<FlushOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL:
      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::ERROR_SYMBOL:
      case MySQLParser::GENERAL_SYMBOL:
      case MySQLParser::LOGS_SYMBOL:
      case MySQLParser::SLOW_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5848);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::BINARY_SYMBOL ||
            ((((_la - 163) & ~0x3fULL) == 0) && ((1ULL << (_la - 163)) & 35184372088837) != 0) ||
            _la == MySQLParser::SLOW_SYMBOL) {
          setState(5847);
          logType();
        }
        setState(5850);
        antlrcpp::downCast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::LOGS_SYMBOL);
        break;
      }

      case MySQLParser::RELAY_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5851);
        antlrcpp::downCast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::RELAY_SYMBOL);
        setState(5852);
        match(MySQLParser::LOGS_SYMBOL);
        setState(5854);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(5853);
          channel();
        }
        break;
      }

      case MySQLParser::OPTIMIZER_COSTS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5856);
        antlrcpp::downCast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::OPTIMIZER_COSTS_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogTypeContext ------------------------------------------------------------------

MySQLParser::LogTypeContext::LogTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LogTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LogTypeContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LogTypeContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LogTypeContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LogTypeContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

size_t MySQLParser::LogTypeContext::getRuleIndex() const {
  return MySQLParser::RuleLogType;
}

void MySQLParser::LogTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogType(this);
}

void MySQLParser::LogTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogType(this);
}

std::any MySQLParser::LogTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLogType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogTypeContext *MySQLParser::logType() {
  LogTypeContext *_localctx = _tracker.createInstance<LogTypeContext>(_ctx, getState());
  enterRule(_localctx, 812, MySQLParser::RuleLogType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5859);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BINARY_SYMBOL ||
          ((((_la - 163) & ~0x3fULL) == 0) && ((1ULL << (_la - 163)) & 35184372088837) != 0) ||
          _la == MySQLParser::SLOW_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesContext ------------------------------------------------------------------

MySQLParser::FlushTablesContext::FlushTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FlushTablesContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::FlushTablesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::FlushTablesOptionsContext *MySQLParser::FlushTablesContext::flushTablesOptions() {
  return getRuleContext<MySQLParser::FlushTablesOptionsContext>(0);
}

size_t MySQLParser::FlushTablesContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTables;
}

void MySQLParser::FlushTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTables(this);
}

void MySQLParser::FlushTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTables(this);
}

std::any MySQLParser::FlushTablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFlushTables(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushTablesContext *MySQLParser::flushTables() {
  FlushTablesContext *_localctx = _tracker.createInstance<FlushTablesContext>(_ctx, getState());
  enterRule(_localctx, 814, MySQLParser::RuleFlushTables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5861);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

          || _la == MySQLParser::TABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5869);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 693, _ctx)) {
      case 1: {
        setState(5862);
        match(MySQLParser::WITH_SYMBOL);
        setState(5863);
        match(MySQLParser::READ_SYMBOL);
        setState(5864);
        match(MySQLParser::LOCK_SYMBOL);
        break;
      }

      case 2: {
        setState(5865);
        identifierList();
        setState(5867);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::WITH_SYMBOL) {
          setState(5866);
          flushTablesOptions();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesOptionsContext ------------------------------------------------------------------

MySQLParser::FlushTablesOptionsContext::FlushTablesOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FlushTablesOptionsContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesOptionsContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesOptionsContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FlushTablesOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

size_t MySQLParser::FlushTablesOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTablesOptions;
}

void MySQLParser::FlushTablesOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTablesOptions(this);
}

void MySQLParser::FlushTablesOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTablesOptions(this);
}

std::any MySQLParser::FlushTablesOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFlushTablesOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FlushTablesOptionsContext *MySQLParser::flushTablesOptions() {
  FlushTablesOptionsContext *_localctx = _tracker.createInstance<FlushTablesOptionsContext>(_ctx, getState());
  enterRule(_localctx, 816, MySQLParser::RuleFlushTablesOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5876);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5871);
        match(MySQLParser::FOR_SYMBOL);
        setState(5872);
        match(MySQLParser::EXPORT_SYMBOL);
        break;
      }

      case MySQLParser::WITH_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5873);
        match(MySQLParser::WITH_SYMBOL);
        setState(5874);
        match(MySQLParser::READ_SYMBOL);
        setState(5875);
        match(MySQLParser::LOCK_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadTailContext ------------------------------------------------------------------

MySQLParser::PreloadTailContext::PreloadTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::PreloadTailContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::AdminPartitionContext *MySQLParser::PreloadTailContext::adminPartition() {
  return getRuleContext<MySQLParser::AdminPartitionContext>(0);
}

MySQLParser::CacheKeyListContext *MySQLParser::PreloadTailContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode *MySQLParser::PreloadTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PreloadTailContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

MySQLParser::PreloadListContext *MySQLParser::PreloadTailContext::preloadList() {
  return getRuleContext<MySQLParser::PreloadListContext>(0);
}

size_t MySQLParser::PreloadTailContext::getRuleIndex() const {
  return MySQLParser::RulePreloadTail;
}

void MySQLParser::PreloadTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadTail(this);
}

void MySQLParser::PreloadTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadTail(this);
}

std::any MySQLParser::PreloadTailContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPreloadTail(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadTailContext *MySQLParser::preloadTail() {
  PreloadTailContext *_localctx = _tracker.createInstance<PreloadTailContext>(_ctx, getState());
  enterRule(_localctx, 818, MySQLParser::RulePreloadTail);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5888);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(5878);
        tableRef();
        setState(5879);
        adminPartition();
        setState(5881);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::INDEX_SYMBOL

            || _la == MySQLParser::KEY_SYMBOL) {
          setState(5880);
          cacheKeyList();
        }
        setState(5885);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL) {
          setState(5883);
          match(MySQLParser::IGNORE_SYMBOL);
          setState(5884);
          match(MySQLParser::LEAVES_SYMBOL);
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(5887);
        preloadList();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadListContext ------------------------------------------------------------------

MySQLParser::PreloadListContext::PreloadListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PreloadKeysContext *> MySQLParser::PreloadListContext::preloadKeys() {
  return getRuleContexts<MySQLParser::PreloadKeysContext>();
}

MySQLParser::PreloadKeysContext *MySQLParser::PreloadListContext::preloadKeys(size_t i) {
  return getRuleContext<MySQLParser::PreloadKeysContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::PreloadListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::PreloadListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::PreloadListContext::getRuleIndex() const {
  return MySQLParser::RulePreloadList;
}

void MySQLParser::PreloadListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadList(this);
}

void MySQLParser::PreloadListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadList(this);
}

std::any MySQLParser::PreloadListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPreloadList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadListContext *MySQLParser::preloadList() {
  PreloadListContext *_localctx = _tracker.createInstance<PreloadListContext>(_ctx, getState());
  enterRule(_localctx, 820, MySQLParser::RulePreloadList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5890);
    preloadKeys();
    setState(5895);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5891);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5892);
      preloadKeys();
      setState(5897);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadKeysContext ------------------------------------------------------------------

MySQLParser::PreloadKeysContext::PreloadKeysContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::PreloadKeysContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext *MySQLParser::PreloadKeysContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode *MySQLParser::PreloadKeysContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PreloadKeysContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

size_t MySQLParser::PreloadKeysContext::getRuleIndex() const {
  return MySQLParser::RulePreloadKeys;
}

void MySQLParser::PreloadKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadKeys(this);
}

void MySQLParser::PreloadKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadKeys(this);
}

std::any MySQLParser::PreloadKeysContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPreloadKeys(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PreloadKeysContext *MySQLParser::preloadKeys() {
  PreloadKeysContext *_localctx = _tracker.createInstance<PreloadKeysContext>(_ctx, getState());
  enterRule(_localctx, 822, MySQLParser::RulePreloadKeys);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5898);
    tableRef();
    setState(5900);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL) {
      setState(5899);
      cacheKeyList();
    }
    setState(5904);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(5902);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(5903);
      match(MySQLParser::LEAVES_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdminPartitionContext ------------------------------------------------------------------

MySQLParser::AdminPartitionContext::AdminPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AdminPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AdminPartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext *MySQLParser::AdminPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode *MySQLParser::AdminPartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::AdminPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAdminPartition;
}

void MySQLParser::AdminPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdminPartition(this);
}

void MySQLParser::AdminPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdminPartition(this);
}

std::any MySQLParser::AdminPartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAdminPartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AdminPartitionContext *MySQLParser::adminPartition() {
  AdminPartitionContext *_localctx = _tracker.createInstance<AdminPartitionContext>(_ctx, getState());
  enterRule(_localctx, 824, MySQLParser::RuleAdminPartition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5906);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5907);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5908);
    allOrPartitionNameList();
    setState(5909);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupManagementContext ------------------------------------------------------------------

MySQLParser::ResourceGroupManagementContext::ResourceGroupManagementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateResourceGroupContext *MySQLParser::ResourceGroupManagementContext::createResourceGroup() {
  return getRuleContext<MySQLParser::CreateResourceGroupContext>(0);
}

MySQLParser::AlterResourceGroupContext *MySQLParser::ResourceGroupManagementContext::alterResourceGroup() {
  return getRuleContext<MySQLParser::AlterResourceGroupContext>(0);
}

MySQLParser::SetResourceGroupContext *MySQLParser::ResourceGroupManagementContext::setResourceGroup() {
  return getRuleContext<MySQLParser::SetResourceGroupContext>(0);
}

MySQLParser::DropResourceGroupContext *MySQLParser::ResourceGroupManagementContext::dropResourceGroup() {
  return getRuleContext<MySQLParser::DropResourceGroupContext>(0);
}

size_t MySQLParser::ResourceGroupManagementContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupManagement;
}

void MySQLParser::ResourceGroupManagementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupManagement(this);
}

void MySQLParser::ResourceGroupManagementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupManagement(this);
}

std::any MySQLParser::ResourceGroupManagementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResourceGroupManagement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupManagementContext *MySQLParser::resourceGroupManagement() {
  ResourceGroupManagementContext *_localctx = _tracker.createInstance<ResourceGroupManagementContext>(_ctx, getState());
  enterRule(_localctx, 826, MySQLParser::RuleResourceGroupManagement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(5915);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CREATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5911);
        createResourceGroup();
        break;
      }

      case MySQLParser::ALTER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5912);
        alterResourceGroup();
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5913);
        setResourceGroup();
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5914);
        dropResourceGroup();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateResourceGroupContext ------------------------------------------------------------------

MySQLParser::CreateResourceGroupContext::CreateResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CreateResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateResourceGroupContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::EqualContext *MySQLParser::CreateResourceGroupContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext *MySQLParser::CreateResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext *MySQLParser::CreateResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext *MySQLParser::CreateResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}

size_t MySQLParser::CreateResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateResourceGroup;
}

void MySQLParser::CreateResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateResourceGroup(this);
}

void MySQLParser::CreateResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateResourceGroup(this);
}

std::any MySQLParser::CreateResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateResourceGroupContext *MySQLParser::createResourceGroup() {
  CreateResourceGroupContext *_localctx = _tracker.createInstance<CreateResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 828, MySQLParser::RuleCreateResourceGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5917);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5918);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5919);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5920);
    identifier();
    setState(5921);
    match(MySQLParser::TYPE_SYMBOL);
    setState(5923);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

        || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5922);
      equal();
    }
    setState(5925);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::USER_SYMBOL || _la == MySQLParser::SYSTEM_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5927);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5926);
      resourceGroupVcpuList();
    }
    setState(5930);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5929);
      resourceGroupPriority();
    }
    setState(5933);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

        || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5932);
      resourceGroupEnableDisable();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupVcpuListContext ------------------------------------------------------------------

MySQLParser::ResourceGroupVcpuListContext::ResourceGroupVcpuListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ResourceGroupVcpuListContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

std::vector<MySQLParser::VcpuNumOrRangeContext *> MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange() {
  return getRuleContexts<MySQLParser::VcpuNumOrRangeContext>();
}

MySQLParser::VcpuNumOrRangeContext *MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange(size_t i) {
  return getRuleContext<MySQLParser::VcpuNumOrRangeContext>(i);
}

MySQLParser::EqualContext *MySQLParser::ResourceGroupVcpuListContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ResourceGroupVcpuListContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupVcpuList;
}

void MySQLParser::ResourceGroupVcpuListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupVcpuList(this);
}

void MySQLParser::ResourceGroupVcpuListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupVcpuList(this);
}

std::any MySQLParser::ResourceGroupVcpuListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResourceGroupVcpuList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupVcpuListContext *MySQLParser::resourceGroupVcpuList() {
  ResourceGroupVcpuListContext *_localctx = _tracker.createInstance<ResourceGroupVcpuListContext>(_ctx, getState());
  enterRule(_localctx, 830, MySQLParser::RuleResourceGroupVcpuList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5935);
    match(MySQLParser::VCPU_SYMBOL);
    setState(5937);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

        || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5936);
      equal();
    }
    setState(5939);
    vcpuNumOrRange();
    setState(5946);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::INT_NUMBER

           || _la == MySQLParser::COMMA_SYMBOL) {
      setState(5941);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5940);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5943);
      vcpuNumOrRange();
      setState(5948);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VcpuNumOrRangeContext ------------------------------------------------------------------

MySQLParser::VcpuNumOrRangeContext::VcpuNumOrRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::VcpuNumOrRangeContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode *MySQLParser::VcpuNumOrRangeContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode *MySQLParser::VcpuNumOrRangeContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

size_t MySQLParser::VcpuNumOrRangeContext::getRuleIndex() const {
  return MySQLParser::RuleVcpuNumOrRange;
}

void MySQLParser::VcpuNumOrRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVcpuNumOrRange(this);
}

void MySQLParser::VcpuNumOrRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVcpuNumOrRange(this);
}

std::any MySQLParser::VcpuNumOrRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitVcpuNumOrRange(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VcpuNumOrRangeContext *MySQLParser::vcpuNumOrRange() {
  VcpuNumOrRangeContext *_localctx = _tracker.createInstance<VcpuNumOrRangeContext>(_ctx, getState());
  enterRule(_localctx, 832, MySQLParser::RuleVcpuNumOrRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5949);
    match(MySQLParser::INT_NUMBER);
    setState(5952);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MINUS_OPERATOR) {
      setState(5950);
      match(MySQLParser::MINUS_OPERATOR);
      setState(5951);
      match(MySQLParser::INT_NUMBER);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupPriorityContext ------------------------------------------------------------------

MySQLParser::ResourceGroupPriorityContext::ResourceGroupPriorityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ResourceGroupPriorityContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ResourceGroupPriorityContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::EqualContext *MySQLParser::ResourceGroupPriorityContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

size_t MySQLParser::ResourceGroupPriorityContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupPriority;
}

void MySQLParser::ResourceGroupPriorityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupPriority(this);
}

void MySQLParser::ResourceGroupPriorityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupPriority(this);
}

std::any MySQLParser::ResourceGroupPriorityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResourceGroupPriority(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupPriorityContext *MySQLParser::resourceGroupPriority() {
  ResourceGroupPriorityContext *_localctx = _tracker.createInstance<ResourceGroupPriorityContext>(_ctx, getState());
  enterRule(_localctx, 834, MySQLParser::RuleResourceGroupPriority);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5954);
    match(MySQLParser::THREAD_PRIORITY_SYMBOL);
    setState(5956);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

        || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5955);
      equal();
    }
    setState(5958);
    match(MySQLParser::INT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupEnableDisableContext ------------------------------------------------------------------

MySQLParser::ResourceGroupEnableDisableContext::ResourceGroupEnableDisableContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ResourceGroupEnableDisableContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ResourceGroupEnableDisableContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

size_t MySQLParser::ResourceGroupEnableDisableContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupEnableDisable;
}

void MySQLParser::ResourceGroupEnableDisableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupEnableDisable(this);
}

void MySQLParser::ResourceGroupEnableDisableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupEnableDisable(this);
}

std::any MySQLParser::ResourceGroupEnableDisableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResourceGroupEnableDisable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupEnableDisableContext *MySQLParser::resourceGroupEnableDisable() {
  ResourceGroupEnableDisableContext *_localctx =
    _tracker.createInstance<ResourceGroupEnableDisableContext>(_ctx, getState());
  enterRule(_localctx, 836, MySQLParser::RuleResourceGroupEnableDisable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5960);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DISABLE_SYMBOL

          || _la == MySQLParser::ENABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterResourceGroupContext ------------------------------------------------------------------

MySQLParser::AlterResourceGroupContext::AlterResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AlterResourceGroupContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AlterResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext *MySQLParser::AlterResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext *MySQLParser::AlterResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext *MySQLParser::AlterResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext *MySQLParser::AlterResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}

tree::TerminalNode *MySQLParser::AlterResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

size_t MySQLParser::AlterResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterResourceGroup;
}

void MySQLParser::AlterResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterResourceGroup(this);
}

void MySQLParser::AlterResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterResourceGroup(this);
}

std::any MySQLParser::AlterResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAlterResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AlterResourceGroupContext *MySQLParser::alterResourceGroup() {
  AlterResourceGroupContext *_localctx = _tracker.createInstance<AlterResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 838, MySQLParser::RuleAlterResourceGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5962);
    match(MySQLParser::ALTER_SYMBOL);
    setState(5963);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5964);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5965);
    resourceGroupRef();
    setState(5967);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5966);
      resourceGroupVcpuList();
    }
    setState(5970);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5969);
      resourceGroupPriority();
    }
    setState(5973);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

        || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5972);
      resourceGroupEnableDisable();
    }
    setState(5976);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(5975);
      match(MySQLParser::FORCE_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetResourceGroupContext ------------------------------------------------------------------

MySQLParser::SetResourceGroupContext::SetResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SetResourceGroupContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::SetResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::SetResourceGroupContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::ThreadIdListContext *MySQLParser::SetResourceGroupContext::threadIdList() {
  return getRuleContext<MySQLParser::ThreadIdListContext>(0);
}

size_t MySQLParser::SetResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleSetResourceGroup;
}

void MySQLParser::SetResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetResourceGroup(this);
}

void MySQLParser::SetResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetResourceGroup(this);
}

std::any MySQLParser::SetResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetResourceGroupContext *MySQLParser::setResourceGroup() {
  SetResourceGroupContext *_localctx = _tracker.createInstance<SetResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 840, MySQLParser::RuleSetResourceGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5978);
    match(MySQLParser::SET_SYMBOL);
    setState(5979);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5980);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5981);
    identifier();
    setState(5984);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5982);
      match(MySQLParser::FOR_SYMBOL);
      setState(5983);
      threadIdList();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadIdListContext ------------------------------------------------------------------

MySQLParser::ThreadIdListContext::ThreadIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::ThreadIdListContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext *MySQLParser::ThreadIdListContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ThreadIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ThreadIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ThreadIdListContext::getRuleIndex() const {
  return MySQLParser::RuleThreadIdList;
}

void MySQLParser::ThreadIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadIdList(this);
}

void MySQLParser::ThreadIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadIdList(this);
}

std::any MySQLParser::ThreadIdListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitThreadIdList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThreadIdListContext *MySQLParser::threadIdList() {
  ThreadIdListContext *_localctx = _tracker.createInstance<ThreadIdListContext>(_ctx, getState());
  enterRule(_localctx, 842, MySQLParser::RuleThreadIdList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5986);
    real_ulong_number();
    setState(5993);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 2199090364423) != 0)) {
      setState(5988);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5987);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5990);
      real_ulong_number();
      setState(5995);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropResourceGroupContext ------------------------------------------------------------------

MySQLParser::DropResourceGroupContext::DropResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DropResourceGroupContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DropResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext *MySQLParser::DropResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

tree::TerminalNode *MySQLParser::DropResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

size_t MySQLParser::DropResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropResourceGroup;
}

void MySQLParser::DropResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropResourceGroup(this);
}

void MySQLParser::DropResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropResourceGroup(this);
}

std::any MySQLParser::DropResourceGroupContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDropResourceGroup(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DropResourceGroupContext *MySQLParser::dropResourceGroup() {
  DropResourceGroupContext *_localctx = _tracker.createInstance<DropResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 844, MySQLParser::RuleDropResourceGroup);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5996);
    match(MySQLParser::DROP_SYMBOL);
    setState(5997);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5998);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5999);
    resourceGroupRef();
    setState(6001);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(6000);
      match(MySQLParser::FORCE_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UtilityStatementContext ------------------------------------------------------------------

MySQLParser::UtilityStatementContext::UtilityStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DescribeStatementContext *MySQLParser::UtilityStatementContext::describeStatement() {
  return getRuleContext<MySQLParser::DescribeStatementContext>(0);
}

MySQLParser::ExplainStatementContext *MySQLParser::UtilityStatementContext::explainStatement() {
  return getRuleContext<MySQLParser::ExplainStatementContext>(0);
}

MySQLParser::HelpCommandContext *MySQLParser::UtilityStatementContext::helpCommand() {
  return getRuleContext<MySQLParser::HelpCommandContext>(0);
}

MySQLParser::UseCommandContext *MySQLParser::UtilityStatementContext::useCommand() {
  return getRuleContext<MySQLParser::UseCommandContext>(0);
}

MySQLParser::RestartServerContext *MySQLParser::UtilityStatementContext::restartServer() {
  return getRuleContext<MySQLParser::RestartServerContext>(0);
}

size_t MySQLParser::UtilityStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUtilityStatement;
}

void MySQLParser::UtilityStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUtilityStatement(this);
}

void MySQLParser::UtilityStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUtilityStatement(this);
}

std::any MySQLParser::UtilityStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUtilityStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UtilityStatementContext *MySQLParser::utilityStatement() {
  UtilityStatementContext *_localctx = _tracker.createInstance<UtilityStatementContext>(_ctx, getState());
  enterRule(_localctx, 846, MySQLParser::RuleUtilityStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6009);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 719, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6003);
        describeStatement();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6004);
        explainStatement();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6005);
        helpCommand();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(6006);
        useCommand();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(6007);

        if (!(serverVersion >= 80011))
          throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(6008);
        restartServer();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescribeStatementContext ------------------------------------------------------------------

MySQLParser::DescribeStatementContext::DescribeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext *MySQLParser::DescribeStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode *MySQLParser::DescribeStatementContext::EXPLAIN_SYMBOL() {
  return getToken(MySQLParser::EXPLAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DescribeStatementContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DescribeStatementContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::DescribeStatementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::ColumnRefContext *MySQLParser::DescribeStatementContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

size_t MySQLParser::DescribeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDescribeStatement;
}

void MySQLParser::DescribeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribeStatement(this);
}

void MySQLParser::DescribeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribeStatement(this);
}

std::any MySQLParser::DescribeStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDescribeStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DescribeStatementContext *MySQLParser::describeStatement() {
  DescribeStatementContext *_localctx = _tracker.createInstance<DescribeStatementContext>(_ctx, getState());
  enterRule(_localctx, 848, MySQLParser::RuleDescribeStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6011);
    _la = _input->LA(1);
    if (!(((((_la - 134) & ~0x3fULL) == 0) && ((1ULL << (_la - 134)) & 17592186044419) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6012);
    tableRef();
    setState(6015);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 720, _ctx)) {
      case 1: {
        setState(6013);
        textString();
        break;
      }

      case 2: {
        setState(6014);
        columnRef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainStatementContext ------------------------------------------------------------------

MySQLParser::ExplainStatementContext::ExplainStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExplainableStatementContext *MySQLParser::ExplainStatementContext::explainableStatement() {
  return getRuleContext<MySQLParser::ExplainableStatementContext>(0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::EXPLAIN_SYMBOL() {
  return getToken(MySQLParser::EXPLAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::ExplainStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::ExplainStatementContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

size_t MySQLParser::ExplainStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExplainStatement;
}

void MySQLParser::ExplainStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainStatement(this);
}

void MySQLParser::ExplainStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainStatement(this);
}

std::any MySQLParser::ExplainStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExplainStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExplainStatementContext *MySQLParser::explainStatement() {
  ExplainStatementContext *_localctx = _tracker.createInstance<ExplainStatementContext>(_ctx, getState());
  enterRule(_localctx, 850, MySQLParser::RuleExplainStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6017);
    _la = _input->LA(1);
    if (!(((((_la - 134) & ~0x3fULL) == 0) && ((1ULL << (_la - 134)) & 17592186044419) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6029);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 721, _ctx)) {
      case 1: {
        setState(6018);
        match(MySQLParser::EXTENDED_SYMBOL);
        break;
      }

      case 2: {
        setState(6019);
        match(MySQLParser::FORMAT_SYMBOL);
        setState(6020);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(6021);
        textOrIdentifier();
        break;
      }

      case 3: {
        setState(6022);

        if (!(serverVersion >= 80018))
          throw FailedPredicateException(this, "serverVersion >= 80018");
        setState(6023);
        match(MySQLParser::ANALYZE_SYMBOL);
        break;
      }

      case 4: {
        setState(6024);

        if (!(serverVersion >= 80019))
          throw FailedPredicateException(this, "serverVersion >= 80019");
        setState(6025);
        match(MySQLParser::ANALYZE_SYMBOL);
        setState(6026);
        match(MySQLParser::FORMAT_SYMBOL);
        setState(6027);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(6028);
        textOrIdentifier();
        break;
      }

      default:
        break;
    }
    setState(6031);
    explainableStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainableStatementContext ------------------------------------------------------------------

MySQLParser::ExplainableStatementContext::ExplainableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SelectStatementContext *MySQLParser::ExplainableStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::DeleteStatementContext *MySQLParser::ExplainableStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::InsertStatementContext *MySQLParser::ExplainableStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::ReplaceStatementContext *MySQLParser::ExplainableStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::UpdateStatementContext *MySQLParser::ExplainableStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

tree::TerminalNode *MySQLParser::ExplainableStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExplainableStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::ExplainableStatementContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

size_t MySQLParser::ExplainableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExplainableStatement;
}

void MySQLParser::ExplainableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainableStatement(this);
}

void MySQLParser::ExplainableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainableStatement(this);
}

std::any MySQLParser::ExplainableStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExplainableStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExplainableStatementContext *MySQLParser::explainableStatement() {
  ExplainableStatementContext *_localctx = _tracker.createInstance<ExplainableStatementContext>(_ctx, getState());
  enterRule(_localctx, 852, MySQLParser::RuleExplainableStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6041);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 722, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6033);
        selectStatement();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6034);
        deleteStatement();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6035);
        insertStatement();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(6036);
        replaceStatement();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(6037);
        updateStatement();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(6038);
        match(MySQLParser::FOR_SYMBOL);
        setState(6039);
        match(MySQLParser::CONNECTION_SYMBOL);
        setState(6040);
        real_ulong_number();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelpCommandContext ------------------------------------------------------------------

MySQLParser::HelpCommandContext::HelpCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HelpCommandContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::HelpCommandContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::HelpCommandContext::getRuleIndex() const {
  return MySQLParser::RuleHelpCommand;
}

void MySQLParser::HelpCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHelpCommand(this);
}

void MySQLParser::HelpCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHelpCommand(this);
}

std::any MySQLParser::HelpCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHelpCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HelpCommandContext *MySQLParser::helpCommand() {
  HelpCommandContext *_localctx = _tracker.createInstance<HelpCommandContext>(_ctx, getState());
  enterRule(_localctx, 854, MySQLParser::RuleHelpCommand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6043);
    match(MySQLParser::HELP_SYMBOL);
    setState(6044);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseCommandContext ------------------------------------------------------------------

MySQLParser::UseCommandContext::UseCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UseCommandContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext *MySQLParser::UseCommandContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

size_t MySQLParser::UseCommandContext::getRuleIndex() const {
  return MySQLParser::RuleUseCommand;
}

void MySQLParser::UseCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseCommand(this);
}

void MySQLParser::UseCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseCommand(this);
}

std::any MySQLParser::UseCommandContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUseCommand(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UseCommandContext *MySQLParser::useCommand() {
  UseCommandContext *_localctx = _tracker.createInstance<UseCommandContext>(_ctx, getState());
  enterRule(_localctx, 856, MySQLParser::RuleUseCommand);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6046);
    match(MySQLParser::USE_SYMBOL);
    setState(6047);
    schemaRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestartServerContext ------------------------------------------------------------------

MySQLParser::RestartServerContext::RestartServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RestartServerContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}

size_t MySQLParser::RestartServerContext::getRuleIndex() const {
  return MySQLParser::RuleRestartServer;
}

void MySQLParser::RestartServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestartServer(this);
}

void MySQLParser::RestartServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestartServer(this);
}

std::any MySQLParser::RestartServerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRestartServer(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RestartServerContext *MySQLParser::restartServer() {
  RestartServerContext *_localctx = _tracker.createInstance<RestartServerContext>(_ctx, getState());
  enterRule(_localctx, 858, MySQLParser::RuleRestartServer);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6049);
    match(MySQLParser::RESTART_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

MySQLParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

size_t MySQLParser::ExprContext::getRuleIndex() const {
  return MySQLParser::RuleExpr;
}

void MySQLParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ExprOrContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprOrContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ExprOrContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::ExprOrContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExprOrContext::LOGICAL_OR_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_OR_OPERATOR, 0);
}

MySQLParser::ExprOrContext::ExprOrContext(ExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::ExprOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprOr(this);
}
void MySQLParser::ExprOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprOr(this);
}

std::any MySQLParser::ExprOrContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprOr(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprNotContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::ExprNotContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ExprNotContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ExprNotContext::ExprNotContext(ExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::ExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprNot(this);
}
void MySQLParser::ExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprNot(this);
}

std::any MySQLParser::ExprNotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprNot(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprIsContext ------------------------------------------------------------------

MySQLParser::BoolPriContext *MySQLParser::ExprIsContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode *MySQLParser::ExprIsContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExprIsContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExprIsContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExprIsContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::ExprIsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::ExprIsContext::ExprIsContext(ExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::ExprIsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprIs(this);
}
void MySQLParser::ExprIsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprIs(this);
}

std::any MySQLParser::ExprIsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprIs(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprAndContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprAndContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ExprAndContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::ExprAndContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ExprAndContext::LOGICAL_AND_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_AND_OPERATOR, 0);
}

MySQLParser::ExprAndContext::ExprAndContext(ExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::ExprAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprAnd(this);
}
void MySQLParser::ExprAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprAnd(this);
}

std::any MySQLParser::ExprAndContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprAnd(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ExprXorContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprXorContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ExprXorContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::ExprXorContext::XOR_SYMBOL() {
  return getToken(MySQLParser::XOR_SYMBOL, 0);
}

MySQLParser::ExprXorContext::ExprXorContext(ExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::ExprXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprXor(this);
}
void MySQLParser::ExprXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprXor(this);
}

std::any MySQLParser::ExprXorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprXor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprContext *MySQLParser::expr() {
  return expr(0);
}

MySQLParser::ExprContext *MySQLParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  MySQLParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 860;
  enterRecursionRule(_localctx, 860, MySQLParser::RuleExpr, precedence);

  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6062);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 725, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<ExprIsContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(6052);
        boolPri(0);
        setState(6058);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 724, _ctx)) {
          case 1: {
            setState(6053);
            match(MySQLParser::IS_SYMBOL);
            setState(6055);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::NOT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL) {
              setState(6054);
              notRule();
            }
            setState(6057);
            antlrcpp::downCast<ExprIsContext *>(_localctx)->type = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL

                  || _la == MySQLParser::UNKNOWN_SYMBOL)) {
              antlrcpp::downCast<ExprIsContext *>(_localctx)->type = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<ExprNotContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6060);
        match(MySQLParser::NOT_SYMBOL);
        setState(6061);
        expr(4);
        break;
      }

      default:
        break;
    }
    _ctx->stop = _input->LT(-1);
    setState(6075);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6073);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 726, _ctx)) {
          case 1: {
            auto newContext =
              _tracker.createInstance<ExprAndContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleExpr);
            setState(6064);

            if (!(precpred(_ctx, 3)))
              throw FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(6065);
            antlrcpp::downCast<ExprAndContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::AND_SYMBOL || _la == MySQLParser::LOGICAL_AND_OPERATOR)) {
              antlrcpp::downCast<ExprAndContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6066);
            expr(4);
            break;
          }

          case 2: {
            auto newContext =
              _tracker.createInstance<ExprXorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleExpr);
            setState(6067);

            if (!(precpred(_ctx, 2)))
              throw FailedPredicateException(this, "precpred(_ctx, 2)");
            setState(6068);
            match(MySQLParser::XOR_SYMBOL);
            setState(6069);
            expr(3);
            break;
          }

          case 3: {
            auto newContext =
              _tracker.createInstance<ExprOrContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleExpr);
            setState(6070);

            if (!(precpred(_ctx, 1)))
              throw FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(6071);
            antlrcpp::downCast<ExprOrContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::OR_SYMBOL || _la == MySQLParser::LOGICAL_OR_OPERATOR)) {
              antlrcpp::downCast<ExprOrContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6072);
            expr(2);
            break;
          }

          default:
            break;
        }
      }
      setState(6077);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx);
    }
  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- BoolPriContext ------------------------------------------------------------------

MySQLParser::BoolPriContext::BoolPriContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

size_t MySQLParser::BoolPriContext::getRuleIndex() const {
  return MySQLParser::RuleBoolPri;
}

void MySQLParser::BoolPriContext::copyFrom(BoolPriContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryExprPredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext *MySQLParser::PrimaryExprPredicateContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprPredicateContext::PrimaryExprPredicateContext(BoolPriContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PrimaryExprPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprPredicate(this);
}
void MySQLParser::PrimaryExprPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprPredicate(this);
}

std::any MySQLParser::PrimaryExprPredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrimaryExprPredicate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprCompareContext ------------------------------------------------------------------

MySQLParser::BoolPriContext *MySQLParser::PrimaryExprCompareContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext *MySQLParser::PrimaryExprCompareContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::PredicateContext *MySQLParser::PrimaryExprCompareContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprCompareContext::PrimaryExprCompareContext(BoolPriContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PrimaryExprCompareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprCompare(this);
}
void MySQLParser::PrimaryExprCompareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprCompare(this);
}

std::any MySQLParser::PrimaryExprCompareContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrimaryExprCompare(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprAllAnyContext ------------------------------------------------------------------

MySQLParser::BoolPriContext *MySQLParser::PrimaryExprAllAnyContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext *MySQLParser::PrimaryExprAllAnyContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::SubqueryContext *MySQLParser::PrimaryExprAllAnyContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode *MySQLParser::PrimaryExprAllAnyContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PrimaryExprAllAnyContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

MySQLParser::PrimaryExprAllAnyContext::PrimaryExprAllAnyContext(BoolPriContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PrimaryExprAllAnyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprAllAny(this);
}
void MySQLParser::PrimaryExprAllAnyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprAllAny(this);
}

std::any MySQLParser::PrimaryExprAllAnyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrimaryExprAllAny(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PrimaryExprIsNullContext ------------------------------------------------------------------

MySQLParser::BoolPriContext *MySQLParser::PrimaryExprIsNullContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode *MySQLParser::PrimaryExprIsNullContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PrimaryExprIsNullContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::PrimaryExprIsNullContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::PrimaryExprIsNullContext::PrimaryExprIsNullContext(BoolPriContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PrimaryExprIsNullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprIsNull(this);
}
void MySQLParser::PrimaryExprIsNullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprIsNull(this);
}

std::any MySQLParser::PrimaryExprIsNullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrimaryExprIsNull(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BoolPriContext *MySQLParser::boolPri() {
  return boolPri(0);
}

MySQLParser::BoolPriContext *MySQLParser::boolPri(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BoolPriContext *_localctx = _tracker.createInstance<BoolPriContext>(_ctx, parentState);
  MySQLParser::BoolPriContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 862;
  enterRecursionRule(_localctx, 862, MySQLParser::RuleBoolPri, precedence);

  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryExprPredicateContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(6079);
    predicate();
    _ctx->stop = _input->LT(-1);
    setState(6098);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 730, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6096);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 729, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<PrimaryExprIsNullContext>(
              _tracker.createInstance<BoolPriContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleBoolPri);
            setState(6081);

            if (!(precpred(_ctx, 3)))
              throw FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(6082);
            match(MySQLParser::IS_SYMBOL);
            setState(6084);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::NOT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL) {
              setState(6083);
              notRule();
            }
            setState(6086);
            match(MySQLParser::NULL_SYMBOL);
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<PrimaryExprCompareContext>(
              _tracker.createInstance<BoolPriContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleBoolPri);
            setState(6087);

            if (!(precpred(_ctx, 2)))
              throw FailedPredicateException(this, "precpred(_ctx, 2)");
            setState(6088);
            compOp();
            setState(6089);
            predicate();
            break;
          }

          case 3: {
            auto newContext = _tracker.createInstance<PrimaryExprAllAnyContext>(
              _tracker.createInstance<BoolPriContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleBoolPri);
            setState(6091);

            if (!(precpred(_ctx, 1)))
              throw FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(6092);
            compOp();
            setState(6093);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::ALL_SYMBOL

                  || _la == MySQLParser::ANY_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6094);
            subquery();
            break;
          }

          default:
            break;
        }
      }
      setState(6100);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 730, _ctx);
    }
  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- CompOpContext ------------------------------------------------------------------

MySQLParser::CompOpContext::CompOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CompOpContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::NULL_SAFE_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NULL_SAFE_EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CompOpContext::NOT_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NOT_EQUAL_OPERATOR, 0);
}

size_t MySQLParser::CompOpContext::getRuleIndex() const {
  return MySQLParser::RuleCompOp;
}

void MySQLParser::CompOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompOp(this);
}

void MySQLParser::CompOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompOp(this);
}

std::any MySQLParser::CompOpContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCompOp(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompOpContext *MySQLParser::compOp() {
  CompOpContext *_localctx = _tracker.createInstance<CompOpContext>(_ctx, getState());
  enterRule(_localctx, 864, MySQLParser::RuleCompOp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6101);
    _la = _input->LA(1);
    if (!(((((_la - 750) & ~0x3fULL) == 0) && ((1ULL << (_la - 750)) & 253) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::PredicateContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext *MySQLParser::PredicateContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

MySQLParser::PredicateOperationsContext *MySQLParser::PredicateContext::predicateOperations() {
  return getRuleContext<MySQLParser::PredicateOperationsContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateContext::MEMBER_SYMBOL() {
  return getToken(MySQLParser::MEMBER_SYMBOL, 0);
}

MySQLParser::SimpleExprWithParenthesesContext *MySQLParser::PredicateContext::simpleExprWithParentheses() {
  return getRuleContext<MySQLParser::SimpleExprWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PredicateContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::PredicateContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateContext::OF_SYMBOL() {
  return getToken(MySQLParser::OF_SYMBOL, 0);
}

size_t MySQLParser::PredicateContext::getRuleIndex() const {
  return MySQLParser::RulePredicate;
}

void MySQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void MySQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

std::any MySQLParser::PredicateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPredicate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PredicateContext *MySQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 866, MySQLParser::RulePredicate);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6103);
    bitExpr(0);
    setState(6117);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 733, _ctx)) {
      case 1: {
        setState(6105);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL) {
          setState(6104);
          notRule();
        }
        setState(6107);
        predicateOperations();
        break;
      }

      case 2: {
        setState(6108);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(6109);
        match(MySQLParser::MEMBER_SYMBOL);
        setState(6111);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OF_SYMBOL) {
          setState(6110);
          match(MySQLParser::OF_SYMBOL);
        }
        setState(6113);
        simpleExprWithParentheses();
        break;
      }

      case 3: {
        setState(6114);
        match(MySQLParser::SOUNDS_SYMBOL);
        setState(6115);
        match(MySQLParser::LIKE_SYMBOL);
        setState(6116);
        bitExpr(0);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateOperationsContext ------------------------------------------------------------------

MySQLParser::PredicateOperationsContext::PredicateOperationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

size_t MySQLParser::PredicateOperationsContext::getRuleIndex() const {
  return MySQLParser::RulePredicateOperations;
}

void MySQLParser::PredicateOperationsContext::copyFrom(PredicateOperationsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PredicateExprRegexContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PredicateExprRegexContext::REGEXP_SYMBOL() {
  return getToken(MySQLParser::REGEXP_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::PredicateExprRegexContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

MySQLParser::PredicateExprRegexContext::PredicateExprRegexContext(PredicateOperationsContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PredicateExprRegexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprRegex(this);
}
void MySQLParser::PredicateExprRegexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprRegex(this);
}

std::any MySQLParser::PredicateExprRegexContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPredicateExprRegex(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprBetweenContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PredicateExprBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::PredicateExprBetweenContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateExprBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

MySQLParser::PredicateContext *MySQLParser::PredicateExprBetweenContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PredicateExprBetweenContext::PredicateExprBetweenContext(PredicateOperationsContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PredicateExprBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprBetween(this);
}
void MySQLParser::PredicateExprBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprBetween(this);
}

std::any MySQLParser::PredicateExprBetweenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPredicateExprBetween(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprInContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PredicateExprInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::SubqueryContext *MySQLParser::PredicateExprInContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateExprInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::PredicateExprInContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::PredicateExprInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PredicateExprInContext::PredicateExprInContext(PredicateOperationsContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PredicateExprInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprIn(this);
}
void MySQLParser::PredicateExprInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprIn(this);
}

std::any MySQLParser::PredicateExprInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPredicateExprIn(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PredicateExprLikeContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PredicateExprLikeContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::PredicateExprLikeContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext *MySQLParser::PredicateExprLikeContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode *MySQLParser::PredicateExprLikeContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

MySQLParser::PredicateExprLikeContext::PredicateExprLikeContext(PredicateOperationsContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PredicateExprLikeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprLike(this);
}
void MySQLParser::PredicateExprLikeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprLike(this);
}

std::any MySQLParser::PredicateExprLikeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPredicateExprLike(this);
  else
    return visitor->visitChildren(this);
}
MySQLParser::PredicateOperationsContext *MySQLParser::predicateOperations() {
  PredicateOperationsContext *_localctx = _tracker.createInstance<PredicateOperationsContext>(_ctx, getState());
  enterRule(_localctx, 868, MySQLParser::RulePredicateOperations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6140);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::IN_SYMBOL: {
        _localctx = _tracker.createInstance<MySQLParser::PredicateExprInContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(6119);
        match(MySQLParser::IN_SYMBOL);
        setState(6125);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 734, _ctx)) {
          case 1: {
            setState(6120);
            subquery();
            break;
          }

          case 2: {
            setState(6121);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(6122);
            exprList();
            setState(6123);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        _localctx = _tracker.createInstance<MySQLParser::PredicateExprBetweenContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(6127);
        match(MySQLParser::BETWEEN_SYMBOL);
        setState(6128);
        bitExpr(0);
        setState(6129);
        match(MySQLParser::AND_SYMBOL);
        setState(6130);
        predicate();
        break;
      }

      case MySQLParser::LIKE_SYMBOL: {
        _localctx = _tracker.createInstance<MySQLParser::PredicateExprLikeContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(6132);
        match(MySQLParser::LIKE_SYMBOL);
        setState(6133);
        simpleExpr(0);
        setState(6136);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 735, _ctx)) {
          case 1: {
            setState(6134);
            match(MySQLParser::ESCAPE_SYMBOL);
            setState(6135);
            simpleExpr(0);
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::REGEXP_SYMBOL: {
        _localctx = _tracker.createInstance<MySQLParser::PredicateExprRegexContext>(_localctx);
        enterOuterAlt(_localctx, 4);
        setState(6138);
        match(MySQLParser::REGEXP_SYMBOL);
        setState(6139);
        bitExpr(0);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExprContext ------------------------------------------------------------------

MySQLParser::BitExprContext::BitExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleExprContext *MySQLParser::BitExprContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::BitExprContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext *MySQLParser::BitExprContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

tree::TerminalNode *MySQLParser::BitExprContext::BITWISE_XOR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_XOR_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::DIV_OPERATOR() {
  return getToken(MySQLParser::DIV_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::MOD_OPERATOR() {
  return getToken(MySQLParser::MOD_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::DIV_SYMBOL() {
  return getToken(MySQLParser::DIV_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::SHIFT_LEFT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_LEFT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::SHIFT_RIGHT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_RIGHT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::BITWISE_AND_OPERATOR() {
  return getToken(MySQLParser::BITWISE_AND_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::BITWISE_OR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_OR_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::BitExprContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::BitExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext *MySQLParser::BitExprContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

size_t MySQLParser::BitExprContext::getRuleIndex() const {
  return MySQLParser::RuleBitExpr;
}

void MySQLParser::BitExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExpr(this);
}

void MySQLParser::BitExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExpr(this);
}

std::any MySQLParser::BitExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitBitExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BitExprContext *MySQLParser::bitExpr() {
  return bitExpr(0);
}

MySQLParser::BitExprContext *MySQLParser::bitExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BitExprContext *_localctx = _tracker.createInstance<BitExprContext>(_ctx, parentState);
  MySQLParser::BitExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 870;
  enterRecursionRule(_localctx, 870, MySQLParser::RuleBitExpr, precedence);

  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6143);
    simpleExpr(0);
    _ctx->stop = _input->LT(-1);
    setState(6171);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 738, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6169);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 737, _ctx)) {
          case 1: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6145);

            if (!(precpred(_ctx, 7)))
              throw FailedPredicateException(this, "precpred(_ctx, 7)");
            setState(6146);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_XOR_OPERATOR);
            setState(6147);
            bitExpr(8);
            break;
          }

          case 2: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6148);

            if (!(precpred(_ctx, 6)))
              throw FailedPredicateException(this, "precpred(_ctx, 6)");
            setState(6149);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::DIV_SYMBOL || _la == MySQLParser::MOD_SYMBOL ||
                  ((((_la - 760) & ~0x3fULL) == 0) && ((1ULL << (_la - 760)) & 7) != 0))) {
              antlrcpp::downCast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6150);
            bitExpr(7);
            break;
          }

          case 3: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6151);

            if (!(precpred(_ctx, 5)))
              throw FailedPredicateException(this, "precpred(_ctx, 5)");
            setState(6152);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::PLUS_OPERATOR

                  || _la == MySQLParser::MINUS_OPERATOR)) {
              antlrcpp::downCast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6153);
            bitExpr(6);
            break;
          }

          case 4: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6154);

            if (!(precpred(_ctx, 3)))
              throw FailedPredicateException(this, "precpred(_ctx, 3)");
            setState(6155);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::SHIFT_LEFT_OPERATOR

                  || _la == MySQLParser::SHIFT_RIGHT_OPERATOR)) {
              antlrcpp::downCast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6156);
            bitExpr(4);
            break;
          }

          case 5: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6157);

            if (!(precpred(_ctx, 2)))
              throw FailedPredicateException(this, "precpred(_ctx, 2)");
            setState(6158);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_AND_OPERATOR);
            setState(6159);
            bitExpr(3);
            break;
          }

          case 6: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6160);

            if (!(precpred(_ctx, 1)))
              throw FailedPredicateException(this, "precpred(_ctx, 1)");
            setState(6161);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_OR_OPERATOR);
            setState(6162);
            bitExpr(2);
            break;
          }

          case 7: {
            _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
            pushNewRecursionContext(_localctx, startState, RuleBitExpr);
            setState(6163);

            if (!(precpred(_ctx, 4)))
              throw FailedPredicateException(this, "precpred(_ctx, 4)");
            setState(6164);
            antlrcpp::downCast<BitExprContext *>(_localctx)->op = _input->LT(1);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::PLUS_OPERATOR

                  || _la == MySQLParser::MINUS_OPERATOR)) {
              antlrcpp::downCast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            setState(6165);
            match(MySQLParser::INTERVAL_SYMBOL);
            setState(6166);
            expr(0);
            setState(6167);
            interval();
            break;
          }

          default:
            break;
        }
      }
      setState(6173);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 738, _ctx);
    }
  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- SimpleExprContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext::SimpleExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

size_t MySQLParser::SimpleExprContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleExpr;
}

void MySQLParser::SimpleExprContext::copyFrom(SimpleExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SimpleExprConvertContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprConvertContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::CastTypeContext *MySQLParser::SimpleExprConvertContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertContext::SimpleExprConvertContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvert(this);
}
void MySQLParser::SimpleExprConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvert(this);
}

std::any MySQLParser::SimpleExprConvertContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprConvert(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCastContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprCastContext::CAST_SYMBOL() {
  return getToken(MySQLParser::CAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprCastContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::CastTypeContext *MySQLParser::SimpleExprCastContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

MySQLParser::ArrayCastContext *MySQLParser::SimpleExprCastContext::arrayCast() {
  return getRuleContext<MySQLParser::ArrayCastContext>(0);
}

MySQLParser::SimpleExprCastContext::SimpleExprCastContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprCastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCast(this);
}
void MySQLParser::SimpleExprCastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCast(this);
}

std::any MySQLParser::SimpleExprCastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprCast(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprUnaryContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprUnaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprUnaryContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprUnaryContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprUnaryContext::BITWISE_NOT_OPERATOR() {
  return getToken(MySQLParser::BITWISE_NOT_OPERATOR, 0);
}

MySQLParser::SimpleExprUnaryContext::SimpleExprUnaryContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprUnary(this);
}
void MySQLParser::SimpleExprUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprUnary(this);
}

std::any MySQLParser::SimpleExprUnaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprUnary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExpressionRValueContext ------------------------------------------------------------------

MySQLParser::RvalueSystemOrUserVariableContext *
MySQLParser::SimpleExpressionRValueContext::rvalueSystemOrUserVariable() {
  return getRuleContext<MySQLParser::RvalueSystemOrUserVariableContext>(0);
}

MySQLParser::SimpleExpressionRValueContext::SimpleExpressionRValueContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExpressionRValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExpressionRValue(this);
}
void MySQLParser::SimpleExpressionRValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExpressionRValue(this);
}

std::any MySQLParser::SimpleExpressionRValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExpressionRValue(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprOdbcContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprOdbcContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::SimpleExprOdbcContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprOdbcContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprOdbcContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

MySQLParser::SimpleExprOdbcContext::SimpleExprOdbcContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprOdbcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprOdbc(this);
}
void MySQLParser::SimpleExprOdbcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprOdbc(this);
}

std::any MySQLParser::SimpleExprOdbcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprOdbc(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprRuntimeFunctionContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext *MySQLParser::SimpleExprRuntimeFunctionContext::runtimeFunctionCall() {
  return getRuleContext<MySQLParser::RuntimeFunctionCallContext>(0);
}

MySQLParser::SimpleExprRuntimeFunctionContext::SimpleExprRuntimeFunctionContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprRuntimeFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprRuntimeFunction(this);
}
void MySQLParser::SimpleExprRuntimeFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprRuntimeFunction(this);
}

std::any MySQLParser::SimpleExprRuntimeFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprRuntimeFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprFunctionContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext *MySQLParser::SimpleExprFunctionContext::functionCall() {
  return getRuleContext<MySQLParser::FunctionCallContext>(0);
}

MySQLParser::SimpleExprFunctionContext::SimpleExprFunctionContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprFunction(this);
}
void MySQLParser::SimpleExprFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprFunction(this);
}

std::any MySQLParser::SimpleExprFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCollateContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprCollateContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::SimpleExprCollateContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::SimpleExprCollateContext::SimpleExprCollateContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCollate(this);
}
void MySQLParser::SimpleExprCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCollate(this);
}

std::any MySQLParser::SimpleExprCollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprCollate(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprMatchContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprMatchContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

MySQLParser::IdentListArgContext *MySQLParser::SimpleExprMatchContext::identListArg() {
  return getRuleContext<MySQLParser::IdentListArgContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprMatchContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprMatchContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::SimpleExprMatchContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprMatchContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FulltextOptionsContext *MySQLParser::SimpleExprMatchContext::fulltextOptions() {
  return getRuleContext<MySQLParser::FulltextOptionsContext>(0);
}

MySQLParser::SimpleExprMatchContext::SimpleExprMatchContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprMatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprMatch(this);
}
void MySQLParser::SimpleExprMatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprMatch(this);
}

std::any MySQLParser::SimpleExprMatchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprMatch(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprWindowingFunctionContext
//------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext *MySQLParser::SimpleExprWindowingFunctionContext::windowFunctionCall() {
  return getRuleContext<MySQLParser::WindowFunctionCallContext>(0);
}

MySQLParser::SimpleExprWindowingFunctionContext::SimpleExprWindowingFunctionContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprWindowingFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprWindowingFunction(this);
}
void MySQLParser::SimpleExprWindowingFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprWindowingFunction(this);
}

std::any MySQLParser::SimpleExprWindowingFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprWindowingFunction(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprBinaryContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprBinaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprBinaryContext::SimpleExprBinaryContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprBinary(this);
}
void MySQLParser::SimpleExprBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprBinary(this);
}

std::any MySQLParser::SimpleExprBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprBinary(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext *MySQLParser::SimpleExprColumnRefContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::JsonOperatorContext *MySQLParser::SimpleExprColumnRefContext::jsonOperator() {
  return getRuleContext<MySQLParser::JsonOperatorContext>(0);
}

MySQLParser::SimpleExprColumnRefContext::SimpleExprColumnRefContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprColumnRef(this);
}
void MySQLParser::SimpleExprColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprColumnRef(this);
}

std::any MySQLParser::SimpleExprColumnRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprColumnRef(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprParamMarkerContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprParamMarkerContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::SimpleExprParamMarkerContext::SimpleExprParamMarkerContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprParamMarkerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprParamMarker(this);
}
void MySQLParser::SimpleExprParamMarkerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprParamMarker(this);
}

std::any MySQLParser::SimpleExprParamMarkerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprParamMarker(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprSumContext ------------------------------------------------------------------

MySQLParser::SumExprContext *MySQLParser::SimpleExprSumContext::sumExpr() {
  return getRuleContext<MySQLParser::SumExprContext>(0);
}

MySQLParser::SimpleExprSumContext::SimpleExprSumContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprSumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSum(this);
}
void MySQLParser::SimpleExprSumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSum(this);
}

std::any MySQLParser::SimpleExprSumContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprSum(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCastTimeContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::CAST_SYMBOL() {
  return getToken(MySQLParser::CAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprCastTimeContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::ZONE_SYMBOL() {
  return getToken(MySQLParser::ZONE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::SimpleExprCastTimeContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext *MySQLParser::SimpleExprCastTimeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCastTimeContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::SimpleExprCastTimeContext::SimpleExprCastTimeContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprCastTimeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCastTime(this);
}
void MySQLParser::SimpleExprCastTimeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCastTime(this);
}

std::any MySQLParser::SimpleExprCastTimeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprCastTime(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprConvertUsingContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprConvertUsingContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertUsingContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprConvertUsingContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertUsingContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext *MySQLParser::SimpleExprConvertUsingContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprConvertUsingContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertUsingContext::SimpleExprConvertUsingContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprConvertUsingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvertUsing(this);
}
void MySQLParser::SimpleExprConvertUsingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvertUsing(this);
}

std::any MySQLParser::SimpleExprConvertUsingContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprConvertUsing(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprSubQueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext *MySQLParser::SimpleExprSubQueryContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprSubQueryContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::SimpleExprSubQueryContext::SimpleExprSubQueryContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprSubQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSubQuery(this);
}
void MySQLParser::SimpleExprSubQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSubQuery(this);
}

std::any MySQLParser::SimpleExprSubQueryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprSubQuery(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprGroupingOperationContext
//------------------------------------------------------------------

MySQLParser::GroupingOperationContext *MySQLParser::SimpleExprGroupingOperationContext::groupingOperation() {
  return getRuleContext<MySQLParser::GroupingOperationContext>(0);
}

MySQLParser::SimpleExprGroupingOperationContext::SimpleExprGroupingOperationContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprGroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprGroupingOperation(this);
}
void MySQLParser::SimpleExprGroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprGroupingOperation(this);
}

std::any MySQLParser::SimpleExprGroupingOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprGroupingOperation(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprNotContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext *MySQLParser::SimpleExprNotContext::not2Rule() {
  return getRuleContext<MySQLParser::Not2RuleContext>(0);
}

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprNotContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprNotContext::SimpleExprNotContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprNot(this);
}
void MySQLParser::SimpleExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprNot(this);
}

std::any MySQLParser::SimpleExprNotContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprNot(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprValuesContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprValuesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext *MySQLParser::SimpleExprValuesContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprValuesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprValuesContext::SimpleExprValuesContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprValues(this);
}
void MySQLParser::SimpleExprValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprValues(this);
}

std::any MySQLParser::SimpleExprValuesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprValues(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprUserVariableAssignmentContext
//------------------------------------------------------------------

MySQLParser::InExpressionUserVariableAssignmentContext *
MySQLParser::SimpleExprUserVariableAssignmentContext::inExpressionUserVariableAssignment() {
  return getRuleContext<MySQLParser::InExpressionUserVariableAssignmentContext>(0);
}

MySQLParser::SimpleExprUserVariableAssignmentContext::SimpleExprUserVariableAssignmentContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprUserVariableAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprUserVariableAssignment(this);
}
void MySQLParser::SimpleExprUserVariableAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprUserVariableAssignment(this);
}

std::any MySQLParser::SimpleExprUserVariableAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprUserVariableAssignment(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprDefaultContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprDefaultContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext *MySQLParser::SimpleExprDefaultContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprDefaultContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprDefaultContext::SimpleExprDefaultContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprDefault(this);
}
void MySQLParser::SimpleExprDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprDefault(this);
}

std::any MySQLParser::SimpleExprDefaultContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprDefault(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprListContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::SimpleExprListContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprListContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::SimpleExprListContext::SimpleExprListContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprList(this);
}
void MySQLParser::SimpleExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprList(this);
}

std::any MySQLParser::SimpleExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprList(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprIntervalContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprIntervalContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SimpleExprIntervalContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::SimpleExprIntervalContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

MySQLParser::IntervalContext *MySQLParser::SimpleExprIntervalContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprIntervalContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::SimpleExprIntervalContext::SimpleExprIntervalContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprIntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprInterval(this);
}
void MySQLParser::SimpleExprIntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprInterval(this);
}

std::any MySQLParser::SimpleExprIntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprInterval(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprCaseContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::SimpleExprCaseContext::CASE_SYMBOL() {
  return getToken(MySQLParser::CASE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SimpleExprCaseContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::SimpleExprCaseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::SimpleExprCaseContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext *MySQLParser::SimpleExprCaseContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenExpressionContext *> MySQLParser::SimpleExprCaseContext::thenExpression() {
  return getRuleContexts<MySQLParser::ThenExpressionContext>();
}

MySQLParser::ThenExpressionContext *MySQLParser::SimpleExprCaseContext::thenExpression(size_t i) {
  return getRuleContext<MySQLParser::ThenExpressionContext>(i);
}

MySQLParser::ElseExpressionContext *MySQLParser::SimpleExprCaseContext::elseExpression() {
  return getRuleContext<MySQLParser::ElseExpressionContext>(0);
}

MySQLParser::SimpleExprCaseContext::SimpleExprCaseContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCase(this);
}
void MySQLParser::SimpleExprCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCase(this);
}

std::any MySQLParser::SimpleExprCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprCase(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprConcatContext ------------------------------------------------------------------

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::SimpleExprConcatContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprConcatContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode *MySQLParser::SimpleExprConcatContext::CONCAT_PIPES_SYMBOL() {
  return getToken(MySQLParser::CONCAT_PIPES_SYMBOL, 0);
}

MySQLParser::SimpleExprConcatContext::SimpleExprConcatContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprConcatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConcat(this);
}
void MySQLParser::SimpleExprConcatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConcat(this);
}

std::any MySQLParser::SimpleExprConcatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprConcat(this);
  else
    return visitor->visitChildren(this);
}
//----------------- SimpleExprLiteralContext ------------------------------------------------------------------

MySQLParser::LiteralOrNullContext *MySQLParser::SimpleExprLiteralContext::literalOrNull() {
  return getRuleContext<MySQLParser::LiteralOrNullContext>(0);
}

MySQLParser::SimpleExprLiteralContext::SimpleExprLiteralContext(SimpleExprContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::SimpleExprLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprLiteral(this);
}
void MySQLParser::SimpleExprLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprLiteral(this);
}

std::any MySQLParser::SimpleExprLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleExprContext *MySQLParser::simpleExpr() {
  return simpleExpr(0);
}

MySQLParser::SimpleExprContext *MySQLParser::simpleExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::SimpleExprContext *_localctx = _tracker.createInstance<SimpleExprContext>(_ctx, parentState);
  MySQLParser::SimpleExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 872;
  enterRecursionRule(_localctx, 872, MySQLParser::RuleSimpleExpr, precedence);

  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6296);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 749, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<SimpleExprColumnRefContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(6175);
        columnRef();
        setState(6177);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 739, _ctx)) {
          case 1: {
            setState(6176);
            jsonOperator();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<SimpleExprRuntimeFunctionContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6179);
        runtimeFunctionCall();
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<SimpleExprFunctionContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6180);
        functionCall();
        break;
      }

      case 4: {
        _localctx = _tracker.createInstance<SimpleExprLiteralContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6181);
        literalOrNull();
        break;
      }

      case 5: {
        _localctx = _tracker.createInstance<SimpleExprParamMarkerContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6182);
        match(MySQLParser::PARAM_MARKER);
        break;
      }

      case 6: {
        _localctx = _tracker.createInstance<SimpleExpressionRValueContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6183);
        rvalueSystemOrUserVariable();
        break;
      }

      case 7: {
        _localctx = _tracker.createInstance<SimpleExprUserVariableAssignmentContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6184);
        inExpressionUserVariableAssignment();
        break;
      }

      case 8: {
        _localctx = _tracker.createInstance<SimpleExprSumContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6185);
        sumExpr();
        break;
      }

      case 9: {
        _localctx = _tracker.createInstance<SimpleExprGroupingOperationContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6186);
        groupingOperation();
        break;
      }

      case 10: {
        _localctx = _tracker.createInstance<SimpleExprWindowingFunctionContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6187);
        windowFunctionCall();
        break;
      }

      case 11: {
        _localctx = _tracker.createInstance<SimpleExprUnaryContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6188);
        antlrcpp::downCast<SimpleExprUnaryContext *>(_localctx)->op = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 758) & ~0x3fULL) == 0) && ((1ULL << (_la - 758)) & 67) != 0))) {
          antlrcpp::downCast<SimpleExprUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6189);
        simpleExpr(15);
        break;
      }

      case 12: {
        _localctx = _tracker.createInstance<SimpleExprNotContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6190);
        not2Rule();
        setState(6191);
        simpleExpr(14);
        break;
      }

      case 13: {
        _localctx = _tracker.createInstance<SimpleExprListContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6194);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ROW_SYMBOL) {
          setState(6193);
          match(MySQLParser::ROW_SYMBOL);
        }
        setState(6196);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6197);
        exprList();
        setState(6198);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 14: {
        _localctx = _tracker.createInstance<SimpleExprSubQueryContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6201);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXISTS_SYMBOL) {
          setState(6200);
          match(MySQLParser::EXISTS_SYMBOL);
        }
        setState(6203);
        subquery();
        break;
      }

      case 15: {
        _localctx = _tracker.createInstance<SimpleExprOdbcContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6204);
        match(MySQLParser::OPEN_CURLY_SYMBOL);
        setState(6205);
        identifier();
        setState(6206);
        expr(0);
        setState(6207);
        match(MySQLParser::CLOSE_CURLY_SYMBOL);
        break;
      }

      case 16: {
        _localctx = _tracker.createInstance<SimpleExprMatchContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6209);
        match(MySQLParser::MATCH_SYMBOL);
        setState(6210);
        identListArg();
        setState(6211);
        match(MySQLParser::AGAINST_SYMBOL);
        setState(6212);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6213);
        bitExpr(0);
        setState(6215);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IN_SYMBOL || _la == MySQLParser::WITH_SYMBOL) {
          setState(6214);
          fulltextOptions();
        }
        setState(6217);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 17: {
        _localctx = _tracker.createInstance<SimpleExprBinaryContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6219);
        match(MySQLParser::BINARY_SYMBOL);
        setState(6220);
        simpleExpr(9);
        break;
      }

      case 18: {
        _localctx = _tracker.createInstance<SimpleExprCastContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6221);
        match(MySQLParser::CAST_SYMBOL);
        setState(6222);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6223);
        expr(0);
        setState(6226);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AT_SYMBOL) {
          setState(6224);
          match(MySQLParser::AT_SYMBOL);
          setState(6225);
          match(MySQLParser::LOCAL_SYMBOL);
        }
        setState(6228);
        match(MySQLParser::AS_SYMBOL);
        setState(6229);
        castType();
        setState(6231);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 744, _ctx)) {
          case 1: {
            setState(6230);
            arrayCast();
            break;
          }

          default:
            break;
        }
        setState(6233);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 19: {
        _localctx = _tracker.createInstance<SimpleExprCastTimeContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6235);
        match(MySQLParser::CAST_SYMBOL);
        setState(6236);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6237);
        expr(0);
        setState(6238);
        match(MySQLParser::AT_SYMBOL);
        setState(6239);
        match(MySQLParser::TIME_SYMBOL);
        setState(6240);
        match(MySQLParser::ZONE_SYMBOL);
        setState(6242);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 745, _ctx)) {
          case 1: {
            setState(6241);
            match(MySQLParser::INTERVAL_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(6244);
        textStringLiteral();
        setState(6245);
        match(MySQLParser::AS_SYMBOL);
        setState(6246);
        match(MySQLParser::DATETIME_SYMBOL);
        setState(6247);
        typeDatetimePrecision();
        setState(6248);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 20: {
        _localctx = _tracker.createInstance<SimpleExprCaseContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6250);
        match(MySQLParser::CASE_SYMBOL);
        setState(6252);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 746, _ctx)) {
          case 1: {
            setState(6251);
            expr(0);
            break;
          }

          default:
            break;
        }
        setState(6257);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(6254);
          whenExpression();
          setState(6255);
          thenExpression();
          setState(6259);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySQLParser::WHEN_SYMBOL);
        setState(6262);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ELSE_SYMBOL) {
          setState(6261);
          elseExpression();
        }
        setState(6264);
        match(MySQLParser::END_SYMBOL);
        break;
      }

      case 21: {
        _localctx = _tracker.createInstance<SimpleExprConvertContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6266);
        match(MySQLParser::CONVERT_SYMBOL);
        setState(6267);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6268);
        expr(0);
        setState(6269);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6270);
        castType();
        setState(6271);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 22: {
        _localctx = _tracker.createInstance<SimpleExprConvertUsingContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6273);
        match(MySQLParser::CONVERT_SYMBOL);
        setState(6274);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6275);
        expr(0);
        setState(6276);
        match(MySQLParser::USING_SYMBOL);
        setState(6277);
        charsetName();
        setState(6278);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 23: {
        _localctx = _tracker.createInstance<SimpleExprDefaultContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6280);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(6281);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6282);
        simpleIdentifier();
        setState(6283);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 24: {
        _localctx = _tracker.createInstance<SimpleExprValuesContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6285);
        match(MySQLParser::VALUES_SYMBOL);
        setState(6286);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6287);
        simpleIdentifier();
        setState(6288);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 25: {
        _localctx = _tracker.createInstance<SimpleExprIntervalContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(6290);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(6291);
        expr(0);
        setState(6292);
        interval();
        setState(6293);
        match(MySQLParser::PLUS_OPERATOR);
        setState(6294);
        expr(0);
        break;
      }

      default:
        break;
    }
    _ctx->stop = _input->LT(-1);
    setState(6306);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 751, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(6304);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 750, _ctx)) {
          case 1: {
            auto newContext = _tracker.createInstance<SimpleExprConcatContext>(
              _tracker.createInstance<SimpleExprContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
            setState(6298);

            if (!(precpred(_ctx, 16)))
              throw FailedPredicateException(this, "precpred(_ctx, 16)");
            setState(6299);
            match(MySQLParser::CONCAT_PIPES_SYMBOL);
            setState(6300);
            simpleExpr(17);
            break;
          }

          case 2: {
            auto newContext = _tracker.createInstance<SimpleExprCollateContext>(
              _tracker.createInstance<SimpleExprContext>(parentContext, parentState));
            _localctx = newContext;
            pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
            setState(6301);

            if (!(precpred(_ctx, 24)))
              throw FailedPredicateException(this, "precpred(_ctx, 24)");
            setState(6302);
            match(MySQLParser::COLLATE_SYMBOL);
            setState(6303);
            textOrIdentifier();
            break;
          }

          default:
            break;
        }
      }
      setState(6308);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 751, _ctx);
    }
  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ArrayCastContext ------------------------------------------------------------------

MySQLParser::ArrayCastContext::ArrayCastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ArrayCastContext::ARRAY_SYMBOL() {
  return getToken(MySQLParser::ARRAY_SYMBOL, 0);
}

size_t MySQLParser::ArrayCastContext::getRuleIndex() const {
  return MySQLParser::RuleArrayCast;
}

void MySQLParser::ArrayCastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayCast(this);
}

void MySQLParser::ArrayCastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayCast(this);
}

std::any MySQLParser::ArrayCastContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitArrayCast(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ArrayCastContext *MySQLParser::arrayCast() {
  ArrayCastContext *_localctx = _tracker.createInstance<ArrayCastContext>(_ctx, getState());
  enterRule(_localctx, 874, MySQLParser::RuleArrayCast);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6309);

    if (!(serverVersion >= 80017))
      throw FailedPredicateException(this, "serverVersion >= 80017");
    setState(6310);
    match(MySQLParser::ARRAY_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOperatorContext ------------------------------------------------------------------

MySQLParser::JsonOperatorContext::JsonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::JsonOperatorContext::JSON_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::JsonOperatorContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::JsonOperatorContext::JSON_UNQUOTED_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL, 0);
}

size_t MySQLParser::JsonOperatorContext::getRuleIndex() const {
  return MySQLParser::RuleJsonOperator;
}

void MySQLParser::JsonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOperator(this);
}

void MySQLParser::JsonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOperator(this);
}

std::any MySQLParser::JsonOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJsonOperator(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonOperatorContext *MySQLParser::jsonOperator() {
  JsonOperatorContext *_localctx = _tracker.createInstance<JsonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 876, MySQLParser::RuleJsonOperator);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6316);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JSON_SEPARATOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6312);
        match(MySQLParser::JSON_SEPARATOR_SYMBOL);
        setState(6313);
        textStringLiteral();
        break;
      }

      case MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6314);
        match(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL);
        setState(6315);
        textStringLiteral();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SumExprContext ------------------------------------------------------------------

MySQLParser::SumExprContext::SumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SumExprContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::InSumExprContext *MySQLParser::SumExprContext::inSumExpr() {
  return getRuleContext<MySQLParser::InSumExprContext>(0);
}

tree::TerminalNode *MySQLParser::SumExprContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext *MySQLParser::SumExprContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode *MySQLParser::SumExprContext::BIT_AND_SYMBOL() {
  return getToken(MySQLParser::BIT_AND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::BIT_OR_SYMBOL() {
  return getToken(MySQLParser::BIT_OR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::BIT_XOR_SYMBOL() {
  return getToken(MySQLParser::BIT_XOR_SYMBOL, 0);
}

MySQLParser::JsonFunctionContext *MySQLParser::SumExprContext::jsonFunction() {
  return getRuleContext<MySQLParser::JsonFunctionContext>(0);
}

tree::TerminalNode *MySQLParser::SumExprContext::ST_COLLECT_SYMBOL() {
  return getToken(MySQLParser::ST_COLLECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

MySQLParser::ExprListContext *MySQLParser::SumExprContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::SumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::MIN_SYMBOL() {
  return getToken(MySQLParser::MIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::MAX_SYMBOL() {
  return getToken(MySQLParser::MAX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::STD_SYMBOL() {
  return getToken(MySQLParser::STD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::VARIANCE_SYMBOL() {
  return getToken(MySQLParser::VARIANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::STDDEV_SAMP_SYMBOL() {
  return getToken(MySQLParser::STDDEV_SAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::VAR_SAMP_SYMBOL() {
  return getToken(MySQLParser::VAR_SAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::SUM_SYMBOL() {
  return getToken(MySQLParser::SUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SumExprContext::GROUP_CONCAT_SYMBOL() {
  return getToken(MySQLParser::GROUP_CONCAT_SYMBOL, 0);
}

MySQLParser::OrderClauseContext *MySQLParser::SumExprContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

tree::TerminalNode *MySQLParser::SumExprContext::SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::SumExprContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::SumExprContext::getRuleIndex() const {
  return MySQLParser::RuleSumExpr;
}

void MySQLParser::SumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSumExpr(this);
}

void MySQLParser::SumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSumExpr(this);
}

std::any MySQLParser::SumExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSumExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SumExprContext *MySQLParser::sumExpr() {
  SumExprContext *_localctx = _tracker.createInstance<SumExprContext>(_ctx, getState());
  enterRule(_localctx, 878, MySQLParser::RuleSumExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6403);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 769, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6318);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = match(MySQLParser::AVG_SYMBOL);
        setState(6319);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6321);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 753, _ctx)) {
          case 1: {
            setState(6320);
            match(MySQLParser::DISTINCT_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(6323);
        inSumExpr();
        setState(6324);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6326);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 754, _ctx)) {
          case 1: {
            setState(6325);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6328);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = _input->LT(1);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 377957122048) != 0))) {
          antlrcpp::downCast<SumExprContext *>(_localctx)->name = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6329);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6330);
        inSumExpr();
        setState(6331);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6333);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 755, _ctx)) {
          case 1: {
            setState(6332);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6335);
        jsonFunction();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(6336);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = match(MySQLParser::ST_COLLECT_SYMBOL);
        setState(6337);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6339);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 756, _ctx)) {
          case 1: {
            setState(6338);
            match(MySQLParser::DISTINCT_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(6341);
        inSumExpr();
        setState(6342);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6344);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 757, _ctx)) {
          case 1: {
            setState(6343);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(6346);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = match(MySQLParser::COUNT_SYMBOL);
        setState(6347);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6355);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 759, _ctx)) {
          case 1: {
            setState(6349);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::ALL_SYMBOL) {
              setState(6348);
              match(MySQLParser::ALL_SYMBOL);
            }
            setState(6351);
            match(MySQLParser::MULT_OPERATOR);
            break;
          }

          case 2: {
            setState(6352);
            inSumExpr();
            break;
          }

          case 3: {
            setState(6353);
            match(MySQLParser::DISTINCT_SYMBOL);
            setState(6354);
            exprList();
            break;
          }

          default:
            break;
        }
        setState(6357);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6359);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 760, _ctx)) {
          case 1: {
            setState(6358);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(6361);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::MAX_SYMBOL

              || _la == MySQLParser::MIN_SYMBOL)) {
          antlrcpp::downCast<SumExprContext *>(_localctx)->name = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6362);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6364);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 761, _ctx)) {
          case 1: {
            setState(6363);
            match(MySQLParser::DISTINCT_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(6366);
        inSumExpr();
        setState(6367);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6369);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 762, _ctx)) {
          case 1: {
            setState(6368);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(6371);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 548) & ~0x3fULL) == 0) && ((1ULL << (_la - 548)) & 65545) != 0) ||
              _la == MySQLParser::VARIANCE_SYMBOL

              || _la == MySQLParser::VAR_SAMP_SYMBOL)) {
          antlrcpp::downCast<SumExprContext *>(_localctx)->name = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6372);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6373);
        inSumExpr();
        setState(6374);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6376);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 763, _ctx)) {
          case 1: {
            setState(6375);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(6378);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = match(MySQLParser::SUM_SYMBOL);
        setState(6379);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6380);
        match(MySQLParser::DISTINCT_SYMBOL);
        setState(6381);
        inSumExpr();
        setState(6382);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6384);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 764, _ctx)) {
          case 1: {
            setState(6383);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(6386);
        antlrcpp::downCast<SumExprContext *>(_localctx)->name = match(MySQLParser::GROUP_CONCAT_SYMBOL);
        setState(6387);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6389);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 765, _ctx)) {
          case 1: {
            setState(6388);
            match(MySQLParser::DISTINCT_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(6391);
        exprList();
        setState(6393);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ORDER_SYMBOL) {
          setState(6392);
          orderClause();
        }
        setState(6397);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SEPARATOR_SYMBOL) {
          setState(6395);
          match(MySQLParser::SEPARATOR_SYMBOL);
          setState(6396);
          textString();
        }
        setState(6399);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6401);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 768, _ctx)) {
          case 1: {
            setState(6400);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingOperationContext ------------------------------------------------------------------

MySQLParser::GroupingOperationContext::GroupingOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GroupingOperationContext::GROUPING_SYMBOL() {
  return getToken(MySQLParser::GROUPING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GroupingOperationContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::GroupingOperationContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::GroupingOperationContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::GroupingOperationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingOperation;
}

void MySQLParser::GroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingOperation(this);
}

void MySQLParser::GroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingOperation(this);
}

std::any MySQLParser::GroupingOperationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupingOperation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupingOperationContext *MySQLParser::groupingOperation() {
  GroupingOperationContext *_localctx = _tracker.createInstance<GroupingOperationContext>(_ctx, getState());
  enterRule(_localctx, 880, MySQLParser::RuleGroupingOperation);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6405);
    match(MySQLParser::GROUPING_SYMBOL);
    setState(6406);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6407);
    exprList();
    setState(6408);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFunctionCallContext ------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext::WindowFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParenthesesContext *MySQLParser::WindowFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

MySQLParser::WindowingClauseContext *MySQLParser::WindowFunctionCallContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::ROW_NUMBER_SYMBOL() {
  return getToken(MySQLParser::ROW_NUMBER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::RANK_SYMBOL() {
  return getToken(MySQLParser::RANK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::DENSE_RANK_SYMBOL() {
  return getToken(MySQLParser::DENSE_RANK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::CUME_DIST_SYMBOL() {
  return getToken(MySQLParser::CUME_DIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::PERCENT_RANK_SYMBOL() {
  return getToken(MySQLParser::PERCENT_RANK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::NTILE_SYMBOL() {
  return getToken(MySQLParser::NTILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::StableIntegerContext *MySQLParser::WindowFunctionCallContext::stableInteger() {
  return getRuleContext<MySQLParser::StableIntegerContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprWithParenthesesContext *MySQLParser::WindowFunctionCallContext::simpleExprWithParentheses() {
  return getRuleContext<MySQLParser::SimpleExprWithParenthesesContext>(0);
}

MySQLParser::ExprContext *MySQLParser::WindowFunctionCallContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::LEAD_SYMBOL() {
  return getToken(MySQLParser::LEAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::LAG_SYMBOL() {
  return getToken(MySQLParser::LAG_SYMBOL, 0);
}

MySQLParser::LeadLagInfoContext *MySQLParser::WindowFunctionCallContext::leadLagInfo() {
  return getRuleContext<MySQLParser::LeadLagInfoContext>(0);
}

MySQLParser::NullTreatmentContext *MySQLParser::WindowFunctionCallContext::nullTreatment() {
  return getRuleContext<MySQLParser::NullTreatmentContext>(0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::WindowFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::FIRST_VALUE_SYMBOL() {
  return getToken(MySQLParser::FIRST_VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::LAST_VALUE_SYMBOL() {
  return getToken(MySQLParser::LAST_VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::NTH_VALUE_SYMBOL() {
  return getToken(MySQLParser::NTH_VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::SimpleExprContext *MySQLParser::WindowFunctionCallContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WindowFunctionCallContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

size_t MySQLParser::WindowFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFunctionCall;
}

void MySQLParser::WindowFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFunctionCall(this);
}

void MySQLParser::WindowFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFunctionCall(this);
}

std::any MySQLParser::WindowFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowFunctionCallContext *MySQLParser::windowFunctionCall() {
  WindowFunctionCallContext *_localctx = _tracker.createInstance<WindowFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 882, MySQLParser::RuleWindowFunctionCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6459);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CUME_DIST_SYMBOL:
      case MySQLParser::DENSE_RANK_SYMBOL:
      case MySQLParser::PERCENT_RANK_SYMBOL:
      case MySQLParser::RANK_SYMBOL:
      case MySQLParser::ROW_NUMBER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6410);
        _la = _input->LA(1);
        if (!(((((_la - 678) & ~0x3fULL) == 0) && ((1ULL << (_la - 678)) & 344067) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6411);
        parentheses();
        setState(6412);
        windowingClause();
        break;
      }

      case MySQLParser::NTILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6414);
        match(MySQLParser::NTILE_SYMBOL);
        setState(6421);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 770, _ctx)) {
          case 1: {
            setState(6415);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(6416);
            stableInteger();
            setState(6417);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          case 2: {
            setState(6419);

            if (!(serverVersion < 80024))
              throw FailedPredicateException(this, "serverVersion < 80024");
            setState(6420);
            simpleExprWithParentheses();
            break;
          }

          default:
            break;
        }
        setState(6423);
        windowingClause();
        break;
      }

      case MySQLParser::LAG_SYMBOL:
      case MySQLParser::LEAD_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6425);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LAG_SYMBOL

              || _la == MySQLParser::LEAD_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6426);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6427);
        expr(0);
        setState(6429);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6428);
          leadLagInfo();
        }
        setState(6431);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6433);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(6432);
          nullTreatment();
        }
        setState(6435);
        windowingClause();
        break;
      }

      case MySQLParser::FIRST_VALUE_SYMBOL:
      case MySQLParser::LAST_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6437);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FIRST_VALUE_SYMBOL

              || _la == MySQLParser::LAST_VALUE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6438);
        exprWithParentheses();
        setState(6440);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(6439);
          nullTreatment();
        }
        setState(6442);
        windowingClause();
        break;
      }

      case MySQLParser::NTH_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(6444);
        match(MySQLParser::NTH_VALUE_SYMBOL);
        setState(6445);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6446);
        expr(0);
        setState(6447);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6448);
        simpleExpr(0);
        setState(6449);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6452);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FROM_SYMBOL) {
          setState(6450);
          match(MySQLParser::FROM_SYMBOL);
          setState(6451);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL)) {
            _errHandler->recoverInline(this);
          } else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(6455);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(6454);
          nullTreatment();
        }
        setState(6457);
        windowingClause();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowingClauseContext ------------------------------------------------------------------

MySQLParser::WindowingClauseContext::WindowingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WindowingClauseContext::OVER_SYMBOL() {
  return getToken(MySQLParser::OVER_SYMBOL, 0);
}

MySQLParser::WindowNameContext *MySQLParser::WindowingClauseContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

MySQLParser::WindowSpecContext *MySQLParser::WindowingClauseContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}

size_t MySQLParser::WindowingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowingClause;
}

void MySQLParser::WindowingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowingClause(this);
}

void MySQLParser::WindowingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowingClause(this);
}

std::any MySQLParser::WindowingClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowingClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowingClauseContext *MySQLParser::windowingClause() {
  WindowingClauseContext *_localctx = _tracker.createInstance<WindowingClauseContext>(_ctx, getState());
  enterRule(_localctx, 884, MySQLParser::RuleWindowingClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6461);
    match(MySQLParser::OVER_SYMBOL);
    setState(6464);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 777, _ctx)) {
      case 1: {
        setState(6462);
        windowName();
        break;
      }

      case 2: {
        setState(6463);
        windowSpec();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadLagInfoContext ------------------------------------------------------------------

MySQLParser::LeadLagInfoContext::LeadLagInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LeadLagInfoContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::LeadLagInfoContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::LeadLagInfoContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::LeadLagInfoContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::StableIntegerContext *MySQLParser::LeadLagInfoContext::stableInteger() {
  return getRuleContext<MySQLParser::StableIntegerContext>(0);
}

MySQLParser::ExprContext *MySQLParser::LeadLagInfoContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::LeadLagInfoContext::getRuleIndex() const {
  return MySQLParser::RuleLeadLagInfo;
}

void MySQLParser::LeadLagInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadLagInfo(this);
}

void MySQLParser::LeadLagInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadLagInfo(this);
}

std::any MySQLParser::LeadLagInfoContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLeadLagInfo(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LeadLagInfoContext *MySQLParser::leadLagInfo() {
  LeadLagInfoContext *_localctx = _tracker.createInstance<LeadLagInfoContext>(_ctx, getState());
  enterRule(_localctx, 886, MySQLParser::RuleLeadLagInfo);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6466);
    match(MySQLParser::COMMA_SYMBOL);
    setState(6471);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
      case 1: {
        setState(6467);
        ulonglong_number();
        break;
      }

      case 2: {
        setState(6468);
        match(MySQLParser::PARAM_MARKER);
        break;
      }

      case 3: {
        setState(6469);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(6470);
        stableInteger();
        break;
      }

      default:
        break;
    }
    setState(6475);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6473);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6474);
      expr(0);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StableIntegerContext ------------------------------------------------------------------

MySQLParser::StableIntegerContext::StableIntegerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Int64LiteralContext *MySQLParser::StableIntegerContext::int64Literal() {
  return getRuleContext<MySQLParser::Int64LiteralContext>(0);
}

MySQLParser::ParamOrVarContext *MySQLParser::StableIntegerContext::paramOrVar() {
  return getRuleContext<MySQLParser::ParamOrVarContext>(0);
}

size_t MySQLParser::StableIntegerContext::getRuleIndex() const {
  return MySQLParser::RuleStableInteger;
}

void MySQLParser::StableIntegerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStableInteger(this);
}

void MySQLParser::StableIntegerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStableInteger(this);
}

std::any MySQLParser::StableIntegerContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStableInteger(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StableIntegerContext *MySQLParser::stableInteger() {
  StableIntegerContext *_localctx = _tracker.createInstance<StableIntegerContext>(_ctx, getState());
  enterRule(_localctx, 888, MySQLParser::RuleStableInteger);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6479);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 780, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6477);
        int64Literal();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6478);
        paramOrVar();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParamOrVarContext ------------------------------------------------------------------

MySQLParser::ParamOrVarContext::ParamOrVarContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ParamOrVarContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ParamOrVarContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::ParamOrVarContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::ParamOrVarContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::ParamOrVarContext::getRuleIndex() const {
  return MySQLParser::RuleParamOrVar;
}

void MySQLParser::ParamOrVarContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParamOrVar(this);
}

void MySQLParser::ParamOrVarContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParamOrVar(this);
}

std::any MySQLParser::ParamOrVarContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitParamOrVar(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ParamOrVarContext *MySQLParser::paramOrVar() {
  ParamOrVarContext *_localctx = _tracker.createInstance<ParamOrVarContext>(_ctx, getState());
  enterRule(_localctx, 890, MySQLParser::RuleParamOrVar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6485);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 781, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6481);
        match(MySQLParser::PARAM_MARKER);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6482);
        identifier();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6483);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(6484);
        textOrIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTreatmentContext ------------------------------------------------------------------

MySQLParser::NullTreatmentContext::NullTreatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NullTreatmentContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NullTreatmentContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NullTreatmentContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

size_t MySQLParser::NullTreatmentContext::getRuleIndex() const {
  return MySQLParser::RuleNullTreatment;
}

void MySQLParser::NullTreatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullTreatment(this);
}

void MySQLParser::NullTreatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullTreatment(this);
}

std::any MySQLParser::NullTreatmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNullTreatment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NullTreatmentContext *MySQLParser::nullTreatment() {
  NullTreatmentContext *_localctx = _tracker.createInstance<NullTreatmentContext>(_ctx, getState());
  enterRule(_localctx, 892, MySQLParser::RuleNullTreatment);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6487);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6488);
    match(MySQLParser::NULLS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonFunctionContext ------------------------------------------------------------------

MySQLParser::JsonFunctionContext::JsonFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::JsonFunctionContext::JSON_ARRAYAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_ARRAYAGG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::JsonFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::InSumExprContext *> MySQLParser::JsonFunctionContext::inSumExpr() {
  return getRuleContexts<MySQLParser::InSumExprContext>();
}

MySQLParser::InSumExprContext *MySQLParser::JsonFunctionContext::inSumExpr(size_t i) {
  return getRuleContext<MySQLParser::InSumExprContext>(i);
}

tree::TerminalNode *MySQLParser::JsonFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext *MySQLParser::JsonFunctionContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode *MySQLParser::JsonFunctionContext::JSON_OBJECTAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_OBJECTAGG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::JsonFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

size_t MySQLParser::JsonFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleJsonFunction;
}

void MySQLParser::JsonFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonFunction(this);
}

void MySQLParser::JsonFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonFunction(this);
}

std::any MySQLParser::JsonFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJsonFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonFunctionContext *MySQLParser::jsonFunction() {
  JsonFunctionContext *_localctx = _tracker.createInstance<JsonFunctionContext>(_ctx, getState());
  enterRule(_localctx, 894, MySQLParser::RuleJsonFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6506);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JSON_ARRAYAGG_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6490);
        match(MySQLParser::JSON_ARRAYAGG_SYMBOL);
        setState(6491);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6492);
        inSumExpr();
        setState(6493);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6495);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 782, _ctx)) {
          case 1: {
            setState(6494);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::JSON_OBJECTAGG_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6497);
        match(MySQLParser::JSON_OBJECTAGG_SYMBOL);
        setState(6498);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6499);
        inSumExpr();
        setState(6500);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6501);
        inSumExpr();
        setState(6502);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(6504);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 783, _ctx)) {
          case 1: {
            setState(6503);
            windowingClause();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InSumExprContext ------------------------------------------------------------------

MySQLParser::InSumExprContext::InSumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::InSumExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::InSumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

size_t MySQLParser::InSumExprContext::getRuleIndex() const {
  return MySQLParser::RuleInSumExpr;
}

void MySQLParser::InSumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInSumExpr(this);
}

void MySQLParser::InSumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInSumExpr(this);
}

std::any MySQLParser::InSumExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInSumExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InSumExprContext *MySQLParser::inSumExpr() {
  InSumExprContext *_localctx = _tracker.createInstance<InSumExprContext>(_ctx, getState());
  enterRule(_localctx, 896, MySQLParser::RuleInSumExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6509);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 785, _ctx)) {
      case 1: {
        setState(6508);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(6511);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListArgContext ------------------------------------------------------------------

MySQLParser::IdentListArgContext::IdentListArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentListContext *MySQLParser::IdentListArgContext::identList() {
  return getRuleContext<MySQLParser::IdentListContext>(0);
}

tree::TerminalNode *MySQLParser::IdentListArgContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentListArgContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::IdentListArgContext::getRuleIndex() const {
  return MySQLParser::RuleIdentListArg;
}

void MySQLParser::IdentListArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentListArg(this);
}

void MySQLParser::IdentListArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentListArg(this);
}

std::any MySQLParser::IdentListArgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentListArg(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentListArgContext *MySQLParser::identListArg() {
  IdentListArgContext *_localctx = _tracker.createInstance<IdentListArgContext>(_ctx, getState());
  enterRule(_localctx, 898, MySQLParser::RuleIdentListArg);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6518);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 786, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6513);
        identList();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6514);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6515);
        identList();
        setState(6516);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListContext ------------------------------------------------------------------

MySQLParser::IdentListContext::IdentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SimpleIdentifierContext *> MySQLParser::IdentListContext::simpleIdentifier() {
  return getRuleContexts<MySQLParser::SimpleIdentifierContext>();
}

MySQLParser::SimpleIdentifierContext *MySQLParser::IdentListContext::simpleIdentifier(size_t i) {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::IdentListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::IdentListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentList;
}

void MySQLParser::IdentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentList(this);
}

void MySQLParser::IdentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentList(this);
}

std::any MySQLParser::IdentListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentListContext *MySQLParser::identList() {
  IdentListContext *_localctx = _tracker.createInstance<IdentListContext>(_ctx, getState());
  enterRule(_localctx, 900, MySQLParser::RuleIdentList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6520);
    simpleIdentifier();
    setState(6525);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6521);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6522);
      simpleIdentifier();
      setState(6527);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextOptionsContext ------------------------------------------------------------------

MySQLParser::FulltextOptionsContext::FulltextOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextOptionsContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

size_t MySQLParser::FulltextOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextOptions;
}

void MySQLParser::FulltextOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextOptions(this);
}

void MySQLParser::FulltextOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextOptions(this);
}

std::any MySQLParser::FulltextOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFulltextOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FulltextOptionsContext *MySQLParser::fulltextOptions() {
  FulltextOptionsContext *_localctx = _tracker.createInstance<FulltextOptionsContext>(_ctx, getState());
  enterRule(_localctx, 902, MySQLParser::RuleFulltextOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6543);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 789, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6528);
        match(MySQLParser::IN_SYMBOL);
        setState(6529);
        match(MySQLParser::BOOLEAN_SYMBOL);
        setState(6530);
        match(MySQLParser::MODE_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6531);
        match(MySQLParser::IN_SYMBOL);
        setState(6532);
        match(MySQLParser::NATURAL_SYMBOL);
        setState(6533);
        match(MySQLParser::LANGUAGE_SYMBOL);
        setState(6534);
        match(MySQLParser::MODE_SYMBOL);
        setState(6538);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(6535);
          match(MySQLParser::WITH_SYMBOL);
          setState(6536);
          match(MySQLParser::QUERY_SYMBOL);
          setState(6537);
          match(MySQLParser::EXPANSION_SYMBOL);
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6540);
        match(MySQLParser::WITH_SYMBOL);
        setState(6541);
        match(MySQLParser::QUERY_SYMBOL);
        setState(6542);
        match(MySQLParser::EXPANSION_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuntimeFunctionCallContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext::RuntimeFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::RuntimeFunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext *MySQLParser::RuntimeFunctionCallContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext *MySQLParser::RuntimeFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::RuntimeFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::RuntimeFunctionCallContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::RuntimeFunctionCallContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::JSON_VALUE_SYMBOL() {
  return getToken(MySQLParser::JSON_VALUE_SYMBOL, 0);
}

MySQLParser::SimpleExprContext *MySQLParser::RuntimeFunctionCallContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::TextLiteralContext *MySQLParser::RuntimeFunctionCallContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::OnEmptyOrErrorContext *MySQLParser::RuntimeFunctionCallContext::onEmptyOrError() {
  return getRuleContext<MySQLParser::OnEmptyOrErrorContext>(0);
}

MySQLParser::ReturningTypeContext *MySQLParser::RuntimeFunctionCallContext::returningType() {
  return getRuleContext<MySQLParser::ReturningTypeContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

MySQLParser::TrimFunctionContext *MySQLParser::RuntimeFunctionCallContext::trimFunction() {
  return getRuleContext<MySQLParser::TrimFunctionContext>(0);
}

MySQLParser::UserFunctionContext *MySQLParser::RuntimeFunctionCallContext::userFunction() {
  return getRuleContext<MySQLParser::UserFunctionContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

MySQLParser::IntervalContext *MySQLParser::RuntimeFunctionCallContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CURDATE_SYMBOL() {
  return getToken(MySQLParser::CURDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CURTIME_SYMBOL() {
  return getToken(MySQLParser::CURTIME_SYMBOL, 0);
}

MySQLParser::TimeFunctionParametersContext *MySQLParser::RuntimeFunctionCallContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::DATE_ADD_SYMBOL() {
  return getToken(MySQLParser::DATE_ADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::DATE_SUB_SYMBOL() {
  return getToken(MySQLParser::DATE_SUB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::EXTRACT_SYMBOL() {
  return getToken(MySQLParser::EXTRACT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

MySQLParser::DateTimeTtypeContext *MySQLParser::RuntimeFunctionCallContext::dateTimeTtype() {
  return getRuleContext<MySQLParser::DateTimeTtypeContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::POSITION_SYMBOL() {
  return getToken(MySQLParser::POSITION_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::RuntimeFunctionCallContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::SubstringFunctionContext *MySQLParser::RuntimeFunctionCallContext::substringFunction() {
  return getRuleContext<MySQLParser::SubstringFunctionContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::SYSDATE_SYMBOL() {
  return getToken(MySQLParser::SYSDATE_SYMBOL, 0);
}

MySQLParser::IntervalTimeStampContext *MySQLParser::RuntimeFunctionCallContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::TIMESTAMPADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::TIMESTAMPDIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPDIFF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::UTC_DATE_SYMBOL() {
  return getToken(MySQLParser::UTC_DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::UTC_TIME_SYMBOL() {
  return getToken(MySQLParser::UTC_TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::UTC_TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::UTC_TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

MySQLParser::ExprListWithParenthesesContext *MySQLParser::RuntimeFunctionCallContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::REPEAT_SYMBOL() {
  return getToken(MySQLParser::REPEAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RuntimeFunctionCallContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::WsNumCodepointsContext *MySQLParser::RuntimeFunctionCallContext::wsNumCodepoints() {
  return getRuleContext<MySQLParser::WsNumCodepointsContext>(0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::RuntimeFunctionCallContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext *MySQLParser::RuntimeFunctionCallContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

MySQLParser::GeometryFunctionContext *MySQLParser::RuntimeFunctionCallContext::geometryFunction() {
  return getRuleContext<MySQLParser::GeometryFunctionContext>(0);
}

size_t MySQLParser::RuntimeFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleRuntimeFunctionCall;
}

void MySQLParser::RuntimeFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuntimeFunctionCall(this);
}

void MySQLParser::RuntimeFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuntimeFunctionCall(this);
}

std::any MySQLParser::RuntimeFunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRuntimeFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RuntimeFunctionCallContext *MySQLParser::runtimeFunctionCall() {
  RuntimeFunctionCallContext *_localctx = _tracker.createInstance<RuntimeFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 904, MySQLParser::RuleRuntimeFunctionCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6818);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 807, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6545);
        match(MySQLParser::CHAR_SYMBOL);
        setState(6546);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6547);
        exprList();
        setState(6550);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::USING_SYMBOL) {
          setState(6548);
          match(MySQLParser::USING_SYMBOL);
          setState(6549);
          charsetName();
        }
        setState(6552);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6554);
        match(MySQLParser::CURRENT_USER_SYMBOL);
        setState(6556);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 791, _ctx)) {
          case 1: {
            setState(6555);
            parentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(6558);
        match(MySQLParser::DATE_SYMBOL);
        setState(6559);
        exprWithParentheses();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(6560);
        match(MySQLParser::DAY_SYMBOL);
        setState(6561);
        exprWithParentheses();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(6562);
        match(MySQLParser::HOUR_SYMBOL);
        setState(6563);
        exprWithParentheses();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(6564);
        match(MySQLParser::INSERT_SYMBOL);
        setState(6565);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6566);
        expr(0);
        setState(6567);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6568);
        expr(0);
        setState(6569);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6570);
        expr(0);
        setState(6571);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6572);
        expr(0);
        setState(6573);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(6575);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(6576);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6577);
        expr(0);
        setState(6580);
        _errHandler->sync(this);
        _la = _input->LA(1);
        do {
          setState(6578);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6579);
          expr(0);
          setState(6582);
          _errHandler->sync(this);
          _la = _input->LA(1);
        } while (_la == MySQLParser::COMMA_SYMBOL);
        setState(6584);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(6586);
        match(MySQLParser::JSON_VALUE_SYMBOL);
        setState(6587);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6588);
        simpleExpr(0);
        setState(6589);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6590);
        textLiteral();
        setState(6592);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::RETURNING_SYMBOL) {
          setState(6591);
          returningType();
        }
        setState(6594);
        onEmptyOrError();
        setState(6595);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(6597);
        match(MySQLParser::LEFT_SYMBOL);
        setState(6598);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6599);
        expr(0);
        setState(6600);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6601);
        expr(0);
        setState(6602);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(6604);
        match(MySQLParser::MINUTE_SYMBOL);
        setState(6605);
        exprWithParentheses();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(6606);
        match(MySQLParser::MONTH_SYMBOL);
        setState(6607);
        exprWithParentheses();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(6608);
        match(MySQLParser::RIGHT_SYMBOL);
        setState(6609);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6610);
        expr(0);
        setState(6611);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6612);
        expr(0);
        setState(6613);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(6615);
        match(MySQLParser::SECOND_SYMBOL);
        setState(6616);
        exprWithParentheses();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(6617);
        match(MySQLParser::TIME_SYMBOL);
        setState(6618);
        exprWithParentheses();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(6619);
        match(MySQLParser::TIMESTAMP_SYMBOL);
        setState(6620);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6621);
        expr(0);
        setState(6624);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6622);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6623);
          expr(0);
        }
        setState(6626);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(6628);
        trimFunction();
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(6629);
        userFunction();
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(6630);
        match(MySQLParser::VALUES_SYMBOL);
        setState(6631);
        exprWithParentheses();
        break;
      }

      case 19: {
        enterOuterAlt(_localctx, 19);
        setState(6632);
        match(MySQLParser::YEAR_SYMBOL);
        setState(6633);
        exprWithParentheses();
        break;
      }

      case 20: {
        enterOuterAlt(_localctx, 20);
        setState(6634);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ADDDATE_SYMBOL || _la == MySQLParser::SUBDATE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6635);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6636);
        expr(0);
        setState(6637);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6643);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 795, _ctx)) {
          case 1: {
            setState(6638);
            expr(0);
            break;
          }

          case 2: {
            setState(6639);
            match(MySQLParser::INTERVAL_SYMBOL);
            setState(6640);
            expr(0);
            setState(6641);
            interval();
            break;
          }

          default:
            break;
        }
        setState(6645);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 21: {
        enterOuterAlt(_localctx, 21);
        setState(6647);
        match(MySQLParser::CURDATE_SYMBOL);
        setState(6649);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 796, _ctx)) {
          case 1: {
            setState(6648);
            parentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 22: {
        enterOuterAlt(_localctx, 22);
        setState(6651);
        match(MySQLParser::CURTIME_SYMBOL);
        setState(6653);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 797, _ctx)) {
          case 1: {
            setState(6652);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 23: {
        enterOuterAlt(_localctx, 23);
        setState(6655);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DATE_ADD_SYMBOL

              || _la == MySQLParser::DATE_SUB_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6656);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6657);
        expr(0);
        setState(6658);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6659);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(6660);
        expr(0);
        setState(6661);
        interval();
        setState(6662);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 24: {
        enterOuterAlt(_localctx, 24);
        setState(6664);
        match(MySQLParser::EXTRACT_SYMBOL);
        setState(6665);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6666);
        interval();
        setState(6667);
        match(MySQLParser::FROM_SYMBOL);
        setState(6668);
        expr(0);
        setState(6669);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 25: {
        enterOuterAlt(_localctx, 25);
        setState(6671);
        match(MySQLParser::GET_FORMAT_SYMBOL);
        setState(6672);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6673);
        dateTimeTtype();
        setState(6674);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6675);
        expr(0);
        setState(6676);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 26: {
        enterOuterAlt(_localctx, 26);
        setState(6678);
        match(MySQLParser::NOW_SYMBOL);
        setState(6680);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 798, _ctx)) {
          case 1: {
            setState(6679);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 27: {
        enterOuterAlt(_localctx, 27);
        setState(6682);
        match(MySQLParser::POSITION_SYMBOL);
        setState(6683);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6684);
        bitExpr(0);
        setState(6685);
        match(MySQLParser::IN_SYMBOL);
        setState(6686);
        expr(0);
        setState(6687);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 28: {
        enterOuterAlt(_localctx, 28);
        setState(6689);
        substringFunction();
        break;
      }

      case 29: {
        enterOuterAlt(_localctx, 29);
        setState(6690);
        match(MySQLParser::SYSDATE_SYMBOL);
        setState(6692);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 799, _ctx)) {
          case 1: {
            setState(6691);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 30: {
        enterOuterAlt(_localctx, 30);
        setState(6694);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::TIMESTAMPADD_SYMBOL

              || _la == MySQLParser::TIMESTAMPDIFF_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6695);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6696);
        intervalTimeStamp();
        setState(6697);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6698);
        expr(0);
        setState(6699);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6700);
        expr(0);
        setState(6701);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 31: {
        enterOuterAlt(_localctx, 31);
        setState(6703);
        match(MySQLParser::UTC_DATE_SYMBOL);
        setState(6705);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 800, _ctx)) {
          case 1: {
            setState(6704);
            parentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 32: {
        enterOuterAlt(_localctx, 32);
        setState(6707);
        match(MySQLParser::UTC_TIME_SYMBOL);
        setState(6709);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 801, _ctx)) {
          case 1: {
            setState(6708);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 33: {
        enterOuterAlt(_localctx, 33);
        setState(6711);
        match(MySQLParser::UTC_TIMESTAMP_SYMBOL);
        setState(6713);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 802, _ctx)) {
          case 1: {
            setState(6712);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 34: {
        enterOuterAlt(_localctx, 34);
        setState(6715);
        match(MySQLParser::ASCII_SYMBOL);
        setState(6716);
        exprWithParentheses();
        break;
      }

      case 35: {
        enterOuterAlt(_localctx, 35);
        setState(6717);
        match(MySQLParser::CHARSET_SYMBOL);
        setState(6718);
        exprWithParentheses();
        break;
      }

      case 36: {
        enterOuterAlt(_localctx, 36);
        setState(6719);
        match(MySQLParser::COALESCE_SYMBOL);
        setState(6720);
        exprListWithParentheses();
        break;
      }

      case 37: {
        enterOuterAlt(_localctx, 37);
        setState(6721);
        match(MySQLParser::COLLATION_SYMBOL);
        setState(6722);
        exprWithParentheses();
        break;
      }

      case 38: {
        enterOuterAlt(_localctx, 38);
        setState(6723);
        match(MySQLParser::DATABASE_SYMBOL);
        setState(6724);
        parentheses();
        break;
      }

      case 39: {
        enterOuterAlt(_localctx, 39);
        setState(6725);
        match(MySQLParser::IF_SYMBOL);
        setState(6726);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6727);
        expr(0);
        setState(6728);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6729);
        expr(0);
        setState(6730);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6731);
        expr(0);
        setState(6732);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 40: {
        enterOuterAlt(_localctx, 40);
        setState(6734);
        match(MySQLParser::FORMAT_SYMBOL);
        setState(6735);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6736);
        expr(0);
        setState(6737);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6738);
        expr(0);
        setState(6741);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6739);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6740);
          expr(0);
        }
        setState(6743);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 41: {
        enterOuterAlt(_localctx, 41);
        setState(6745);
        match(MySQLParser::MICROSECOND_SYMBOL);
        setState(6746);
        exprWithParentheses();
        break;
      }

      case 42: {
        enterOuterAlt(_localctx, 42);
        setState(6747);
        match(MySQLParser::MOD_SYMBOL);
        setState(6748);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6749);
        expr(0);
        setState(6750);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6751);
        expr(0);
        setState(6752);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 43: {
        enterOuterAlt(_localctx, 43);
        setState(6754);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(6755);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(6756);
        exprWithParentheses();
        break;
      }

      case 44: {
        enterOuterAlt(_localctx, 44);
        setState(6757);
        match(MySQLParser::QUARTER_SYMBOL);
        setState(6758);
        exprWithParentheses();
        break;
      }

      case 45: {
        enterOuterAlt(_localctx, 45);
        setState(6759);
        match(MySQLParser::REPEAT_SYMBOL);
        setState(6760);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6761);
        expr(0);
        setState(6762);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6763);
        expr(0);
        setState(6764);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 46: {
        enterOuterAlt(_localctx, 46);
        setState(6766);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(6767);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6768);
        expr(0);
        setState(6769);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6770);
        expr(0);
        setState(6771);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6772);
        expr(0);
        setState(6773);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 47: {
        enterOuterAlt(_localctx, 47);
        setState(6775);
        match(MySQLParser::REVERSE_SYMBOL);
        setState(6776);
        exprWithParentheses();
        break;
      }

      case 48: {
        enterOuterAlt(_localctx, 48);
        setState(6777);
        match(MySQLParser::ROW_COUNT_SYMBOL);
        setState(6778);
        parentheses();
        break;
      }

      case 49: {
        enterOuterAlt(_localctx, 49);
        setState(6779);
        match(MySQLParser::TRUNCATE_SYMBOL);
        setState(6780);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6781);
        expr(0);
        setState(6782);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6783);
        expr(0);
        setState(6784);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 50: {
        enterOuterAlt(_localctx, 50);
        setState(6786);
        match(MySQLParser::WEEK_SYMBOL);
        setState(6787);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6788);
        expr(0);
        setState(6791);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6789);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6790);
          expr(0);
        }
        setState(6793);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 51: {
        enterOuterAlt(_localctx, 51);
        setState(6795);
        match(MySQLParser::WEIGHT_STRING_SYMBOL);
        setState(6796);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6797);
        expr(0);
        setState(6813);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 806, _ctx)) {
          case 1: {
            setState(6801);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::AS_SYMBOL) {
              setState(6798);
              match(MySQLParser::AS_SYMBOL);
              setState(6799);
              match(MySQLParser::CHAR_SYMBOL);
              setState(6800);
              wsNumCodepoints();
            }
            break;
          }

          case 2: {
            setState(6803);
            match(MySQLParser::AS_SYMBOL);
            setState(6804);
            match(MySQLParser::BINARY_SYMBOL);
            setState(6805);
            wsNumCodepoints();
            break;
          }

          case 3: {
            setState(6806);
            match(MySQLParser::COMMA_SYMBOL);
            setState(6807);
            ulong_number();
            setState(6808);
            match(MySQLParser::COMMA_SYMBOL);
            setState(6809);
            ulong_number();
            setState(6810);
            match(MySQLParser::COMMA_SYMBOL);
            setState(6811);
            ulong_number();
            break;
          }

          default:
            break;
        }
        setState(6815);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 52: {
        enterOuterAlt(_localctx, 52);
        setState(6817);
        geometryFunction();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturningTypeContext ------------------------------------------------------------------

MySQLParser::ReturningTypeContext::ReturningTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReturningTypeContext::RETURNING_SYMBOL() {
  return getToken(MySQLParser::RETURNING_SYMBOL, 0);
}

MySQLParser::CastTypeContext *MySQLParser::ReturningTypeContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

size_t MySQLParser::ReturningTypeContext::getRuleIndex() const {
  return MySQLParser::RuleReturningType;
}

void MySQLParser::ReturningTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturningType(this);
}

void MySQLParser::ReturningTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturningType(this);
}

std::any MySQLParser::ReturningTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReturningType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReturningTypeContext *MySQLParser::returningType() {
  ReturningTypeContext *_localctx = _tracker.createInstance<ReturningTypeContext>(_ctx, getState());
  enterRule(_localctx, 906, MySQLParser::RuleReturningType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6820);
    match(MySQLParser::RETURNING_SYMBOL);
    setState(6821);
    castType();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeometryFunctionContext ------------------------------------------------------------------

MySQLParser::GeometryFunctionContext::GeometryFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::GeometryFunctionContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

MySQLParser::ExprListWithParenthesesContext *MySQLParser::GeometryFunctionContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::GeometryFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::GeometryFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GeometryFunctionContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

size_t MySQLParser::GeometryFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleGeometryFunction;
}

void MySQLParser::GeometryFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeometryFunction(this);
}

void MySQLParser::GeometryFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeometryFunction(this);
}

std::any MySQLParser::GeometryFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGeometryFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GeometryFunctionContext *MySQLParser::geometryFunction() {
  GeometryFunctionContext *_localctx = _tracker.createInstance<GeometryFunctionContext>(_ctx, getState());
  enterRule(_localctx, 908, MySQLParser::RuleGeometryFunction);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6846);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GEOMETRYCOLLECTION_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6823);
        match(MySQLParser::GEOMETRYCOLLECTION_SYMBOL);
        setState(6824);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6826);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 808, _ctx)) {
          case 1: {
            setState(6825);
            exprList();
            break;
          }

          default:
            break;
        }
        setState(6828);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::LINESTRING_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6829);
        match(MySQLParser::LINESTRING_SYMBOL);
        setState(6830);
        exprListWithParentheses();
        break;
      }

      case MySQLParser::MULTILINESTRING_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6831);
        match(MySQLParser::MULTILINESTRING_SYMBOL);
        setState(6832);
        exprListWithParentheses();
        break;
      }

      case MySQLParser::MULTIPOINT_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6833);
        match(MySQLParser::MULTIPOINT_SYMBOL);
        setState(6834);
        exprListWithParentheses();
        break;
      }

      case MySQLParser::MULTIPOLYGON_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(6835);
        match(MySQLParser::MULTIPOLYGON_SYMBOL);
        setState(6836);
        exprListWithParentheses();
        break;
      }

      case MySQLParser::POINT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(6837);
        match(MySQLParser::POINT_SYMBOL);
        setState(6838);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6839);
        expr(0);
        setState(6840);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6841);
        expr(0);
        setState(6842);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::POLYGON_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(6844);
        match(MySQLParser::POLYGON_SYMBOL);
        setState(6845);
        exprListWithParentheses();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeFunctionParametersContext ------------------------------------------------------------------

MySQLParser::TimeFunctionParametersContext::TimeFunctionParametersContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TimeFunctionParametersContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TimeFunctionParametersContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FractionalPrecisionContext *MySQLParser::TimeFunctionParametersContext::fractionalPrecision() {
  return getRuleContext<MySQLParser::FractionalPrecisionContext>(0);
}

size_t MySQLParser::TimeFunctionParametersContext::getRuleIndex() const {
  return MySQLParser::RuleTimeFunctionParameters;
}

void MySQLParser::TimeFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeFunctionParameters(this);
}

void MySQLParser::TimeFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeFunctionParameters(this);
}

std::any MySQLParser::TimeFunctionParametersContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTimeFunctionParameters(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TimeFunctionParametersContext *MySQLParser::timeFunctionParameters() {
  TimeFunctionParametersContext *_localctx = _tracker.createInstance<TimeFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 910, MySQLParser::RuleTimeFunctionParameters);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6848);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6850);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INT_NUMBER) {
      setState(6849);
      fractionalPrecision();
    }
    setState(6852);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FractionalPrecisionContext ------------------------------------------------------------------

MySQLParser::FractionalPrecisionContext::FractionalPrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FractionalPrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

size_t MySQLParser::FractionalPrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleFractionalPrecision;
}

void MySQLParser::FractionalPrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFractionalPrecision(this);
}

void MySQLParser::FractionalPrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFractionalPrecision(this);
}

std::any MySQLParser::FractionalPrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFractionalPrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FractionalPrecisionContext *MySQLParser::fractionalPrecision() {
  FractionalPrecisionContext *_localctx = _tracker.createInstance<FractionalPrecisionContext>(_ctx, getState());
  enterRule(_localctx, 912, MySQLParser::RuleFractionalPrecision);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6854);
    match(MySQLParser::INT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelsContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelsContext::WeightStringLevelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WeightStringLevelsContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::WeightStringLevelsContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext *MySQLParser::WeightStringLevelsContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

tree::TerminalNode *MySQLParser::WeightStringLevelsContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

std::vector<MySQLParser::WeightStringLevelListItemContext *>
MySQLParser::WeightStringLevelsContext::weightStringLevelListItem() {
  return getRuleContexts<MySQLParser::WeightStringLevelListItemContext>();
}

MySQLParser::WeightStringLevelListItemContext *MySQLParser::WeightStringLevelsContext::weightStringLevelListItem(
  size_t i) {
  return getRuleContext<MySQLParser::WeightStringLevelListItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::WeightStringLevelsContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevels;
}

void MySQLParser::WeightStringLevelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevels(this);
}

void MySQLParser::WeightStringLevelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevels(this);
}

std::any MySQLParser::WeightStringLevelsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWeightStringLevels(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WeightStringLevelsContext *MySQLParser::weightStringLevels() {
  WeightStringLevelsContext *_localctx = _tracker.createInstance<WeightStringLevelsContext>(_ctx, getState());
  enterRule(_localctx, 914, MySQLParser::RuleWeightStringLevels);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6856);
    match(MySQLParser::LEVEL_SYMBOL);
    setState(6869);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 812, _ctx)) {
      case 1: {
        setState(6857);
        real_ulong_number();
        setState(6858);
        match(MySQLParser::MINUS_OPERATOR);
        setState(6859);
        real_ulong_number();
        break;
      }

      case 2: {
        setState(6861);
        weightStringLevelListItem();
        setState(6866);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6862);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6863);
          weightStringLevelListItem();
          setState(6868);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelListItemContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelListItemContext::WeightStringLevelListItemContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulong_numberContext *MySQLParser::WeightStringLevelListItemContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::WeightStringLevelListItemContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WeightStringLevelListItemContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::WeightStringLevelListItemContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

size_t MySQLParser::WeightStringLevelListItemContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevelListItem;
}

void MySQLParser::WeightStringLevelListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevelListItem(this);
}

void MySQLParser::WeightStringLevelListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevelListItem(this);
}

std::any MySQLParser::WeightStringLevelListItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWeightStringLevelListItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WeightStringLevelListItemContext *MySQLParser::weightStringLevelListItem() {
  WeightStringLevelListItemContext *_localctx =
    _tracker.createInstance<WeightStringLevelListItemContext>(_ctx, getState());
  enterRule(_localctx, 916, MySQLParser::RuleWeightStringLevelListItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6871);
    real_ulong_number();
    setState(6877);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASC_SYMBOL:
      case MySQLParser::DESC_SYMBOL: {
        setState(6872);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6874);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REVERSE_SYMBOL) {
          setState(6873);
          match(MySQLParser::REVERSE_SYMBOL);
        }
        break;
      }

      case MySQLParser::REVERSE_SYMBOL: {
        setState(6876);
        match(MySQLParser::REVERSE_SYMBOL);
        break;
      }

      case MySQLParser::EOF:
      case MySQLParser::COMMA_SYMBOL: {
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DateTimeTtypeContext ------------------------------------------------------------------

MySQLParser::DateTimeTtypeContext::DateTimeTtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DateTimeTtypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DateTimeTtypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DateTimeTtypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DateTimeTtypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

size_t MySQLParser::DateTimeTtypeContext::getRuleIndex() const {
  return MySQLParser::RuleDateTimeTtype;
}

void MySQLParser::DateTimeTtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDateTimeTtype(this);
}

void MySQLParser::DateTimeTtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDateTimeTtype(this);
}

std::any MySQLParser::DateTimeTtypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDateTimeTtype(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DateTimeTtypeContext *MySQLParser::dateTimeTtype() {
  DateTimeTtypeContext *_localctx = _tracker.createInstance<DateTimeTtypeContext>(_ctx, getState());
  enterRule(_localctx, 918, MySQLParser::RuleDateTimeTtype);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6879);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DATETIME_SYMBOL

          || _la == MySQLParser::DATE_SYMBOL || _la == MySQLParser::TIMESTAMP_SYMBOL

          || _la == MySQLParser::TIME_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrimFunctionContext ------------------------------------------------------------------

MySQLParser::TrimFunctionContext::TrimFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::TRIM_SYMBOL() {
  return getToken(MySQLParser::TRIM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::TrimFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::TrimFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::LEADING_SYMBOL() {
  return getToken(MySQLParser::LEADING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::TRAILING_SYMBOL() {
  return getToken(MySQLParser::TRAILING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TrimFunctionContext::BOTH_SYMBOL() {
  return getToken(MySQLParser::BOTH_SYMBOL, 0);
}

size_t MySQLParser::TrimFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTrimFunction;
}

void MySQLParser::TrimFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrimFunction(this);
}

void MySQLParser::TrimFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrimFunction(this);
}

std::any MySQLParser::TrimFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTrimFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TrimFunctionContext *MySQLParser::trimFunction() {
  TrimFunctionContext *_localctx = _tracker.createInstance<TrimFunctionContext>(_ctx, getState());
  enterRule(_localctx, 920, MySQLParser::RuleTrimFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6881);
    match(MySQLParser::TRIM_SYMBOL);
    setState(6882);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6906);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 819, _ctx)) {
      case 1: {
        setState(6883);
        expr(0);
        setState(6886);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FROM_SYMBOL) {
          setState(6884);
          match(MySQLParser::FROM_SYMBOL);
          setState(6885);
          expr(0);
        }
        break;
      }

      case 2: {
        setState(6888);
        match(MySQLParser::LEADING_SYMBOL);
        setState(6890);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 816, _ctx)) {
          case 1: {
            setState(6889);
            expr(0);
            break;
          }

          default:
            break;
        }
        setState(6892);
        match(MySQLParser::FROM_SYMBOL);
        setState(6893);
        expr(0);
        break;
      }

      case 3: {
        setState(6894);
        match(MySQLParser::TRAILING_SYMBOL);
        setState(6896);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 817, _ctx)) {
          case 1: {
            setState(6895);
            expr(0);
            break;
          }

          default:
            break;
        }
        setState(6898);
        match(MySQLParser::FROM_SYMBOL);
        setState(6899);
        expr(0);
        break;
      }

      case 4: {
        setState(6900);
        match(MySQLParser::BOTH_SYMBOL);
        setState(6902);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 818, _ctx)) {
          case 1: {
            setState(6901);
            expr(0);
            break;
          }

          default:
            break;
        }
        setState(6904);
        match(MySQLParser::FROM_SYMBOL);
        setState(6905);
        expr(0);
        break;
      }

      default:
        break;
    }
    setState(6908);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubstringFunctionContext ------------------------------------------------------------------

MySQLParser::SubstringFunctionContext::SubstringFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::SUBSTRING_SYMBOL() {
  return getToken(MySQLParser::SUBSTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SubstringFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::SubstringFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SubstringFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubstringFunctionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

size_t MySQLParser::SubstringFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleSubstringFunction;
}

void MySQLParser::SubstringFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstringFunction(this);
}

void MySQLParser::SubstringFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstringFunction(this);
}

std::any MySQLParser::SubstringFunctionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSubstringFunction(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubstringFunctionContext *MySQLParser::substringFunction() {
  SubstringFunctionContext *_localctx = _tracker.createInstance<SubstringFunctionContext>(_ctx, getState());
  enterRule(_localctx, 922, MySQLParser::RuleSubstringFunction);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6910);
    match(MySQLParser::SUBSTRING_SYMBOL);
    setState(6911);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6912);
    expr(0);
    setState(6925);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMA_SYMBOL: {
        setState(6913);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6914);
        expr(0);
        setState(6917);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6915);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6916);
          expr(0);
        }
        break;
      }

      case MySQLParser::FROM_SYMBOL: {
        setState(6919);
        match(MySQLParser::FROM_SYMBOL);
        setState(6920);
        expr(0);
        setState(6923);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(6921);
          match(MySQLParser::FOR_SYMBOL);
          setState(6922);
          expr(0);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(6927);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext *MySQLParser::FunctionCallContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::FunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::UdfExprListContext *MySQLParser::FunctionCallContext::udfExprList() {
  return getRuleContext<MySQLParser::UdfExprListContext>(0);
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::FunctionCallContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::ExprListContext *MySQLParser::FunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

size_t MySQLParser::FunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionCall;
}

void MySQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void MySQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}

std::any MySQLParser::FunctionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFunctionCall(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionCallContext *MySQLParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 924, MySQLParser::RuleFunctionCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6943);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 825, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6929);
        pureIdentifier();
        setState(6930);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6932);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 823, _ctx)) {
          case 1: {
            setState(6931);
            udfExprList();
            break;
          }

          default:
            break;
        }
        setState(6934);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6936);
        qualifiedIdentifier();
        setState(6937);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(6939);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 824, _ctx)) {
          case 1: {
            setState(6938);
            exprList();
            break;
          }

          default:
            break;
        }
        setState(6941);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprListContext ------------------------------------------------------------------

MySQLParser::UdfExprListContext::UdfExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UdfExprContext *> MySQLParser::UdfExprListContext::udfExpr() {
  return getRuleContexts<MySQLParser::UdfExprContext>();
}

MySQLParser::UdfExprContext *MySQLParser::UdfExprListContext::udfExpr(size_t i) {
  return getRuleContext<MySQLParser::UdfExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UdfExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::UdfExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::UdfExprListContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExprList;
}

void MySQLParser::UdfExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExprList(this);
}

void MySQLParser::UdfExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExprList(this);
}

std::any MySQLParser::UdfExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUdfExprList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfExprListContext *MySQLParser::udfExprList() {
  UdfExprListContext *_localctx = _tracker.createInstance<UdfExprListContext>(_ctx, getState());
  enterRule(_localctx, 926, MySQLParser::RuleUdfExprList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6945);
    udfExpr();
    setState(6950);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6946);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6947);
      udfExpr();
      setState(6952);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprContext ------------------------------------------------------------------

MySQLParser::UdfExprContext::UdfExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::UdfExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext *MySQLParser::UdfExprContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}

size_t MySQLParser::UdfExprContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExpr;
}

void MySQLParser::UdfExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExpr(this);
}

void MySQLParser::UdfExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExpr(this);
}

std::any MySQLParser::UdfExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUdfExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfExprContext *MySQLParser::udfExpr() {
  UdfExprContext *_localctx = _tracker.createInstance<UdfExprContext>(_ctx, getState());
  enterRule(_localctx, 928, MySQLParser::RuleUdfExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6953);
    expr(0);
    setState(6955);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 827, _ctx)) {
      case 1: {
        setState(6954);
        selectAlias();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserVariableContext ------------------------------------------------------------------

MySQLParser::UserVariableContext::UserVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UserVariableContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::UserVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::UserVariableContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

size_t MySQLParser::UserVariableContext::getRuleIndex() const {
  return MySQLParser::RuleUserVariable;
}

void MySQLParser::UserVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserVariable(this);
}

void MySQLParser::UserVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserVariable(this);
}

std::any MySQLParser::UserVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserVariableContext *MySQLParser::userVariable() {
  UserVariableContext *_localctx = _tracker.createInstance<UserVariableContext>(_ctx, getState());
  enterRule(_localctx, 930, MySQLParser::RuleUserVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6960);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6957);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(6958);
        textOrIdentifier();
        break;
      }

      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 2);
        setState(6959);
        match(MySQLParser::AT_TEXT_SUFFIX);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InExpressionUserVariableAssignmentContext
//------------------------------------------------------------------

MySQLParser::InExpressionUserVariableAssignmentContext::InExpressionUserVariableAssignmentContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserVariableContext *MySQLParser::InExpressionUserVariableAssignmentContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

tree::TerminalNode *MySQLParser::InExpressionUserVariableAssignmentContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}

MySQLParser::ExprContext *MySQLParser::InExpressionUserVariableAssignmentContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::InExpressionUserVariableAssignmentContext::getRuleIndex() const {
  return MySQLParser::RuleInExpressionUserVariableAssignment;
}

void MySQLParser::InExpressionUserVariableAssignmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInExpressionUserVariableAssignment(this);
}

void MySQLParser::InExpressionUserVariableAssignmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInExpressionUserVariableAssignment(this);
}

std::any MySQLParser::InExpressionUserVariableAssignmentContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInExpressionUserVariableAssignment(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InExpressionUserVariableAssignmentContext *MySQLParser::inExpressionUserVariableAssignment() {
  InExpressionUserVariableAssignmentContext *_localctx =
    _tracker.createInstance<InExpressionUserVariableAssignmentContext>(_ctx, getState());
  enterRule(_localctx, 932, MySQLParser::RuleInExpressionUserVariableAssignment);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6962);
    userVariable();
    setState(6963);
    match(MySQLParser::ASSIGN_OPERATOR);
    setState(6964);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RvalueSystemOrUserVariableContext ------------------------------------------------------------------

MySQLParser::RvalueSystemOrUserVariableContext::RvalueSystemOrUserVariableContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserVariableContext *MySQLParser::RvalueSystemOrUserVariableContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

tree::TerminalNode *MySQLParser::RvalueSystemOrUserVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::RvalueSystemVariableContext *MySQLParser::RvalueSystemOrUserVariableContext::rvalueSystemVariable() {
  return getRuleContext<MySQLParser::RvalueSystemVariableContext>(0);
}

MySQLParser::RvalueSystemVariableTypeContext *
MySQLParser::RvalueSystemOrUserVariableContext::rvalueSystemVariableType() {
  return getRuleContext<MySQLParser::RvalueSystemVariableTypeContext>(0);
}

size_t MySQLParser::RvalueSystemOrUserVariableContext::getRuleIndex() const {
  return MySQLParser::RuleRvalueSystemOrUserVariable;
}

void MySQLParser::RvalueSystemOrUserVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRvalueSystemOrUserVariable(this);
}

void MySQLParser::RvalueSystemOrUserVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRvalueSystemOrUserVariable(this);
}

std::any MySQLParser::RvalueSystemOrUserVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRvalueSystemOrUserVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RvalueSystemOrUserVariableContext *MySQLParser::rvalueSystemOrUserVariable() {
  RvalueSystemOrUserVariableContext *_localctx =
    _tracker.createInstance<RvalueSystemOrUserVariableContext>(_ctx, getState());
  enterRule(_localctx, 934, MySQLParser::RuleRvalueSystemOrUserVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6972);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL:
      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 1);
        setState(6966);
        userVariable();
        break;
      }

      case MySQLParser::AT_AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6967);
        match(MySQLParser::AT_AT_SIGN_SYMBOL);
        setState(6969);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 829, _ctx)) {
          case 1: {
            setState(6968);
            rvalueSystemVariableType();
            break;
          }

          default:
            break;
        }
        setState(6971);
        rvalueSystemVariable();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LvalueVariableContext ------------------------------------------------------------------

MySQLParser::LvalueVariableContext::LvalueVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::LvalueVariableContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::LValueIdentifierContext *MySQLParser::LvalueVariableContext::lValueIdentifier() {
  return getRuleContext<MySQLParser::LValueIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::LvalueVariableContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::LvalueVariableContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::LvalueVariableContext::getRuleIndex() const {
  return MySQLParser::RuleLvalueVariable;
}

void MySQLParser::LvalueVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLvalueVariable(this);
}

void MySQLParser::LvalueVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLvalueVariable(this);
}

std::any MySQLParser::LvalueVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLvalueVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LvalueVariableContext *MySQLParser::lvalueVariable() {
  LvalueVariableContext *_localctx = _tracker.createInstance<LvalueVariableContext>(_ctx, getState());
  enterRule(_localctx, 936, MySQLParser::RuleLvalueVariable);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(6987);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 834, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(6983);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 833, _ctx)) {
          case 1: {
            setState(6974);
            identifier();
            setState(6976);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::DOT_SYMBOL) {
              setState(6975);
              dotIdentifier();
            }
            break;
          }

          case 2: {
            setState(6978);

            if (!(serverVersion >= 80017))
              throw FailedPredicateException(this, "serverVersion >= 80017");
            setState(6979);
            lValueIdentifier();
            setState(6981);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::DOT_SYMBOL) {
              setState(6980);
              dotIdentifier();
            }
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(6985);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(6986);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RvalueSystemVariableContext ------------------------------------------------------------------

MySQLParser::RvalueSystemVariableContext::RvalueSystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::RvalueSystemVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::RvalueSystemVariableContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::RvalueSystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleRvalueSystemVariable;
}

void MySQLParser::RvalueSystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRvalueSystemVariable(this);
}

void MySQLParser::RvalueSystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRvalueSystemVariable(this);
}

std::any MySQLParser::RvalueSystemVariableContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRvalueSystemVariable(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RvalueSystemVariableContext *MySQLParser::rvalueSystemVariable() {
  RvalueSystemVariableContext *_localctx = _tracker.createInstance<RvalueSystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 938, MySQLParser::RuleRvalueSystemVariable);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6989);
    textOrIdentifier();
    setState(6991);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 835, _ctx)) {
      case 1: {
        setState(6990);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenExpressionContext ------------------------------------------------------------------

MySQLParser::WhenExpressionContext::WhenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WhenExpressionContext::WHEN_SYMBOL() {
  return getToken(MySQLParser::WHEN_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::WhenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::WhenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleWhenExpression;
}

void MySQLParser::WhenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenExpression(this);
}

void MySQLParser::WhenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenExpression(this);
}

std::any MySQLParser::WhenExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWhenExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhenExpressionContext *MySQLParser::whenExpression() {
  WhenExpressionContext *_localctx = _tracker.createInstance<WhenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 940, MySQLParser::RuleWhenExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6993);
    match(MySQLParser::WHEN_SYMBOL);
    setState(6994);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenExpressionContext ------------------------------------------------------------------

MySQLParser::ThenExpressionContext::ThenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ThenExpressionContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ThenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::ThenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleThenExpression;
}

void MySQLParser::ThenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenExpression(this);
}

void MySQLParser::ThenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenExpression(this);
}

std::any MySQLParser::ThenExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitThenExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThenExpressionContext *MySQLParser::thenExpression() {
  ThenExpressionContext *_localctx = _tracker.createInstance<ThenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 942, MySQLParser::RuleThenExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6996);
    match(MySQLParser::THEN_SYMBOL);
    setState(6997);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseExpressionContext ------------------------------------------------------------------

MySQLParser::ElseExpressionContext::ElseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ElseExpressionContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ElseExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::ElseExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleElseExpression;
}

void MySQLParser::ElseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseExpression(this);
}

void MySQLParser::ElseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseExpression(this);
}

std::any MySQLParser::ElseExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitElseExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ElseExpressionContext *MySQLParser::elseExpression() {
  ElseExpressionContext *_localctx = _tracker.createInstance<ElseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 944, MySQLParser::RuleElseExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6999);
    match(MySQLParser::ELSE_SYMBOL);
    setState(7000);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastTypeContext ------------------------------------------------------------------

MySQLParser::CastTypeContext::CastTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CastTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::FieldLengthContext *MySQLParser::CastTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext *MySQLParser::CastTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext *MySQLParser::CastTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::UNSIGNED_SYMBOL() {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext *MySQLParser::CastTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext *MySQLParser::CastTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

MySQLParser::RealTypeContext *MySQLParser::CastTypeContext::realType() {
  return getRuleContext<MySQLParser::RealTypeContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::FLOAT_SYMBOL() {
  return getToken(MySQLParser::FLOAT_SYMBOL, 0);
}

MySQLParser::StandardFloatOptionsContext *MySQLParser::CastTypeContext::standardFloatOptions() {
  return getRuleContext<MySQLParser::StandardFloatOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CastTypeContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

size_t MySQLParser::CastTypeContext::getRuleIndex() const {
  return MySQLParser::RuleCastType;
}

void MySQLParser::CastTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastType(this);
}

void MySQLParser::CastTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastType(this);
}

std::any MySQLParser::CastTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCastType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CastTypeContext *MySQLParser::castType() {
  CastTypeContext *_localctx = _tracker.createInstance<CastTypeContext>(_ctx, getState());
  enterRule(_localctx, 946, MySQLParser::RuleCastType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7050);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 846, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7002);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7004);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 836, _ctx)) {
          case 1: {
            setState(7003);
            fieldLength();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7006);
        match(MySQLParser::CHAR_SYMBOL);
        setState(7008);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 837, _ctx)) {
          case 1: {
            setState(7007);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7011);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 838, _ctx)) {
          case 1: {
            setState(7010);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7013);
        nchar();
        setState(7015);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 839, _ctx)) {
          case 1: {
            setState(7014);
            fieldLength();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7017);
        match(MySQLParser::SIGNED_SYMBOL);
        setState(7019);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 840, _ctx)) {
          case 1: {
            setState(7018);
            match(MySQLParser::INT_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7021);
        match(MySQLParser::UNSIGNED_SYMBOL);
        setState(7023);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 841, _ctx)) {
          case 1: {
            setState(7022);
            match(MySQLParser::INT_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(7025);
        match(MySQLParser::DATE_SYMBOL);
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(7026);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7027);
        match(MySQLParser::YEAR_SYMBOL);
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(7028);
        match(MySQLParser::TIME_SYMBOL);
        setState(7030);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 842, _ctx)) {
          case 1: {
            setState(7029);
            typeDatetimePrecision();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(7032);
        match(MySQLParser::DATETIME_SYMBOL);
        setState(7034);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 843, _ctx)) {
          case 1: {
            setState(7033);
            typeDatetimePrecision();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(7036);
        match(MySQLParser::DECIMAL_SYMBOL);
        setState(7038);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 844, _ctx)) {
          case 1: {
            setState(7037);
            floatOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(7040);
        match(MySQLParser::JSON_SYMBOL);
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(7041);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(7042);
        realType();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(7043);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(7044);
        match(MySQLParser::FLOAT_SYMBOL);
        setState(7046);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
          case 1: {
            setState(7045);
            standardFloatOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(7048);

        if (!(serverVersion >= 80027))
          throw FailedPredicateException(this, "serverVersion >= 80027");
        setState(7049);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::GEOMETRYCOLLECTION_SYMBOL || _la == MySQLParser::LINESTRING_SYMBOL ||
              ((((_la - 351) & ~0x3fULL) == 0) && ((1ULL << (_la - 351)) & 3458764513820540935) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListContext ------------------------------------------------------------------

MySQLParser::ExprListContext::ExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprListContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ExprListContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ExprListContext::getRuleIndex() const {
  return MySQLParser::RuleExprList;
}

void MySQLParser::ExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprList(this);
}

void MySQLParser::ExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprList(this);
}

std::any MySQLParser::ExprListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprListContext *MySQLParser::exprList() {
  ExprListContext *_localctx = _tracker.createInstance<ExprListContext>(_ctx, getState());
  enterRule(_localctx, 948, MySQLParser::RuleExprList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7052);
    expr(0);
    setState(7057);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7053);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7054);
      expr(0);
      setState(7059);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetContext ------------------------------------------------------------------

MySQLParser::CharsetContext::CharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CharsetContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CharsetContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CharsetContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

size_t MySQLParser::CharsetContext::getRuleIndex() const {
  return MySQLParser::RuleCharset;
}

void MySQLParser::CharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharset(this);
}

void MySQLParser::CharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharset(this);
}

std::any MySQLParser::CharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetContext *MySQLParser::charset() {
  CharsetContext *_localctx = _tracker.createInstance<CharsetContext>(_ctx, getState());
  enterRule(_localctx, 950, MySQLParser::RuleCharset);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7063);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7060);
        match(MySQLParser::CHAR_SYMBOL);
        setState(7061);
        match(MySQLParser::SET_SYMBOL);
        break;
      }

      case MySQLParser::CHARSET_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7062);
        match(MySQLParser::CHARSET_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotRuleContext ------------------------------------------------------------------

MySQLParser::NotRuleContext::NotRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NotRuleContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NotRuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}

size_t MySQLParser::NotRuleContext::getRuleIndex() const {
  return MySQLParser::RuleNotRule;
}

void MySQLParser::NotRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotRule(this);
}

void MySQLParser::NotRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotRule(this);
}

std::any MySQLParser::NotRuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNotRule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NotRuleContext *MySQLParser::notRule() {
  NotRuleContext *_localctx = _tracker.createInstance<NotRuleContext>(_ctx, getState());
  enterRule(_localctx, 952, MySQLParser::RuleNotRule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7065);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Not2RuleContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext::Not2RuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Not2RuleContext::LOGICAL_NOT_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_NOT_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::Not2RuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}

size_t MySQLParser::Not2RuleContext::getRuleIndex() const {
  return MySQLParser::RuleNot2Rule;
}

void MySQLParser::Not2RuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNot2Rule(this);
}

void MySQLParser::Not2RuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNot2Rule(this);
}

std::any MySQLParser::Not2RuleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNot2Rule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Not2RuleContext *MySQLParser::not2Rule() {
  Not2RuleContext *_localctx = _tracker.createInstance<Not2RuleContext>(_ctx, getState());
  enterRule(_localctx, 954, MySQLParser::RuleNot2Rule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7067);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT2_SYMBOL

          || _la == MySQLParser::LOGICAL_NOT_OPERATOR)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalContext ------------------------------------------------------------------

MySQLParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IntervalTimeStampContext *MySQLParser::IntervalContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode *MySQLParser::IntervalContext::SECOND_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::MINUTE_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::MINUTE_SECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::HOUR_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::HOUR_SECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::HOUR_MINUTE_SYMBOL() {
  return getToken(MySQLParser::HOUR_MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::DAY_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::DAY_SECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::DAY_MINUTE_SYMBOL() {
  return getToken(MySQLParser::DAY_MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::DAY_HOUR_SYMBOL() {
  return getToken(MySQLParser::DAY_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalContext::YEAR_MONTH_SYMBOL() {
  return getToken(MySQLParser::YEAR_MONTH_SYMBOL, 0);
}

size_t MySQLParser::IntervalContext::getRuleIndex() const {
  return MySQLParser::RuleInterval;
}

void MySQLParser::IntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterval(this);
}

void MySQLParser::IntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterval(this);
}

std::any MySQLParser::IntervalContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInterval(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntervalContext *MySQLParser::interval() {
  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());
  enterRule(_localctx, 956, MySQLParser::RuleInterval);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7071);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DAY_SYMBOL:
      case MySQLParser::HOUR_SYMBOL:
      case MySQLParser::MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SYMBOL:
      case MySQLParser::MONTH_SYMBOL:
      case MySQLParser::QUARTER_SYMBOL:
      case MySQLParser::SECOND_SYMBOL:
      case MySQLParser::WEEK_SYMBOL:
      case MySQLParser::YEAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7069);
        intervalTimeStamp();
        break;
      }

      case MySQLParser::DAY_HOUR_SYMBOL:
      case MySQLParser::DAY_MICROSECOND_SYMBOL:
      case MySQLParser::DAY_MINUTE_SYMBOL:
      case MySQLParser::DAY_SECOND_SYMBOL:
      case MySQLParser::HOUR_MICROSECOND_SYMBOL:
      case MySQLParser::HOUR_MINUTE_SYMBOL:
      case MySQLParser::HOUR_SECOND_SYMBOL:
      case MySQLParser::MINUTE_MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SECOND_SYMBOL:
      case MySQLParser::SECOND_MICROSECOND_SYMBOL:
      case MySQLParser::YEAR_MONTH_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7070);
        _la = _input->LA(1);
        if (!(((((_la - 118) & ~0x3fULL) == 0) && ((1ULL << (_la - 118)) & 15) != 0) ||
              ((((_la - 226) & ~0x3fULL) == 0) && ((1ULL << (_la - 226)) & 7) != 0) ||
              _la == MySQLParser::MINUTE_MICROSECOND_SYMBOL

              || _la == MySQLParser::MINUTE_SECOND_SYMBOL || _la == MySQLParser::SECOND_MICROSECOND_SYMBOL ||
              _la == MySQLParser::YEAR_MONTH_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalTimeStampContext ------------------------------------------------------------------

MySQLParser::IntervalTimeStampContext::IntervalTimeStampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IntervalTimeStampContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

size_t MySQLParser::IntervalTimeStampContext::getRuleIndex() const {
  return MySQLParser::RuleIntervalTimeStamp;
}

void MySQLParser::IntervalTimeStampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalTimeStamp(this);
}

void MySQLParser::IntervalTimeStampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalTimeStamp(this);
}

std::any MySQLParser::IntervalTimeStampContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIntervalTimeStamp(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IntervalTimeStampContext *MySQLParser::intervalTimeStamp() {
  IntervalTimeStampContext *_localctx = _tracker.createInstance<IntervalTimeStampContext>(_ctx, getState());
  enterRule(_localctx, 958, MySQLParser::RuleIntervalTimeStamp);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7073);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DAY_SYMBOL || _la == MySQLParser::HOUR_SYMBOL ||
          ((((_la - 337) & ~0x3fULL) == 0) && ((1ULL << (_la - 337)) & 8257) != 0) ||
          _la == MySQLParser::QUARTER_SYMBOL || _la == MySQLParser::SECOND_SYMBOL || _la == MySQLParser::WEEK_SYMBOL

          || _la == MySQLParser::YEAR_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprListWithParenthesesContext::ExprListWithParenthesesContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ExprListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext *MySQLParser::ExprListWithParenthesesContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode *MySQLParser::ExprListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::ExprListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprListWithParentheses;
}

void MySQLParser::ExprListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprListWithParentheses(this);
}

void MySQLParser::ExprListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprListWithParentheses(this);
}

std::any MySQLParser::ExprListWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprListWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprListWithParenthesesContext *MySQLParser::exprListWithParentheses() {
  ExprListWithParenthesesContext *_localctx = _tracker.createInstance<ExprListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 960, MySQLParser::RuleExprListWithParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7075);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7076);
    exprList();
    setState(7077);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprWithParenthesesContext::ExprWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ExprWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ExprWithParenthesesContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::ExprWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::ExprWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprWithParentheses;
}

void MySQLParser::ExprWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprWithParentheses(this);
}

void MySQLParser::ExprWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprWithParentheses(this);
}

std::any MySQLParser::ExprWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitExprWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::exprWithParentheses() {
  ExprWithParenthesesContext *_localctx = _tracker.createInstance<ExprWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 962, MySQLParser::RuleExprWithParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7079);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7080);
    expr(0);
    setState(7081);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleExprWithParenthesesContext ------------------------------------------------------------------

MySQLParser::SimpleExprWithParenthesesContext::SimpleExprWithParenthesesContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SimpleExprWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprContext *MySQLParser::SimpleExprWithParenthesesContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode *MySQLParser::SimpleExprWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::SimpleExprWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleExprWithParentheses;
}

void MySQLParser::SimpleExprWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprWithParentheses(this);
}

void MySQLParser::SimpleExprWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprWithParentheses(this);
}

std::any MySQLParser::SimpleExprWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleExprWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleExprWithParenthesesContext *MySQLParser::simpleExprWithParentheses() {
  SimpleExprWithParenthesesContext *_localctx =
    _tracker.createInstance<SimpleExprWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 964, MySQLParser::RuleSimpleExprWithParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7083);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7084);
    simpleExpr(0);
    setState(7085);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderListContext ------------------------------------------------------------------

MySQLParser::OrderListContext::OrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::OrderExpressionContext *> MySQLParser::OrderListContext::orderExpression() {
  return getRuleContexts<MySQLParser::OrderExpressionContext>();
}

MySQLParser::OrderExpressionContext *MySQLParser::OrderListContext::orderExpression(size_t i) {
  return getRuleContext<MySQLParser::OrderExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::OrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::OrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::OrderListContext::getRuleIndex() const {
  return MySQLParser::RuleOrderList;
}

void MySQLParser::OrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderList(this);
}

void MySQLParser::OrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderList(this);
}

std::any MySQLParser::OrderListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOrderList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderListContext *MySQLParser::orderList() {
  OrderListContext *_localctx = _tracker.createInstance<OrderListContext>(_ctx, getState());
  enterRule(_localctx, 966, MySQLParser::RuleOrderList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7087);
    orderExpression();
    setState(7092);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7088);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7089);
        orderExpression();
      }
      setState(7094);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderExpressionContext ------------------------------------------------------------------

MySQLParser::OrderExpressionContext::OrderExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::OrderExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::DirectionContext *MySQLParser::OrderExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}

size_t MySQLParser::OrderExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleOrderExpression;
}

void MySQLParser::OrderExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderExpression(this);
}

void MySQLParser::OrderExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderExpression(this);
}

std::any MySQLParser::OrderExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOrderExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OrderExpressionContext *MySQLParser::orderExpression() {
  OrderExpressionContext *_localctx = _tracker.createInstance<OrderExpressionContext>(_ctx, getState());
  enterRule(_localctx, 968, MySQLParser::RuleOrderExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7095);
    expr(0);
    setState(7097);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 851, _ctx)) {
      case 1: {
        setState(7096);
        direction();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupListContext ------------------------------------------------------------------

MySQLParser::GroupListContext::GroupListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::GroupingExpressionContext *> MySQLParser::GroupListContext::groupingExpression() {
  return getRuleContexts<MySQLParser::GroupingExpressionContext>();
}

MySQLParser::GroupingExpressionContext *MySQLParser::GroupListContext::groupingExpression(size_t i) {
  return getRuleContext<MySQLParser::GroupingExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::GroupListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::GroupListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::GroupListContext::getRuleIndex() const {
  return MySQLParser::RuleGroupList;
}

void MySQLParser::GroupListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupList(this);
}

void MySQLParser::GroupListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupList(this);
}

std::any MySQLParser::GroupListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupListContext *MySQLParser::groupList() {
  GroupListContext *_localctx = _tracker.createInstance<GroupListContext>(_ctx, getState());
  enterRule(_localctx, 970, MySQLParser::RuleGroupList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7099);
    groupingExpression();
    setState(7104);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7100);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7101);
      groupingExpression();
      setState(7106);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingExpressionContext ------------------------------------------------------------------

MySQLParser::GroupingExpressionContext::GroupingExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::GroupingExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::GroupingExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingExpression;
}

void MySQLParser::GroupingExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingExpression(this);
}

void MySQLParser::GroupingExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingExpression(this);
}

std::any MySQLParser::GroupingExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGroupingExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GroupingExpressionContext *MySQLParser::groupingExpression() {
  GroupingExpressionContext *_localctx = _tracker.createInstance<GroupingExpressionContext>(_ctx, getState());
  enterRule(_localctx, 972, MySQLParser::RuleGroupingExpression);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7107);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelContext ------------------------------------------------------------------

MySQLParser::ChannelContext::ChannelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ChannelContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ChannelContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::ChannelContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

size_t MySQLParser::ChannelContext::getRuleIndex() const {
  return MySQLParser::RuleChannel;
}

void MySQLParser::ChannelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannel(this);
}

void MySQLParser::ChannelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannel(this);
}

std::any MySQLParser::ChannelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitChannel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ChannelContext *MySQLParser::channel() {
  ChannelContext *_localctx = _tracker.createInstance<ChannelContext>(_ctx, getState());
  enterRule(_localctx, 974, MySQLParser::RuleChannel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7109);
    match(MySQLParser::FOR_SYMBOL);
    setState(7110);
    match(MySQLParser::CHANNEL_SYMBOL);
    setState(7111);
    textStringNoLinebreak();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

MySQLParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleStatementContext *MySQLParser::CompoundStatementContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::ReturnStatementContext *MySQLParser::CompoundStatementContext::returnStatement() {
  return getRuleContext<MySQLParser::ReturnStatementContext>(0);
}

MySQLParser::IfStatementContext *MySQLParser::CompoundStatementContext::ifStatement() {
  return getRuleContext<MySQLParser::IfStatementContext>(0);
}

MySQLParser::CaseStatementContext *MySQLParser::CompoundStatementContext::caseStatement() {
  return getRuleContext<MySQLParser::CaseStatementContext>(0);
}

MySQLParser::LabeledBlockContext *MySQLParser::CompoundStatementContext::labeledBlock() {
  return getRuleContext<MySQLParser::LabeledBlockContext>(0);
}

MySQLParser::UnlabeledBlockContext *MySQLParser::CompoundStatementContext::unlabeledBlock() {
  return getRuleContext<MySQLParser::UnlabeledBlockContext>(0);
}

MySQLParser::LabeledControlContext *MySQLParser::CompoundStatementContext::labeledControl() {
  return getRuleContext<MySQLParser::LabeledControlContext>(0);
}

MySQLParser::UnlabeledControlContext *MySQLParser::CompoundStatementContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LeaveStatementContext *MySQLParser::CompoundStatementContext::leaveStatement() {
  return getRuleContext<MySQLParser::LeaveStatementContext>(0);
}

MySQLParser::IterateStatementContext *MySQLParser::CompoundStatementContext::iterateStatement() {
  return getRuleContext<MySQLParser::IterateStatementContext>(0);
}

MySQLParser::CursorOpenContext *MySQLParser::CompoundStatementContext::cursorOpen() {
  return getRuleContext<MySQLParser::CursorOpenContext>(0);
}

MySQLParser::CursorFetchContext *MySQLParser::CompoundStatementContext::cursorFetch() {
  return getRuleContext<MySQLParser::CursorFetchContext>(0);
}

MySQLParser::CursorCloseContext *MySQLParser::CompoundStatementContext::cursorClose() {
  return getRuleContext<MySQLParser::CursorCloseContext>(0);
}

size_t MySQLParser::CompoundStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatement;
}

void MySQLParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void MySQLParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}

std::any MySQLParser::CompoundStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCompoundStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompoundStatementContext *MySQLParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 976, MySQLParser::RuleCompoundStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7126);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 853, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7113);
        simpleStatement();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7114);
        returnStatement();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7115);
        ifStatement();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7116);
        caseStatement();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7117);
        labeledBlock();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(7118);
        unlabeledBlock();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(7119);
        labeledControl();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(7120);
        unlabeledControl();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(7121);
        leaveStatement();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(7122);
        iterateStatement();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(7123);
        cursorOpen();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(7124);
        cursorFetch();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(7125);
        cursorClose();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

MySQLParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReturnStatementContext::RETURN_SYMBOL() {
  return getToken(MySQLParser::RETURN_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::ReturnStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::ReturnStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReturnStatement;
}

void MySQLParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void MySQLParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

std::any MySQLParser::ReturnStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReturnStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReturnStatementContext *MySQLParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 978, MySQLParser::RuleReturnStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7128);
    match(MySQLParser::RETURN_SYMBOL);
    setState(7129);
    expr(0);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

MySQLParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::IfStatementContext::IF_SYMBOL() {
  return getTokens(MySQLParser::IF_SYMBOL);
}

tree::TerminalNode *MySQLParser::IfStatementContext::IF_SYMBOL(size_t i) {
  return getToken(MySQLParser::IF_SYMBOL, i);
}

MySQLParser::IfBodyContext *MySQLParser::IfStatementContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode *MySQLParser::IfStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

size_t MySQLParser::IfStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIfStatement;
}

void MySQLParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void MySQLParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

std::any MySQLParser::IfStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIfStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfStatementContext *MySQLParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 980, MySQLParser::RuleIfStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7131);
    match(MySQLParser::IF_SYMBOL);
    setState(7132);
    ifBody();
    setState(7133);
    match(MySQLParser::END_SYMBOL);
    setState(7134);
    match(MySQLParser::IF_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfBodyContext ------------------------------------------------------------------

MySQLParser::IfBodyContext::IfBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext *MySQLParser::IfBodyContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ThenStatementContext *MySQLParser::IfBodyContext::thenStatement() {
  return getRuleContext<MySQLParser::ThenStatementContext>(0);
}

tree::TerminalNode *MySQLParser::IfBodyContext::ELSEIF_SYMBOL() {
  return getToken(MySQLParser::ELSEIF_SYMBOL, 0);
}

MySQLParser::IfBodyContext *MySQLParser::IfBodyContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode *MySQLParser::IfBodyContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext *MySQLParser::IfBodyContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

size_t MySQLParser::IfBodyContext::getRuleIndex() const {
  return MySQLParser::RuleIfBody;
}

void MySQLParser::IfBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfBody(this);
}

void MySQLParser::IfBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfBody(this);
}

std::any MySQLParser::IfBodyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIfBody(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfBodyContext *MySQLParser::ifBody() {
  IfBodyContext *_localctx = _tracker.createInstance<IfBodyContext>(_ctx, getState());
  enterRule(_localctx, 982, MySQLParser::RuleIfBody);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7136);
    expr(0);
    setState(7137);
    thenStatement();
    setState(7142);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ELSEIF_SYMBOL: {
        setState(7138);
        match(MySQLParser::ELSEIF_SYMBOL);
        setState(7139);
        ifBody();
        break;
      }

      case MySQLParser::ELSE_SYMBOL: {
        setState(7140);
        match(MySQLParser::ELSE_SYMBOL);
        setState(7141);
        compoundStatementList();
        break;
      }

      case MySQLParser::END_SYMBOL: {
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenStatementContext ------------------------------------------------------------------

MySQLParser::ThenStatementContext::ThenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ThenStatementContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext *MySQLParser::ThenStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

size_t MySQLParser::ThenStatementContext::getRuleIndex() const {
  return MySQLParser::RuleThenStatement;
}

void MySQLParser::ThenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenStatement(this);
}

void MySQLParser::ThenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenStatement(this);
}

std::any MySQLParser::ThenStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitThenStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ThenStatementContext *MySQLParser::thenStatement() {
  ThenStatementContext *_localctx = _tracker.createInstance<ThenStatementContext>(_ctx, getState());
  enterRule(_localctx, 984, MySQLParser::RuleThenStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7144);
    match(MySQLParser::THEN_SYMBOL);
    setState(7145);
    compoundStatementList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementListContext ------------------------------------------------------------------

MySQLParser::CompoundStatementListContext::CompoundStatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CompoundStatementContext *> MySQLParser::CompoundStatementListContext::compoundStatement() {
  return getRuleContexts<MySQLParser::CompoundStatementContext>();
}

MySQLParser::CompoundStatementContext *MySQLParser::CompoundStatementListContext::compoundStatement(size_t i) {
  return getRuleContext<MySQLParser::CompoundStatementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode *MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}

size_t MySQLParser::CompoundStatementListContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatementList;
}

void MySQLParser::CompoundStatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatementList(this);
}

void MySQLParser::CompoundStatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatementList(this);
}

std::any MySQLParser::CompoundStatementListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCompoundStatementList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CompoundStatementListContext *MySQLParser::compoundStatementList() {
  CompoundStatementListContext *_localctx = _tracker.createInstance<CompoundStatementListContext>(_ctx, getState());
  enterRule(_localctx, 986, MySQLParser::RuleCompoundStatementList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7150);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(7147);
          compoundStatement();
          setState(7148);
          match(MySQLParser::SEMICOLON_SYMBOL);
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(7152);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 855, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStatementContext ------------------------------------------------------------------

MySQLParser::CaseStatementContext::CaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::CaseStatementContext::CASE_SYMBOL() {
  return getTokens(MySQLParser::CASE_SYMBOL);
}

tree::TerminalNode *MySQLParser::CaseStatementContext::CASE_SYMBOL(size_t i) {
  return getToken(MySQLParser::CASE_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::CaseStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::CaseStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::CaseStatementContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext *MySQLParser::CaseStatementContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenStatementContext *> MySQLParser::CaseStatementContext::thenStatement() {
  return getRuleContexts<MySQLParser::ThenStatementContext>();
}

MySQLParser::ThenStatementContext *MySQLParser::CaseStatementContext::thenStatement(size_t i) {
  return getRuleContext<MySQLParser::ThenStatementContext>(i);
}

MySQLParser::ElseStatementContext *MySQLParser::CaseStatementContext::elseStatement() {
  return getRuleContext<MySQLParser::ElseStatementContext>(0);
}

size_t MySQLParser::CaseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCaseStatement;
}

void MySQLParser::CaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStatement(this);
}

void MySQLParser::CaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStatement(this);
}

std::any MySQLParser::CaseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCaseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CaseStatementContext *MySQLParser::caseStatement() {
  CaseStatementContext *_localctx = _tracker.createInstance<CaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 988, MySQLParser::RuleCaseStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7154);
    match(MySQLParser::CASE_SYMBOL);
    setState(7156);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 856, _ctx)) {
      case 1: {
        setState(7155);
        expr(0);
        break;
      }

      default:
        break;
    }
    setState(7161);
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(7158);
      whenExpression();
      setState(7159);
      thenStatement();
      setState(7163);
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLParser::WHEN_SYMBOL);
    setState(7166);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ELSE_SYMBOL) {
      setState(7165);
      elseStatement();
    }
    setState(7168);
    match(MySQLParser::END_SYMBOL);
    setState(7169);
    match(MySQLParser::CASE_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseStatementContext ------------------------------------------------------------------

MySQLParser::ElseStatementContext::ElseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ElseStatementContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext *MySQLParser::ElseStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

size_t MySQLParser::ElseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleElseStatement;
}

void MySQLParser::ElseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseStatement(this);
}

void MySQLParser::ElseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseStatement(this);
}

std::any MySQLParser::ElseStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitElseStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ElseStatementContext *MySQLParser::elseStatement() {
  ElseStatementContext *_localctx = _tracker.createInstance<ElseStatementContext>(_ctx, getState());
  enterRule(_localctx, 990, MySQLParser::RuleElseStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7171);
    match(MySQLParser::ELSE_SYMBOL);
    setState(7172);
    compoundStatementList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledBlockContext ------------------------------------------------------------------

MySQLParser::LabeledBlockContext::LabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext *MySQLParser::LabeledBlockContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::BeginEndBlockContext *MySQLParser::LabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}

MySQLParser::LabelRefContext *MySQLParser::LabeledBlockContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}

size_t MySQLParser::LabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledBlock;
}

void MySQLParser::LabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledBlock(this);
}

void MySQLParser::LabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledBlock(this);
}

std::any MySQLParser::LabeledBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabeledBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabeledBlockContext *MySQLParser::labeledBlock() {
  LabeledBlockContext *_localctx = _tracker.createInstance<LabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 992, MySQLParser::RuleLabeledBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7174);
    label();
    setState(7175);
    beginEndBlock();
    setState(7177);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 859, _ctx)) {
      case 1: {
        setState(7176);
        labelRef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledBlockContext ------------------------------------------------------------------

MySQLParser::UnlabeledBlockContext::UnlabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BeginEndBlockContext *MySQLParser::UnlabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}

size_t MySQLParser::UnlabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledBlock;
}

void MySQLParser::UnlabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledBlock(this);
}

void MySQLParser::UnlabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledBlock(this);
}

std::any MySQLParser::UnlabeledBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUnlabeledBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnlabeledBlockContext *MySQLParser::unlabeledBlock() {
  UnlabeledBlockContext *_localctx = _tracker.createInstance<UnlabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 994, MySQLParser::RuleUnlabeledBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7179);
    beginEndBlock();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelContext ------------------------------------------------------------------

MySQLParser::LabelContext::LabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext *MySQLParser::LabelContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::LabelContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}

size_t MySQLParser::LabelContext::getRuleIndex() const {
  return MySQLParser::RuleLabel;
}

void MySQLParser::LabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel(this);
}

void MySQLParser::LabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel(this);
}

std::any MySQLParser::LabelContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabel(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelContext *MySQLParser::label() {
  LabelContext *_localctx = _tracker.createInstance<LabelContext>(_ctx, getState());
  enterRule(_localctx, 996, MySQLParser::RuleLabel);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7181);
    labelIdentifier();
    setState(7182);
    match(MySQLParser::COLON_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginEndBlockContext ------------------------------------------------------------------

MySQLParser::BeginEndBlockContext::BeginEndBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::BeginEndBlockContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::BeginEndBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::SpDeclarationsContext *MySQLParser::BeginEndBlockContext::spDeclarations() {
  return getRuleContext<MySQLParser::SpDeclarationsContext>(0);
}

MySQLParser::CompoundStatementListContext *MySQLParser::BeginEndBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

size_t MySQLParser::BeginEndBlockContext::getRuleIndex() const {
  return MySQLParser::RuleBeginEndBlock;
}

void MySQLParser::BeginEndBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginEndBlock(this);
}

void MySQLParser::BeginEndBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginEndBlock(this);
}

std::any MySQLParser::BeginEndBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitBeginEndBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BeginEndBlockContext *MySQLParser::beginEndBlock() {
  BeginEndBlockContext *_localctx = _tracker.createInstance<BeginEndBlockContext>(_ctx, getState());
  enterRule(_localctx, 998, MySQLParser::RuleBeginEndBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7184);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(7186);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx)) {
      case 1: {
        setState(7185);
        spDeclarations();
        break;
      }

      default:
        break;
    }
    setState(7189);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 861, _ctx)) {
      case 1: {
        setState(7188);
        compoundStatementList();
        break;
      }

      default:
        break;
    }
    setState(7191);
    match(MySQLParser::END_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledControlContext ------------------------------------------------------------------

MySQLParser::LabeledControlContext::LabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext *MySQLParser::LabeledControlContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::UnlabeledControlContext *MySQLParser::LabeledControlContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LabelRefContext *MySQLParser::LabeledControlContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}

size_t MySQLParser::LabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledControl;
}

void MySQLParser::LabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledControl(this);
}

void MySQLParser::LabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledControl(this);
}

std::any MySQLParser::LabeledControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabeledControl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabeledControlContext *MySQLParser::labeledControl() {
  LabeledControlContext *_localctx = _tracker.createInstance<LabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 1000, MySQLParser::RuleLabeledControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7193);
    label();
    setState(7194);
    unlabeledControl();
    setState(7196);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 862, _ctx)) {
      case 1: {
        setState(7195);
        labelRef();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledControlContext ------------------------------------------------------------------

MySQLParser::UnlabeledControlContext::UnlabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LoopBlockContext *MySQLParser::UnlabeledControlContext::loopBlock() {
  return getRuleContext<MySQLParser::LoopBlockContext>(0);
}

MySQLParser::WhileDoBlockContext *MySQLParser::UnlabeledControlContext::whileDoBlock() {
  return getRuleContext<MySQLParser::WhileDoBlockContext>(0);
}

MySQLParser::RepeatUntilBlockContext *MySQLParser::UnlabeledControlContext::repeatUntilBlock() {
  return getRuleContext<MySQLParser::RepeatUntilBlockContext>(0);
}

size_t MySQLParser::UnlabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledControl;
}

void MySQLParser::UnlabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledControl(this);
}

void MySQLParser::UnlabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledControl(this);
}

std::any MySQLParser::UnlabeledControlContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUnlabeledControl(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnlabeledControlContext *MySQLParser::unlabeledControl() {
  UnlabeledControlContext *_localctx = _tracker.createInstance<UnlabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 1002, MySQLParser::RuleUnlabeledControl);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7201);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LOOP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7198);
        loopBlock();
        break;
      }

      case MySQLParser::WHILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7199);
        whileDoBlock();
        break;
      }

      case MySQLParser::REPEAT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7200);
        repeatUntilBlock();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopBlockContext ------------------------------------------------------------------

MySQLParser::LoopBlockContext::LoopBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LoopBlockContext::LOOP_SYMBOL() {
  return getTokens(MySQLParser::LOOP_SYMBOL);
}

tree::TerminalNode *MySQLParser::LoopBlockContext::LOOP_SYMBOL(size_t i) {
  return getToken(MySQLParser::LOOP_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext *MySQLParser::LoopBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode *MySQLParser::LoopBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

size_t MySQLParser::LoopBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLoopBlock;
}

void MySQLParser::LoopBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopBlock(this);
}

void MySQLParser::LoopBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopBlock(this);
}

std::any MySQLParser::LoopBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLoopBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LoopBlockContext *MySQLParser::loopBlock() {
  LoopBlockContext *_localctx = _tracker.createInstance<LoopBlockContext>(_ctx, getState());
  enterRule(_localctx, 1004, MySQLParser::RuleLoopBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7203);
    match(MySQLParser::LOOP_SYMBOL);
    setState(7204);
    compoundStatementList();
    setState(7205);
    match(MySQLParser::END_SYMBOL);
    setState(7206);
    match(MySQLParser::LOOP_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileDoBlockContext ------------------------------------------------------------------

MySQLParser::WhileDoBlockContext::WhileDoBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::WhileDoBlockContext::WHILE_SYMBOL() {
  return getTokens(MySQLParser::WHILE_SYMBOL);
}

tree::TerminalNode *MySQLParser::WhileDoBlockContext::WHILE_SYMBOL(size_t i) {
  return getToken(MySQLParser::WHILE_SYMBOL, i);
}

MySQLParser::ExprContext *MySQLParser::WhileDoBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::WhileDoBlockContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext *MySQLParser::WhileDoBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode *MySQLParser::WhileDoBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

size_t MySQLParser::WhileDoBlockContext::getRuleIndex() const {
  return MySQLParser::RuleWhileDoBlock;
}

void MySQLParser::WhileDoBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileDoBlock(this);
}

void MySQLParser::WhileDoBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileDoBlock(this);
}

std::any MySQLParser::WhileDoBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWhileDoBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WhileDoBlockContext *MySQLParser::whileDoBlock() {
  WhileDoBlockContext *_localctx = _tracker.createInstance<WhileDoBlockContext>(_ctx, getState());
  enterRule(_localctx, 1006, MySQLParser::RuleWhileDoBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7208);
    match(MySQLParser::WHILE_SYMBOL);
    setState(7209);
    expr(0);
    setState(7210);
    match(MySQLParser::DO_SYMBOL);
    setState(7211);
    compoundStatementList();
    setState(7212);
    match(MySQLParser::END_SYMBOL);
    setState(7213);
    match(MySQLParser::WHILE_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatUntilBlockContext ------------------------------------------------------------------

MySQLParser::RepeatUntilBlockContext::RepeatUntilBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL() {
  return getTokens(MySQLParser::REPEAT_SYMBOL);
}

tree::TerminalNode *MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL(size_t i) {
  return getToken(MySQLParser::REPEAT_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext *MySQLParser::RepeatUntilBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode *MySQLParser::RepeatUntilBlockContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::RepeatUntilBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::RepeatUntilBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

size_t MySQLParser::RepeatUntilBlockContext::getRuleIndex() const {
  return MySQLParser::RuleRepeatUntilBlock;
}

void MySQLParser::RepeatUntilBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatUntilBlock(this);
}

void MySQLParser::RepeatUntilBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatUntilBlock(this);
}

std::any MySQLParser::RepeatUntilBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRepeatUntilBlock(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RepeatUntilBlockContext *MySQLParser::repeatUntilBlock() {
  RepeatUntilBlockContext *_localctx = _tracker.createInstance<RepeatUntilBlockContext>(_ctx, getState());
  enterRule(_localctx, 1008, MySQLParser::RuleRepeatUntilBlock);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7215);
    match(MySQLParser::REPEAT_SYMBOL);
    setState(7216);
    compoundStatementList();
    setState(7217);
    match(MySQLParser::UNTIL_SYMBOL);
    setState(7218);
    expr(0);
    setState(7219);
    match(MySQLParser::END_SYMBOL);
    setState(7220);
    match(MySQLParser::REPEAT_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationsContext ------------------------------------------------------------------

MySQLParser::SpDeclarationsContext::SpDeclarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SpDeclarationContext *> MySQLParser::SpDeclarationsContext::spDeclaration() {
  return getRuleContexts<MySQLParser::SpDeclarationContext>();
}

MySQLParser::SpDeclarationContext *MySQLParser::SpDeclarationsContext::spDeclaration(size_t i) {
  return getRuleContext<MySQLParser::SpDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode *MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}

size_t MySQLParser::SpDeclarationsContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclarations;
}

void MySQLParser::SpDeclarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclarations(this);
}

void MySQLParser::SpDeclarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclarations(this);
}

std::any MySQLParser::SpDeclarationsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSpDeclarations(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpDeclarationsContext *MySQLParser::spDeclarations() {
  SpDeclarationsContext *_localctx = _tracker.createInstance<SpDeclarationsContext>(_ctx, getState());
  enterRule(_localctx, 1010, MySQLParser::RuleSpDeclarations);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7225);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(7222);
          spDeclaration();
          setState(7223);
          match(MySQLParser::SEMICOLON_SYMBOL);
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(7227);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 864, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationContext ------------------------------------------------------------------

MySQLParser::SpDeclarationContext::SpDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::VariableDeclarationContext *MySQLParser::SpDeclarationContext::variableDeclaration() {
  return getRuleContext<MySQLParser::VariableDeclarationContext>(0);
}

MySQLParser::ConditionDeclarationContext *MySQLParser::SpDeclarationContext::conditionDeclaration() {
  return getRuleContext<MySQLParser::ConditionDeclarationContext>(0);
}

MySQLParser::HandlerDeclarationContext *MySQLParser::SpDeclarationContext::handlerDeclaration() {
  return getRuleContext<MySQLParser::HandlerDeclarationContext>(0);
}

MySQLParser::CursorDeclarationContext *MySQLParser::SpDeclarationContext::cursorDeclaration() {
  return getRuleContext<MySQLParser::CursorDeclarationContext>(0);
}

size_t MySQLParser::SpDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclaration;
}

void MySQLParser::SpDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclaration(this);
}

void MySQLParser::SpDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclaration(this);
}

std::any MySQLParser::SpDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSpDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpDeclarationContext *MySQLParser::spDeclaration() {
  SpDeclarationContext *_localctx = _tracker.createInstance<SpDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 1012, MySQLParser::RuleSpDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7233);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 865, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7229);
        variableDeclaration();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7230);
        conditionDeclaration();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7231);
        handlerDeclaration();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7232);
        cursorDeclaration();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

MySQLParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::VariableDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::VariableDeclarationContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::DataTypeContext *MySQLParser::VariableDeclarationContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext *MySQLParser::VariableDeclarationContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode *MySQLParser::VariableDeclarationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExprContext *MySQLParser::VariableDeclarationContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

size_t MySQLParser::VariableDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleVariableDeclaration;
}

void MySQLParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void MySQLParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

std::any MySQLParser::VariableDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitVariableDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VariableDeclarationContext *MySQLParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 1014, MySQLParser::RuleVariableDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7235);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(7236);
    identifierList();
    setState(7237);
    dataType();
    setState(7239);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLLATE_SYMBOL) {
      setState(7238);
      collate();
    }
    setState(7243);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7241);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(7242);
      expr(0);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionDeclarationContext ------------------------------------------------------------------

MySQLParser::ConditionDeclarationContext::ConditionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConditionDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ConditionDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::ConditionDeclarationContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ConditionDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SpConditionContext *MySQLParser::ConditionDeclarationContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}

size_t MySQLParser::ConditionDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleConditionDeclaration;
}

void MySQLParser::ConditionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionDeclaration(this);
}

void MySQLParser::ConditionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionDeclaration(this);
}

std::any MySQLParser::ConditionDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConditionDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConditionDeclarationContext *MySQLParser::conditionDeclaration() {
  ConditionDeclarationContext *_localctx = _tracker.createInstance<ConditionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 1016, MySQLParser::RuleConditionDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7245);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(7246);
    identifier();
    setState(7247);
    match(MySQLParser::CONDITION_SYMBOL);
    setState(7248);
    match(MySQLParser::FOR_SYMBOL);
    setState(7249);
    spCondition();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpConditionContext ------------------------------------------------------------------

MySQLParser::SpConditionContext::SpConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext *MySQLParser::SpConditionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

MySQLParser::SqlstateContext *MySQLParser::SpConditionContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}

size_t MySQLParser::SpConditionContext::getRuleIndex() const {
  return MySQLParser::RuleSpCondition;
}

void MySQLParser::SpConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpCondition(this);
}

void MySQLParser::SpConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpCondition(this);
}

std::any MySQLParser::SpConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSpCondition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpConditionContext *MySQLParser::spCondition() {
  SpConditionContext *_localctx = _tracker.createInstance<SpConditionContext>(_ctx, getState());
  enterRule(_localctx, 1018, MySQLParser::RuleSpCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7253);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(7251);
        ulong_number();
        break;
      }

      case MySQLParser::SQLSTATE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7252);
        sqlstate();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqlstateContext ------------------------------------------------------------------

MySQLParser::SqlstateContext::SqlstateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SqlstateContext::SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::SQLSTATE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::SqlstateContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::SqlstateContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

size_t MySQLParser::SqlstateContext::getRuleIndex() const {
  return MySQLParser::RuleSqlstate;
}

void MySQLParser::SqlstateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlstate(this);
}

void MySQLParser::SqlstateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlstate(this);
}

std::any MySQLParser::SqlstateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSqlstate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SqlstateContext *MySQLParser::sqlstate() {
  SqlstateContext *_localctx = _tracker.createInstance<SqlstateContext>(_ctx, getState());
  enterRule(_localctx, 1020, MySQLParser::RuleSqlstate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7255);
    match(MySQLParser::SQLSTATE_SYMBOL);
    setState(7257);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx)) {
      case 1: {
        setState(7256);
        match(MySQLParser::VALUE_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(7259);
    textLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerDeclarationContext ------------------------------------------------------------------

MySQLParser::HandlerDeclarationContext::HandlerDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

std::vector<MySQLParser::HandlerConditionContext *> MySQLParser::HandlerDeclarationContext::handlerCondition() {
  return getRuleContexts<MySQLParser::HandlerConditionContext>();
}

MySQLParser::HandlerConditionContext *MySQLParser::HandlerDeclarationContext::handlerCondition(size_t i) {
  return getRuleContext<MySQLParser::HandlerConditionContext>(i);
}

MySQLParser::CompoundStatementContext *MySQLParser::HandlerDeclarationContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::CONTINUE_SYMBOL() {
  return getToken(MySQLParser::CONTINUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::EXIT_SYMBOL() {
  return getToken(MySQLParser::EXIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::HandlerDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerDeclaration;
}

void MySQLParser::HandlerDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerDeclaration(this);
}

void MySQLParser::HandlerDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerDeclaration(this);
}

std::any MySQLParser::HandlerDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHandlerDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerDeclarationContext *MySQLParser::handlerDeclaration() {
  HandlerDeclarationContext *_localctx = _tracker.createInstance<HandlerDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 1022, MySQLParser::RuleHandlerDeclaration);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7261);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(7262);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CONTINUE_SYMBOL || _la == MySQLParser::EXIT_SYMBOL || _la == MySQLParser::UNDO_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7263);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(7264);
    match(MySQLParser::FOR_SYMBOL);
    setState(7265);
    handlerCondition();
    setState(7270);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7266);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7267);
        handlerCondition();
      }
      setState(7272);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx);
    }
    setState(7273);
    compoundStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerConditionContext ------------------------------------------------------------------

MySQLParser::HandlerConditionContext::HandlerConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SpConditionContext *MySQLParser::HandlerConditionContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}

MySQLParser::IdentifierContext *MySQLParser::HandlerConditionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerConditionContext::SQLWARNING_SYMBOL() {
  return getToken(MySQLParser::SQLWARNING_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::HandlerConditionContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode *MySQLParser::HandlerConditionContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::HandlerConditionContext::SQLEXCEPTION_SYMBOL() {
  return getToken(MySQLParser::SQLEXCEPTION_SYMBOL, 0);
}

size_t MySQLParser::HandlerConditionContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerCondition;
}

void MySQLParser::HandlerConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerCondition(this);
}

void MySQLParser::HandlerConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerCondition(this);
}

std::any MySQLParser::HandlerConditionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitHandlerCondition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::HandlerConditionContext *MySQLParser::handlerCondition() {
  HandlerConditionContext *_localctx = _tracker.createInstance<HandlerConditionContext>(_ctx, getState());
  enterRule(_localctx, 1024, MySQLParser::RuleHandlerCondition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7282);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7275);
        spCondition();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7276);
        identifier();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7277);
        match(MySQLParser::SQLWARNING_SYMBOL);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7278);
        notRule();
        setState(7279);
        match(MySQLParser::FOUND_SYMBOL);
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7281);
        match(MySQLParser::SQLEXCEPTION_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorDeclarationContext ------------------------------------------------------------------

MySQLParser::CursorDeclarationContext::CursorDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CursorDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CursorDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CursorDeclarationContext::CURSOR_SYMBOL() {
  return getToken(MySQLParser::CURSOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CursorDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SelectStatementContext *MySQLParser::CursorDeclarationContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

size_t MySQLParser::CursorDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleCursorDeclaration;
}

void MySQLParser::CursorDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorDeclaration(this);
}

void MySQLParser::CursorDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorDeclaration(this);
}

std::any MySQLParser::CursorDeclarationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCursorDeclaration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorDeclarationContext *MySQLParser::cursorDeclaration() {
  CursorDeclarationContext *_localctx = _tracker.createInstance<CursorDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 1026, MySQLParser::RuleCursorDeclaration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7284);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(7285);
    identifier();
    setState(7286);
    match(MySQLParser::CURSOR_SYMBOL);
    setState(7287);
    match(MySQLParser::FOR_SYMBOL);
    setState(7288);
    selectStatement();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterateStatementContext ------------------------------------------------------------------

MySQLParser::IterateStatementContext::IterateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IterateStatementContext::ITERATE_SYMBOL() {
  return getToken(MySQLParser::ITERATE_SYMBOL, 0);
}

MySQLParser::LabelRefContext *MySQLParser::IterateStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}

size_t MySQLParser::IterateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIterateStatement;
}

void MySQLParser::IterateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterateStatement(this);
}

void MySQLParser::IterateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterateStatement(this);
}

std::any MySQLParser::IterateStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIterateStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IterateStatementContext *MySQLParser::iterateStatement() {
  IterateStatementContext *_localctx = _tracker.createInstance<IterateStatementContext>(_ctx, getState());
  enterRule(_localctx, 1028, MySQLParser::RuleIterateStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7290);
    match(MySQLParser::ITERATE_SYMBOL);
    setState(7291);
    labelRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeaveStatementContext ------------------------------------------------------------------

MySQLParser::LeaveStatementContext::LeaveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LeaveStatementContext::LEAVE_SYMBOL() {
  return getToken(MySQLParser::LEAVE_SYMBOL, 0);
}

MySQLParser::LabelRefContext *MySQLParser::LeaveStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}

size_t MySQLParser::LeaveStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLeaveStatement;
}

void MySQLParser::LeaveStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeaveStatement(this);
}

void MySQLParser::LeaveStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeaveStatement(this);
}

std::any MySQLParser::LeaveStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLeaveStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LeaveStatementContext *MySQLParser::leaveStatement() {
  LeaveStatementContext *_localctx = _tracker.createInstance<LeaveStatementContext>(_ctx, getState());
  enterRule(_localctx, 1030, MySQLParser::RuleLeaveStatement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7293);
    match(MySQLParser::LEAVE_SYMBOL);
    setState(7294);
    labelRef();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetDiagnosticsStatementContext ------------------------------------------------------------------

MySQLParser::GetDiagnosticsStatementContext::GetDiagnosticsStatementContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::GET_SYMBOL() {
  return getToken(MySQLParser::GET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

std::vector<MySQLParser::StatementInformationItemContext *>
MySQLParser::GetDiagnosticsStatementContext::statementInformationItem() {
  return getRuleContexts<MySQLParser::StatementInformationItemContext>();
}

MySQLParser::StatementInformationItemContext *MySQLParser::GetDiagnosticsStatementContext::statementInformationItem(
  size_t i) {
  return getRuleContext<MySQLParser::StatementInformationItemContext>(i);
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

MySQLParser::SignalAllowedExprContext *MySQLParser::GetDiagnosticsStatementContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}

std::vector<MySQLParser::ConditionInformationItemContext *>
MySQLParser::GetDiagnosticsStatementContext::conditionInformationItem() {
  return getRuleContexts<MySQLParser::ConditionInformationItemContext>();
}

MySQLParser::ConditionInformationItemContext *MySQLParser::GetDiagnosticsStatementContext::conditionInformationItem(
  size_t i) {
  return getRuleContext<MySQLParser::ConditionInformationItemContext>(i);
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::GetDiagnosticsStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::GetDiagnosticsStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::GetDiagnosticsStatementContext::getRuleIndex() const {
  return MySQLParser::RuleGetDiagnosticsStatement;
}

void MySQLParser::GetDiagnosticsStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetDiagnosticsStatement(this);
}

void MySQLParser::GetDiagnosticsStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetDiagnosticsStatement(this);
}

std::any MySQLParser::GetDiagnosticsStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGetDiagnosticsStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GetDiagnosticsStatementContext *MySQLParser::getDiagnosticsStatement() {
  GetDiagnosticsStatementContext *_localctx = _tracker.createInstance<GetDiagnosticsStatementContext>(_ctx, getState());
  enterRule(_localctx, 1032, MySQLParser::RuleGetDiagnosticsStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7296);
    match(MySQLParser::GET_SYMBOL);
    setState(7298);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CURRENT_SYMBOL || _la == MySQLParser::STACKED_SYMBOL) {
      setState(7297);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CURRENT_SYMBOL || _la == MySQLParser::STACKED_SYMBOL)) {
        _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(7300);
    match(MySQLParser::DIAGNOSTICS_SYMBOL);
    setState(7319);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 875, _ctx)) {
      case 1: {
        setState(7301);
        statementInformationItem();
        setState(7306);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(7302);
          match(MySQLParser::COMMA_SYMBOL);
          setState(7303);
          statementInformationItem();
          setState(7308);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case 2: {
        setState(7309);
        match(MySQLParser::CONDITION_SYMBOL);
        setState(7310);
        signalAllowedExpr();
        setState(7311);
        conditionInformationItem();
        setState(7316);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(7312);
          match(MySQLParser::COMMA_SYMBOL);
          setState(7313);
          conditionInformationItem();
          setState(7318);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalAllowedExprContext ------------------------------------------------------------------

MySQLParser::SignalAllowedExprContext::SignalAllowedExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext *MySQLParser::SignalAllowedExprContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::RvalueSystemOrUserVariableContext *MySQLParser::SignalAllowedExprContext::rvalueSystemOrUserVariable() {
  return getRuleContext<MySQLParser::RvalueSystemOrUserVariableContext>(0);
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::SignalAllowedExprContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::SignalAllowedExprContext::getRuleIndex() const {
  return MySQLParser::RuleSignalAllowedExpr;
}

void MySQLParser::SignalAllowedExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalAllowedExpr(this);
}

void MySQLParser::SignalAllowedExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalAllowedExpr(this);
}

std::any MySQLParser::SignalAllowedExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignalAllowedExpr(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalAllowedExprContext *MySQLParser::signalAllowedExpr() {
  SignalAllowedExprContext *_localctx = _tracker.createInstance<SignalAllowedExprContext>(_ctx, getState());
  enterRule(_localctx, 1034, MySQLParser::RuleSignalAllowedExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7324);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 876, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7321);
        literal();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7322);
        rvalueSystemOrUserVariable();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7323);
        qualifiedIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementInformationItemContext ------------------------------------------------------------------

MySQLParser::StatementInformationItemContext::StatementInformationItemContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StatementInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::StatementInformationItemContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StatementInformationItemContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

MySQLParser::UserVariableContext *MySQLParser::StatementInformationItemContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::IdentifierContext *MySQLParser::StatementInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::StatementInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleStatementInformationItem;
}

void MySQLParser::StatementInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementInformationItem(this);
}

void MySQLParser::StatementInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementInformationItem(this);
}

std::any MySQLParser::StatementInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStatementInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StatementInformationItemContext *MySQLParser::statementInformationItem() {
  StatementInformationItemContext *_localctx =
    _tracker.createInstance<StatementInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 1036, MySQLParser::RuleStatementInformationItem);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7328);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 877, _ctx)) {
      case 1: {
        setState(7326);
        userVariable();
        break;
      }

      case 2: {
        setState(7327);
        identifier();
        break;
      }

      default:
        break;
    }
    setState(7330);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7331);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NUMBER_SYMBOL || _la == MySQLParser::ROW_COUNT_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionInformationItemContext ------------------------------------------------------------------

MySQLParser::ConditionInformationItemContext::ConditionInformationItemContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConditionInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::UserVariableContext *MySQLParser::ConditionInformationItemContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::IdentifierContext *MySQLParser::ConditionInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SignalInformationItemNameContext *
MySQLParser::ConditionInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode *MySQLParser::ConditionInformationItemContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

size_t MySQLParser::ConditionInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleConditionInformationItem;
}

void MySQLParser::ConditionInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionInformationItem(this);
}

void MySQLParser::ConditionInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionInformationItem(this);
}

std::any MySQLParser::ConditionInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConditionInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConditionInformationItemContext *MySQLParser::conditionInformationItem() {
  ConditionInformationItemContext *_localctx =
    _tracker.createInstance<ConditionInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 1038, MySQLParser::RuleConditionInformationItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7335);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 878, _ctx)) {
      case 1: {
        setState(7333);
        userVariable();
        break;
      }

      case 2: {
        setState(7334);
        identifier();
        break;
      }

      default:
        break;
    }
    setState(7337);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CATALOG_NAME_SYMBOL:
      case MySQLParser::CLASS_ORIGIN_SYMBOL:
      case MySQLParser::COLUMN_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
      case MySQLParser::CONSTRAINT_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
      case MySQLParser::CURSOR_NAME_SYMBOL:
      case MySQLParser::MESSAGE_TEXT_SYMBOL:
      case MySQLParser::MYSQL_ERRNO_SYMBOL:
      case MySQLParser::SCHEMA_NAME_SYMBOL:
      case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
      case MySQLParser::TABLE_NAME_SYMBOL: {
        setState(7338);
        signalInformationItemName();
        break;
      }

      case MySQLParser::RETURNED_SQLSTATE_SYMBOL: {
        setState(7339);
        match(MySQLParser::RETURNED_SQLSTATE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemNameContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemNameContext::SignalInformationItemNameContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemNameContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

size_t MySQLParser::SignalInformationItemNameContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItemName;
}

void MySQLParser::SignalInformationItemNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItemName(this);
}

void MySQLParser::SignalInformationItemNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItemName(this);
}

std::any MySQLParser::SignalInformationItemNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignalInformationItemName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalInformationItemNameContext *MySQLParser::signalInformationItemName() {
  SignalInformationItemNameContext *_localctx =
    _tracker.createInstance<SignalInformationItemNameContext>(_ctx, getState());
  enterRule(_localctx, 1040, MySQLParser::RuleSignalInformationItemName);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7342);
    _la = _input->LA(1);
    if (!(((((_la - 53) & ~0x3fULL) == 0) && ((1ULL << (_la - 53)) & 18014518769616897) != 0) ||
          _la == MySQLParser::MESSAGE_TEXT_SYMBOL

          || _la == MySQLParser::MYSQL_ERRNO_SYMBOL || _la == MySQLParser::SCHEMA_NAME_SYMBOL ||
          _la == MySQLParser::SUBCLASS_ORIGIN_SYMBOL

          || _la == MySQLParser::TABLE_NAME_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

MySQLParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SignalStatementContext::SIGNAL_SYMBOL() {
  return getToken(MySQLParser::SIGNAL_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::SignalStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SqlstateContext *MySQLParser::SignalStatementContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}

tree::TerminalNode *MySQLParser::SignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *> MySQLParser::SignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext *MySQLParser::SignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::SignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::SignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSignalStatement;
}

void MySQLParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void MySQLParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}

std::any MySQLParser::SignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalStatementContext *MySQLParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 1042, MySQLParser::RuleSignalStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7344);
    match(MySQLParser::SIGNAL_SYMBOL);
    setState(7347);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx)) {
      case 1: {
        setState(7345);
        identifier();
        break;
      }

      case 2: {
        setState(7346);
        sqlstate();
        break;
      }

      default:
        break;
    }
    setState(7358);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(7349);
      match(MySQLParser::SET_SYMBOL);
      setState(7350);
      signalInformationItem();
      setState(7355);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7351);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7352);
        signalInformationItem();
        setState(7357);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResignalStatementContext ------------------------------------------------------------------

MySQLParser::ResignalStatementContext::ResignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ResignalStatementContext::RESIGNAL_SYMBOL() {
  return getToken(MySQLParser::RESIGNAL_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ResignalStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SqlstateContext *MySQLParser::ResignalStatementContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}

tree::TerminalNode *MySQLParser::ResignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *>
MySQLParser::ResignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext *MySQLParser::ResignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ResignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ResignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ResignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleResignalStatement;
}

void MySQLParser::ResignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignalStatement(this);
}

void MySQLParser::ResignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignalStatement(this);
}

std::any MySQLParser::ResignalStatementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResignalStatement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResignalStatementContext *MySQLParser::resignalStatement() {
  ResignalStatementContext *_localctx = _tracker.createInstance<ResignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 1044, MySQLParser::RuleResignalStatement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7360);
    match(MySQLParser::RESIGNAL_SYMBOL);
    setState(7363);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 883, _ctx)) {
      case 1: {
        setState(7361);
        identifier();
        break;
      }

      case 2: {
        setState(7362);
        sqlstate();
        break;
      }

      default:
        break;
    }
    setState(7374);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(7365);
      match(MySQLParser::SET_SYMBOL);
      setState(7366);
      signalInformationItem();
      setState(7371);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7367);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7368);
        signalInformationItem();
        setState(7373);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemContext::SignalInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SignalInformationItemNameContext *MySQLParser::SignalInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode *MySQLParser::SignalInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::SignalAllowedExprContext *MySQLParser::SignalInformationItemContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}

size_t MySQLParser::SignalInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItem;
}

void MySQLParser::SignalInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItem(this);
}

void MySQLParser::SignalInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItem(this);
}

std::any MySQLParser::SignalInformationItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignalInformationItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignalInformationItemContext *MySQLParser::signalInformationItem() {
  SignalInformationItemContext *_localctx = _tracker.createInstance<SignalInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 1046, MySQLParser::RuleSignalInformationItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7376);
    signalInformationItemName();
    setState(7377);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7378);
    signalAllowedExpr();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorOpenContext ------------------------------------------------------------------

MySQLParser::CursorOpenContext::CursorOpenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CursorOpenContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CursorOpenContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::CursorOpenContext::getRuleIndex() const {
  return MySQLParser::RuleCursorOpen;
}

void MySQLParser::CursorOpenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorOpen(this);
}

void MySQLParser::CursorOpenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorOpen(this);
}

std::any MySQLParser::CursorOpenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCursorOpen(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorOpenContext *MySQLParser::cursorOpen() {
  CursorOpenContext *_localctx = _tracker.createInstance<CursorOpenContext>(_ctx, getState());
  enterRule(_localctx, 1048, MySQLParser::RuleCursorOpen);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7380);
    match(MySQLParser::OPEN_SYMBOL);
    setState(7381);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorCloseContext ------------------------------------------------------------------

MySQLParser::CursorCloseContext::CursorCloseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CursorCloseContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CursorCloseContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::CursorCloseContext::getRuleIndex() const {
  return MySQLParser::RuleCursorClose;
}

void MySQLParser::CursorCloseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorClose(this);
}

void MySQLParser::CursorCloseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorClose(this);
}

std::any MySQLParser::CursorCloseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCursorClose(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorCloseContext *MySQLParser::cursorClose() {
  CursorCloseContext *_localctx = _tracker.createInstance<CursorCloseContext>(_ctx, getState());
  enterRule(_localctx, 1050, MySQLParser::RuleCursorClose);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7383);
    match(MySQLParser::CLOSE_SYMBOL);
    setState(7384);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorFetchContext ------------------------------------------------------------------

MySQLParser::CursorFetchContext::CursorFetchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CursorFetchContext::FETCH_SYMBOL() {
  return getToken(MySQLParser::FETCH_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CursorFetchContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CursorFetchContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::CursorFetchContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode *MySQLParser::CursorFetchContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CursorFetchContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

size_t MySQLParser::CursorFetchContext::getRuleIndex() const {
  return MySQLParser::RuleCursorFetch;
}

void MySQLParser::CursorFetchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorFetch(this);
}

void MySQLParser::CursorFetchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorFetch(this);
}

std::any MySQLParser::CursorFetchContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCursorFetch(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CursorFetchContext *MySQLParser::cursorFetch() {
  CursorFetchContext *_localctx = _tracker.createInstance<CursorFetchContext>(_ctx, getState());
  enterRule(_localctx, 1052, MySQLParser::RuleCursorFetch);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7386);
    match(MySQLParser::FETCH_SYMBOL);
    setState(7391);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 887, _ctx)) {
      case 1: {
        setState(7388);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NEXT_SYMBOL) {
          setState(7387);
          match(MySQLParser::NEXT_SYMBOL);
        }
        setState(7390);
        match(MySQLParser::FROM_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(7393);
    identifier();
    setState(7394);
    match(MySQLParser::INTO_SYMBOL);
    setState(7395);
    identifierList();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScheduleContext ------------------------------------------------------------------

MySQLParser::ScheduleContext::ScheduleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ScheduleContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ScheduleContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext *MySQLParser::ScheduleContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode *MySQLParser::ScheduleContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

MySQLParser::IntervalContext *MySQLParser::ScheduleContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode *MySQLParser::ScheduleContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ScheduleContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

size_t MySQLParser::ScheduleContext::getRuleIndex() const {
  return MySQLParser::RuleSchedule;
}

void MySQLParser::ScheduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchedule(this);
}

void MySQLParser::ScheduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchedule(this);
}

std::any MySQLParser::ScheduleContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSchedule(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ScheduleContext *MySQLParser::schedule() {
  ScheduleContext *_localctx = _tracker.createInstance<ScheduleContext>(_ctx, getState());
  enterRule(_localctx, 1054, MySQLParser::RuleSchedule);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7410);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7397);
        match(MySQLParser::AT_SYMBOL);
        setState(7398);
        expr(0);
        break;
      }

      case MySQLParser::EVERY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7399);
        match(MySQLParser::EVERY_SYMBOL);
        setState(7400);
        expr(0);
        setState(7401);
        interval();
        setState(7404);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STARTS_SYMBOL) {
          setState(7402);
          match(MySQLParser::STARTS_SYMBOL);
          setState(7403);
          expr(0);
        }
        setState(7408);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ENDS_SYMBOL) {
          setState(7406);
          match(MySQLParser::ENDS_SYMBOL);
          setState(7407);
          expr(0);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefinitionContext ------------------------------------------------------------------

MySQLParser::ColumnDefinitionContext::ColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnNameContext *MySQLParser::ColumnDefinitionContext::columnName() {
  return getRuleContext<MySQLParser::ColumnNameContext>(0);
}

MySQLParser::FieldDefinitionContext *MySQLParser::ColumnDefinitionContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

MySQLParser::CheckOrReferencesContext *MySQLParser::ColumnDefinitionContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}

size_t MySQLParser::ColumnDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleColumnDefinition;
}

void MySQLParser::ColumnDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDefinition(this);
}

void MySQLParser::ColumnDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDefinition(this);
}

std::any MySQLParser::ColumnDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnDefinitionContext *MySQLParser::columnDefinition() {
  ColumnDefinitionContext *_localctx = _tracker.createInstance<ColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 1056, MySQLParser::RuleColumnDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7412);
    columnName();
    setState(7413);
    fieldDefinition();
    setState(7415);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx)) {
      case 1: {
        setState(7414);
        checkOrReferences();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOrReferencesContext ------------------------------------------------------------------

MySQLParser::CheckOrReferencesContext::CheckOrReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CheckConstraintContext *MySQLParser::CheckOrReferencesContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ReferencesContext *MySQLParser::CheckOrReferencesContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}

size_t MySQLParser::CheckOrReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOrReferences;
}

void MySQLParser::CheckOrReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOrReferences(this);
}

void MySQLParser::CheckOrReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOrReferences(this);
}

std::any MySQLParser::CheckOrReferencesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCheckOrReferences(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckOrReferencesContext *MySQLParser::checkOrReferences() {
  CheckOrReferencesContext *_localctx = _tracker.createInstance<CheckOrReferencesContext>(_ctx, getState());
  enterRule(_localctx, 1058, MySQLParser::RuleCheckOrReferences);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7420);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 892, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7417);

        if (!(serverVersion < 80016))
          throw FailedPredicateException(this, "serverVersion < 80016");
        setState(7418);
        checkConstraint();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7419);
        references();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckConstraintContext ------------------------------------------------------------------

MySQLParser::CheckConstraintContext::CheckConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CheckConstraintContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::CheckConstraintContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

size_t MySQLParser::CheckConstraintContext::getRuleIndex() const {
  return MySQLParser::RuleCheckConstraint;
}

void MySQLParser::CheckConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckConstraint(this);
}

void MySQLParser::CheckConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckConstraint(this);
}

std::any MySQLParser::CheckConstraintContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCheckConstraint(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CheckConstraintContext *MySQLParser::checkConstraint() {
  CheckConstraintContext *_localctx = _tracker.createInstance<CheckConstraintContext>(_ctx, getState());
  enterRule(_localctx, 1060, MySQLParser::RuleCheckConstraint);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7422);
    match(MySQLParser::CHECK_SYMBOL);
    setState(7423);
    exprWithParentheses();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintEnforcementContext ------------------------------------------------------------------

MySQLParser::ConstraintEnforcementContext::ConstraintEnforcementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConstraintEnforcementContext::ENFORCED_SYMBOL() {
  return getToken(MySQLParser::ENFORCED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ConstraintEnforcementContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

size_t MySQLParser::ConstraintEnforcementContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintEnforcement;
}

void MySQLParser::ConstraintEnforcementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintEnforcement(this);
}

void MySQLParser::ConstraintEnforcementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintEnforcement(this);
}

std::any MySQLParser::ConstraintEnforcementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConstraintEnforcement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConstraintEnforcementContext *MySQLParser::constraintEnforcement() {
  ConstraintEnforcementContext *_localctx = _tracker.createInstance<ConstraintEnforcementContext>(_ctx, getState());
  enterRule(_localctx, 1062, MySQLParser::RuleConstraintEnforcement);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7426);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::NOT_SYMBOL) {
      setState(7425);
      match(MySQLParser::NOT_SYMBOL);
    }
    setState(7428);
    match(MySQLParser::ENFORCED_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableConstraintDefContext ------------------------------------------------------------------

MySQLParser::TableConstraintDefContext::TableConstraintDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyListWithExpressionContext *MySQLParser::TableConstraintDefContext::keyListWithExpression() {
  return getRuleContext<MySQLParser::KeyListWithExpressionContext>(0);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IndexNameAndTypeContext *MySQLParser::TableConstraintDefContext::indexNameAndType() {
  return getRuleContext<MySQLParser::IndexNameAndTypeContext>(0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::TableConstraintDefContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext *MySQLParser::TableConstraintDefContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext *MySQLParser::TableConstraintDefContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexNameContext *MySQLParser::TableConstraintDefContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::TableConstraintDefContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext *MySQLParser::TableConstraintDefContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::TableConstraintDefContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext *MySQLParser::TableConstraintDefContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

MySQLParser::KeyListContext *MySQLParser::TableConstraintDefContext::keyList() {
  return getRuleContext<MySQLParser::KeyListContext>(0);
}

MySQLParser::ReferencesContext *MySQLParser::TableConstraintDefContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}

MySQLParser::CheckConstraintContext *MySQLParser::TableConstraintDefContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ConstraintNameContext *MySQLParser::TableConstraintDefContext::constraintName() {
  return getRuleContext<MySQLParser::ConstraintNameContext>(0);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableConstraintDefContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::ConstraintEnforcementContext *MySQLParser::TableConstraintDefContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}

size_t MySQLParser::TableConstraintDefContext::getRuleIndex() const {
  return MySQLParser::RuleTableConstraintDef;
}

void MySQLParser::TableConstraintDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableConstraintDef(this);
}

void MySQLParser::TableConstraintDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableConstraintDef(this);
}

std::any MySQLParser::TableConstraintDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableConstraintDef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableConstraintDefContext *MySQLParser::tableConstraintDef() {
  TableConstraintDefContext *_localctx = _tracker.createInstance<TableConstraintDefContext>(_ctx, getState());
  enterRule(_localctx, 1064, MySQLParser::RuleTableConstraintDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    setState(7505);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::KEY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7430);
        antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INDEX_SYMBOL

              || _la == MySQLParser::KEY_SYMBOL)) {
          antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7432);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 894, _ctx)) {
          case 1: {
            setState(7431);
            indexNameAndType();
            break;
          }

          default:
            break;
        }
        setState(7434);
        keyListWithExpression();
        setState(7438);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 895, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(7435);
            indexOption();
          }
          setState(7440);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 895, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7441);
        antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(7443);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 896, _ctx)) {
          case 1: {
            setState(7442);
            keyOrIndex();
            break;
          }

          default:
            break;
        }
        setState(7446);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 897, _ctx)) {
          case 1: {
            setState(7445);
            indexName();
            break;
          }

          default:
            break;
        }
        setState(7448);
        keyListWithExpression();
        setState(7452);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(7449);
            fulltextIndexOption();
          }
          setState(7454);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 898, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7455);
        antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(7457);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 899, _ctx)) {
          case 1: {
            setState(7456);
            keyOrIndex();
            break;
          }

          default:
            break;
        }
        setState(7460);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 900, _ctx)) {
          case 1: {
            setState(7459);
            indexName();
            break;
          }

          default:
            break;
        }
        setState(7462);
        keyListWithExpression();
        setState(7466);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 901, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(7463);
            spatialIndexOption();
          }
          setState(7468);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 901, _ctx);
        }
        break;
      }

      case MySQLParser::CHECK_SYMBOL:
      case MySQLParser::CONSTRAINT_SYMBOL:
      case MySQLParser::FOREIGN_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(7470);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CONSTRAINT_SYMBOL) {
          setState(7469);
          constraintName();
        }
        setState(7503);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::PRIMARY_SYMBOL:
          case MySQLParser::UNIQUE_SYMBOL: {
            setState(7478);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::PRIMARY_SYMBOL: {
                setState(7472);
                antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::PRIMARY_SYMBOL);
                setState(7473);
                match(MySQLParser::KEY_SYMBOL);
                break;
              }

              case MySQLParser::UNIQUE_SYMBOL: {
                setState(7474);
                antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::UNIQUE_SYMBOL);
                setState(7476);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 903, _ctx)) {
                  case 1: {
                    setState(7475);
                    keyOrIndex();
                    break;
                  }

                  default:
                    break;
                }
                break;
              }

              default:
                throw NoViableAltException(this);
            }
            setState(7481);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 905, _ctx)) {
              case 1: {
                setState(7480);
                indexNameAndType();
                break;
              }

              default:
                break;
            }
            setState(7483);
            keyListWithExpression();
            setState(7487);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 906, _ctx);
            while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
              if (alt == 1) {
                setState(7484);
                indexOption();
              }
              setState(7489);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 906, _ctx);
            }
            break;
          }

          case MySQLParser::FOREIGN_SYMBOL: {
            setState(7490);
            antlrcpp::downCast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FOREIGN_SYMBOL);
            setState(7491);
            match(MySQLParser::KEY_SYMBOL);
            setState(7493);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 907, _ctx)) {
              case 1: {
                setState(7492);
                indexName();
                break;
              }

              default:
                break;
            }
            setState(7495);
            keyList();
            setState(7496);
            references();
            break;
          }

          case MySQLParser::CHECK_SYMBOL: {
            setState(7498);
            checkConstraint();
            setState(7501);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 908, _ctx)) {
              case 1: {
                setState(7499);

                if (!(serverVersion >= 80017))
                  throw FailedPredicateException(this, "serverVersion >= 80017");
                setState(7500);
                constraintEnforcement();
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintNameContext ------------------------------------------------------------------

MySQLParser::ConstraintNameContext::ConstraintNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ConstraintNameContext::CONSTRAINT_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::ConstraintNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::ConstraintNameContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintName;
}

void MySQLParser::ConstraintNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintName(this);
}

void MySQLParser::ConstraintNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintName(this);
}

std::any MySQLParser::ConstraintNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitConstraintName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ConstraintNameContext *MySQLParser::constraintName() {
  ConstraintNameContext *_localctx = _tracker.createInstance<ConstraintNameContext>(_ctx, getState());
  enterRule(_localctx, 1066, MySQLParser::RuleConstraintName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7507);
    match(MySQLParser::CONSTRAINT_SYMBOL);
    setState(7509);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
      case 1: {
        setState(7508);
        identifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDefinitionContext ------------------------------------------------------------------

MySQLParser::FieldDefinitionContext::FieldDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext *MySQLParser::FieldDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode *MySQLParser::FieldDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::FieldDefinitionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

std::vector<MySQLParser::ColumnAttributeContext *> MySQLParser::FieldDefinitionContext::columnAttribute() {
  return getRuleContexts<MySQLParser::ColumnAttributeContext>();
}

MySQLParser::ColumnAttributeContext *MySQLParser::FieldDefinitionContext::columnAttribute(size_t i) {
  return getRuleContext<MySQLParser::ColumnAttributeContext>(i);
}

MySQLParser::CollateContext *MySQLParser::FieldDefinitionContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode *MySQLParser::FieldDefinitionContext::GENERATED_SYMBOL() {
  return getToken(MySQLParser::GENERATED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldDefinitionContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldDefinitionContext::VIRTUAL_SYMBOL() {
  return getToken(MySQLParser::VIRTUAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldDefinitionContext::STORED_SYMBOL() {
  return getToken(MySQLParser::STORED_SYMBOL, 0);
}

size_t MySQLParser::FieldDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFieldDefinition;
}

void MySQLParser::FieldDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldDefinition(this);
}

void MySQLParser::FieldDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldDefinition(this);
}

std::any MySQLParser::FieldDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldDefinitionContext *MySQLParser::fieldDefinition() {
  FieldDefinitionContext *_localctx = _tracker.createInstance<FieldDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 1068, MySQLParser::RuleFieldDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7511);
    dataType();
    setState(7536);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 917, _ctx)) {
      case 1: {
        setState(7515);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(7512);
            columnAttribute();
          }
          setState(7517);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx);
        }
        break;
      }

      case 2: {
        setState(7519);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COLLATE_SYMBOL) {
          setState(7518);
          collate();
        }
        setState(7523);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::GENERATED_SYMBOL) {
          setState(7521);
          match(MySQLParser::GENERATED_SYMBOL);
          setState(7522);
          match(MySQLParser::ALWAYS_SYMBOL);
        }
        setState(7525);
        match(MySQLParser::AS_SYMBOL);
        setState(7526);
        exprWithParentheses();
        setState(7528);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 915, _ctx)) {
          case 1: {
            setState(7527);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::STORED_SYMBOL || _la == MySQLParser::VIRTUAL_SYMBOL)) {
              _errHandler->recoverInline(this);
            } else {
              _errHandler->reportMatch(this);
              consume();
            }
            break;
          }

          default:
            break;
        }
        setState(7533);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(7530);
            columnAttribute();
          }
          setState(7535);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnAttributeContext ------------------------------------------------------------------

MySQLParser::ColumnAttributeContext::ColumnAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::NullLiteralContext *MySQLParser::ColumnAttributeContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::NowOrSignedLiteralContext *MySQLParser::ColumnAttributeContext::nowOrSignedLiteral() {
  return getRuleContext<MySQLParser::NowOrSignedLiteralContext>(0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::ColumnAttributeContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TimeFunctionParametersContext *MySQLParser::ColumnAttributeContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::ColumnAttributeContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::CollateContext *MySQLParser::ColumnAttributeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

MySQLParser::ColumnFormatContext *MySQLParser::ColumnAttributeContext::columnFormat() {
  return getRuleContext<MySQLParser::ColumnFormatContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

MySQLParser::StorageMediaContext *MySQLParser::ColumnAttributeContext::storageMedia() {
  return getRuleContext<MySQLParser::StorageMediaContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::ColumnAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

MySQLParser::CheckConstraintContext *MySQLParser::ColumnAttributeContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ConstraintNameContext *MySQLParser::ColumnAttributeContext::constraintName() {
  return getRuleContext<MySQLParser::ConstraintNameContext>(0);
}

MySQLParser::ConstraintEnforcementContext *MySQLParser::ColumnAttributeContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}

MySQLParser::JsonAttributeContext *MySQLParser::ColumnAttributeContext::jsonAttribute() {
  return getRuleContext<MySQLParser::JsonAttributeContext>(0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::ColumnAttributeContext::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0);
}

MySQLParser::VisibilityContext *MySQLParser::ColumnAttributeContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}

size_t MySQLParser::ColumnAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleColumnAttribute;
}

void MySQLParser::ColumnAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnAttribute(this);
}

void MySQLParser::ColumnAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnAttribute(this);
}

std::any MySQLParser::ColumnAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnAttributeContext *MySQLParser::columnAttribute() {
  ColumnAttributeContext *_localctx = _tracker.createInstance<ColumnAttributeContext>(_ctx, getState());
  enterRule(_localctx, 1070, MySQLParser::RuleColumnAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7599);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 926, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7539);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL) {
          setState(7538);
          match(MySQLParser::NOT_SYMBOL);
        }
        setState(7541);
        nullLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7542);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(7543);
        match(MySQLParser::NOT_SYMBOL);
        setState(7544);
        match(MySQLParser::SECONDARY_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7545);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::DEFAULT_SYMBOL);
        setState(7549);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 919, _ctx)) {
          case 1: {
            setState(7546);
            nowOrSignedLiteral();
            break;
          }

          case 2: {
            setState(7547);

            if (!(serverVersion >= 80013))
              throw FailedPredicateException(this, "serverVersion >= 80013");
            setState(7548);
            exprWithParentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7551);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::ON_SYMBOL);
        setState(7552);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(7553);
        match(MySQLParser::NOW_SYMBOL);
        setState(7555);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 920, _ctx)) {
          case 1: {
            setState(7554);
            timeFunctionParameters();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7557);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(7558);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SERIAL_SYMBOL);
        setState(7559);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(7560);
        match(MySQLParser::VALUE_SYMBOL);
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(7562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIMARY_SYMBOL) {
          setState(7561);
          match(MySQLParser::PRIMARY_SYMBOL);
        }
        setState(7564);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(7565);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::UNIQUE_SYMBOL);
        setState(7567);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 922, _ctx)) {
          case 1: {
            setState(7566);
            match(MySQLParser::KEY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(7569);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COMMENT_SYMBOL);
        setState(7570);
        textLiteral();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(7571);
        collate();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(7572);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COLUMN_FORMAT_SYMBOL);
        setState(7573);
        columnFormat();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(7574);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::STORAGE_SYMBOL);
        setState(7575);
        storageMedia();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(7576);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SRID_SYMBOL);
        setState(7577);
        real_ulonglong_number();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(7578);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(7580);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CONSTRAINT_SYMBOL) {
          setState(7579);
          constraintName();
        }
        setState(7582);
        checkConstraint();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(7583);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(7584);
        constraintEnforcement();
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(7585);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7586);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL);
        setState(7588);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 924, _ctx)) {
          case 1: {
            setState(7587);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(7590);
        jsonAttribute();
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(7591);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7592);
        antlrcpp::downCast<ColumnAttributeContext *>(_localctx)->value =
          match(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL);
        setState(7594);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 925, _ctx)) {
          case 1: {
            setState(7593);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(7596);
        jsonAttribute();
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(7597);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7598);
        visibility();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnFormatContext ------------------------------------------------------------------

MySQLParser::ColumnFormatContext::ColumnFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ColumnFormatContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnFormatContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ColumnFormatContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::ColumnFormatContext::getRuleIndex() const {
  return MySQLParser::RuleColumnFormat;
}

void MySQLParser::ColumnFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnFormat(this);
}

void MySQLParser::ColumnFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnFormat(this);
}

std::any MySQLParser::ColumnFormatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnFormat(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnFormatContext *MySQLParser::columnFormat() {
  ColumnFormatContext *_localctx = _tracker.createInstance<ColumnFormatContext>(_ctx, getState());
  enterRule(_localctx, 1072, MySQLParser::RuleColumnFormat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7601);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFAULT_SYMBOL

          || _la == MySQLParser::DYNAMIC_SYMBOL || _la == MySQLParser::FIXED_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageMediaContext ------------------------------------------------------------------

MySQLParser::StorageMediaContext::StorageMediaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StorageMediaContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StorageMediaContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::StorageMediaContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::StorageMediaContext::getRuleIndex() const {
  return MySQLParser::RuleStorageMedia;
}

void MySQLParser::StorageMediaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageMedia(this);
}

void MySQLParser::StorageMediaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageMedia(this);
}

std::any MySQLParser::StorageMediaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStorageMedia(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StorageMediaContext *MySQLParser::storageMedia() {
  StorageMediaContext *_localctx = _tracker.createInstance<StorageMediaContext>(_ctx, getState());
  enterRule(_localctx, 1074, MySQLParser::RuleStorageMedia);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7603);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFAULT_SYMBOL

          || _la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NowContext ------------------------------------------------------------------

MySQLParser::NowContext::NowContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NowContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

MySQLParser::FunctionDatetimePrecisionContext *MySQLParser::NowContext::functionDatetimePrecision() {
  return getRuleContext<MySQLParser::FunctionDatetimePrecisionContext>(0);
}

size_t MySQLParser::NowContext::getRuleIndex() const {
  return MySQLParser::RuleNow;
}

void MySQLParser::NowContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNow(this);
}

void MySQLParser::NowContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNow(this);
}

std::any MySQLParser::NowContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNow(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NowContext *MySQLParser::now() {
  NowContext *_localctx = _tracker.createInstance<NowContext>(_ctx, getState());
  enterRule(_localctx, 1076, MySQLParser::RuleNow);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7605);
    match(MySQLParser::NOW_SYMBOL);
    setState(7606);
    functionDatetimePrecision();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NowOrSignedLiteralContext ------------------------------------------------------------------

MySQLParser::NowOrSignedLiteralContext::NowOrSignedLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::NowContext *MySQLParser::NowOrSignedLiteralContext::now() {
  return getRuleContext<MySQLParser::NowContext>(0);
}

MySQLParser::SignedLiteralOrNullContext *MySQLParser::NowOrSignedLiteralContext::signedLiteralOrNull() {
  return getRuleContext<MySQLParser::SignedLiteralOrNullContext>(0);
}

size_t MySQLParser::NowOrSignedLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNowOrSignedLiteral;
}

void MySQLParser::NowOrSignedLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNowOrSignedLiteral(this);
}

void MySQLParser::NowOrSignedLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNowOrSignedLiteral(this);
}

std::any MySQLParser::NowOrSignedLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNowOrSignedLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NowOrSignedLiteralContext *MySQLParser::nowOrSignedLiteral() {
  NowOrSignedLiteralContext *_localctx = _tracker.createInstance<NowOrSignedLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1078, MySQLParser::RuleNowOrSignedLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7610);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 927, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7608);
        now();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7609);
        signedLiteralOrNull();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GcolAttributeContext ------------------------------------------------------------------

MySQLParser::GcolAttributeContext::GcolAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::GcolAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GcolAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::GcolAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::GcolAttributeContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::GcolAttributeContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::GcolAttributeContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode *MySQLParser::GcolAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

size_t MySQLParser::GcolAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleGcolAttribute;
}

void MySQLParser::GcolAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGcolAttribute(this);
}

void MySQLParser::GcolAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGcolAttribute(this);
}

std::any MySQLParser::GcolAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitGcolAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::GcolAttributeContext *MySQLParser::gcolAttribute() {
  GcolAttributeContext *_localctx = _tracker.createInstance<GcolAttributeContext>(_ctx, getState());
  enterRule(_localctx, 1080, MySQLParser::RuleGcolAttribute);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7626);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7612);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(7614);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::KEY_SYMBOL) {
          setState(7613);
          match(MySQLParser::KEY_SYMBOL);
        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7616);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(7617);
        textString();
        break;
      }

      case MySQLParser::NOT_SYMBOL:
      case MySQLParser::NULL_SYMBOL:
      case MySQLParser::NOT2_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7619);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL || _la == MySQLParser::NOT2_SYMBOL) {
          setState(7618);
          notRule();
        }
        setState(7621);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(7623);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIMARY_SYMBOL) {
          setState(7622);
          match(MySQLParser::PRIMARY_SYMBOL);
        }
        setState(7625);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferencesContext ------------------------------------------------------------------

MySQLParser::ReferencesContext::ReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReferencesContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

MySQLParser::TableRefContext *MySQLParser::ReferencesContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::IdentifierListWithParenthesesContext *MySQLParser::ReferencesContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::ReferencesContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ReferencesContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode *MySQLParser::ReferencesContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

std::vector<MySQLParser::DeleteOptionContext *> MySQLParser::ReferencesContext::deleteOption() {
  return getRuleContexts<MySQLParser::DeleteOptionContext>();
}

MySQLParser::DeleteOptionContext *MySQLParser::ReferencesContext::deleteOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteOptionContext>(i);
}

tree::TerminalNode *MySQLParser::ReferencesContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReferencesContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReferencesContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReferencesContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ReferencesContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

size_t MySQLParser::ReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleReferences;
}

void MySQLParser::ReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferences(this);
}

void MySQLParser::ReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferences(this);
}

std::any MySQLParser::ReferencesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReferences(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReferencesContext *MySQLParser::references() {
  ReferencesContext *_localctx = _tracker.createInstance<ReferencesContext>(_ctx, getState());
  enterRule(_localctx, 1082, MySQLParser::RuleReferences);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7628);
    match(MySQLParser::REFERENCES_SYMBOL);
    setState(7629);
    tableRef();
    setState(7631);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(7630);
      identifierListWithParentheses();
    }
    setState(7635);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MATCH_SYMBOL) {
      setState(7633);
      match(MySQLParser::MATCH_SYMBOL);
      setState(7634);
      antlrcpp::downCast<ReferencesContext *>(_localctx)->match = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FULL_SYMBOL || _la == MySQLParser::PARTIAL_SYMBOL ||
            _la == MySQLParser::SIMPLE_SYMBOL)) {
        antlrcpp::downCast<ReferencesContext *>(_localctx)->match = _errHandler->recoverInline(this);
      } else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(7653);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 936, _ctx)) {
      case 1: {
        setState(7637);
        match(MySQLParser::ON_SYMBOL);
        setState(7638);
        antlrcpp::downCast<ReferencesContext *>(_localctx)->option = match(MySQLParser::UPDATE_SYMBOL);
        setState(7639);
        deleteOption();
        setState(7643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(7640);
          match(MySQLParser::ON_SYMBOL);
          setState(7641);
          match(MySQLParser::DELETE_SYMBOL);
          setState(7642);
          deleteOption();
        }
        break;
      }

      case 2: {
        setState(7645);
        match(MySQLParser::ON_SYMBOL);
        setState(7646);
        antlrcpp::downCast<ReferencesContext *>(_localctx)->option = match(MySQLParser::DELETE_SYMBOL);
        setState(7647);
        deleteOption();
        setState(7651);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(7648);
          match(MySQLParser::ON_SYMBOL);
          setState(7649);
          match(MySQLParser::UPDATE_SYMBOL);
          setState(7650);
          deleteOption();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteOptionContext ------------------------------------------------------------------

MySQLParser::DeleteOptionContext::DeleteOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::NullLiteralContext *MySQLParser::DeleteOptionContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DeleteOptionContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

size_t MySQLParser::DeleteOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteOption;
}

void MySQLParser::DeleteOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteOption(this);
}

void MySQLParser::DeleteOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteOption(this);
}

std::any MySQLParser::DeleteOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDeleteOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DeleteOptionContext *MySQLParser::deleteOption() {
  DeleteOptionContext *_localctx = _tracker.createInstance<DeleteOptionContext>(_ctx, getState());
  enterRule(_localctx, 1084, MySQLParser::RuleDeleteOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7662);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 937, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7655);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7656);
        match(MySQLParser::SET_SYMBOL);
        setState(7657);
        nullLiteral();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7658);
        match(MySQLParser::SET_SYMBOL);
        setState(7659);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7660);
        match(MySQLParser::NO_SYMBOL);
        setState(7661);
        match(MySQLParser::ACTION_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListContext ------------------------------------------------------------------

MySQLParser::KeyListContext::KeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::KeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartContext *> MySQLParser::KeyListContext::keyPart() {
  return getRuleContexts<MySQLParser::KeyPartContext>();
}

MySQLParser::KeyPartContext *MySQLParser::KeyListContext::keyPart(size_t i) {
  return getRuleContext<MySQLParser::KeyPartContext>(i);
}

tree::TerminalNode *MySQLParser::KeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::KeyListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::KeyListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyList;
}

void MySQLParser::KeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyList(this);
}

void MySQLParser::KeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyList(this);
}

std::any MySQLParser::KeyListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyListContext *MySQLParser::keyList() {
  KeyListContext *_localctx = _tracker.createInstance<KeyListContext>(_ctx, getState());
  enterRule(_localctx, 1086, MySQLParser::RuleKeyList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7664);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7665);
    keyPart();
    setState(7670);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7666);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7667);
      keyPart();
      setState(7672);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7673);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartContext ------------------------------------------------------------------

MySQLParser::KeyPartContext::KeyPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::KeyPartContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldLengthContext *MySQLParser::KeyPartContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::DirectionContext *MySQLParser::KeyPartContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}

size_t MySQLParser::KeyPartContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPart;
}

void MySQLParser::KeyPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPart(this);
}

void MySQLParser::KeyPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPart(this);
}

std::any MySQLParser::KeyPartContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyPart(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyPartContext *MySQLParser::keyPart() {
  KeyPartContext *_localctx = _tracker.createInstance<KeyPartContext>(_ctx, getState());
  enterRule(_localctx, 1088, MySQLParser::RuleKeyPart);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7675);
    identifier();
    setState(7677);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(7676);
      fieldLength();
    }
    setState(7680);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
      setState(7679);
      direction();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListWithExpressionContext ------------------------------------------------------------------

MySQLParser::KeyListWithExpressionContext::KeyListWithExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::KeyListWithExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartOrExpressionContext *>
MySQLParser::KeyListWithExpressionContext::keyPartOrExpression() {
  return getRuleContexts<MySQLParser::KeyPartOrExpressionContext>();
}

MySQLParser::KeyPartOrExpressionContext *MySQLParser::KeyListWithExpressionContext::keyPartOrExpression(size_t i) {
  return getRuleContext<MySQLParser::KeyPartOrExpressionContext>(i);
}

tree::TerminalNode *MySQLParser::KeyListWithExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::KeyListWithExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyListWithExpression;
}

void MySQLParser::KeyListWithExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListWithExpression(this);
}

void MySQLParser::KeyListWithExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListWithExpression(this);
}

std::any MySQLParser::KeyListWithExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyListWithExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyListWithExpressionContext *MySQLParser::keyListWithExpression() {
  KeyListWithExpressionContext *_localctx = _tracker.createInstance<KeyListWithExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1090, MySQLParser::RuleKeyListWithExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7682);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7683);
    keyPartOrExpression();
    setState(7688);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7684);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7685);
      keyPartOrExpression();
      setState(7690);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7691);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartOrExpressionContext ------------------------------------------------------------------

MySQLParser::KeyPartOrExpressionContext::KeyPartOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyPartContext *MySQLParser::KeyPartOrExpressionContext::keyPart() {
  return getRuleContext<MySQLParser::KeyPartContext>(0);
}

MySQLParser::ExprWithParenthesesContext *MySQLParser::KeyPartOrExpressionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::DirectionContext *MySQLParser::KeyPartOrExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}

size_t MySQLParser::KeyPartOrExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPartOrExpression;
}

void MySQLParser::KeyPartOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPartOrExpression(this);
}

void MySQLParser::KeyPartOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPartOrExpression(this);
}

std::any MySQLParser::KeyPartOrExpressionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitKeyPartOrExpression(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::KeyPartOrExpressionContext *MySQLParser::keyPartOrExpression() {
  KeyPartOrExpressionContext *_localctx = _tracker.createInstance<KeyPartOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 1092, MySQLParser::RuleKeyPartOrExpression);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7699);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 943, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7693);
        keyPart();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7694);

        if (!(serverVersion >= 80013))
          throw FailedPredicateException(this, "serverVersion >= 80013");
        setState(7695);
        exprWithParentheses();
        setState(7697);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
          setState(7696);
          direction();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeContext ------------------------------------------------------------------

MySQLParser::IndexTypeContext::IndexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IndexTypeContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexTypeContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexTypeContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

size_t MySQLParser::IndexTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexType;
}

void MySQLParser::IndexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexType(this);
}

void MySQLParser::IndexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexType(this);
}

std::any MySQLParser::IndexTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexTypeContext *MySQLParser::indexType() {
  IndexTypeContext *_localctx = _tracker.createInstance<IndexTypeContext>(_ctx, getState());
  enterRule(_localctx, 1094, MySQLParser::RuleIndexType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7701);
    antlrcpp::downCast<IndexTypeContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BTREE_SYMBOL || _la == MySQLParser::HASH_SYMBOL || _la == MySQLParser::RTREE_SYMBOL)) {
      antlrcpp::downCast<IndexTypeContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexOptionContext ------------------------------------------------------------------

MySQLParser::IndexOptionContext::IndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext *MySQLParser::IndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

MySQLParser::IndexTypeClauseContext *MySQLParser::IndexOptionContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}

size_t MySQLParser::IndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleIndexOption;
}

void MySQLParser::IndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexOption(this);
}

void MySQLParser::IndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexOption(this);
}

std::any MySQLParser::IndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexOptionContext *MySQLParser::indexOption() {
  IndexOptionContext *_localctx = _tracker.createInstance<IndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 1096, MySQLParser::RuleIndexOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7705);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 944, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7703);
        commonIndexOption();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7704);
        indexTypeClause();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonIndexOptionContext ------------------------------------------------------------------

MySQLParser::CommonIndexOptionContext::CommonIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CommonIndexOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::CommonIndexOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::CommonIndexOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CommonIndexOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::CommonIndexOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::VisibilityContext *MySQLParser::CommonIndexOptionContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}

tree::TerminalNode *MySQLParser::CommonIndexOptionContext::ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL, 0);
}

MySQLParser::JsonAttributeContext *MySQLParser::CommonIndexOptionContext::jsonAttribute() {
  return getRuleContext<MySQLParser::JsonAttributeContext>(0);
}

tree::TerminalNode *MySQLParser::CommonIndexOptionContext::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0);
}

size_t MySQLParser::CommonIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonIndexOption;
}

void MySQLParser::CommonIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonIndexOption(this);
}

void MySQLParser::CommonIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonIndexOption(this);
}

std::any MySQLParser::CommonIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCommonIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CommonIndexOptionContext *MySQLParser::commonIndexOption() {
  CommonIndexOptionContext *_localctx = _tracker.createInstance<CommonIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 1098, MySQLParser::RuleCommonIndexOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7727);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 948, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7707);
        match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
        setState(7709);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(7708);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(7711);
        ulong_number();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7712);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(7713);
        textLiteral();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7714);
        visibility();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7715);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7716);
        match(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL);
        setState(7718);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 946, _ctx)) {
          case 1: {
            setState(7717);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(7720);
        jsonAttribute();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7721);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(7722);
        match(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL);
        setState(7724);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 947, _ctx)) {
          case 1: {
            setState(7723);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(7726);
        jsonAttribute();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityContext ------------------------------------------------------------------

MySQLParser::VisibilityContext::VisibilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::VisibilityContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::VisibilityContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

size_t MySQLParser::VisibilityContext::getRuleIndex() const {
  return MySQLParser::RuleVisibility;
}

void MySQLParser::VisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibility(this);
}

void MySQLParser::VisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibility(this);
}

std::any MySQLParser::VisibilityContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitVisibility(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::VisibilityContext *MySQLParser::visibility() {
  VisibilityContext *_localctx = _tracker.createInstance<VisibilityContext>(_ctx, getState());
  enterRule(_localctx, 1100, MySQLParser::RuleVisibility);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7729);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INVISIBLE_SYMBOL

          || _la == MySQLParser::VISIBLE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeClauseContext ------------------------------------------------------------------

MySQLParser::IndexTypeClauseContext::IndexTypeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexTypeContext *MySQLParser::IndexTypeClauseContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode *MySQLParser::IndexTypeClauseContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IndexTypeClauseContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

size_t MySQLParser::IndexTypeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexTypeClause;
}

void MySQLParser::IndexTypeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexTypeClause(this);
}

void MySQLParser::IndexTypeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexTypeClause(this);
}

std::any MySQLParser::IndexTypeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexTypeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexTypeClauseContext *MySQLParser::indexTypeClause() {
  IndexTypeClauseContext *_localctx = _tracker.createInstance<IndexTypeClauseContext>(_ctx, getState());
  enterRule(_localctx, 1102, MySQLParser::RuleIndexTypeClause);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7731);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TYPE_SYMBOL

          || _la == MySQLParser::USING_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7732);
    indexType();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextIndexOptionContext ------------------------------------------------------------------

MySQLParser::FulltextIndexOptionContext::FulltextIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext *MySQLParser::FulltextIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

tree::TerminalNode *MySQLParser::FulltextIndexOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FulltextIndexOptionContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::FulltextIndexOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::FulltextIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextIndexOption;
}

void MySQLParser::FulltextIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextIndexOption(this);
}

void MySQLParser::FulltextIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextIndexOption(this);
}

std::any MySQLParser::FulltextIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFulltextIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FulltextIndexOptionContext *MySQLParser::fulltextIndexOption() {
  FulltextIndexOptionContext *_localctx = _tracker.createInstance<FulltextIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 1104, MySQLParser::RuleFulltextIndexOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7738);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 949, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7734);
        commonIndexOption();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7735);
        match(MySQLParser::WITH_SYMBOL);
        setState(7736);
        match(MySQLParser::PARSER_SYMBOL);
        setState(7737);
        identifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpatialIndexOptionContext ------------------------------------------------------------------

MySQLParser::SpatialIndexOptionContext::SpatialIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext *MySQLParser::SpatialIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

size_t MySQLParser::SpatialIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSpatialIndexOption;
}

void MySQLParser::SpatialIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpatialIndexOption(this);
}

void MySQLParser::SpatialIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpatialIndexOption(this);
}

std::any MySQLParser::SpatialIndexOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSpatialIndexOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SpatialIndexOptionContext *MySQLParser::spatialIndexOption() {
  SpatialIndexOptionContext *_localctx = _tracker.createInstance<SpatialIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 1106, MySQLParser::RuleSpatialIndexOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7740);
    commonIndexOption();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeDefinitionContext ------------------------------------------------------------------

MySQLParser::DataTypeDefinitionContext::DataTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext *MySQLParser::DataTypeDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeDefinitionContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

size_t MySQLParser::DataTypeDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleDataTypeDefinition;
}

void MySQLParser::DataTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataTypeDefinition(this);
}

void MySQLParser::DataTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataTypeDefinition(this);
}

std::any MySQLParser::DataTypeDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDataTypeDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataTypeDefinitionContext *MySQLParser::dataTypeDefinition() {
  DataTypeDefinitionContext *_localctx = _tracker.createInstance<DataTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 1108, MySQLParser::RuleDataTypeDefinition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7742);
    dataType();
    setState(7743);
    match(MySQLParser::EOF);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

MySQLParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DataTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TINYINT_SYMBOL() {
  return getToken(MySQLParser::TINYINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::SMALLINT_SYMBOL() {
  return getToken(MySQLParser::SMALLINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MEDIUMINT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BIGINT_SYMBOL() {
  return getToken(MySQLParser::BIGINT_SYMBOL, 0);
}

MySQLParser::FieldLengthContext *MySQLParser::DataTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::FieldOptionsContext *MySQLParser::DataTypeContext::fieldOptions() {
  return getRuleContext<MySQLParser::FieldOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::DOUBLE_SYMBOL() {
  return getToken(MySQLParser::DOUBLE_SYMBOL, 0);
}

MySQLParser::PrecisionContext *MySQLParser::DataTypeContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::PRECISION_SYMBOL() {
  return getToken(MySQLParser::PRECISION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::FLOAT_SYMBOL() {
  return getToken(MySQLParser::FLOAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::NUMERIC_SYMBOL() {
  return getToken(MySQLParser::NUMERIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext *MySQLParser::DataTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext *MySQLParser::DataTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext *MySQLParser::DataTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::VARBINARY_SYMBOL() {
  return getToken(MySQLParser::VARBINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext *MySQLParser::DataTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TINYBLOB_SYMBOL() {
  return getToken(MySQLParser::TINYBLOB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::BLOB_SYMBOL() {
  return getToken(MySQLParser::BLOB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MEDIUMBLOB_SYMBOL() {
  return getToken(MySQLParser::MEDIUMBLOB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::LONGBLOB_SYMBOL() {
  return getToken(MySQLParser::LONGBLOB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::LONG_SYMBOL() {
  return getToken(MySQLParser::LONG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TINYTEXT_SYMBOL() {
  return getToken(MySQLParser::TINYTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MEDIUMTEXT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::LONGTEXT_SYMBOL() {
  return getToken(MySQLParser::LONGTEXT_SYMBOL, 0);
}

MySQLParser::StringListContext *MySQLParser::DataTypeContext::stringList() {
  return getRuleContext<MySQLParser::StringListContext>(0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DataTypeContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

size_t MySQLParser::DataTypeContext::getRuleIndex() const {
  return MySQLParser::RuleDataType;
}

void MySQLParser::DataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataType(this);
}

void MySQLParser::DataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataType(this);
}

std::any MySQLParser::DataTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDataType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DataTypeContext *MySQLParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 1110, MySQLParser::RuleDataType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7891);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7745);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BIGINT_SYMBOL || _la == MySQLParser::INT_SYMBOL ||
              _la == MySQLParser::MEDIUMINT_SYMBOL || _la == MySQLParser::SMALLINT_SYMBOL ||
              _la == MySQLParser::TINYINT_SYMBOL)) {
          antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7747);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 950, _ctx)) {
          case 1: {
            setState(7746);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7750);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 951, _ctx)) {
          case 1: {
            setState(7749);
            fieldOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7757);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::REAL_SYMBOL: {
            setState(7752);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::REAL_SYMBOL);
            break;
          }

          case MySQLParser::DOUBLE_SYMBOL: {
            setState(7753);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DOUBLE_SYMBOL);
            setState(7755);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 952, _ctx)) {
              case 1: {
                setState(7754);
                match(MySQLParser::PRECISION_SYMBOL);
                break;
              }

              default:
                break;
            }
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        setState(7760);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 954, _ctx)) {
          case 1: {
            setState(7759);
            precision();
            break;
          }

          default:
            break;
        }
        setState(7763);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 955, _ctx)) {
          case 1: {
            setState(7762);
            fieldOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7765);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DECIMAL_SYMBOL || _la == MySQLParser::FIXED_SYMBOL

              || _la == MySQLParser::FLOAT_SYMBOL || _la == MySQLParser::NUMERIC_SYMBOL)) {
          antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7767);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 956, _ctx)) {
          case 1: {
            setState(7766);
            floatOptions();
            break;
          }

          default:
            break;
        }
        setState(7770);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 957, _ctx)) {
          case 1: {
            setState(7769);
            fieldOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7772);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BIT_SYMBOL);
        setState(7774);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 958, _ctx)) {
          case 1: {
            setState(7773);
            fieldLength();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7776);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BOOLEAN_SYMBOL

              || _la == MySQLParser::BOOL_SYMBOL)) {
          antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(7777);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
        setState(7779);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 959, _ctx)) {
          case 1: {
            setState(7778);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7782);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 960, _ctx)) {
          case 1: {
            setState(7781);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(7784);
        nchar();
        setState(7786);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 961, _ctx)) {
          case 1: {
            setState(7785);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7789);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 962, _ctx)) {
          case 1: {
            setState(7788);
            match(MySQLParser::BINARY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(7791);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BINARY_SYMBOL);
        setState(7793);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 963, _ctx)) {
          case 1: {
            setState(7792);
            fieldLength();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(7798);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::CHAR_SYMBOL: {
            setState(7795);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
            setState(7796);
            match(MySQLParser::VARYING_SYMBOL);
            break;
          }

          case MySQLParser::VARCHAR_SYMBOL: {
            setState(7797);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARCHAR_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        setState(7800);
        fieldLength();
        setState(7802);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 965, _ctx)) {
          case 1: {
            setState(7801);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(7814);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 966, _ctx)) {
          case 1: {
            setState(7804);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
            setState(7805);
            match(MySQLParser::VARCHAR_SYMBOL);
            break;
          }

          case 2: {
            setState(7806);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NVARCHAR_SYMBOL);
            break;
          }

          case 3: {
            setState(7807);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
            setState(7808);
            match(MySQLParser::VARCHAR_SYMBOL);
            break;
          }

          case 4: {
            setState(7809);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
            setState(7810);
            match(MySQLParser::CHAR_SYMBOL);
            setState(7811);
            match(MySQLParser::VARYING_SYMBOL);
            break;
          }

          case 5: {
            setState(7812);
            antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
            setState(7813);
            match(MySQLParser::VARYING_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(7816);
        fieldLength();
        setState(7818);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 967, _ctx)) {
          case 1: {
            setState(7817);
            match(MySQLParser::BINARY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(7820);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARBINARY_SYMBOL);
        setState(7821);
        fieldLength();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(7822);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::YEAR_SYMBOL);
        setState(7824);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 968, _ctx)) {
          case 1: {
            setState(7823);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7827);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 969, _ctx)) {
          case 1: {
            setState(7826);
            fieldOptions();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(7829);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATE_SYMBOL);
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(7830);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIME_SYMBOL);
        setState(7832);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 970, _ctx)) {
          case 1: {
            setState(7831);
            typeDatetimePrecision();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(7834);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIMESTAMP_SYMBOL);
        setState(7836);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 971, _ctx)) {
          case 1: {
            setState(7835);
            typeDatetimePrecision();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(7838);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATETIME_SYMBOL);
        setState(7840);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
          case 1: {
            setState(7839);
            typeDatetimePrecision();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(7842);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYBLOB_SYMBOL);
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(7843);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BLOB_SYMBOL);
        setState(7845);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 973, _ctx)) {
          case 1: {
            setState(7844);
            fieldLength();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 19: {
        enterOuterAlt(_localctx, 19);
        setState(7847);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LONGBLOB_SYMBOL

              || _la == MySQLParser::MEDIUMBLOB_SYMBOL)) {
          antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 20: {
        enterOuterAlt(_localctx, 20);
        setState(7848);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
        setState(7849);
        match(MySQLParser::VARBINARY_SYMBOL);
        break;
      }

      case 21: {
        enterOuterAlt(_localctx, 21);
        setState(7850);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
        setState(7854);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 974, _ctx)) {
          case 1: {
            setState(7851);
            match(MySQLParser::CHAR_SYMBOL);
            setState(7852);
            match(MySQLParser::VARYING_SYMBOL);
            break;
          }

          case 2: {
            setState(7853);
            match(MySQLParser::VARCHAR_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(7857);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 975, _ctx)) {
          case 1: {
            setState(7856);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 22: {
        enterOuterAlt(_localctx, 22);
        setState(7859);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYTEXT_SYMBOL);
        setState(7861);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 976, _ctx)) {
          case 1: {
            setState(7860);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 23: {
        enterOuterAlt(_localctx, 23);
        setState(7863);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TEXT_SYMBOL);
        setState(7865);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 977, _ctx)) {
          case 1: {
            setState(7864);
            fieldLength();
            break;
          }

          default:
            break;
        }
        setState(7868);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 978, _ctx)) {
          case 1: {
            setState(7867);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 24: {
        enterOuterAlt(_localctx, 24);
        setState(7870);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::MEDIUMTEXT_SYMBOL);
        setState(7872);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 979, _ctx)) {
          case 1: {
            setState(7871);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 25: {
        enterOuterAlt(_localctx, 25);
        setState(7874);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONGTEXT_SYMBOL);
        setState(7876);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 980, _ctx)) {
          case 1: {
            setState(7875);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 26: {
        enterOuterAlt(_localctx, 26);
        setState(7878);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::ENUM_SYMBOL);
        setState(7879);
        stringList();
        setState(7881);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 981, _ctx)) {
          case 1: {
            setState(7880);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 27: {
        enterOuterAlt(_localctx, 27);
        setState(7883);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SET_SYMBOL);
        setState(7884);
        stringList();
        setState(7886);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 982, _ctx)) {
          case 1: {
            setState(7885);
            charsetWithOptBinary();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 28: {
        enterOuterAlt(_localctx, 28);
        setState(7888);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SERIAL_SYMBOL);
        break;
      }

      case 29: {
        enterOuterAlt(_localctx, 29);
        setState(7889);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = match(MySQLParser::JSON_SYMBOL);
        break;
      }

      case 30: {
        enterOuterAlt(_localctx, 30);
        setState(7890);
        antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::GEOMETRYCOLLECTION_SYMBOL

              || _la == MySQLParser::GEOMETRY_SYMBOL || _la == MySQLParser::LINESTRING_SYMBOL ||
              ((((_la - 351) & ~0x3fULL) == 0) && ((1ULL << (_la - 351)) & 3458764513820540935) != 0))) {
          antlrcpp::downCast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NcharContext ------------------------------------------------------------------

MySQLParser::NcharContext::NcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NcharContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NcharContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

size_t MySQLParser::NcharContext::getRuleIndex() const {
  return MySQLParser::RuleNchar;
}

void MySQLParser::NcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNchar(this);
}

void MySQLParser::NcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNchar(this);
}

std::any MySQLParser::NcharContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNchar(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NcharContext *MySQLParser::nchar() {
  NcharContext *_localctx = _tracker.createInstance<NcharContext>(_ctx, getState());
  enterRule(_localctx, 1112, MySQLParser::RuleNchar);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7896);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NCHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7893);
        antlrcpp::downCast<NcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        break;
      }

      case MySQLParser::NATIONAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7894);
        antlrcpp::downCast<NcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(7895);
        match(MySQLParser::CHAR_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RealTypeContext ------------------------------------------------------------------

MySQLParser::RealTypeContext::RealTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RealTypeContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RealTypeContext::DOUBLE_SYMBOL() {
  return getToken(MySQLParser::DOUBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RealTypeContext::PRECISION_SYMBOL() {
  return getToken(MySQLParser::PRECISION_SYMBOL, 0);
}

size_t MySQLParser::RealTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRealType;
}

void MySQLParser::RealTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealType(this);
}

void MySQLParser::RealTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealType(this);
}

std::any MySQLParser::RealTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRealType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RealTypeContext *MySQLParser::realType() {
  RealTypeContext *_localctx = _tracker.createInstance<RealTypeContext>(_ctx, getState());
  enterRule(_localctx, 1114, MySQLParser::RuleRealType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7903);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REAL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7898);
        antlrcpp::downCast<RealTypeContext *>(_localctx)->type = match(MySQLParser::REAL_SYMBOL);
        break;
      }

      case MySQLParser::DOUBLE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7899);
        antlrcpp::downCast<RealTypeContext *>(_localctx)->type = match(MySQLParser::DOUBLE_SYMBOL);
        setState(7901);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 985, _ctx)) {
          case 1: {
            setState(7900);
            match(MySQLParser::PRECISION_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldLengthContext ------------------------------------------------------------------

MySQLParser::FieldLengthContext::FieldLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FieldLengthContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldLengthContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::FieldLengthContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::FieldLengthContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

size_t MySQLParser::FieldLengthContext::getRuleIndex() const {
  return MySQLParser::RuleFieldLength;
}

void MySQLParser::FieldLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldLength(this);
}

void MySQLParser::FieldLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldLength(this);
}

std::any MySQLParser::FieldLengthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldLength(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldLengthContext *MySQLParser::fieldLength() {
  FieldLengthContext *_localctx = _tracker.createInstance<FieldLengthContext>(_ctx, getState());
  enterRule(_localctx, 1116, MySQLParser::RuleFieldLength);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7905);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7908);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 987, _ctx)) {
      case 1: {
        setState(7906);
        real_ulonglong_number();
        break;
      }

      case 2: {
        setState(7907);
        match(MySQLParser::DECIMAL_NUMBER);
        break;
      }

      default:
        break;
    }
    setState(7910);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOptionsContext ------------------------------------------------------------------

MySQLParser::FieldOptionsContext::FieldOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::SIGNED_SYMBOL() {
  return getTokens(MySQLParser::SIGNED_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOptionsContext::SIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::SIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL() {
  return getTokens(MySQLParser::UNSIGNED_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL() {
  return getTokens(MySQLParser::ZEROFILL_SYMBOL);
}

tree::TerminalNode *MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL(size_t i) {
  return getToken(MySQLParser::ZEROFILL_SYMBOL, i);
}

size_t MySQLParser::FieldOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOptions;
}

void MySQLParser::FieldOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOptions(this);
}

void MySQLParser::FieldOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOptions(this);
}

std::any MySQLParser::FieldOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldOptionsContext *MySQLParser::fieldOptions() {
  FieldOptionsContext *_localctx = _tracker.createInstance<FieldOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1118, MySQLParser::RuleFieldOptions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7913);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(7912);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::SIGNED_SYMBOL || _la == MySQLParser::UNSIGNED_SYMBOL

                || _la == MySQLParser::ZEROFILL_SYMBOL)) {
            _errHandler->recoverInline(this);
          } else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(7915);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 988, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetWithOptBinaryContext ------------------------------------------------------------------

MySQLParser::CharsetWithOptBinaryContext::CharsetWithOptBinaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AsciiContext *MySQLParser::CharsetWithOptBinaryContext::ascii() {
  return getRuleContext<MySQLParser::AsciiContext>(0);
}

MySQLParser::UnicodeContext *MySQLParser::CharsetWithOptBinaryContext::unicode() {
  return getRuleContext<MySQLParser::UnicodeContext>(0);
}

tree::TerminalNode *MySQLParser::CharsetWithOptBinaryContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

MySQLParser::CharsetContext *MySQLParser::CharsetWithOptBinaryContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext *MySQLParser::CharsetWithOptBinaryContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode *MySQLParser::CharsetWithOptBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

size_t MySQLParser::CharsetWithOptBinaryContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetWithOptBinary;
}

void MySQLParser::CharsetWithOptBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetWithOptBinary(this);
}

void MySQLParser::CharsetWithOptBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetWithOptBinary(this);
}

std::any MySQLParser::CharsetWithOptBinaryContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCharsetWithOptBinary(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetWithOptBinaryContext *MySQLParser::charsetWithOptBinary() {
  CharsetWithOptBinaryContext *_localctx = _tracker.createInstance<CharsetWithOptBinaryContext>(_ctx, getState());
  enterRule(_localctx, 1120, MySQLParser::RuleCharsetWithOptBinary);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7931);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 991, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7917);
        ascii();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7918);
        unicode();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7919);
        match(MySQLParser::BYTE_SYMBOL);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(7920);
        charset();
        setState(7921);
        charsetName();
        setState(7923);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 989, _ctx)) {
          case 1: {
            setState(7922);
            match(MySQLParser::BINARY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(7925);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7929);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 990, _ctx)) {
          case 1: {
            setState(7926);
            charset();
            setState(7927);
            charsetName();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsciiContext ------------------------------------------------------------------

MySQLParser::AsciiContext::AsciiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::AsciiContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::AsciiContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

size_t MySQLParser::AsciiContext::getRuleIndex() const {
  return MySQLParser::RuleAscii;
}

void MySQLParser::AsciiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAscii(this);
}

void MySQLParser::AsciiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAscii(this);
}

std::any MySQLParser::AsciiContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitAscii(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::AsciiContext *MySQLParser::ascii() {
  AsciiContext *_localctx = _tracker.createInstance<AsciiContext>(_ctx, getState());
  enterRule(_localctx, 1122, MySQLParser::RuleAscii);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7939);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASCII_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7933);
        match(MySQLParser::ASCII_SYMBOL);
        setState(7935);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx)) {
          case 1: {
            setState(7934);
            match(MySQLParser::BINARY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7937);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7938);
        match(MySQLParser::ASCII_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnicodeContext ------------------------------------------------------------------

MySQLParser::UnicodeContext::UnicodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UnicodeContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UnicodeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

size_t MySQLParser::UnicodeContext::getRuleIndex() const {
  return MySQLParser::RuleUnicode;
}

void MySQLParser::UnicodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnicode(this);
}

void MySQLParser::UnicodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnicode(this);
}

std::any MySQLParser::UnicodeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUnicode(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UnicodeContext *MySQLParser::unicode() {
  UnicodeContext *_localctx = _tracker.createInstance<UnicodeContext>(_ctx, getState());
  enterRule(_localctx, 1124, MySQLParser::RuleUnicode);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7947);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNICODE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7941);
        match(MySQLParser::UNICODE_SYMBOL);
        setState(7943);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx)) {
          case 1: {
            setState(7942);
            match(MySQLParser::BINARY_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7945);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7946);
        match(MySQLParser::UNICODE_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WsNumCodepointsContext ------------------------------------------------------------------

MySQLParser::WsNumCodepointsContext::WsNumCodepointsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::WsNumCodepointsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::WsNumCodepointsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::WsNumCodepointsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::WsNumCodepointsContext::getRuleIndex() const {
  return MySQLParser::RuleWsNumCodepoints;
}

void MySQLParser::WsNumCodepointsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWsNumCodepoints(this);
}

void MySQLParser::WsNumCodepointsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWsNumCodepoints(this);
}

std::any MySQLParser::WsNumCodepointsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWsNumCodepoints(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WsNumCodepointsContext *MySQLParser::wsNumCodepoints() {
  WsNumCodepointsContext *_localctx = _tracker.createInstance<WsNumCodepointsContext>(_ctx, getState());
  enterRule(_localctx, 1126, MySQLParser::RuleWsNumCodepoints);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7949);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7950);
    real_ulong_number();
    setState(7951);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDatetimePrecisionContext ------------------------------------------------------------------

MySQLParser::TypeDatetimePrecisionContext::TypeDatetimePrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TypeDatetimePrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TypeDatetimePrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::TypeDatetimePrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::TypeDatetimePrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleTypeDatetimePrecision;
}

void MySQLParser::TypeDatetimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDatetimePrecision(this);
}

void MySQLParser::TypeDatetimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDatetimePrecision(this);
}

std::any MySQLParser::TypeDatetimePrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTypeDatetimePrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TypeDatetimePrecisionContext *MySQLParser::typeDatetimePrecision() {
  TypeDatetimePrecisionContext *_localctx = _tracker.createInstance<TypeDatetimePrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1128, MySQLParser::RuleTypeDatetimePrecision);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7953);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7954);
    match(MySQLParser::INT_NUMBER);
    setState(7955);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionDatetimePrecisionContext ------------------------------------------------------------------

MySQLParser::FunctionDatetimePrecisionContext::FunctionDatetimePrecisionContext(ParserRuleContext *parent,
                                                                                size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParenthesesContext *MySQLParser::FunctionDatetimePrecisionContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::FunctionDatetimePrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FunctionDatetimePrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::FunctionDatetimePrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::FunctionDatetimePrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionDatetimePrecision;
}

void MySQLParser::FunctionDatetimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionDatetimePrecision(this);
}

void MySQLParser::FunctionDatetimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionDatetimePrecision(this);
}

std::any MySQLParser::FunctionDatetimePrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFunctionDatetimePrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionDatetimePrecisionContext *MySQLParser::functionDatetimePrecision() {
  FunctionDatetimePrecisionContext *_localctx =
    _tracker.createInstance<FunctionDatetimePrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1130, MySQLParser::RuleFunctionDatetimePrecision);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7962);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 996, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);

        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7958);
        parentheses();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7959);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(7960);
        match(MySQLParser::INT_NUMBER);
        setState(7961);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameContext ------------------------------------------------------------------

MySQLParser::CharsetNameContext::CharsetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::CharsetNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CharsetNameContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CharsetNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::CharsetNameContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetName;
}

void MySQLParser::CharsetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetName(this);
}

void MySQLParser::CharsetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetName(this);
}

std::any MySQLParser::CharsetNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCharsetName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetNameContext *MySQLParser::charsetName() {
  CharsetNameContext *_localctx = _tracker.createInstance<CharsetNameContext>(_ctx, getState());
  enterRule(_localctx, 1132, MySQLParser::RuleCharsetName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7968);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 997, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7964);
        textOrIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7965);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7966);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(7967);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollationNameContext ------------------------------------------------------------------

MySQLParser::CollationNameContext::CollationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::CollationNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CollationNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CollationNameContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

size_t MySQLParser::CollationNameContext::getRuleIndex() const {
  return MySQLParser::RuleCollationName;
}

void MySQLParser::CollationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollationName(this);
}

void MySQLParser::CollationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollationName(this);
}

std::any MySQLParser::CollationNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCollationName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CollationNameContext *MySQLParser::collationName() {
  CollationNameContext *_localctx = _tracker.createInstance<CollationNameContext>(_ctx, getState());
  enterRule(_localctx, 1134, MySQLParser::RuleCollationName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7975);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 998, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7970);
        textOrIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7971);

        if (!(serverVersion < 80011))
          throw FailedPredicateException(this, "serverVersion < 80011");
        setState(7972);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(7973);

        if (!(serverVersion >= 80018))
          throw FailedPredicateException(this, "serverVersion >= 80018");
        setState(7974);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsContext::CreateTableOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *> MySQLParser::CreateTableOptionsContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext *MySQLParser::CreateTableOptionsContext::createTableOption(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::CreateTableOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptions;
}

void MySQLParser::CreateTableOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptions(this);
}

void MySQLParser::CreateTableOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptions(this);
}

std::any MySQLParser::CreateTableOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTableOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionsContext *MySQLParser::createTableOptions() {
  CreateTableOptionsContext *_localctx = _tracker.createInstance<CreateTableOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1136, MySQLParser::RuleCreateTableOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7977);
    createTableOption();
    setState(7984);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7979);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 999, _ctx)) {
          case 1: {
            setState(7978);
            match(MySQLParser::COMMA_SYMBOL);
            break;
          }

          default:
            break;
        }
        setState(7981);
        createTableOption();
      }
      setState(7986);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1000, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsEtcContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsEtcContext::CreateTableOptionsEtcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateTableOptionsContext *MySQLParser::CreateTableOptionsEtcContext::createTableOptions() {
  return getRuleContext<MySQLParser::CreateTableOptionsContext>(0);
}

MySQLParser::CreatePartitioningEtcContext *MySQLParser::CreateTableOptionsEtcContext::createPartitioningEtc() {
  return getRuleContext<MySQLParser::CreatePartitioningEtcContext>(0);
}

size_t MySQLParser::CreateTableOptionsEtcContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptionsEtc;
}

void MySQLParser::CreateTableOptionsEtcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptionsEtc(this);
}

void MySQLParser::CreateTableOptionsEtcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptionsEtc(this);
}

std::any MySQLParser::CreateTableOptionsEtcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTableOptionsEtc(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionsEtcContext *MySQLParser::createTableOptionsEtc() {
  CreateTableOptionsEtcContext *_localctx = _tracker.createInstance<CreateTableOptionsEtcContext>(_ctx, getState());
  enterRule(_localctx, 1138, MySQLParser::RuleCreateTableOptionsEtc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7992);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7987);
        createTableOptions();
        setState(7989);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1001, _ctx)) {
          case 1: {
            setState(7988);
            createPartitioningEtc();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7991);
        createPartitioningEtc();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreatePartitioningEtcContext ------------------------------------------------------------------

MySQLParser::CreatePartitioningEtcContext::CreatePartitioningEtcContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PartitionClauseContext *MySQLParser::CreatePartitioningEtcContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::DuplicateAsQeContext *MySQLParser::CreatePartitioningEtcContext::duplicateAsQe() {
  return getRuleContext<MySQLParser::DuplicateAsQeContext>(0);
}

size_t MySQLParser::CreatePartitioningEtcContext::getRuleIndex() const {
  return MySQLParser::RuleCreatePartitioningEtc;
}

void MySQLParser::CreatePartitioningEtcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreatePartitioningEtc(this);
}

void MySQLParser::CreatePartitioningEtcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreatePartitioningEtc(this);
}

std::any MySQLParser::CreatePartitioningEtcContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreatePartitioningEtc(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreatePartitioningEtcContext *MySQLParser::createPartitioningEtc() {
  CreatePartitioningEtcContext *_localctx = _tracker.createInstance<CreatePartitioningEtcContext>(_ctx, getState());
  enterRule(_localctx, 1140, MySQLParser::RuleCreatePartitioningEtc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(7999);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1004, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(7994);
        partitionClause();
        setState(7996);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1003, _ctx)) {
          case 1: {
            setState(7995);
            duplicateAsQe();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(7998);
        duplicateAsQe();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsSpaceSeparatedContext
//------------------------------------------------------------------

MySQLParser::CreateTableOptionsSpaceSeparatedContext::CreateTableOptionsSpaceSeparatedContext(ParserRuleContext *parent,
                                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *>
MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext *MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption(
  size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}

size_t MySQLParser::CreateTableOptionsSpaceSeparatedContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptionsSpaceSeparated;
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptionsSpaceSeparated(this);
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptionsSpaceSeparated(this);
}

std::any MySQLParser::CreateTableOptionsSpaceSeparatedContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTableOptionsSpaceSeparated(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext *MySQLParser::createTableOptionsSpaceSeparated() {
  CreateTableOptionsSpaceSeparatedContext *_localctx =
    _tracker.createInstance<CreateTableOptionsSpaceSeparatedContext>(_ctx, getState());
  enterRule(_localctx, 1142, MySQLParser::RuleCreateTableOptionsSpaceSeparated);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8002);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(8001);
          createTableOption();
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(8004);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1005, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionContext::CreateTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::EngineRefContext *MySQLParser::CreateTableOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::CreateTableOptionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::EqualContext *MySQLParser::CreateTableOptionContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::CreateTableOptionContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::CreateTableOptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::CreateTableOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

MySQLParser::TernaryOptionContext *MySQLParser::CreateTableOptionContext::ternaryOption() {
  return getRuleContext<MySQLParser::TernaryOptionContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::CreateTableOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableRefListContext *MySQLParser::CreateTableOptionContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::UNION_SYMBOL() {
  return getToken(MySQLParser::UNION_SYMBOL, 0);
}

MySQLParser::DefaultCharsetContext *MySQLParser::CreateTableOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext *MySQLParser::CreateTableOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::CreateTableOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

MySQLParser::JsonAttributeContext *MySQLParser::CreateTableOptionContext::jsonAttribute() {
  return getRuleContext<MySQLParser::JsonAttributeContext>(0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::CreateTableOptionContext::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0);
}

MySQLParser::TsOptionAutoextendSizeContext *MySQLParser::CreateTableOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

size_t MySQLParser::CreateTableOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOption;
}

void MySQLParser::CreateTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOption(this);
}

void MySQLParser::CreateTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOption(this);
}

std::any MySQLParser::CreateTableOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateTableOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateTableOptionContext *MySQLParser::createTableOption() {
  CreateTableOptionContext *_localctx = _tracker.createInstance<CreateTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 1144, MySQLParser::RuleCreateTableOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8146);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8006);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
        setState(8008);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1006, _ctx)) {
          case 1: {
            setState(8007);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8010);
        engineRef();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8011);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(8012);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::SECONDARY_ENGINE_SYMBOL);
        setState(8014);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1007, _ctx)) {
          case 1: {
            setState(8013);
            equal();
            break;
          }

          default:
            break;
        }
        setState(8018);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1008, _ctx)) {
          case 1: {
            setState(8016);
            match(MySQLParser::NULL_SYMBOL);
            break;
          }

          case 2: {
            setState(8017);
            textOrIdentifier();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8020);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MAX_ROWS_SYMBOL);
        setState(8022);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8021);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8024);
        ulonglong_number();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(8025);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MIN_ROWS_SYMBOL);
        setState(8027);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8026);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8029);
        ulonglong_number();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(8030);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AVG_ROW_LENGTH_SYMBOL);
        setState(8032);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8031);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8034);
        ulonglong_number();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(8035);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
        setState(8037);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1012, _ctx)) {
          case 1: {
            setState(8036);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8039);
        textStringLiteral();
        break;
      }

      case 7: {
        enterOuterAlt(_localctx, 7);
        setState(8040);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(8042);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
          case 1: {
            setState(8041);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8044);
        textStringLiteral();
        break;
      }

      case 8: {
        enterOuterAlt(_localctx, 8);
        setState(8045);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMPRESSION_SYMBOL);
        setState(8047);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1014, _ctx)) {
          case 1: {
            setState(8046);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8049);
        textString();
        break;
      }

      case 9: {
        enterOuterAlt(_localctx, 9);
        setState(8050);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENCRYPTION_SYMBOL);
        setState(8052);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1015, _ctx)) {
          case 1: {
            setState(8051);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8054);
        textString();
        break;
      }

      case 10: {
        enterOuterAlt(_localctx, 10);
        setState(8055);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
        setState(8057);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8056);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8059);
        ulonglong_number();
        break;
      }

      case 11: {
        enterOuterAlt(_localctx, 11);
        setState(8060);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PACK_KEYS_SYMBOL);
        setState(8062);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8061);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8064);
        ternaryOption();
        break;
      }

      case 12: {
        enterOuterAlt(_localctx, 12);
        setState(8065);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 544) & ~0x3fULL) == 0) && ((1ULL << (_la - 544)) & 7) != 0))) {
          antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8067);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8066);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8069);
        ternaryOption();
        break;
      }

      case 13: {
        enterOuterAlt(_localctx, 13);
        setState(8070);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CHECKSUM_SYMBOL || _la == MySQLParser::TABLE_CHECKSUM_SYMBOL)) {
          antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8072);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8071);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8074);
        ulong_number();
        break;
      }

      case 14: {
        enterOuterAlt(_localctx, 14);
        setState(8075);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DELAY_KEY_WRITE_SYMBOL);
        setState(8077);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8076);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8079);
        ulong_number();
        break;
      }

      case 15: {
        enterOuterAlt(_localctx, 15);
        setState(8080);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ROW_FORMAT_SYMBOL);
        setState(8082);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8081);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8084);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->format = _input->LT(1);
        _la = _input->LA(1);
        if (!(((((_la - 78) & ~0x3fULL) == 0) && ((1ULL << (_la - 78)) & 1125899906842629) != 0) ||
              _la == MySQLParser::DYNAMIC_SYMBOL

              || _la == MySQLParser::FIXED_SYMBOL || _la == MySQLParser::REDUNDANT_SYMBOL)) {
          antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->format = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 16: {
        enterOuterAlt(_localctx, 16);
        setState(8085);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::UNION_SYMBOL);
        setState(8087);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8086);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8089);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(8090);
        tableRefList();
        setState(8091);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 17: {
        enterOuterAlt(_localctx, 17);
        setState(8093);
        defaultCharset();
        break;
      }

      case 18: {
        enterOuterAlt(_localctx, 18);
        setState(8094);
        defaultCollation();
        break;
      }

      case 19: {
        enterOuterAlt(_localctx, 19);
        setState(8095);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INSERT_METHOD_SYMBOL);
        setState(8097);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8096);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8099);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->method = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL || _la == MySQLParser::NO_SYMBOL)) {
          antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->method = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 20: {
        enterOuterAlt(_localctx, 20);
        setState(8100);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DATA_SYMBOL);
        setState(8101);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(8103);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1024, _ctx)) {
          case 1: {
            setState(8102);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8105);
        textString();
        break;
      }

      case 21: {
        enterOuterAlt(_localctx, 21);
        setState(8106);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INDEX_SYMBOL);
        setState(8107);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(8109);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1025, _ctx)) {
          case 1: {
            setState(8108);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8111);
        textString();
        break;
      }

      case 22: {
        enterOuterAlt(_localctx, 22);
        setState(8112);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
        setState(8114);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1026, _ctx)) {
          case 1: {
            setState(8113);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8116);
        identifier();
        break;
      }

      case 23: {
        enterOuterAlt(_localctx, 23);
        setState(8117);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::STORAGE_SYMBOL);
        setState(8118);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 24: {
        enterOuterAlt(_localctx, 24);
        setState(8119);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::CONNECTION_SYMBOL);
        setState(8121);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1027, _ctx)) {
          case 1: {
            setState(8120);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8123);
        textString();
        break;
      }

      case 25: {
        enterOuterAlt(_localctx, 25);
        setState(8124);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
        setState(8126);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8125);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8128);
        ulonglong_number();
        break;
      }

      case 26: {
        enterOuterAlt(_localctx, 26);
        setState(8129);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8130);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::START_SYMBOL);
        setState(8131);
        match(MySQLParser::TRANSACTION_SYMBOL);
        break;
      }

      case 27: {
        enterOuterAlt(_localctx, 27);
        setState(8132);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8133);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL);
        setState(8135);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1029, _ctx)) {
          case 1: {
            setState(8134);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8137);
        jsonAttribute();
        break;
      }

      case 28: {
        enterOuterAlt(_localctx, 28);
        setState(8138);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8139);
        antlrcpp::downCast<CreateTableOptionContext *>(_localctx)->option =
          match(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL);
        setState(8141);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1030, _ctx)) {
          case 1: {
            setState(8140);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8143);
        jsonAttribute();
        break;
      }

      case 29: {
        enterOuterAlt(_localctx, 29);
        setState(8144);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8145);
        tsOptionAutoextendSize();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TernaryOptionContext ------------------------------------------------------------------

MySQLParser::TernaryOptionContext::TernaryOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext *MySQLParser::TernaryOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::TernaryOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::TernaryOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTernaryOption;
}

void MySQLParser::TernaryOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryOption(this);
}

void MySQLParser::TernaryOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryOption(this);
}

std::any MySQLParser::TernaryOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTernaryOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TernaryOptionContext *MySQLParser::ternaryOption() {
  TernaryOptionContext *_localctx = _tracker.createInstance<TernaryOptionContext>(_ctx, getState());
  enterRule(_localctx, 1146, MySQLParser::RuleTernaryOption);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8150);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(8148);
        ulong_number();
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8149);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCollationContext ------------------------------------------------------------------

MySQLParser::DefaultCollationContext::DefaultCollationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DefaultCollationContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext *MySQLParser::DefaultCollationContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}

tree::TerminalNode *MySQLParser::DefaultCollationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefaultCollationContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::DefaultCollationContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCollation;
}

void MySQLParser::DefaultCollationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCollation(this);
}

void MySQLParser::DefaultCollationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCollation(this);
}

std::any MySQLParser::DefaultCollationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefaultCollation(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultCollationContext *MySQLParser::defaultCollation() {
  DefaultCollationContext *_localctx = _tracker.createInstance<DefaultCollationContext>(_ctx, getState());
  enterRule(_localctx, 1148, MySQLParser::RuleDefaultCollation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8153);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(8152);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(8155);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(8157);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1034, _ctx)) {
      case 1: {
        setState(8156);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(8159);
    collationName();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultEncryptionContext ------------------------------------------------------------------

MySQLParser::DefaultEncryptionContext::DefaultEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DefaultEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::DefaultEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::DefaultEncryptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefaultEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::DefaultEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultEncryption;
}

void MySQLParser::DefaultEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultEncryption(this);
}

void MySQLParser::DefaultEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultEncryption(this);
}

std::any MySQLParser::DefaultEncryptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefaultEncryption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultEncryptionContext *MySQLParser::defaultEncryption() {
  DefaultEncryptionContext *_localctx = _tracker.createInstance<DefaultEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 1150, MySQLParser::RuleDefaultEncryption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8162);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(8161);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(8164);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(8166);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1036, _ctx)) {
      case 1: {
        setState(8165);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(8168);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCharsetContext ------------------------------------------------------------------

MySQLParser::DefaultCharsetContext::DefaultCharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext *MySQLParser::DefaultCharsetContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext *MySQLParser::DefaultCharsetContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode *MySQLParser::DefaultCharsetContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefaultCharsetContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

size_t MySQLParser::DefaultCharsetContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCharset;
}

void MySQLParser::DefaultCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCharset(this);
}

void MySQLParser::DefaultCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCharset(this);
}

std::any MySQLParser::DefaultCharsetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefaultCharset(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefaultCharsetContext *MySQLParser::defaultCharset() {
  DefaultCharsetContext *_localctx = _tracker.createInstance<DefaultCharsetContext>(_ctx, getState());
  enterRule(_localctx, 1152, MySQLParser::RuleDefaultCharset);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8171);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(8170);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(8173);
    charset();
    setState(8175);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1038, _ctx)) {
      case 1: {
        setState(8174);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      default:
        break;
    }
    setState(8177);
    charsetName();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionClauseContext ------------------------------------------------------------------

MySQLParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionClauseContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::PartitionTypeDefContext *MySQLParser::PartitionClauseContext::partitionTypeDef() {
  return getRuleContext<MySQLParser::PartitionTypeDefContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionClauseContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::PartitionClauseContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::SubPartitionsContext *MySQLParser::PartitionClauseContext::subPartitions() {
  return getRuleContext<MySQLParser::SubPartitionsContext>(0);
}

MySQLParser::PartitionDefinitionsContext *MySQLParser::PartitionClauseContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}

size_t MySQLParser::PartitionClauseContext::getRuleIndex() const {
  return MySQLParser::RulePartitionClause;
}

void MySQLParser::PartitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionClause(this);
}

void MySQLParser::PartitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionClause(this);
}

std::any MySQLParser::PartitionClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionClauseContext *MySQLParser::partitionClause() {
  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 1154, MySQLParser::RulePartitionClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8179);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(8180);
    match(MySQLParser::BY_SYMBOL);
    setState(8181);
    partitionTypeDef();
    setState(8184);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1039, _ctx)) {
      case 1: {
        setState(8182);
        match(MySQLParser::PARTITIONS_SYMBOL);
        setState(8183);
        real_ulong_number();
        break;
      }

      default:
        break;
    }
    setState(8187);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1040, _ctx)) {
      case 1: {
        setState(8186);
        subPartitions();
        break;
      }

      default:
        break;
    }
    setState(8190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1041, _ctx)) {
      case 1: {
        setState(8189);
        partitionDefinitions();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionTypeDefContext ------------------------------------------------------------------

MySQLParser::PartitionTypeDefContext::PartitionTypeDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

size_t MySQLParser::PartitionTypeDefContext::getRuleIndex() const {
  return MySQLParser::RulePartitionTypeDef;
}

void MySQLParser::PartitionTypeDefContext::copyFrom(PartitionTypeDefContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionDefRangeListContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PartitionDefRangeListContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefRangeListContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefRangeListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::PartitionDefRangeListContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionDefRangeListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefRangeListContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::PartitionDefRangeListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefRangeListContext::PartitionDefRangeListContext(PartitionTypeDefContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PartitionDefRangeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefRangeList(this);
}
void MySQLParser::PartitionDefRangeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefRangeList(this);
}

std::any MySQLParser::PartitionDefRangeListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDefRangeList(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionDefKeyContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PartitionDefKeyContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefKeyContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefKeyContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefKeyContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionKeyAlgorithmContext *MySQLParser::PartitionDefKeyContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}

MySQLParser::IdentifierListContext *MySQLParser::PartitionDefKeyContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefKeyContext::PartitionDefKeyContext(PartitionTypeDefContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PartitionDefKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefKey(this);
}
void MySQLParser::PartitionDefKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefKey(this);
}

std::any MySQLParser::PartitionDefKeyContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDefKey(this);
  else
    return visitor->visitChildren(this);
}
//----------------- PartitionDefHashContext ------------------------------------------------------------------

tree::TerminalNode *MySQLParser::PartitionDefHashContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefHashContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::PartitionDefHashContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionDefHashContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefHashContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionDefHashContext::PartitionDefHashContext(PartitionTypeDefContext *ctx) {
  copyFrom(ctx);
}

void MySQLParser::PartitionDefHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefHash(this);
}
void MySQLParser::PartitionDefHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefHash(this);
}

std::any MySQLParser::PartitionDefHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDefHash(this);
  else
    return visitor->visitChildren(this);
}
MySQLParser::PartitionTypeDefContext *MySQLParser::partitionTypeDef() {
  PartitionTypeDefContext *_localctx = _tracker.createInstance<PartitionTypeDefContext>(_ctx, getState());
  enterRule(_localctx, 1156, MySQLParser::RulePartitionTypeDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8225);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1048, _ctx)) {
      case 1: {
        _localctx = _tracker.createInstance<MySQLParser::PartitionDefKeyContext>(_localctx);
        enterOuterAlt(_localctx, 1);
        setState(8193);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LINEAR_SYMBOL) {
          setState(8192);
          match(MySQLParser::LINEAR_SYMBOL);
        }
        setState(8195);
        match(MySQLParser::KEY_SYMBOL);
        setState(8197);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(8196);
          partitionKeyAlgorithm();
        }
        setState(8199);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(8201);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1044, _ctx)) {
          case 1: {
            setState(8200);
            identifierList();
            break;
          }

          default:
            break;
        }
        setState(8203);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 2: {
        _localctx = _tracker.createInstance<MySQLParser::PartitionDefHashContext>(_localctx);
        enterOuterAlt(_localctx, 2);
        setState(8205);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LINEAR_SYMBOL) {
          setState(8204);
          match(MySQLParser::LINEAR_SYMBOL);
        }
        setState(8207);
        match(MySQLParser::HASH_SYMBOL);
        setState(8208);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(8209);
        bitExpr(0);
        setState(8210);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case 3: {
        _localctx = _tracker.createInstance<MySQLParser::PartitionDefRangeListContext>(_localctx);
        enterOuterAlt(_localctx, 3);
        setState(8212);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LIST_SYMBOL || _la == MySQLParser::RANGE_SYMBOL)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8223);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(8213);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(8214);
            bitExpr(0);
            setState(8215);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          case MySQLParser::COLUMNS_SYMBOL: {
            setState(8217);
            match(MySQLParser::COLUMNS_SYMBOL);
            setState(8218);
            match(MySQLParser::OPEN_PAR_SYMBOL);
            setState(8220);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1046, _ctx)) {
              case 1: {
                setState(8219);
                identifierList();
                break;
              }

              default:
                break;
            }
            setState(8222);
            match(MySQLParser::CLOSE_PAR_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubPartitionsContext ------------------------------------------------------------------

MySQLParser::SubPartitionsContext::SubPartitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext *MySQLParser::SubPartitionsContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext *MySQLParser::SubPartitionsContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SubPartitionsContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::SubPartitionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::PartitionKeyAlgorithmContext *MySQLParser::SubPartitionsContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}

size_t MySQLParser::SubPartitionsContext::getRuleIndex() const {
  return MySQLParser::RuleSubPartitions;
}

void MySQLParser::SubPartitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitions(this);
}

void MySQLParser::SubPartitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitions(this);
}

std::any MySQLParser::SubPartitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSubPartitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubPartitionsContext *MySQLParser::subPartitions() {
  SubPartitionsContext *_localctx = _tracker.createInstance<SubPartitionsContext>(_ctx, getState());
  enterRule(_localctx, 1158, MySQLParser::RuleSubPartitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8227);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(8228);
    match(MySQLParser::BY_SYMBOL);
    setState(8230);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINEAR_SYMBOL) {
      setState(8229);
      match(MySQLParser::LINEAR_SYMBOL);
    }
    setState(8242);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HASH_SYMBOL: {
        setState(8232);
        match(MySQLParser::HASH_SYMBOL);
        setState(8233);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(8234);
        bitExpr(0);
        setState(8235);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL: {
        setState(8237);
        match(MySQLParser::KEY_SYMBOL);
        setState(8239);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(8238);
          partitionKeyAlgorithm();
        }
        setState(8241);
        identifierListWithParentheses();
        break;
      }

      default:
        throw NoViableAltException(this);
    }
    setState(8246);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx)) {
      case 1: {
        setState(8244);
        match(MySQLParser::SUBPARTITIONS_SYMBOL);
        setState(8245);
        real_ulong_number();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionKeyAlgorithmContext ------------------------------------------------------------------

MySQLParser::PartitionKeyAlgorithmContext::PartitionKeyAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionKeyAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionKeyAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::PartitionKeyAlgorithmContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

size_t MySQLParser::PartitionKeyAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RulePartitionKeyAlgorithm;
}

void MySQLParser::PartitionKeyAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionKeyAlgorithm(this);
}

void MySQLParser::PartitionKeyAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionKeyAlgorithm(this);
}

std::any MySQLParser::PartitionKeyAlgorithmContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionKeyAlgorithm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionKeyAlgorithmContext *MySQLParser::partitionKeyAlgorithm() {
  PartitionKeyAlgorithmContext *_localctx = _tracker.createInstance<PartitionKeyAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 1160, MySQLParser::RulePartitionKeyAlgorithm);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8248);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(8249);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(8250);
    real_ulong_number();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionsContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionsContext::PartitionDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionDefinitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionDefinitionContext *> MySQLParser::PartitionDefinitionsContext::partitionDefinition() {
  return getRuleContexts<MySQLParser::PartitionDefinitionContext>();
}

MySQLParser::PartitionDefinitionContext *MySQLParser::PartitionDefinitionsContext::partitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::PartitionDefinitionsContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinitions;
}

void MySQLParser::PartitionDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitions(this);
}

void MySQLParser::PartitionDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitions(this);
}

std::any MySQLParser::PartitionDefinitionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDefinitions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDefinitionsContext *MySQLParser::partitionDefinitions() {
  PartitionDefinitionsContext *_localctx = _tracker.createInstance<PartitionDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 1162, MySQLParser::RulePartitionDefinitions);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8252);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8253);
    partitionDefinition();
    setState(8258);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8254);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8255);
      partitionDefinition();
      setState(8260);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8261);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionContext::PartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::PartitionDefinitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::PartitionValuesInContext *MySQLParser::PartitionDefinitionContext::partitionValuesIn() {
  return getRuleContext<MySQLParser::PartitionValuesInContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::PartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext *MySQLParser::PartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SubpartitionDefinitionContext *>
MySQLParser::PartitionDefinitionContext::subpartitionDefinition() {
  return getRuleContexts<MySQLParser::SubpartitionDefinitionContext>();
}

MySQLParser::SubpartitionDefinitionContext *MySQLParser::PartitionDefinitionContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::SubpartitionDefinitionContext>(i);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PartitionValueItemListParenContext *
MySQLParser::PartitionDefinitionContext::partitionValueItemListParen() {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::PartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinition;
}

void MySQLParser::PartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinition(this);
}

void MySQLParser::PartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinition(this);
}

std::any MySQLParser::PartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionDefinitionContext *MySQLParser::partitionDefinition() {
  PartitionDefinitionContext *_localctx = _tracker.createInstance<PartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 1164, MySQLParser::RulePartitionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8263);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(8264);
    identifier();
    setState(8275);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1055, _ctx)) {
      case 1: {
        setState(8265);
        match(MySQLParser::VALUES_SYMBOL);
        setState(8266);
        match(MySQLParser::LESS_SYMBOL);
        setState(8267);
        match(MySQLParser::THAN_SYMBOL);
        setState(8270);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(8268);
            partitionValueItemListParen();
            break;
          }

          case MySQLParser::MAXVALUE_SYMBOL: {
            setState(8269);
            match(MySQLParser::MAXVALUE_SYMBOL);
            break;
          }

          default:
            throw NoViableAltException(this);
        }
        break;
      }

      case 2: {
        setState(8272);
        match(MySQLParser::VALUES_SYMBOL);
        setState(8273);
        match(MySQLParser::IN_SYMBOL);
        setState(8274);
        partitionValuesIn();
        break;
      }

      default:
        break;
    }
    setState(8280);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL

           || _la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL ||
           _la == MySQLParser::INDEX_SYMBOL ||
           ((((_la - 323) & ~0x3fULL) == 0) && ((1ULL << (_la - 323)) & 35184374185985) != 0) ||
           _la == MySQLParser::STORAGE_SYMBOL

           || _la == MySQLParser::TABLESPACE_SYMBOL) {
      setState(8277);
      partitionOption();
      setState(8282);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8294);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(8283);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(8284);
      subpartitionDefinition();
      setState(8289);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(8285);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8286);
        subpartitionDefinition();
        setState(8291);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(8292);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValuesInContext ------------------------------------------------------------------

MySQLParser::PartitionValuesInContext::PartitionValuesInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PartitionValueItemListParenContext *>
MySQLParser::PartitionValuesInContext::partitionValueItemListParen() {
  return getRuleContexts<MySQLParser::PartitionValueItemListParenContext>();
}

MySQLParser::PartitionValueItemListParenContext *MySQLParser::PartitionValuesInContext::partitionValueItemListParen(
  size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(i);
}

tree::TerminalNode *MySQLParser::PartitionValuesInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionValuesInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValuesInContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::PartitionValuesInContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::PartitionValuesInContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValuesIn;
}

void MySQLParser::PartitionValuesInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValuesIn(this);
}

void MySQLParser::PartitionValuesInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValuesIn(this);
}

std::any MySQLParser::PartitionValuesInContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionValuesIn(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValuesInContext *MySQLParser::partitionValuesIn() {
  PartitionValuesInContext *_localctx = _tracker.createInstance<PartitionValuesInContext>(_ctx, getState());
  enterRule(_localctx, 1166, MySQLParser::RulePartitionValuesIn);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8308);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1060, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8296);
        partitionValueItemListParen();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8297);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(8298);
        partitionValueItemListParen();
        setState(8303);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(8299);
          match(MySQLParser::COMMA_SYMBOL);
          setState(8300);
          partitionValueItemListParen();
          setState(8305);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(8306);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionOptionContext ------------------------------------------------------------------

MySQLParser::PartitionOptionContext::PartitionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::PartitionOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::EngineRefContext *MySQLParser::PartitionOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::PartitionOptionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextLiteralContext *MySQLParser::PartitionOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PartitionOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

size_t MySQLParser::PartitionOptionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionOption;
}

void MySQLParser::PartitionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOption(this);
}

void MySQLParser::PartitionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOption(this);
}

std::any MySQLParser::PartitionOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionOptionContext *MySQLParser::partitionOption() {
  PartitionOptionContext *_localctx = _tracker.createInstance<PartitionOptionContext>(_ctx, getState());
  enterRule(_localctx, 1168, MySQLParser::RulePartitionOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8344);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TABLESPACE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8310);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
        setState(8312);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1061, _ctx)) {
          case 1: {
            setState(8311);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8314);
        identifier();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8316);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STORAGE_SYMBOL) {
          setState(8315);
          match(MySQLParser::STORAGE_SYMBOL);
        }
        setState(8318);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
        setState(8320);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1063, _ctx)) {
          case 1: {
            setState(8319);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8322);
        engineRef();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8323);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::NODEGROUP_SYMBOL);
        setState(8325);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8324);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8327);
        real_ulong_number();
        break;
      }

      case MySQLParser::MAX_ROWS_SYMBOL:
      case MySQLParser::MIN_ROWS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(8328);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::MAX_ROWS_SYMBOL

              || _la == MySQLParser::MIN_ROWS_SYMBOL)) {
          antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8330);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(8329);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(8332);
        real_ulong_number();
        break;
      }

      case MySQLParser::DATA_SYMBOL:
      case MySQLParser::INDEX_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(8333);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::INDEX_SYMBOL)) {
          antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(8334);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(8336);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1066, _ctx)) {
          case 1: {
            setState(8335);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8338);
        textLiteral();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(8339);
        antlrcpp::downCast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(8341);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1067, _ctx)) {
          case 1: {
            setState(8340);
            match(MySQLParser::EQUAL_OPERATOR);
            break;
          }

          default:
            break;
        }
        setState(8343);
        textLiteral();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::SubpartitionDefinitionContext::SubpartitionDefinitionContext(ParserRuleContext *parent,
                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SubpartitionDefinitionContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::SubpartitionDefinitionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::SubpartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext *MySQLParser::SubpartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}

size_t MySQLParser::SubpartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleSubpartitionDefinition;
}

void MySQLParser::SubpartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpartitionDefinition(this);
}

void MySQLParser::SubpartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpartitionDefinition(this);
}

std::any MySQLParser::SubpartitionDefinitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSubpartitionDefinition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SubpartitionDefinitionContext *MySQLParser::subpartitionDefinition() {
  SubpartitionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 1170, MySQLParser::RuleSubpartitionDefinition);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8346);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(8347);
    textOrIdentifier();
    setState(8351);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL

           || _la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL ||
           _la == MySQLParser::INDEX_SYMBOL ||
           ((((_la - 323) & ~0x3fULL) == 0) && ((1ULL << (_la - 323)) & 35184374185985) != 0) ||
           _la == MySQLParser::STORAGE_SYMBOL

           || _la == MySQLParser::TABLESPACE_SYMBOL) {
      setState(8348);
      partitionOption();
      setState(8353);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemListParenContext
//------------------------------------------------------------------

MySQLParser::PartitionValueItemListParenContext::PartitionValueItemListParenContext(ParserRuleContext *parent,
                                                                                    size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PartitionValueItemListParenContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionValueItemContext *>
MySQLParser::PartitionValueItemListParenContext::partitionValueItem() {
  return getRuleContexts<MySQLParser::PartitionValueItemContext>();
}

MySQLParser::PartitionValueItemContext *MySQLParser::PartitionValueItemListParenContext::partitionValueItem(size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemContext>(i);
}

tree::TerminalNode *MySQLParser::PartitionValueItemListParenContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::PartitionValueItemListParenContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItemListParen;
}

void MySQLParser::PartitionValueItemListParenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItemListParen(this);
}

void MySQLParser::PartitionValueItemListParenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItemListParen(this);
}

std::any MySQLParser::PartitionValueItemListParenContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionValueItemListParen(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValueItemListParenContext *MySQLParser::partitionValueItemListParen() {
  PartitionValueItemListParenContext *_localctx =
    _tracker.createInstance<PartitionValueItemListParenContext>(_ctx, getState());
  enterRule(_localctx, 1172, MySQLParser::RulePartitionValueItemListParen);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8354);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8355);
    partitionValueItem();
    setState(8360);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8356);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8357);
      partitionValueItem();
      setState(8362);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8363);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemContext ------------------------------------------------------------------

MySQLParser::PartitionValueItemContext::PartitionValueItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BitExprContext *MySQLParser::PartitionValueItemContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode *MySQLParser::PartitionValueItemContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}

size_t MySQLParser::PartitionValueItemContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItem;
}

void MySQLParser::PartitionValueItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItem(this);
}

void MySQLParser::PartitionValueItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItem(this);
}

std::any MySQLParser::PartitionValueItemContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPartitionValueItem(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PartitionValueItemContext *MySQLParser::partitionValueItem() {
  PartitionValueItemContext *_localctx = _tracker.createInstance<PartitionValueItemContext>(_ctx, getState());
  enterRule(_localctx, 1174, MySQLParser::RulePartitionValueItem);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8367);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1071, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8365);
        bitExpr(0);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8366);
        match(MySQLParser::MAXVALUE_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinerClauseContext ------------------------------------------------------------------

MySQLParser::DefinerClauseContext::DefinerClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DefinerClauseContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DefinerClauseContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::UserContext *MySQLParser::DefinerClauseContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

size_t MySQLParser::DefinerClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefinerClause;
}

void MySQLParser::DefinerClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinerClause(this);
}

void MySQLParser::DefinerClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinerClause(this);
}

std::any MySQLParser::DefinerClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDefinerClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DefinerClauseContext *MySQLParser::definerClause() {
  DefinerClauseContext *_localctx = _tracker.createInstance<DefinerClauseContext>(_ctx, getState());
  enterRule(_localctx, 1176, MySQLParser::RuleDefinerClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8369);
    match(MySQLParser::DEFINER_SYMBOL);
    setState(8370);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(8371);
    user();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfExistsContext ------------------------------------------------------------------

MySQLParser::IfExistsContext::IfExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IfExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IfExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

size_t MySQLParser::IfExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfExists;
}

void MySQLParser::IfExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfExists(this);
}

void MySQLParser::IfExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfExists(this);
}

std::any MySQLParser::IfExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIfExists(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfExistsContext *MySQLParser::ifExists() {
  IfExistsContext *_localctx = _tracker.createInstance<IfExistsContext>(_ctx, getState());
  enterRule(_localctx, 1178, MySQLParser::RuleIfExists);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8373);
    match(MySQLParser::IF_SYMBOL);
    setState(8374);
    match(MySQLParser::EXISTS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfNotExistsContext ------------------------------------------------------------------

MySQLParser::IfNotExistsContext::IfNotExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IfNotExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

MySQLParser::NotRuleContext *MySQLParser::IfNotExistsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode *MySQLParser::IfNotExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

size_t MySQLParser::IfNotExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfNotExists;
}

void MySQLParser::IfNotExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfNotExists(this);
}

void MySQLParser::IfNotExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfNotExists(this);
}

std::any MySQLParser::IfNotExistsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIfNotExists(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IfNotExistsContext *MySQLParser::ifNotExists() {
  IfNotExistsContext *_localctx = _tracker.createInstance<IfNotExistsContext>(_ctx, getState());
  enterRule(_localctx, 1180, MySQLParser::RuleIfNotExists);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8376);
    match(MySQLParser::IF_SYMBOL);
    setState(8377);
    notRule();
    setState(8378);
    match(MySQLParser::EXISTS_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IgnoreUnknownUserContext ------------------------------------------------------------------

MySQLParser::IgnoreUnknownUserContext::IgnoreUnknownUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IgnoreUnknownUserContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IgnoreUnknownUserContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IgnoreUnknownUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

size_t MySQLParser::IgnoreUnknownUserContext::getRuleIndex() const {
  return MySQLParser::RuleIgnoreUnknownUser;
}

void MySQLParser::IgnoreUnknownUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIgnoreUnknownUser(this);
}

void MySQLParser::IgnoreUnknownUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIgnoreUnknownUser(this);
}

std::any MySQLParser::IgnoreUnknownUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIgnoreUnknownUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IgnoreUnknownUserContext *MySQLParser::ignoreUnknownUser() {
  IgnoreUnknownUserContext *_localctx = _tracker.createInstance<IgnoreUnknownUserContext>(_ctx, getState());
  enterRule(_localctx, 1182, MySQLParser::RuleIgnoreUnknownUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8380);
    match(MySQLParser::IGNORE_SYMBOL);
    setState(8381);
    match(MySQLParser::UNKNOWN_SYMBOL);
    setState(8382);
    match(MySQLParser::USER_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureParameterContext ------------------------------------------------------------------

MySQLParser::ProcedureParameterContext::ProcedureParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FunctionParameterContext *MySQLParser::ProcedureParameterContext::functionParameter() {
  return getRuleContext<MySQLParser::FunctionParameterContext>(0);
}

tree::TerminalNode *MySQLParser::ProcedureParameterContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProcedureParameterContext::OUT_SYMBOL() {
  return getToken(MySQLParser::OUT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ProcedureParameterContext::INOUT_SYMBOL() {
  return getToken(MySQLParser::INOUT_SYMBOL, 0);
}

size_t MySQLParser::ProcedureParameterContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureParameter;
}

void MySQLParser::ProcedureParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureParameter(this);
}

void MySQLParser::ProcedureParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureParameter(this);
}

std::any MySQLParser::ProcedureParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProcedureParameter(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureParameterContext *MySQLParser::procedureParameter() {
  ProcedureParameterContext *_localctx = _tracker.createInstance<ProcedureParameterContext>(_ctx, getState());
  enterRule(_localctx, 1184, MySQLParser::RuleProcedureParameter);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8385);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1072, _ctx)) {
      case 1: {
        setState(8384);
        antlrcpp::downCast<ProcedureParameterContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INOUT_SYMBOL

              || _la == MySQLParser::IN_SYMBOL || _la == MySQLParser::OUT_SYMBOL)) {
          antlrcpp::downCast<ProcedureParameterContext *>(_localctx)->type = _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }
    setState(8387);
    functionParameter();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParameterContext ------------------------------------------------------------------

MySQLParser::FunctionParameterContext::FunctionParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParameterNameContext *MySQLParser::FunctionParameterContext::parameterName() {
  return getRuleContext<MySQLParser::ParameterNameContext>(0);
}

MySQLParser::TypeWithOptCollateContext *MySQLParser::FunctionParameterContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}

size_t MySQLParser::FunctionParameterContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionParameter;
}

void MySQLParser::FunctionParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParameter(this);
}

void MySQLParser::FunctionParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParameter(this);
}

std::any MySQLParser::FunctionParameterContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFunctionParameter(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionParameterContext *MySQLParser::functionParameter() {
  FunctionParameterContext *_localctx = _tracker.createInstance<FunctionParameterContext>(_ctx, getState());
  enterRule(_localctx, 1186, MySQLParser::RuleFunctionParameter);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8389);
    parameterName();
    setState(8390);
    typeWithOptCollate();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollateContext ------------------------------------------------------------------

MySQLParser::CollateContext::CollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::CollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext *MySQLParser::CollateContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}

size_t MySQLParser::CollateContext::getRuleIndex() const {
  return MySQLParser::RuleCollate;
}

void MySQLParser::CollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollate(this);
}

void MySQLParser::CollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollate(this);
}

std::any MySQLParser::CollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCollate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CollateContext *MySQLParser::collate() {
  CollateContext *_localctx = _tracker.createInstance<CollateContext>(_ctx, getState());
  enterRule(_localctx, 1188, MySQLParser::RuleCollate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8392);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(8393);
    collationName();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeWithOptCollateContext ------------------------------------------------------------------

MySQLParser::TypeWithOptCollateContext::TypeWithOptCollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext *MySQLParser::TypeWithOptCollateContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext *MySQLParser::TypeWithOptCollateContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

size_t MySQLParser::TypeWithOptCollateContext::getRuleIndex() const {
  return MySQLParser::RuleTypeWithOptCollate;
}

void MySQLParser::TypeWithOptCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeWithOptCollate(this);
}

void MySQLParser::TypeWithOptCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeWithOptCollate(this);
}

std::any MySQLParser::TypeWithOptCollateContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTypeWithOptCollate(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TypeWithOptCollateContext *MySQLParser::typeWithOptCollate() {
  TypeWithOptCollateContext *_localctx = _tracker.createInstance<TypeWithOptCollateContext>(_ctx, getState());
  enterRule(_localctx, 1190, MySQLParser::RuleTypeWithOptCollate);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8395);
    dataType();
    setState(8397);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1073, _ctx)) {
      case 1: {
        setState(8396);
        collate();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaIdentifierPairContext ------------------------------------------------------------------

MySQLParser::SchemaIdentifierPairContext::SchemaIdentifierPairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SchemaIdentifierPairContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::SchemaIdentifierPairContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext *MySQLParser::SchemaIdentifierPairContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

tree::TerminalNode *MySQLParser::SchemaIdentifierPairContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SchemaIdentifierPairContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::SchemaIdentifierPairContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaIdentifierPair;
}

void MySQLParser::SchemaIdentifierPairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaIdentifierPair(this);
}

void MySQLParser::SchemaIdentifierPairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaIdentifierPair(this);
}

std::any MySQLParser::SchemaIdentifierPairContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSchemaIdentifierPair(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaIdentifierPairContext *MySQLParser::schemaIdentifierPair() {
  SchemaIdentifierPairContext *_localctx = _tracker.createInstance<SchemaIdentifierPairContext>(_ctx, getState());
  enterRule(_localctx, 1192, MySQLParser::RuleSchemaIdentifierPair);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8399);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8400);
    schemaRef();
    setState(8401);
    match(MySQLParser::COMMA_SYMBOL);
    setState(8402);
    schemaRef();
    setState(8403);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefListContext ------------------------------------------------------------------

MySQLParser::ViewRefListContext::ViewRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ViewRefContext *> MySQLParser::ViewRefListContext::viewRef() {
  return getRuleContexts<MySQLParser::ViewRefContext>();
}

MySQLParser::ViewRefContext *MySQLParser::ViewRefListContext::viewRef(size_t i) {
  return getRuleContext<MySQLParser::ViewRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ViewRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ViewRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ViewRefListContext::getRuleIndex() const {
  return MySQLParser::RuleViewRefList;
}

void MySQLParser::ViewRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRefList(this);
}

void MySQLParser::ViewRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRefList(this);
}

std::any MySQLParser::ViewRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewRefListContext *MySQLParser::viewRefList() {
  ViewRefListContext *_localctx = _tracker.createInstance<ViewRefListContext>(_ctx, getState());
  enterRule(_localctx, 1194, MySQLParser::RuleViewRefList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8405);
    viewRef();
    setState(8410);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8406);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8407);
      viewRef();
      setState(8412);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateListContext ------------------------------------------------------------------

MySQLParser::UpdateListContext::UpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UpdateElementContext *> MySQLParser::UpdateListContext::updateElement() {
  return getRuleContexts<MySQLParser::UpdateElementContext>();
}

MySQLParser::UpdateElementContext *MySQLParser::UpdateListContext::updateElement(size_t i) {
  return getRuleContext<MySQLParser::UpdateElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UpdateListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::UpdateListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::UpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateList;
}

void MySQLParser::UpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateList(this);
}

void MySQLParser::UpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateList(this);
}

std::any MySQLParser::UpdateListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUpdateList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateListContext *MySQLParser::updateList() {
  UpdateListContext *_localctx = _tracker.createInstance<UpdateListContext>(_ctx, getState());
  enterRule(_localctx, 1196, MySQLParser::RuleUpdateList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8413);
    updateElement();
    setState(8418);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8414);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8415);
        updateElement();
      }
      setState(8420);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateElementContext ------------------------------------------------------------------

MySQLParser::UpdateElementContext::UpdateElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext *MySQLParser::UpdateElementContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

tree::TerminalNode *MySQLParser::UpdateElementContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::ExprContext *MySQLParser::UpdateElementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode *MySQLParser::UpdateElementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

size_t MySQLParser::UpdateElementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateElement;
}

void MySQLParser::UpdateElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateElement(this);
}

void MySQLParser::UpdateElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateElement(this);
}

std::any MySQLParser::UpdateElementContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUpdateElement(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UpdateElementContext *MySQLParser::updateElement() {
  UpdateElementContext *_localctx = _tracker.createInstance<UpdateElementContext>(_ctx, getState());
  enterRule(_localctx, 1198, MySQLParser::RuleUpdateElement);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8421);
    columnRef();
    setState(8422);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(8425);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1076, _ctx)) {
      case 1: {
        setState(8423);
        expr(0);
        break;
      }

      case 2: {
        setState(8424);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetClauseContext ------------------------------------------------------------------

MySQLParser::CharsetClauseContext::CharsetClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext *MySQLParser::CharsetClauseContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext *MySQLParser::CharsetClauseContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

size_t MySQLParser::CharsetClauseContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetClause;
}

void MySQLParser::CharsetClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetClause(this);
}

void MySQLParser::CharsetClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetClause(this);
}

std::any MySQLParser::CharsetClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCharsetClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CharsetClauseContext *MySQLParser::charsetClause() {
  CharsetClauseContext *_localctx = _tracker.createInstance<CharsetClauseContext>(_ctx, getState());
  enterRule(_localctx, 1200, MySQLParser::RuleCharsetClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8427);
    charset();
    setState(8428);
    charsetName();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsClauseContext ------------------------------------------------------------------

MySQLParser::FieldsClauseContext::FieldsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FieldsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

std::vector<MySQLParser::FieldTermContext *> MySQLParser::FieldsClauseContext::fieldTerm() {
  return getRuleContexts<MySQLParser::FieldTermContext>();
}

MySQLParser::FieldTermContext *MySQLParser::FieldsClauseContext::fieldTerm(size_t i) {
  return getRuleContext<MySQLParser::FieldTermContext>(i);
}

size_t MySQLParser::FieldsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFieldsClause;
}

void MySQLParser::FieldsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldsClause(this);
}

void MySQLParser::FieldsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldsClause(this);
}

std::any MySQLParser::FieldsClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldsClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldsClauseContext *MySQLParser::fieldsClause() {
  FieldsClauseContext *_localctx = _tracker.createInstance<FieldsClauseContext>(_ctx, getState());
  enterRule(_localctx, 1202, MySQLParser::RuleFieldsClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8430);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(8432);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(8431);
          fieldTerm();
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(8434);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldTermContext ------------------------------------------------------------------

MySQLParser::FieldTermContext::FieldTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::FieldTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::FieldTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::FieldTermContext::ENCLOSED_SYMBOL() {
  return getToken(MySQLParser::ENCLOSED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldTermContext::OPTIONALLY_SYMBOL() {
  return getToken(MySQLParser::OPTIONALLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::FieldTermContext::ESCAPED_SYMBOL() {
  return getToken(MySQLParser::ESCAPED_SYMBOL, 0);
}

size_t MySQLParser::FieldTermContext::getRuleIndex() const {
  return MySQLParser::RuleFieldTerm;
}

void MySQLParser::FieldTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldTerm(this);
}

void MySQLParser::FieldTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldTerm(this);
}

std::any MySQLParser::FieldTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldTerm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldTermContext *MySQLParser::fieldTerm() {
  FieldTermContext *_localctx = _tracker.createInstance<FieldTermContext>(_ctx, getState());
  enterRule(_localctx, 1204, MySQLParser::RuleFieldTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8448);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TERMINATED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8436);
        match(MySQLParser::TERMINATED_SYMBOL);
        setState(8437);
        match(MySQLParser::BY_SYMBOL);
        setState(8438);
        textString();
        break;
      }

      case MySQLParser::ENCLOSED_SYMBOL:
      case MySQLParser::OPTIONALLY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8440);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPTIONALLY_SYMBOL) {
          setState(8439);
          match(MySQLParser::OPTIONALLY_SYMBOL);
        }
        setState(8442);
        match(MySQLParser::ENCLOSED_SYMBOL);
        setState(8443);
        match(MySQLParser::BY_SYMBOL);
        setState(8444);
        textString();
        break;
      }

      case MySQLParser::ESCAPED_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8445);
        match(MySQLParser::ESCAPED_SYMBOL);
        setState(8446);
        match(MySQLParser::BY_SYMBOL);
        setState(8447);
        textString();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LinesClauseContext ------------------------------------------------------------------

MySQLParser::LinesClauseContext::LinesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LinesClauseContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

std::vector<MySQLParser::LineTermContext *> MySQLParser::LinesClauseContext::lineTerm() {
  return getRuleContexts<MySQLParser::LineTermContext>();
}

MySQLParser::LineTermContext *MySQLParser::LinesClauseContext::lineTerm(size_t i) {
  return getRuleContext<MySQLParser::LineTermContext>(i);
}

size_t MySQLParser::LinesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLinesClause;
}

void MySQLParser::LinesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLinesClause(this);
}

void MySQLParser::LinesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLinesClause(this);
}

std::any MySQLParser::LinesClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLinesClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LinesClauseContext *MySQLParser::linesClause() {
  LinesClauseContext *_localctx = _tracker.createInstance<LinesClauseContext>(_ctx, getState());
  enterRule(_localctx, 1206, MySQLParser::RuleLinesClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8450);
    match(MySQLParser::LINES_SYMBOL);
    setState(8452);
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
          setState(8451);
          lineTerm();
          break;
        }

        default:
          throw NoViableAltException(this);
      }
      setState(8454);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1080, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineTermContext ------------------------------------------------------------------

MySQLParser::LineTermContext::LineTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LineTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::LineTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode *MySQLParser::LineTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LineTermContext::STARTING_SYMBOL() {
  return getToken(MySQLParser::STARTING_SYMBOL, 0);
}

size_t MySQLParser::LineTermContext::getRuleIndex() const {
  return MySQLParser::RuleLineTerm;
}

void MySQLParser::LineTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineTerm(this);
}

void MySQLParser::LineTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineTerm(this);
}

std::any MySQLParser::LineTermContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLineTerm(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LineTermContext *MySQLParser::lineTerm() {
  LineTermContext *_localctx = _tracker.createInstance<LineTermContext>(_ctx, getState());
  enterRule(_localctx, 1208, MySQLParser::RuleLineTerm);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8456);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::STARTING_SYMBOL

          || _la == MySQLParser::TERMINATED_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(8457);
    match(MySQLParser::BY_SYMBOL);
    setState(8458);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserListContext ------------------------------------------------------------------

MySQLParser::UserListContext::UserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserContext *> MySQLParser::UserListContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext *MySQLParser::UserListContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::UserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::UserListContext::getRuleIndex() const {
  return MySQLParser::RuleUserList;
}

void MySQLParser::UserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserList(this);
}

void MySQLParser::UserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserList(this);
}

std::any MySQLParser::UserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserListContext *MySQLParser::userList() {
  UserListContext *_localctx = _tracker.createInstance<UserListContext>(_ctx, getState());
  enterRule(_localctx, 1210, MySQLParser::RuleUserList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8460);
    user();
    setState(8465);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1081, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8461);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8462);
        user();
      }
      setState(8467);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1081, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserListContext ------------------------------------------------------------------

MySQLParser::CreateUserListContext::CreateUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateUserContext *> MySQLParser::CreateUserListContext::createUser() {
  return getRuleContexts<MySQLParser::CreateUserContext>();
}

MySQLParser::CreateUserContext *MySQLParser::CreateUserListContext::createUser(size_t i) {
  return getRuleContext<MySQLParser::CreateUserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::CreateUserListContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserList;
}

void MySQLParser::CreateUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserList(this);
}

void MySQLParser::CreateUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserList(this);
}

std::any MySQLParser::CreateUserListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUserList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserListContext *MySQLParser::createUserList() {
  CreateUserListContext *_localctx = _tracker.createInstance<CreateUserListContext>(_ctx, getState());
  enterRule(_localctx, 1212, MySQLParser::RuleCreateUserList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8468);
    createUser();
    setState(8473);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1082, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8469);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8470);
        createUser();
      }
      setState(8475);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1082, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MySQLParser::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext *MySQLParser::CreateUserContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::IdentificationContext *MySQLParser::CreateUserContext::identification() {
  return getRuleContext<MySQLParser::IdentificationContext>(0);
}

MySQLParser::IdentifiedWithPluginContext *MySQLParser::CreateUserContext::identifiedWithPlugin() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginContext>(0);
}

MySQLParser::CreateUserWithMfaContext *MySQLParser::CreateUserContext::createUserWithMfa() {
  return getRuleContext<MySQLParser::CreateUserWithMfaContext>(0);
}

MySQLParser::InitialAuthContext *MySQLParser::CreateUserContext::initialAuth() {
  return getRuleContext<MySQLParser::InitialAuthContext>(0);
}

size_t MySQLParser::CreateUserContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUser;
}

void MySQLParser::CreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUser(this);
}

void MySQLParser::CreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUser(this);
}

std::any MySQLParser::CreateUserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserContext *MySQLParser::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 1214, MySQLParser::RuleCreateUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8476);
    user();
    setState(8486);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1085, _ctx)) {
      case 1: {
        setState(8477);
        identification();
        setState(8479);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1083, _ctx)) {
          case 1: {
            setState(8478);
            createUserWithMfa();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        setState(8481);
        identifiedWithPlugin();
        setState(8483);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1084, _ctx)) {
          case 1: {
            setState(8482);
            initialAuth();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 3: {
        setState(8485);
        createUserWithMfa();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserWithMfaContext ------------------------------------------------------------------

MySQLParser::CreateUserWithMfaContext::CreateUserWithMfaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::CreateUserWithMfaContext::AND_SYMBOL() {
  return getTokens(MySQLParser::AND_SYMBOL);
}

tree::TerminalNode *MySQLParser::CreateUserWithMfaContext::AND_SYMBOL(size_t i) {
  return getToken(MySQLParser::AND_SYMBOL, i);
}

std::vector<MySQLParser::IdentificationContext *> MySQLParser::CreateUserWithMfaContext::identification() {
  return getRuleContexts<MySQLParser::IdentificationContext>();
}

MySQLParser::IdentificationContext *MySQLParser::CreateUserWithMfaContext::identification(size_t i) {
  return getRuleContext<MySQLParser::IdentificationContext>(i);
}

size_t MySQLParser::CreateUserWithMfaContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserWithMfa;
}

void MySQLParser::CreateUserWithMfaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserWithMfa(this);
}

void MySQLParser::CreateUserWithMfaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserWithMfa(this);
}

std::any MySQLParser::CreateUserWithMfaContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitCreateUserWithMfa(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::CreateUserWithMfaContext *MySQLParser::createUserWithMfa() {
  CreateUserWithMfaContext *_localctx = _tracker.createInstance<CreateUserWithMfaContext>(_ctx, getState());
  enterRule(_localctx, 1216, MySQLParser::RuleCreateUserWithMfa);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8488);
    match(MySQLParser::AND_SYMBOL);
    setState(8489);
    identification();
    setState(8492);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1086, _ctx)) {
      case 1: {
        setState(8490);
        match(MySQLParser::AND_SYMBOL);
        setState(8491);
        identification();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentificationContext ------------------------------------------------------------------

MySQLParser::IdentificationContext::IdentificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifiedByPasswordContext *MySQLParser::IdentificationContext::identifiedByPassword() {
  return getRuleContext<MySQLParser::IdentifiedByPasswordContext>(0);
}

MySQLParser::IdentifiedByRandomPasswordContext *MySQLParser::IdentificationContext::identifiedByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedByRandomPasswordContext>(0);
}

MySQLParser::IdentifiedWithPluginContext *MySQLParser::IdentificationContext::identifiedWithPlugin() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginContext>(0);
}

MySQLParser::IdentifiedWithPluginAsAuthContext *MySQLParser::IdentificationContext::identifiedWithPluginAsAuth() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginAsAuthContext>(0);
}

MySQLParser::IdentifiedWithPluginByPasswordContext *
MySQLParser::IdentificationContext::identifiedWithPluginByPassword() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginByPasswordContext>(0);
}

MySQLParser::IdentifiedWithPluginByRandomPasswordContext *
MySQLParser::IdentificationContext::identifiedWithPluginByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginByRandomPasswordContext>(0);
}

size_t MySQLParser::IdentificationContext::getRuleIndex() const {
  return MySQLParser::RuleIdentification;
}

void MySQLParser::IdentificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentification(this);
}

void MySQLParser::IdentificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentification(this);
}

std::any MySQLParser::IdentificationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentification(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentificationContext *MySQLParser::identification() {
  IdentificationContext *_localctx = _tracker.createInstance<IdentificationContext>(_ctx, getState());
  enterRule(_localctx, 1218, MySQLParser::RuleIdentification);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8500);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1087, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8494);
        identifiedByPassword();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8495);
        identifiedByRandomPassword();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8496);
        identifiedWithPlugin();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(8497);
        identifiedWithPluginAsAuth();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(8498);
        identifiedWithPluginByPassword();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(8499);
        identifiedWithPluginByRandomPassword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedByPasswordContext ------------------------------------------------------------------

MySQLParser::IdentifiedByPasswordContext::IdentifiedByPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedByPasswordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedByPasswordContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::IdentifiedByPasswordContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::IdentifiedByPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedByPassword;
}

void MySQLParser::IdentifiedByPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedByPassword(this);
}

void MySQLParser::IdentifiedByPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedByPassword(this);
}

std::any MySQLParser::IdentifiedByPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedByPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedByPasswordContext *MySQLParser::identifiedByPassword() {
  IdentifiedByPasswordContext *_localctx = _tracker.createInstance<IdentifiedByPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1220, MySQLParser::RuleIdentifiedByPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8502);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8503);
    match(MySQLParser::BY_SYMBOL);
    setState(8504);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedByRandomPasswordContext ------------------------------------------------------------------

MySQLParser::IdentifiedByRandomPasswordContext::IdentifiedByRandomPasswordContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedByRandomPasswordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedByRandomPasswordContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedByRandomPasswordContext::RANDOM_SYMBOL() {
  return getToken(MySQLParser::RANDOM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedByRandomPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

size_t MySQLParser::IdentifiedByRandomPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedByRandomPassword;
}

void MySQLParser::IdentifiedByRandomPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedByRandomPassword(this);
}

void MySQLParser::IdentifiedByRandomPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedByRandomPassword(this);
}

std::any MySQLParser::IdentifiedByRandomPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedByRandomPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedByRandomPasswordContext *MySQLParser::identifiedByRandomPassword() {
  IdentifiedByRandomPasswordContext *_localctx =
    _tracker.createInstance<IdentifiedByRandomPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1222, MySQLParser::RuleIdentifiedByRandomPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8506);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8507);
    match(MySQLParser::BY_SYMBOL);
    setState(8508);
    match(MySQLParser::RANDOM_SYMBOL);
    setState(8509);
    match(MySQLParser::PASSWORD_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedWithPluginContext ------------------------------------------------------------------

MySQLParser::IdentifiedWithPluginContext::IdentifiedWithPluginContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::IdentifiedWithPluginContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::IdentifiedWithPluginContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedWithPlugin;
}

void MySQLParser::IdentifiedWithPluginContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedWithPlugin(this);
}

void MySQLParser::IdentifiedWithPluginContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedWithPlugin(this);
}

std::any MySQLParser::IdentifiedWithPluginContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedWithPlugin(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedWithPluginContext *MySQLParser::identifiedWithPlugin() {
  IdentifiedWithPluginContext *_localctx = _tracker.createInstance<IdentifiedWithPluginContext>(_ctx, getState());
  enterRule(_localctx, 1224, MySQLParser::RuleIdentifiedWithPlugin);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8511);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8512);
    match(MySQLParser::WITH_SYMBOL);
    setState(8513);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedWithPluginAsAuthContext ------------------------------------------------------------------

MySQLParser::IdentifiedWithPluginAsAuthContext::IdentifiedWithPluginAsAuthContext(ParserRuleContext *parent,
                                                                                  size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginAsAuthContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginAsAuthContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::IdentifiedWithPluginAsAuthContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginAsAuthContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringHashContext *MySQLParser::IdentifiedWithPluginAsAuthContext::textStringHash() {
  return getRuleContext<MySQLParser::TextStringHashContext>(0);
}

size_t MySQLParser::IdentifiedWithPluginAsAuthContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedWithPluginAsAuth;
}

void MySQLParser::IdentifiedWithPluginAsAuthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedWithPluginAsAuth(this);
}

void MySQLParser::IdentifiedWithPluginAsAuthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedWithPluginAsAuth(this);
}

std::any MySQLParser::IdentifiedWithPluginAsAuthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedWithPluginAsAuth(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedWithPluginAsAuthContext *MySQLParser::identifiedWithPluginAsAuth() {
  IdentifiedWithPluginAsAuthContext *_localctx =
    _tracker.createInstance<IdentifiedWithPluginAsAuthContext>(_ctx, getState());
  enterRule(_localctx, 1226, MySQLParser::RuleIdentifiedWithPluginAsAuth);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8515);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8516);
    match(MySQLParser::WITH_SYMBOL);
    setState(8517);
    textOrIdentifier();
    setState(8518);
    match(MySQLParser::AS_SYMBOL);
    setState(8519);
    textStringHash();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedWithPluginByPasswordContext
//------------------------------------------------------------------

MySQLParser::IdentifiedWithPluginByPasswordContext::IdentifiedWithPluginByPasswordContext(ParserRuleContext *parent,
                                                                                          size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByPasswordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByPasswordContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::IdentifiedWithPluginByPasswordContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByPasswordContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::IdentifiedWithPluginByPasswordContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::IdentifiedWithPluginByPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedWithPluginByPassword;
}

void MySQLParser::IdentifiedWithPluginByPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedWithPluginByPassword(this);
}

void MySQLParser::IdentifiedWithPluginByPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedWithPluginByPassword(this);
}

std::any MySQLParser::IdentifiedWithPluginByPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedWithPluginByPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedWithPluginByPasswordContext *MySQLParser::identifiedWithPluginByPassword() {
  IdentifiedWithPluginByPasswordContext *_localctx =
    _tracker.createInstance<IdentifiedWithPluginByPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1228, MySQLParser::RuleIdentifiedWithPluginByPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8521);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8522);
    match(MySQLParser::WITH_SYMBOL);
    setState(8523);
    textOrIdentifier();
    setState(8524);
    match(MySQLParser::BY_SYMBOL);
    setState(8525);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifiedWithPluginByRandomPasswordContext
//------------------------------------------------------------------

MySQLParser::IdentifiedWithPluginByRandomPasswordContext::IdentifiedWithPluginByRandomPasswordContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::RANDOM_SYMBOL() {
  return getToken(MySQLParser::RANDOM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifiedWithPluginByRandomPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

size_t MySQLParser::IdentifiedWithPluginByRandomPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifiedWithPluginByRandomPassword;
}

void MySQLParser::IdentifiedWithPluginByRandomPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifiedWithPluginByRandomPassword(this);
}

void MySQLParser::IdentifiedWithPluginByRandomPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifiedWithPluginByRandomPassword(this);
}

std::any MySQLParser::IdentifiedWithPluginByRandomPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifiedWithPluginByRandomPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifiedWithPluginByRandomPasswordContext *MySQLParser::identifiedWithPluginByRandomPassword() {
  IdentifiedWithPluginByRandomPasswordContext *_localctx =
    _tracker.createInstance<IdentifiedWithPluginByRandomPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1230, MySQLParser::RuleIdentifiedWithPluginByRandomPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8527);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(8528);
    match(MySQLParser::WITH_SYMBOL);
    setState(8529);
    textOrIdentifier();
    setState(8530);
    match(MySQLParser::BY_SYMBOL);
    setState(8531);
    match(MySQLParser::RANDOM_SYMBOL);
    setState(8532);
    match(MySQLParser::PASSWORD_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InitialAuthContext ------------------------------------------------------------------

MySQLParser::InitialAuthContext::InitialAuthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::InitialAuthContext::INITIAL_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::InitialAuthContext::AUTHENTICATION_SYMBOL() {
  return getToken(MySQLParser::AUTHENTICATION_SYMBOL, 0);
}

MySQLParser::IdentifiedByRandomPasswordContext *MySQLParser::InitialAuthContext::identifiedByRandomPassword() {
  return getRuleContext<MySQLParser::IdentifiedByRandomPasswordContext>(0);
}

MySQLParser::IdentifiedWithPluginAsAuthContext *MySQLParser::InitialAuthContext::identifiedWithPluginAsAuth() {
  return getRuleContext<MySQLParser::IdentifiedWithPluginAsAuthContext>(0);
}

MySQLParser::IdentifiedByPasswordContext *MySQLParser::InitialAuthContext::identifiedByPassword() {
  return getRuleContext<MySQLParser::IdentifiedByPasswordContext>(0);
}

size_t MySQLParser::InitialAuthContext::getRuleIndex() const {
  return MySQLParser::RuleInitialAuth;
}

void MySQLParser::InitialAuthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInitialAuth(this);
}

void MySQLParser::InitialAuthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInitialAuth(this);
}

std::any MySQLParser::InitialAuthContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInitialAuth(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InitialAuthContext *MySQLParser::initialAuth() {
  InitialAuthContext *_localctx = _tracker.createInstance<InitialAuthContext>(_ctx, getState());
  enterRule(_localctx, 1232, MySQLParser::RuleInitialAuth);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8534);
    match(MySQLParser::INITIAL_SYMBOL);
    setState(8535);
    match(MySQLParser::AUTHENTICATION_SYMBOL);
    setState(8539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1088, _ctx)) {
      case 1: {
        setState(8536);
        identifiedByRandomPassword();
        break;
      }

      case 2: {
        setState(8537);
        identifiedWithPluginAsAuth();
        break;
      }

      case 3: {
        setState(8538);
        identifiedByPassword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RetainCurrentPasswordContext ------------------------------------------------------------------

MySQLParser::RetainCurrentPasswordContext::RetainCurrentPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RetainCurrentPasswordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RetainCurrentPasswordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RetainCurrentPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

size_t MySQLParser::RetainCurrentPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleRetainCurrentPassword;
}

void MySQLParser::RetainCurrentPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRetainCurrentPassword(this);
}

void MySQLParser::RetainCurrentPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRetainCurrentPassword(this);
}

std::any MySQLParser::RetainCurrentPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRetainCurrentPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RetainCurrentPasswordContext *MySQLParser::retainCurrentPassword() {
  RetainCurrentPasswordContext *_localctx = _tracker.createInstance<RetainCurrentPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1234, MySQLParser::RuleRetainCurrentPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8541);
    match(MySQLParser::RETAIN_SYMBOL);
    setState(8542);
    match(MySQLParser::CURRENT_SYMBOL);
    setState(8543);
    match(MySQLParser::PASSWORD_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiscardOldPasswordContext ------------------------------------------------------------------

MySQLParser::DiscardOldPasswordContext::DiscardOldPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DiscardOldPasswordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DiscardOldPasswordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::DiscardOldPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

size_t MySQLParser::DiscardOldPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleDiscardOldPassword;
}

void MySQLParser::DiscardOldPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscardOldPassword(this);
}

void MySQLParser::DiscardOldPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscardOldPassword(this);
}

std::any MySQLParser::DiscardOldPasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDiscardOldPassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DiscardOldPasswordContext *MySQLParser::discardOldPassword() {
  DiscardOldPasswordContext *_localctx = _tracker.createInstance<DiscardOldPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1236, MySQLParser::RuleDiscardOldPassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8545);
    match(MySQLParser::DISCARD_SYMBOL);
    setState(8546);
    match(MySQLParser::OLD_SYMBOL);
    setState(8547);
    match(MySQLParser::PASSWORD_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserRegistrationContext ------------------------------------------------------------------

MySQLParser::UserRegistrationContext::UserRegistrationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FactorContext *MySQLParser::UserRegistrationContext::factor() {
  return getRuleContext<MySQLParser::FactorContext>(0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::INITIATE_SYMBOL() {
  return getToken(MySQLParser::INITIATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::REGISTRATION_SYMBOL() {
  return getToken(MySQLParser::REGISTRATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::UNREGISTER_SYMBOL() {
  return getToken(MySQLParser::UNREGISTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::FINISH_SYMBOL() {
  return getToken(MySQLParser::FINISH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::CHALLENGE_RESPONSE_SYMBOL() {
  return getToken(MySQLParser::CHALLENGE_RESPONSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::UserRegistrationContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringHashContext *MySQLParser::UserRegistrationContext::textStringHash() {
  return getRuleContext<MySQLParser::TextStringHashContext>(0);
}

size_t MySQLParser::UserRegistrationContext::getRuleIndex() const {
  return MySQLParser::RuleUserRegistration;
}

void MySQLParser::UserRegistrationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserRegistration(this);
}

void MySQLParser::UserRegistrationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserRegistration(this);
}

std::any MySQLParser::UserRegistrationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserRegistration(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserRegistrationContext *MySQLParser::userRegistration() {
  UserRegistrationContext *_localctx = _tracker.createInstance<UserRegistrationContext>(_ctx, getState());
  enterRule(_localctx, 1238, MySQLParser::RuleUserRegistration);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8564);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1089, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8549);
        factor();
        setState(8550);
        match(MySQLParser::INITIATE_SYMBOL);
        setState(8551);
        match(MySQLParser::REGISTRATION_SYMBOL);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8553);
        factor();
        setState(8554);
        match(MySQLParser::UNREGISTER_SYMBOL);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8556);
        factor();
        setState(8557);
        match(MySQLParser::FINISH_SYMBOL);
        setState(8558);
        match(MySQLParser::REGISTRATION_SYMBOL);
        setState(8559);
        match(MySQLParser::SET_SYMBOL);
        setState(8560);
        match(MySQLParser::CHALLENGE_RESPONSE_SYMBOL);
        setState(8561);
        match(MySQLParser::AS_SYMBOL);
        setState(8562);
        textStringHash();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FactorContext ------------------------------------------------------------------

MySQLParser::FactorContext::FactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::NumLiteralContext *MySQLParser::FactorContext::numLiteral() {
  return getRuleContext<MySQLParser::NumLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::FactorContext::FACTOR_SYMBOL() {
  return getToken(MySQLParser::FACTOR_SYMBOL, 0);
}

size_t MySQLParser::FactorContext::getRuleIndex() const {
  return MySQLParser::RuleFactor;
}

void MySQLParser::FactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFactor(this);
}

void MySQLParser::FactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFactor(this);
}

std::any MySQLParser::FactorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFactor(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FactorContext *MySQLParser::factor() {
  FactorContext *_localctx = _tracker.createInstance<FactorContext>(_ctx, getState());
  enterRule(_localctx, 1240, MySQLParser::RuleFactor);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8566);
    numLiteral();
    setState(8567);
    match(MySQLParser::FACTOR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplacePasswordContext ------------------------------------------------------------------

MySQLParser::ReplacePasswordContext::ReplacePasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ReplacePasswordContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TextStringContext *MySQLParser::ReplacePasswordContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

size_t MySQLParser::ReplacePasswordContext::getRuleIndex() const {
  return MySQLParser::RuleReplacePassword;
}

void MySQLParser::ReplacePasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplacePassword(this);
}

void MySQLParser::ReplacePasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplacePassword(this);
}

std::any MySQLParser::ReplacePasswordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReplacePassword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ReplacePasswordContext *MySQLParser::replacePassword() {
  ReplacePasswordContext *_localctx = _tracker.createInstance<ReplacePasswordContext>(_ctx, getState());
  enterRule(_localctx, 1242, MySQLParser::RuleReplacePassword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8569);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(8570);
    textString();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserIdentifierOrTextContext ------------------------------------------------------------------

MySQLParser::UserIdentifierOrTextContext::UserIdentifierOrTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::UserIdentifierOrTextContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::UserVariableContext *MySQLParser::UserIdentifierOrTextContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

size_t MySQLParser::UserIdentifierOrTextContext::getRuleIndex() const {
  return MySQLParser::RuleUserIdentifierOrText;
}

void MySQLParser::UserIdentifierOrTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserIdentifierOrText(this);
}

void MySQLParser::UserIdentifierOrTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserIdentifierOrText(this);
}

std::any MySQLParser::UserIdentifierOrTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUserIdentifierOrText(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserIdentifierOrTextContext *MySQLParser::userIdentifierOrText() {
  UserIdentifierOrTextContext *_localctx = _tracker.createInstance<UserIdentifierOrTextContext>(_ctx, getState());
  enterRule(_localctx, 1244, MySQLParser::RuleUserIdentifierOrText);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8572);
    textOrIdentifier();
    setState(8574);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1090, _ctx)) {
      case 1: {
        setState(8573);
        userVariable();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserContext ------------------------------------------------------------------

MySQLParser::UserContext::UserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserIdentifierOrTextContext *MySQLParser::UserContext::userIdentifierOrText() {
  return getRuleContext<MySQLParser::UserIdentifierOrTextContext>(0);
}

tree::TerminalNode *MySQLParser::UserContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext *MySQLParser::UserContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

size_t MySQLParser::UserContext::getRuleIndex() const {
  return MySQLParser::RuleUser;
}

void MySQLParser::UserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser(this);
}

void MySQLParser::UserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser(this);
}

std::any MySQLParser::UserContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUser(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UserContext *MySQLParser::user() {
  UserContext *_localctx = _tracker.createInstance<UserContext>(_ctx, getState());
  enterRule(_localctx, 1246, MySQLParser::RuleUser);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8581);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1092, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8576);
        userIdentifierOrText();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8577);
        match(MySQLParser::CURRENT_USER_SYMBOL);
        setState(8579);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1091, _ctx)) {
          case 1: {
            setState(8578);
            parentheses();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeClauseContext ------------------------------------------------------------------

MySQLParser::LikeClauseContext::LikeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::LikeClauseContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::LikeClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::LikeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLikeClause;
}

void MySQLParser::LikeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeClause(this);
}

void MySQLParser::LikeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeClause(this);
}

std::any MySQLParser::LikeClauseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLikeClause(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LikeClauseContext *MySQLParser::likeClause() {
  LikeClauseContext *_localctx = _tracker.createInstance<LikeClauseContext>(_ctx, getState());
  enterRule(_localctx, 1248, MySQLParser::RuleLikeClause);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8583);
    match(MySQLParser::LIKE_SYMBOL);
    setState(8584);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeOrWhereContext ------------------------------------------------------------------

MySQLParser::LikeOrWhereContext::LikeOrWhereContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LikeClauseContext *MySQLParser::LikeOrWhereContext::likeClause() {
  return getRuleContext<MySQLParser::LikeClauseContext>(0);
}

MySQLParser::WhereClauseContext *MySQLParser::LikeOrWhereContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

size_t MySQLParser::LikeOrWhereContext::getRuleIndex() const {
  return MySQLParser::RuleLikeOrWhere;
}

void MySQLParser::LikeOrWhereContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeOrWhere(this);
}

void MySQLParser::LikeOrWhereContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeOrWhere(this);
}

std::any MySQLParser::LikeOrWhereContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLikeOrWhere(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LikeOrWhereContext *MySQLParser::likeOrWhere() {
  LikeOrWhereContext *_localctx = _tracker.createInstance<LikeOrWhereContext>(_ctx, getState());
  enterRule(_localctx, 1250, MySQLParser::RuleLikeOrWhere);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8588);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LIKE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8586);
        likeClause();
        break;
      }

      case MySQLParser::WHERE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8587);
        whereClause();
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnlineOptionContext ------------------------------------------------------------------

MySQLParser::OnlineOptionContext::OnlineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::OnlineOptionContext::ONLINE_SYMBOL() {
  return getToken(MySQLParser::ONLINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OnlineOptionContext::OFFLINE_SYMBOL() {
  return getToken(MySQLParser::OFFLINE_SYMBOL, 0);
}

size_t MySQLParser::OnlineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOnlineOption;
}

void MySQLParser::OnlineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnlineOption(this);
}

void MySQLParser::OnlineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnlineOption(this);
}

std::any MySQLParser::OnlineOptionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOnlineOption(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OnlineOptionContext *MySQLParser::onlineOption() {
  OnlineOptionContext *_localctx = _tracker.createInstance<OnlineOptionContext>(_ctx, getState());
  enterRule(_localctx, 1252, MySQLParser::RuleOnlineOption);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8590);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::OFFLINE_SYMBOL

          || _la == MySQLParser::ONLINE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoWriteToBinLogContext ------------------------------------------------------------------

MySQLParser::NoWriteToBinLogContext::NoWriteToBinLogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NoWriteToBinLogContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NoWriteToBinLogContext::NO_WRITE_TO_BINLOG_SYMBOL() {
  return getToken(MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL, 0);
}

size_t MySQLParser::NoWriteToBinLogContext::getRuleIndex() const {
  return MySQLParser::RuleNoWriteToBinLog;
}

void MySQLParser::NoWriteToBinLogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoWriteToBinLog(this);
}

void MySQLParser::NoWriteToBinLogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoWriteToBinLog(this);
}

std::any MySQLParser::NoWriteToBinLogContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNoWriteToBinLog(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NoWriteToBinLogContext *MySQLParser::noWriteToBinLog() {
  NoWriteToBinLogContext *_localctx = _tracker.createInstance<NoWriteToBinLogContext>(_ctx, getState());
  enterRule(_localctx, 1254, MySQLParser::RuleNoWriteToBinLog);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8592);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsePartitionContext ------------------------------------------------------------------

MySQLParser::UsePartitionContext::UsePartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::UsePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext *MySQLParser::UsePartitionContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

size_t MySQLParser::UsePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleUsePartition;
}

void MySQLParser::UsePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsePartition(this);
}

void MySQLParser::UsePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsePartition(this);
}

std::any MySQLParser::UsePartitionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUsePartition(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UsePartitionContext *MySQLParser::usePartition() {
  UsePartitionContext *_localctx = _tracker.createInstance<UsePartitionContext>(_ctx, getState());
  enterRule(_localctx, 1256, MySQLParser::RuleUsePartition);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8594);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(8595);
    identifierListWithParentheses();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldIdentifierContext ------------------------------------------------------------------

MySQLParser::FieldIdentifierContext::FieldIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DotIdentifierContext *MySQLParser::FieldIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::FieldIdentifierContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::FieldIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleFieldIdentifier;
}

void MySQLParser::FieldIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldIdentifier(this);
}

void MySQLParser::FieldIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldIdentifier(this);
}

std::any MySQLParser::FieldIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFieldIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FieldIdentifierContext *MySQLParser::fieldIdentifier() {
  FieldIdentifierContext *_localctx = _tracker.createInstance<FieldIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1258, MySQLParser::RuleFieldIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8602);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1095, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8597);
        dotIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8598);
        qualifiedIdentifier();
        setState(8600);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1094, _ctx)) {
          case 1: {
            setState(8599);
            dotIdentifier();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnNameContext ------------------------------------------------------------------

MySQLParser::ColumnNameContext::ColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::ColumnNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::ColumnNameContext::getRuleIndex() const {
  return MySQLParser::RuleColumnName;
}

void MySQLParser::ColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnName(this);
}

void MySQLParser::ColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnName(this);
}

std::any MySQLParser::ColumnNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnNameContext *MySQLParser::columnName() {
  ColumnNameContext *_localctx = _tracker.createInstance<ColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 1260, MySQLParser::RuleColumnName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8604);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefContext::ColumnInternalRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::ColumnInternalRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::ColumnInternalRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRef;
}

void MySQLParser::ColumnInternalRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRef(this);
}

void MySQLParser::ColumnInternalRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRef(this);
}

std::any MySQLParser::ColumnInternalRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnInternalRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnInternalRefContext *MySQLParser::columnInternalRef() {
  ColumnInternalRefContext *_localctx = _tracker.createInstance<ColumnInternalRefContext>(_ctx, getState());
  enterRule(_localctx, 1262, MySQLParser::RuleColumnInternalRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8606);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefListContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefListContext::ColumnInternalRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ColumnInternalRefListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ColumnInternalRefContext *> MySQLParser::ColumnInternalRefListContext::columnInternalRef() {
  return getRuleContexts<MySQLParser::ColumnInternalRefContext>();
}

MySQLParser::ColumnInternalRefContext *MySQLParser::ColumnInternalRefListContext::columnInternalRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(i);
}

tree::TerminalNode *MySQLParser::ColumnInternalRefListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::ColumnInternalRefListContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRefList;
}

void MySQLParser::ColumnInternalRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRefList(this);
}

void MySQLParser::ColumnInternalRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRefList(this);
}

std::any MySQLParser::ColumnInternalRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnInternalRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnInternalRefListContext *MySQLParser::columnInternalRefList() {
  ColumnInternalRefListContext *_localctx = _tracker.createInstance<ColumnInternalRefListContext>(_ctx, getState());
  enterRule(_localctx, 1264, MySQLParser::RuleColumnInternalRefList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8608);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8609);
    columnInternalRef();
    setState(8614);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8610);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8611);
      columnInternalRef();
      setState(8616);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8617);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext::ColumnRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext *MySQLParser::ColumnRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}

size_t MySQLParser::ColumnRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnRef;
}

void MySQLParser::ColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnRef(this);
}

void MySQLParser::ColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnRef(this);
}

std::any MySQLParser::ColumnRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitColumnRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ColumnRefContext *MySQLParser::columnRef() {
  ColumnRefContext *_localctx = _tracker.createInstance<ColumnRefContext>(_ctx, getState());
  enterRule(_localctx, 1266, MySQLParser::RuleColumnRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8619);
    fieldIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertIdentifierContext ------------------------------------------------------------------

MySQLParser::InsertIdentifierContext::InsertIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext *MySQLParser::InsertIdentifierContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::TableWildContext *MySQLParser::InsertIdentifierContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}

size_t MySQLParser::InsertIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleInsertIdentifier;
}

void MySQLParser::InsertIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertIdentifier(this);
}

void MySQLParser::InsertIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertIdentifier(this);
}

std::any MySQLParser::InsertIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInsertIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::InsertIdentifierContext *MySQLParser::insertIdentifier() {
  InsertIdentifierContext *_localctx = _tracker.createInstance<InsertIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1268, MySQLParser::RuleInsertIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8623);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1097, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8621);
        columnRef();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8622);
        tableWild();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameContext ------------------------------------------------------------------

MySQLParser::IndexNameContext::IndexNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::IndexNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::IndexNameContext::getRuleIndex() const {
  return MySQLParser::RuleIndexName;
}

void MySQLParser::IndexNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexName(this);
}

void MySQLParser::IndexNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexName(this);
}

std::any MySQLParser::IndexNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexNameContext *MySQLParser::indexName() {
  IndexNameContext *_localctx = _tracker.createInstance<IndexNameContext>(_ctx, getState());
  enterRule(_localctx, 1270, MySQLParser::RuleIndexName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8625);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexRefContext ------------------------------------------------------------------

MySQLParser::IndexRefContext::IndexRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext *MySQLParser::IndexRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}

size_t MySQLParser::IndexRefContext::getRuleIndex() const {
  return MySQLParser::RuleIndexRef;
}

void MySQLParser::IndexRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexRef(this);
}

void MySQLParser::IndexRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexRef(this);
}

std::any MySQLParser::IndexRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIndexRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IndexRefContext *MySQLParser::indexRef() {
  IndexRefContext *_localctx = _tracker.createInstance<IndexRefContext>(_ctx, getState());
  enterRule(_localctx, 1272, MySQLParser::RuleIndexRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8627);
    fieldIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableWildContext ------------------------------------------------------------------

MySQLParser::TableWildContext::TableWildContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::TableWildContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext *MySQLParser::TableWildContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableWildContext::DOT_SYMBOL() {
  return getTokens(MySQLParser::DOT_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableWildContext::DOT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DOT_SYMBOL, i);
}

tree::TerminalNode *MySQLParser::TableWildContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

size_t MySQLParser::TableWildContext::getRuleIndex() const {
  return MySQLParser::RuleTableWild;
}

void MySQLParser::TableWildContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableWild(this);
}

void MySQLParser::TableWildContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableWild(this);
}

std::any MySQLParser::TableWildContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableWild(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableWildContext *MySQLParser::tableWild() {
  TableWildContext *_localctx = _tracker.createInstance<TableWildContext>(_ctx, getState());
  enterRule(_localctx, 1274, MySQLParser::RuleTableWild);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8629);
    identifier();
    setState(8630);
    match(MySQLParser::DOT_SYMBOL);
    setState(8634);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1098, _ctx)) {
      case 1: {
        setState(8631);
        identifier();
        setState(8632);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      default:
        break;
    }
    setState(8636);
    match(MySQLParser::MULT_OPERATOR);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaNameContext ------------------------------------------------------------------

MySQLParser::SchemaNameContext::SchemaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::SchemaNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::SchemaNameContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaName;
}

void MySQLParser::SchemaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaName(this);
}

void MySQLParser::SchemaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaName(this);
}

std::any MySQLParser::SchemaNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSchemaName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaNameContext *MySQLParser::schemaName() {
  SchemaNameContext *_localctx = _tracker.createInstance<SchemaNameContext>(_ctx, getState());
  enterRule(_localctx, 1276, MySQLParser::RuleSchemaName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8638);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaRefContext ------------------------------------------------------------------

MySQLParser::SchemaRefContext::SchemaRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::SchemaRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::SchemaRefContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaRef;
}

void MySQLParser::SchemaRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaRef(this);
}

void MySQLParser::SchemaRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaRef(this);
}

std::any MySQLParser::SchemaRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSchemaRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SchemaRefContext *MySQLParser::schemaRef() {
  SchemaRefContext *_localctx = _tracker.createInstance<SchemaRefContext>(_ctx, getState());
  enterRule(_localctx, 1278, MySQLParser::RuleSchemaRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8640);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureNameContext ------------------------------------------------------------------

MySQLParser::ProcedureNameContext::ProcedureNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::ProcedureNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::ProcedureNameContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureName;
}

void MySQLParser::ProcedureNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureName(this);
}

void MySQLParser::ProcedureNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureName(this);
}

std::any MySQLParser::ProcedureNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProcedureName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureNameContext *MySQLParser::procedureName() {
  ProcedureNameContext *_localctx = _tracker.createInstance<ProcedureNameContext>(_ctx, getState());
  enterRule(_localctx, 1280, MySQLParser::RuleProcedureName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8642);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureRefContext ------------------------------------------------------------------

MySQLParser::ProcedureRefContext::ProcedureRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::ProcedureRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::ProcedureRefContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureRef;
}

void MySQLParser::ProcedureRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureRef(this);
}

void MySQLParser::ProcedureRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureRef(this);
}

std::any MySQLParser::ProcedureRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitProcedureRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ProcedureRefContext *MySQLParser::procedureRef() {
  ProcedureRefContext *_localctx = _tracker.createInstance<ProcedureRefContext>(_ctx, getState());
  enterRule(_localctx, 1282, MySQLParser::RuleProcedureRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8644);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

MySQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::FunctionNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::FunctionNameContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionName;
}

void MySQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void MySQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}

std::any MySQLParser::FunctionNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFunctionName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionNameContext *MySQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 1284, MySQLParser::RuleFunctionName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8646);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionRefContext ------------------------------------------------------------------

MySQLParser::FunctionRefContext::FunctionRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::FunctionRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::FunctionRefContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionRef;
}

void MySQLParser::FunctionRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionRef(this);
}

void MySQLParser::FunctionRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionRef(this);
}

std::any MySQLParser::FunctionRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFunctionRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FunctionRefContext *MySQLParser::functionRef() {
  FunctionRefContext *_localctx = _tracker.createInstance<FunctionRefContext>(_ctx, getState());
  enterRule(_localctx, 1286, MySQLParser::RuleFunctionRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8648);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerNameContext ------------------------------------------------------------------

MySQLParser::TriggerNameContext::TriggerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::TriggerNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::TriggerNameContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerName;
}

void MySQLParser::TriggerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerName(this);
}

void MySQLParser::TriggerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerName(this);
}

std::any MySQLParser::TriggerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTriggerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerNameContext *MySQLParser::triggerName() {
  TriggerNameContext *_localctx = _tracker.createInstance<TriggerNameContext>(_ctx, getState());
  enterRule(_localctx, 1288, MySQLParser::RuleTriggerName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8650);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerRefContext ------------------------------------------------------------------

MySQLParser::TriggerRefContext::TriggerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::TriggerRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::TriggerRefContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerRef;
}

void MySQLParser::TriggerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerRef(this);
}

void MySQLParser::TriggerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerRef(this);
}

std::any MySQLParser::TriggerRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTriggerRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TriggerRefContext *MySQLParser::triggerRef() {
  TriggerRefContext *_localctx = _tracker.createInstance<TriggerRefContext>(_ctx, getState());
  enterRule(_localctx, 1290, MySQLParser::RuleTriggerRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8652);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewNameContext ------------------------------------------------------------------

MySQLParser::ViewNameContext::ViewNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::ViewNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::ViewNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::ViewNameContext::getRuleIndex() const {
  return MySQLParser::RuleViewName;
}

void MySQLParser::ViewNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewName(this);
}

void MySQLParser::ViewNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewName(this);
}

std::any MySQLParser::ViewNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewNameContext *MySQLParser::viewName() {
  ViewNameContext *_localctx = _tracker.createInstance<ViewNameContext>(_ctx, getState());
  enterRule(_localctx, 1292, MySQLParser::RuleViewName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8656);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1099, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8654);
        qualifiedIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8655);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefContext ------------------------------------------------------------------

MySQLParser::ViewRefContext::ViewRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::ViewRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::ViewRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::ViewRefContext::getRuleIndex() const {
  return MySQLParser::RuleViewRef;
}

void MySQLParser::ViewRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRef(this);
}

void MySQLParser::ViewRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRef(this);
}

std::any MySQLParser::ViewRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitViewRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ViewRefContext *MySQLParser::viewRef() {
  ViewRefContext *_localctx = _tracker.createInstance<ViewRefContext>(_ctx, getState());
  enterRule(_localctx, 1294, MySQLParser::RuleViewRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8660);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1100, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8658);
        qualifiedIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8659);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceNameContext ------------------------------------------------------------------

MySQLParser::TablespaceNameContext::TablespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::TablespaceNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::TablespaceNameContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceName;
}

void MySQLParser::TablespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceName(this);
}

void MySQLParser::TablespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceName(this);
}

std::any MySQLParser::TablespaceNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTablespaceName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceNameContext *MySQLParser::tablespaceName() {
  TablespaceNameContext *_localctx = _tracker.createInstance<TablespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 1296, MySQLParser::RuleTablespaceName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8662);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceRefContext ------------------------------------------------------------------

MySQLParser::TablespaceRefContext::TablespaceRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::TablespaceRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::TablespaceRefContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceRef;
}

void MySQLParser::TablespaceRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceRef(this);
}

void MySQLParser::TablespaceRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceRef(this);
}

std::any MySQLParser::TablespaceRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTablespaceRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TablespaceRefContext *MySQLParser::tablespaceRef() {
  TablespaceRefContext *_localctx = _tracker.createInstance<TablespaceRefContext>(_ctx, getState());
  enterRule(_localctx, 1298, MySQLParser::RuleTablespaceRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8664);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupNameContext ------------------------------------------------------------------

MySQLParser::LogfileGroupNameContext::LogfileGroupNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::LogfileGroupNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::LogfileGroupNameContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupName;
}

void MySQLParser::LogfileGroupNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupName(this);
}

void MySQLParser::LogfileGroupNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupName(this);
}

std::any MySQLParser::LogfileGroupNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLogfileGroupName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupNameContext *MySQLParser::logfileGroupName() {
  LogfileGroupNameContext *_localctx = _tracker.createInstance<LogfileGroupNameContext>(_ctx, getState());
  enterRule(_localctx, 1300, MySQLParser::RuleLogfileGroupName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8666);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupRefContext ------------------------------------------------------------------

MySQLParser::LogfileGroupRefContext::LogfileGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::LogfileGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::LogfileGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupRef;
}

void MySQLParser::LogfileGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupRef(this);
}

void MySQLParser::LogfileGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupRef(this);
}

std::any MySQLParser::LogfileGroupRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLogfileGroupRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LogfileGroupRefContext *MySQLParser::logfileGroupRef() {
  LogfileGroupRefContext *_localctx = _tracker.createInstance<LogfileGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1302, MySQLParser::RuleLogfileGroupRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8668);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventNameContext ------------------------------------------------------------------

MySQLParser::EventNameContext::EventNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::EventNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::EventNameContext::getRuleIndex() const {
  return MySQLParser::RuleEventName;
}

void MySQLParser::EventNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventName(this);
}

void MySQLParser::EventNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventName(this);
}

std::any MySQLParser::EventNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEventName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EventNameContext *MySQLParser::eventName() {
  EventNameContext *_localctx = _tracker.createInstance<EventNameContext>(_ctx, getState());
  enterRule(_localctx, 1304, MySQLParser::RuleEventName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8670);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventRefContext ------------------------------------------------------------------

MySQLParser::EventRefContext::EventRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::EventRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

size_t MySQLParser::EventRefContext::getRuleIndex() const {
  return MySQLParser::RuleEventRef;
}

void MySQLParser::EventRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventRef(this);
}

void MySQLParser::EventRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventRef(this);
}

std::any MySQLParser::EventRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEventRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EventRefContext *MySQLParser::eventRef() {
  EventRefContext *_localctx = _tracker.createInstance<EventRefContext>(_ctx, getState());
  enterRule(_localctx, 1306, MySQLParser::RuleEventRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8672);
    qualifiedIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfNameContext ------------------------------------------------------------------

MySQLParser::UdfNameContext::UdfNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::UdfNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::UdfNameContext::getRuleIndex() const {
  return MySQLParser::RuleUdfName;
}

void MySQLParser::UdfNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfName(this);
}

void MySQLParser::UdfNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfName(this);
}

std::any MySQLParser::UdfNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUdfName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::UdfNameContext *MySQLParser::udfName() {
  UdfNameContext *_localctx = _tracker.createInstance<UdfNameContext>(_ctx, getState());
  enterRule(_localctx, 1308, MySQLParser::RuleUdfName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8674);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerNameContext ------------------------------------------------------------------

MySQLParser::ServerNameContext::ServerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::ServerNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::ServerNameContext::getRuleIndex() const {
  return MySQLParser::RuleServerName;
}

void MySQLParser::ServerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerName(this);
}

void MySQLParser::ServerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerName(this);
}

std::any MySQLParser::ServerNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitServerName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerNameContext *MySQLParser::serverName() {
  ServerNameContext *_localctx = _tracker.createInstance<ServerNameContext>(_ctx, getState());
  enterRule(_localctx, 1310, MySQLParser::RuleServerName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8676);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerRefContext ------------------------------------------------------------------

MySQLParser::ServerRefContext::ServerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::ServerRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::ServerRefContext::getRuleIndex() const {
  return MySQLParser::RuleServerRef;
}

void MySQLParser::ServerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerRef(this);
}

void MySQLParser::ServerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerRef(this);
}

std::any MySQLParser::ServerRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitServerRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ServerRefContext *MySQLParser::serverRef() {
  ServerRefContext *_localctx = _tracker.createInstance<ServerRefContext>(_ctx, getState());
  enterRule(_localctx, 1312, MySQLParser::RuleServerRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8678);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineRefContext ------------------------------------------------------------------

MySQLParser::EngineRefContext::EngineRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext *MySQLParser::EngineRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

size_t MySQLParser::EngineRefContext::getRuleIndex() const {
  return MySQLParser::RuleEngineRef;
}

void MySQLParser::EngineRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineRef(this);
}

void MySQLParser::EngineRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineRef(this);
}

std::any MySQLParser::EngineRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEngineRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EngineRefContext *MySQLParser::engineRef() {
  EngineRefContext *_localctx = _tracker.createInstance<EngineRefContext>(_ctx, getState());
  enterRule(_localctx, 1314, MySQLParser::RuleEngineRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8680);
    textOrIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableNameContext ------------------------------------------------------------------

MySQLParser::TableNameContext::TableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::TableNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::TableNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::TableNameContext::getRuleIndex() const {
  return MySQLParser::RuleTableName;
}

void MySQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}

void MySQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}

std::any MySQLParser::TableNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableNameContext *MySQLParser::tableName() {
  TableNameContext *_localctx = _tracker.createInstance<TableNameContext>(_ctx, getState());
  enterRule(_localctx, 1316, MySQLParser::RuleTableName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8684);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1101, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8682);
        qualifiedIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8683);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableRefContext ------------------------------------------------------------------

MySQLParser::FilterTableRefContext::FilterTableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SchemaRefContext *MySQLParser::FilterTableRefContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::FilterTableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::FilterTableRefContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableRef;
}

void MySQLParser::FilterTableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableRef(this);
}

void MySQLParser::FilterTableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableRef(this);
}

std::any MySQLParser::FilterTableRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFilterTableRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FilterTableRefContext *MySQLParser::filterTableRef() {
  FilterTableRefContext *_localctx = _tracker.createInstance<FilterTableRefContext>(_ctx, getState());
  enterRule(_localctx, 1318, MySQLParser::RuleFilterTableRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8686);
    schemaRef();
    setState(8687);
    dotIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefWithWildcardContext ------------------------------------------------------------------

MySQLParser::TableRefWithWildcardContext::TableRefWithWildcardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::TableRefWithWildcardContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode *MySQLParser::TableRefWithWildcardContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TableRefWithWildcardContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

MySQLParser::DotIdentifierContext *MySQLParser::TableRefWithWildcardContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::TableRefWithWildcardContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefWithWildcard;
}

void MySQLParser::TableRefWithWildcardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefWithWildcard(this);
}

void MySQLParser::TableRefWithWildcardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefWithWildcard(this);
}

std::any MySQLParser::TableRefWithWildcardContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableRefWithWildcard(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefWithWildcardContext *MySQLParser::tableRefWithWildcard() {
  TableRefWithWildcardContext *_localctx = _tracker.createInstance<TableRefWithWildcardContext>(_ctx, getState());
  enterRule(_localctx, 1320, MySQLParser::RuleTableRefWithWildcard);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8689);
    identifier();
    setState(8697);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1103, _ctx)) {
      case 1: {
        setState(8690);
        match(MySQLParser::DOT_SYMBOL);
        setState(8691);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      case 2: {
        setState(8692);
        dotIdentifier();
        setState(8695);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(8693);
          match(MySQLParser::DOT_SYMBOL);
          setState(8694);
          match(MySQLParser::MULT_OPERATOR);
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefContext ------------------------------------------------------------------

MySQLParser::TableRefContext::TableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::TableRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::TableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::TableRefContext::getRuleIndex() const {
  return MySQLParser::RuleTableRef;
}

void MySQLParser::TableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRef(this);
}

void MySQLParser::TableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRef(this);
}

std::any MySQLParser::TableRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefContext *MySQLParser::tableRef() {
  TableRefContext *_localctx = _tracker.createInstance<TableRefContext>(_ctx, getState());
  enterRule(_localctx, 1322, MySQLParser::RuleTableRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8701);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1104, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8699);
        qualifiedIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8700);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefListContext ------------------------------------------------------------------

MySQLParser::TableRefListContext::TableRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefContext *> MySQLParser::TableRefListContext::tableRef() {
  return getRuleContexts<MySQLParser::TableRefContext>();
}

MySQLParser::TableRefContext *MySQLParser::TableRefListContext::tableRef(size_t i) {
  return getRuleContext<MySQLParser::TableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TableRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefList;
}

void MySQLParser::TableRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefList(this);
}

void MySQLParser::TableRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefList(this);
}

std::any MySQLParser::TableRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableRefListContext *MySQLParser::tableRefList() {
  TableRefListContext *_localctx = _tracker.createInstance<TableRefListContext>(_ctx, getState());
  enterRule(_localctx, 1324, MySQLParser::RuleTableRefList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8703);
    tableRef();
    setState(8708);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8704);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8705);
      tableRef();
      setState(8710);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasRefListContext ------------------------------------------------------------------

MySQLParser::TableAliasRefListContext::TableAliasRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefWithWildcardContext *> MySQLParser::TableAliasRefListContext::tableRefWithWildcard() {
  return getRuleContexts<MySQLParser::TableRefWithWildcardContext>();
}

MySQLParser::TableRefWithWildcardContext *MySQLParser::TableAliasRefListContext::tableRefWithWildcard(size_t i) {
  return getRuleContext<MySQLParser::TableRefWithWildcardContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableAliasRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TableAliasRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TableAliasRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableAliasRefList;
}

void MySQLParser::TableAliasRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAliasRefList(this);
}

void MySQLParser::TableAliasRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAliasRefList(this);
}

std::any MySQLParser::TableAliasRefListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTableAliasRefList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TableAliasRefListContext *MySQLParser::tableAliasRefList() {
  TableAliasRefListContext *_localctx = _tracker.createInstance<TableAliasRefListContext>(_ctx, getState());
  enterRule(_localctx, 1326, MySQLParser::RuleTableAliasRefList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8711);
    tableRefWithWildcard();
    setState(8716);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8712);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8713);
      tableRefWithWildcard();
      setState(8718);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterNameContext ------------------------------------------------------------------

MySQLParser::ParameterNameContext::ParameterNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::ParameterNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::ParameterNameContext::getRuleIndex() const {
  return MySQLParser::RuleParameterName;
}

void MySQLParser::ParameterNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterName(this);
}

void MySQLParser::ParameterNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterName(this);
}

std::any MySQLParser::ParameterNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitParameterName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ParameterNameContext *MySQLParser::parameterName() {
  ParameterNameContext *_localctx = _tracker.createInstance<ParameterNameContext>(_ctx, getState());
  enterRule(_localctx, 1328, MySQLParser::RuleParameterName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8719);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelIdentifierContext ------------------------------------------------------------------

MySQLParser::LabelIdentifierContext::LabelIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext *MySQLParser::LabelIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::LabelKeywordContext *MySQLParser::LabelIdentifierContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}

size_t MySQLParser::LabelIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleLabelIdentifier;
}

void MySQLParser::LabelIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelIdentifier(this);
}

void MySQLParser::LabelIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelIdentifier(this);
}

std::any MySQLParser::LabelIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabelIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelIdentifierContext *MySQLParser::labelIdentifier() {
  LabelIdentifierContext *_localctx = _tracker.createInstance<LabelIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1330, MySQLParser::RuleLabelIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8723);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1107, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8721);
        pureIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8722);
        labelKeyword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelRefContext ------------------------------------------------------------------

MySQLParser::LabelRefContext::LabelRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext *MySQLParser::LabelRefContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}

size_t MySQLParser::LabelRefContext::getRuleIndex() const {
  return MySQLParser::RuleLabelRef;
}

void MySQLParser::LabelRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelRef(this);
}

void MySQLParser::LabelRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelRef(this);
}

std::any MySQLParser::LabelRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabelRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelRefContext *MySQLParser::labelRef() {
  LabelRefContext *_localctx = _tracker.createInstance<LabelRefContext>(_ctx, getState());
  enterRule(_localctx, 1332, MySQLParser::RuleLabelRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8725);
    labelIdentifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierContext::RoleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext *MySQLParser::RoleIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::RoleKeywordContext *MySQLParser::RoleIdentifierContext::roleKeyword() {
  return getRuleContext<MySQLParser::RoleKeywordContext>(0);
}

size_t MySQLParser::RoleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifier;
}

void MySQLParser::RoleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifier(this);
}

void MySQLParser::RoleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifier(this);
}

std::any MySQLParser::RoleIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleIdentifierContext *MySQLParser::roleIdentifier() {
  RoleIdentifierContext *_localctx = _tracker.createInstance<RoleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1334, MySQLParser::RuleRoleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8729);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1108, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8727);
        pureIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8728);
        roleKeyword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PluginRefContext ------------------------------------------------------------------

MySQLParser::PluginRefContext::PluginRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::PluginRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::PluginRefContext::getRuleIndex() const {
  return MySQLParser::RulePluginRef;
}

void MySQLParser::PluginRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginRef(this);
}

void MySQLParser::PluginRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginRef(this);
}

std::any MySQLParser::PluginRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPluginRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PluginRefContext *MySQLParser::pluginRef() {
  PluginRefContext *_localctx = _tracker.createInstance<PluginRefContext>(_ctx, getState());
  enterRule(_localctx, 1336, MySQLParser::RulePluginRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8731);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentRefContext ------------------------------------------------------------------

MySQLParser::ComponentRefContext::ComponentRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext *MySQLParser::ComponentRefContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::ComponentRefContext::getRuleIndex() const {
  return MySQLParser::RuleComponentRef;
}

void MySQLParser::ComponentRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentRef(this);
}

void MySQLParser::ComponentRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentRef(this);
}

std::any MySQLParser::ComponentRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitComponentRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ComponentRefContext *MySQLParser::componentRef() {
  ComponentRefContext *_localctx = _tracker.createInstance<ComponentRefContext>(_ctx, getState());
  enterRule(_localctx, 1338, MySQLParser::RuleComponentRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8733);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupRefContext ------------------------------------------------------------------

MySQLParser::ResourceGroupRefContext::ResourceGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::ResourceGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::ResourceGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupRef;
}

void MySQLParser::ResourceGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupRef(this);
}

void MySQLParser::ResourceGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupRef(this);
}

std::any MySQLParser::ResourceGroupRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitResourceGroupRef(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ResourceGroupRefContext *MySQLParser::resourceGroupRef() {
  ResourceGroupRefContext *_localctx = _tracker.createInstance<ResourceGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1340, MySQLParser::RuleResourceGroupRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8735);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowNameContext ------------------------------------------------------------------

MySQLParser::WindowNameContext::WindowNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::WindowNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::WindowNameContext::getRuleIndex() const {
  return MySQLParser::RuleWindowName;
}

void MySQLParser::WindowNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowName(this);
}

void MySQLParser::WindowNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowName(this);
}

std::any MySQLParser::WindowNameContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitWindowName(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::WindowNameContext *MySQLParser::windowName() {
  WindowNameContext *_localctx = _tracker.createInstance<WindowNameContext>(_ctx, getState());
  enterRule(_localctx, 1342, MySQLParser::RuleWindowName);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8737);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PureIdentifierContext ------------------------------------------------------------------

MySQLParser::PureIdentifierContext::PureIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PureIdentifierContext::IDENTIFIER() {
  return getToken(MySQLParser::IDENTIFIER, 0);
}

tree::TerminalNode *MySQLParser::PureIdentifierContext::BACK_TICK_QUOTED_ID() {
  return getToken(MySQLParser::BACK_TICK_QUOTED_ID, 0);
}

tree::TerminalNode *MySQLParser::PureIdentifierContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}

size_t MySQLParser::PureIdentifierContext::getRuleIndex() const {
  return MySQLParser::RulePureIdentifier;
}

void MySQLParser::PureIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPureIdentifier(this);
}

void MySQLParser::PureIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPureIdentifier(this);
}

std::any MySQLParser::PureIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPureIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PureIdentifierContext *MySQLParser::pureIdentifier() {
  PureIdentifierContext *_localctx = _tracker.createInstance<PureIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1344, MySQLParser::RulePureIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8742);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1109, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8739);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::IDENTIFIER

              || _la == MySQLParser::BACK_TICK_QUOTED_ID)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8740);

        if (!(isSqlModeActive(AnsiQuotes)))
          throw FailedPredicateException(this, "isSqlModeActive(AnsiQuotes)");
        setState(8741);
        match(MySQLParser::DOUBLE_QUOTED_TEXT);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

MySQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext *MySQLParser::IdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::IdentifierKeywordContext *MySQLParser::IdentifierContext::identifierKeyword() {
  return getRuleContext<MySQLParser::IdentifierKeywordContext>(0);
}

size_t MySQLParser::IdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifier;
}

void MySQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void MySQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

std::any MySQLParser::IdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierContext *MySQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1346, MySQLParser::RuleIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8746);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1110, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8744);
        pureIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8745);
        identifierKeyword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

MySQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::IdentifierListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext *MySQLParser::IdentifierListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::IdentifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::IdentifierListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierList;
}

void MySQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void MySQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

std::any MySQLParser::IdentifierListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierListContext *MySQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 1348, MySQLParser::RuleIdentifierList);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8748);
    identifier();
    setState(8753);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1111, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8749);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8750);
        identifier();
      }
      setState(8755);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1111, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListWithParenthesesContext
//------------------------------------------------------------------

MySQLParser::IdentifierListWithParenthesesContext::IdentifierListWithParenthesesContext(ParserRuleContext *parent,
                                                                                        size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext *MySQLParser::IdentifierListWithParenthesesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode *MySQLParser::IdentifierListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::IdentifierListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierListWithParentheses;
}

void MySQLParser::IdentifierListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierListWithParentheses(this);
}

void MySQLParser::IdentifierListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierListWithParentheses(this);
}

std::any MySQLParser::IdentifierListWithParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierListWithParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierListWithParenthesesContext *MySQLParser::identifierListWithParentheses() {
  IdentifierListWithParenthesesContext *_localctx =
    _tracker.createInstance<IdentifierListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1350, MySQLParser::RuleIdentifierListWithParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8756);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8757);
    identifierList();
    setState(8758);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifierContext ------------------------------------------------------------------

MySQLParser::QualifiedIdentifierContext::QualifiedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::QualifiedIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::DotIdentifierContext *MySQLParser::QualifiedIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

size_t MySQLParser::QualifiedIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleQualifiedIdentifier;
}

void MySQLParser::QualifiedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifier(this);
}

void MySQLParser::QualifiedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifier(this);
}

std::any MySQLParser::QualifiedIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitQualifiedIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::QualifiedIdentifierContext *MySQLParser::qualifiedIdentifier() {
  QualifiedIdentifierContext *_localctx = _tracker.createInstance<QualifiedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1352, MySQLParser::RuleQualifiedIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8760);
    identifier();
    setState(8762);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1112, _ctx)) {
      case 1: {
        setState(8761);
        dotIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleIdentifierContext ------------------------------------------------------------------

MySQLParser::SimpleIdentifierContext::SimpleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::SimpleIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

std::vector<MySQLParser::DotIdentifierContext *> MySQLParser::SimpleIdentifierContext::dotIdentifier() {
  return getRuleContexts<MySQLParser::DotIdentifierContext>();
}

MySQLParser::DotIdentifierContext *MySQLParser::SimpleIdentifierContext::dotIdentifier(size_t i) {
  return getRuleContext<MySQLParser::DotIdentifierContext>(i);
}

size_t MySQLParser::SimpleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleIdentifier;
}

void MySQLParser::SimpleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleIdentifier(this);
}

void MySQLParser::SimpleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleIdentifier(this);
}

std::any MySQLParser::SimpleIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSimpleIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SimpleIdentifierContext *MySQLParser::simpleIdentifier() {
  SimpleIdentifierContext *_localctx = _tracker.createInstance<SimpleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1354, MySQLParser::RuleSimpleIdentifier);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8764);
    identifier();
    setState(8769);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DOT_SYMBOL) {
      setState(8765);
      dotIdentifier();
      setState(8767);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(8766);
        dotIdentifier();
      }
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DotIdentifierContext ------------------------------------------------------------------

MySQLParser::DotIdentifierContext::DotIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::DotIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::IdentifierContext *MySQLParser::DotIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

size_t MySQLParser::DotIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleDotIdentifier;
}

void MySQLParser::DotIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotIdentifier(this);
}

void MySQLParser::DotIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotIdentifier(this);
}

std::any MySQLParser::DotIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitDotIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::DotIdentifierContext *MySQLParser::dotIdentifier() {
  DotIdentifierContext *_localctx = _tracker.createInstance<DotIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1356, MySQLParser::RuleDotIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8771);
    match(MySQLParser::DOT_SYMBOL);
    setState(8772);
    identifier();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulong_numberContext ------------------------------------------------------------------

MySQLParser::Ulong_numberContext::Ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}

size_t MySQLParser::Ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlong_number;
}

void MySQLParser::Ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlong_number(this);
}

void MySQLParser::Ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlong_number(this);
}

std::any MySQLParser::Ulong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUlong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Ulong_numberContext *MySQLParser::ulong_number() {
  Ulong_numberContext *_localctx = _tracker.createInstance<Ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1358, MySQLParser::RuleUlong_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8774);
    _la = _input->LA(1);
    if (!(((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 28587302322183) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulong_numberContext::Real_ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Real_ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

size_t MySQLParser::Real_ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulong_number;
}

void MySQLParser::Real_ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulong_number(this);
}

void MySQLParser::Real_ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulong_number(this);
}

std::any MySQLParser::Real_ulong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReal_ulong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Real_ulong_numberContext *MySQLParser::real_ulong_number() {
  Real_ulong_numberContext *_localctx = _tracker.createInstance<Real_ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1360, MySQLParser::RuleReal_ulong_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8776);
    _la = _input->LA(1);
    if (!(((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 2199023255559) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Ulonglong_numberContext::Ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulonglong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Ulonglong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}

size_t MySQLParser::Ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlonglong_number;
}

void MySQLParser::Ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlonglong_number(this);
}

void MySQLParser::Ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlonglong_number(this);
}

std::any MySQLParser::Ulonglong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitUlonglong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Ulonglong_numberContext *MySQLParser::ulonglong_number() {
  Ulonglong_numberContext *_localctx = _tracker.createInstance<Ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1362, MySQLParser::RuleUlonglong_number);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8778);
    _la = _input->LA(1);
    if (!(((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 26388279066631) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulonglong_numberContext::Real_ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Real_ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulonglong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Real_ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

size_t MySQLParser::Real_ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulonglong_number;
}

void MySQLParser::Real_ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulonglong_number(this);
}

void MySQLParser::Real_ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulonglong_number(this);
}

std::any MySQLParser::Real_ulonglong_numberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitReal_ulonglong_number(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::real_ulonglong_number() {
  Real_ulonglong_numberContext *_localctx = _tracker.createInstance<Real_ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1364, MySQLParser::RuleReal_ulonglong_number);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8785);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1115, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8780);
        match(MySQLParser::INT_NUMBER);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8781);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(8782);
        match(MySQLParser::HEX_NUMBER);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8783);
        match(MySQLParser::ULONGLONG_NUMBER);
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(8784);
        match(MySQLParser::LONG_NUMBER);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignedLiteralContext ------------------------------------------------------------------

MySQLParser::SignedLiteralContext::SignedLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext *MySQLParser::SignedLiteralContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

tree::TerminalNode *MySQLParser::SignedLiteralContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::Ulong_numberContext *MySQLParser::SignedLiteralContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode *MySQLParser::SignedLiteralContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

size_t MySQLParser::SignedLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleSignedLiteral;
}

void MySQLParser::SignedLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignedLiteral(this);
}

void MySQLParser::SignedLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignedLiteral(this);
}

std::any MySQLParser::SignedLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignedLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignedLiteralContext *MySQLParser::signedLiteral() {
  SignedLiteralContext *_localctx = _tracker.createInstance<SignedLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1366, MySQLParser::RuleSignedLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8792);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1116, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8787);
        literal();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8788);
        match(MySQLParser::PLUS_OPERATOR);
        setState(8789);
        ulong_number();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8790);
        match(MySQLParser::MINUS_OPERATOR);
        setState(8791);
        ulong_number();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignedLiteralOrNullContext ------------------------------------------------------------------

MySQLParser::SignedLiteralOrNullContext::SignedLiteralOrNullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SignedLiteralContext *MySQLParser::SignedLiteralOrNullContext::signedLiteral() {
  return getRuleContext<MySQLParser::SignedLiteralContext>(0);
}

MySQLParser::NullAsLiteralContext *MySQLParser::SignedLiteralOrNullContext::nullAsLiteral() {
  return getRuleContext<MySQLParser::NullAsLiteralContext>(0);
}

size_t MySQLParser::SignedLiteralOrNullContext::getRuleIndex() const {
  return MySQLParser::RuleSignedLiteralOrNull;
}

void MySQLParser::SignedLiteralOrNullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignedLiteralOrNull(this);
}

void MySQLParser::SignedLiteralOrNullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignedLiteralOrNull(this);
}

std::any MySQLParser::SignedLiteralOrNullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSignedLiteralOrNull(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SignedLiteralOrNullContext *MySQLParser::signedLiteralOrNull() {
  SignedLiteralOrNullContext *_localctx = _tracker.createInstance<SignedLiteralOrNullContext>(_ctx, getState());
  enterRule(_localctx, 1368, MySQLParser::RuleSignedLiteralOrNull);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8797);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1117, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8794);
        signedLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8795);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8796);
        nullAsLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

MySQLParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext *MySQLParser::LiteralContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::NumLiteralContext *MySQLParser::LiteralContext::numLiteral() {
  return getRuleContext<MySQLParser::NumLiteralContext>(0);
}

MySQLParser::TemporalLiteralContext *MySQLParser::LiteralContext::temporalLiteral() {
  return getRuleContext<MySQLParser::TemporalLiteralContext>(0);
}

MySQLParser::NullLiteralContext *MySQLParser::LiteralContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

MySQLParser::BoolLiteralContext *MySQLParser::LiteralContext::boolLiteral() {
  return getRuleContext<MySQLParser::BoolLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::LiteralContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::LiteralContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::LiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}

size_t MySQLParser::LiteralContext::getRuleIndex() const {
  return MySQLParser::RuleLiteral;
}

void MySQLParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void MySQLParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

std::any MySQLParser::LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LiteralContext *MySQLParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 1370, MySQLParser::RuleLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8808);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1119, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8799);
        textLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8800);
        numLiteral();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8801);
        temporalLiteral();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(8802);
        nullLiteral();
        break;
      }

      case 5: {
        enterOuterAlt(_localctx, 5);
        setState(8803);
        boolLiteral();
        break;
      }

      case 6: {
        enterOuterAlt(_localctx, 6);
        setState(8805);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::UNDERSCORE_CHARSET) {
          setState(8804);
          match(MySQLParser::UNDERSCORE_CHARSET);
        }
        setState(8807);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::HEX_NUMBER

              || _la == MySQLParser::BIN_NUMBER)) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralOrNullContext ------------------------------------------------------------------

MySQLParser::LiteralOrNullContext::LiteralOrNullContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext *MySQLParser::LiteralOrNullContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::NullAsLiteralContext *MySQLParser::LiteralOrNullContext::nullAsLiteral() {
  return getRuleContext<MySQLParser::NullAsLiteralContext>(0);
}

size_t MySQLParser::LiteralOrNullContext::getRuleIndex() const {
  return MySQLParser::RuleLiteralOrNull;
}

void MySQLParser::LiteralOrNullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteralOrNull(this);
}

void MySQLParser::LiteralOrNullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteralOrNull(this);
}

std::any MySQLParser::LiteralOrNullContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLiteralOrNull(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LiteralOrNullContext *MySQLParser::literalOrNull() {
  LiteralOrNullContext *_localctx = _tracker.createInstance<LiteralOrNullContext>(_ctx, getState());
  enterRule(_localctx, 1372, MySQLParser::RuleLiteralOrNull);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8813);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1120, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8810);
        literal();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8811);

        if (!(serverVersion >= 80024))
          throw FailedPredicateException(this, "serverVersion >= 80024");
        setState(8812);
        nullAsLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullAsLiteralContext ------------------------------------------------------------------

MySQLParser::NullAsLiteralContext::NullAsLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NullAsLiteralContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

size_t MySQLParser::NullAsLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNullAsLiteral;
}

void MySQLParser::NullAsLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullAsLiteral(this);
}

void MySQLParser::NullAsLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullAsLiteral(this);
}

std::any MySQLParser::NullAsLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNullAsLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NullAsLiteralContext *MySQLParser::nullAsLiteral() {
  NullAsLiteralContext *_localctx = _tracker.createInstance<NullAsLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1374, MySQLParser::RuleNullAsLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8815);
    match(MySQLParser::NULL_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringListContext ------------------------------------------------------------------

MySQLParser::StringListContext::StringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::StringListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::StringListContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext *MySQLParser::StringListContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode *MySQLParser::StringListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::StringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::StringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::StringListContext::getRuleIndex() const {
  return MySQLParser::RuleStringList;
}

void MySQLParser::StringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringList(this);
}

void MySQLParser::StringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringList(this);
}

std::any MySQLParser::StringListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStringList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StringListContext *MySQLParser::stringList() {
  StringListContext *_localctx = _tracker.createInstance<StringListContext>(_ctx, getState());
  enterRule(_localctx, 1376, MySQLParser::RuleStringList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8817);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8818);
    textString();
    setState(8823);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8819);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8820);
      textString();
      setState(8825);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8826);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralContext::TextStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TextStringLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode *MySQLParser::TextStringLiteralContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}

size_t MySQLParser::TextStringLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteral;
}

void MySQLParser::TextStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteral(this);
}

void MySQLParser::TextStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteral(this);
}

std::any MySQLParser::TextStringLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextStringLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringLiteralContext *MySQLParser::textStringLiteral() {
  TextStringLiteralContext *_localctx = _tracker.createInstance<TextStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1378, MySQLParser::RuleTextStringLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8831);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1122, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8828);
        antlrcpp::downCast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8829);

        if (!(!isSqlModeActive(AnsiQuotes)))
          throw FailedPredicateException(this, "!isSqlModeActive(AnsiQuotes)");
        setState(8830);
        antlrcpp::downCast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::DOUBLE_QUOTED_TEXT);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringContext ------------------------------------------------------------------

MySQLParser::TextStringContext::TextStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextStringContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::TextStringContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::TextStringContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}

size_t MySQLParser::TextStringContext::getRuleIndex() const {
  return MySQLParser::RuleTextString;
}

void MySQLParser::TextStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextString(this);
}

void MySQLParser::TextStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextString(this);
}

std::any MySQLParser::TextStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextString(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringContext *MySQLParser::textString() {
  TextStringContext *_localctx = _tracker.createInstance<TextStringContext>(_ctx, getState());
  enterRule(_localctx, 1380, MySQLParser::RuleTextString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8836);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1123, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8833);
        textStringLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8834);
        match(MySQLParser::HEX_NUMBER);
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8835);
        match(MySQLParser::BIN_NUMBER);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringHashContext ------------------------------------------------------------------

MySQLParser::TextStringHashContext::TextStringHashContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextStringHashContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode *MySQLParser::TextStringHashContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

size_t MySQLParser::TextStringHashContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringHash;
}

void MySQLParser::TextStringHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringHash(this);
}

void MySQLParser::TextStringHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringHash(this);
}

std::any MySQLParser::TextStringHashContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextStringHash(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringHashContext *MySQLParser::textStringHash() {
  TextStringHashContext *_localctx = _tracker.createInstance<TextStringHashContext>(_ctx, getState());
  enterRule(_localctx, 1382, MySQLParser::RuleTextStringHash);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8841);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1124, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8838);
        textStringLiteral();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8839);

        if (!(serverVersion >= 80017))
          throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(8840);
        match(MySQLParser::HEX_NUMBER);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextLiteralContext ------------------------------------------------------------------

MySQLParser::TextLiteralContext::TextLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextLiteralContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextLiteralContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

tree::TerminalNode *MySQLParser::TextLiteralContext::NCHAR_TEXT() {
  return getToken(MySQLParser::NCHAR_TEXT, 0);
}

tree::TerminalNode *MySQLParser::TextLiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}

size_t MySQLParser::TextLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextLiteral;
}

void MySQLParser::TextLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextLiteral(this);
}

void MySQLParser::TextLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextLiteral(this);
}

std::any MySQLParser::TextLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextLiteralContext *MySQLParser::textLiteral() {
  TextLiteralContext *_localctx = _tracker.createInstance<TextLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1384, MySQLParser::RuleTextLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8848);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1126, _ctx)) {
      case 1: {
        setState(8844);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1125, _ctx)) {
          case 1: {
            setState(8843);
            match(MySQLParser::UNDERSCORE_CHARSET);
            break;
          }

          default:
            break;
        }
        setState(8846);
        textStringLiteral();
        break;
      }

      case 2: {
        setState(8847);
        match(MySQLParser::NCHAR_TEXT);
        break;
      }

      default:
        break;
    }
    setState(8853);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1127, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8850);
        textStringLiteral();
      }
      setState(8855);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1127, _ctx);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringNoLinebreakContext ------------------------------------------------------------------

MySQLParser::TextStringNoLinebreakContext::TextStringNoLinebreakContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextStringNoLinebreakContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::TextStringNoLinebreakContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringNoLinebreak;
}

void MySQLParser::TextStringNoLinebreakContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringNoLinebreak(this);
}

void MySQLParser::TextStringNoLinebreakContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringNoLinebreak(this);
}

std::any MySQLParser::TextStringNoLinebreakContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextStringNoLinebreak(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringNoLinebreakContext *MySQLParser::textStringNoLinebreak() {
  TextStringNoLinebreakContext *_localctx = _tracker.createInstance<TextStringNoLinebreakContext>(_ctx, getState());
  enterRule(_localctx, 1386, MySQLParser::RuleTextStringNoLinebreak);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8856);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralListContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralListContext::TextStringLiteralListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextStringLiteralListContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextStringLiteralListContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode *MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

size_t MySQLParser::TextStringLiteralListContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteralList;
}

void MySQLParser::TextStringLiteralListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteralList(this);
}

void MySQLParser::TextStringLiteralListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteralList(this);
}

std::any MySQLParser::TextStringLiteralListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextStringLiteralList(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextStringLiteralListContext *MySQLParser::textStringLiteralList() {
  TextStringLiteralListContext *_localctx = _tracker.createInstance<TextStringLiteralListContext>(_ctx, getState());
  enterRule(_localctx, 1388, MySQLParser::RuleTextStringLiteralList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8858);
    textStringLiteral();
    setState(8863);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8859);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8860);
      textStringLiteral();
      setState(8865);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumLiteralContext ------------------------------------------------------------------

MySQLParser::NumLiteralContext::NumLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Int64LiteralContext *MySQLParser::NumLiteralContext::int64Literal() {
  return getRuleContext<MySQLParser::Int64LiteralContext>(0);
}

tree::TerminalNode *MySQLParser::NumLiteralContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::NumLiteralContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}

size_t MySQLParser::NumLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNumLiteral;
}

void MySQLParser::NumLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumLiteral(this);
}

void MySQLParser::NumLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumLiteral(this);
}

std::any MySQLParser::NumLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNumLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NumLiteralContext *MySQLParser::numLiteral() {
  NumLiteralContext *_localctx = _tracker.createInstance<NumLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1390, MySQLParser::RuleNumLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8869);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(8866);
        int64Literal();
        break;
      }

      case MySQLParser::DECIMAL_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(8867);
        match(MySQLParser::DECIMAL_NUMBER);
        break;
      }

      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 3);
        setState(8868);
        match(MySQLParser::FLOAT_NUMBER);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoolLiteralContext ------------------------------------------------------------------

MySQLParser::BoolLiteralContext::BoolLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::BoolLiteralContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::BoolLiteralContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}

size_t MySQLParser::BoolLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleBoolLiteral;
}

void MySQLParser::BoolLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolLiteral(this);
}

void MySQLParser::BoolLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolLiteral(this);
}

std::any MySQLParser::BoolLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitBoolLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::BoolLiteralContext *MySQLParser::boolLiteral() {
  BoolLiteralContext *_localctx = _tracker.createInstance<BoolLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1392, MySQLParser::RuleBoolLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8871);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullLiteralContext ------------------------------------------------------------------

MySQLParser::NullLiteralContext::NullLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::NullLiteralContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::NullLiteralContext::NULL2_SYMBOL() {
  return getToken(MySQLParser::NULL2_SYMBOL, 0);
}

size_t MySQLParser::NullLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNullLiteral;
}

void MySQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}

void MySQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}

std::any MySQLParser::NullLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitNullLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::NullLiteralContext *MySQLParser::nullLiteral() {
  NullLiteralContext *_localctx = _tracker.createInstance<NullLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1394, MySQLParser::RuleNullLiteral);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8873);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NULL_SYMBOL || _la == MySQLParser::NULL2_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Int64LiteralContext ------------------------------------------------------------------

MySQLParser::Int64LiteralContext::Int64LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::Int64LiteralContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Int64LiteralContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode *MySQLParser::Int64LiteralContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

size_t MySQLParser::Int64LiteralContext::getRuleIndex() const {
  return MySQLParser::RuleInt64Literal;
}

void MySQLParser::Int64LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInt64Literal(this);
}

void MySQLParser::Int64LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInt64Literal(this);
}

std::any MySQLParser::Int64LiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitInt64Literal(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::Int64LiteralContext *MySQLParser::int64Literal() {
  Int64LiteralContext *_localctx = _tracker.createInstance<Int64LiteralContext>(_ctx, getState());
  enterRule(_localctx, 1396, MySQLParser::RuleInt64Literal);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8875);
    _la = _input->LA(1);
    if (!(((((_la - 747) & ~0x3fULL) == 0) && ((1ULL << (_la - 747)) & 7) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralContext ------------------------------------------------------------------

MySQLParser::TemporalLiteralContext::TemporalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::TemporalLiteralContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TemporalLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode *MySQLParser::TemporalLiteralContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::TemporalLiteralContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

size_t MySQLParser::TemporalLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTemporalLiteral;
}

void MySQLParser::TemporalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiteral(this);
}

void MySQLParser::TemporalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiteral(this);
}

std::any MySQLParser::TemporalLiteralContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTemporalLiteral(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TemporalLiteralContext *MySQLParser::temporalLiteral() {
  TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1398, MySQLParser::RuleTemporalLiteral);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8883);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8877);
        match(MySQLParser::DATE_SYMBOL);
        setState(8878);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIME_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8879);
        match(MySQLParser::TIME_SYMBOL);
        setState(8880);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIMESTAMP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8881);
        match(MySQLParser::TIMESTAMP_SYMBOL);
        setState(8882);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FloatOptionsContext ------------------------------------------------------------------

MySQLParser::FloatOptionsContext::FloatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldLengthContext *MySQLParser::FloatOptionsContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::PrecisionContext *MySQLParser::FloatOptionsContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}

size_t MySQLParser::FloatOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFloatOptions;
}

void MySQLParser::FloatOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatOptions(this);
}

void MySQLParser::FloatOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatOptions(this);
}

std::any MySQLParser::FloatOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitFloatOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::FloatOptionsContext *MySQLParser::floatOptions() {
  FloatOptionsContext *_localctx = _tracker.createInstance<FloatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1400, MySQLParser::RuleFloatOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8887);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1131, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8885);
        fieldLength();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8886);
        precision();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandardFloatOptionsContext ------------------------------------------------------------------

MySQLParser::StandardFloatOptionsContext::StandardFloatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PrecisionContext *MySQLParser::StandardFloatOptionsContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}

size_t MySQLParser::StandardFloatOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleStandardFloatOptions;
}

void MySQLParser::StandardFloatOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandardFloatOptions(this);
}

void MySQLParser::StandardFloatOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandardFloatOptions(this);
}

std::any MySQLParser::StandardFloatOptionsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitStandardFloatOptions(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::StandardFloatOptionsContext *MySQLParser::standardFloatOptions() {
  StandardFloatOptionsContext *_localctx = _tracker.createInstance<StandardFloatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1402, MySQLParser::RuleStandardFloatOptions);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8889);
    precision();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrecisionContext ------------------------------------------------------------------

MySQLParser::PrecisionContext::PrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::PrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PrecisionContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode *MySQLParser::PrecisionContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode *MySQLParser::PrecisionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::PrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::PrecisionContext::getRuleIndex() const {
  return MySQLParser::RulePrecision;
}

void MySQLParser::PrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecision(this);
}

void MySQLParser::PrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecision(this);
}

std::any MySQLParser::PrecisionContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitPrecision(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::PrecisionContext *MySQLParser::precision() {
  PrecisionContext *_localctx = _tracker.createInstance<PrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1404, MySQLParser::RulePrecision);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8891);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8892);
    match(MySQLParser::INT_NUMBER);
    setState(8893);
    match(MySQLParser::COMMA_SYMBOL);
    setState(8894);
    match(MySQLParser::INT_NUMBER);
    setState(8895);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextOrIdentifierContext ------------------------------------------------------------------

MySQLParser::TextOrIdentifierContext::TextOrIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext *MySQLParser::TextOrIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::TextOrIdentifierContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::TextOrIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleTextOrIdentifier;
}

void MySQLParser::TextOrIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextOrIdentifier(this);
}

void MySQLParser::TextOrIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextOrIdentifier(this);
}

std::any MySQLParser::TextOrIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitTextOrIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::TextOrIdentifierContext *MySQLParser::textOrIdentifier() {
  TextOrIdentifierContext *_localctx = _tracker.createInstance<TextOrIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1406, MySQLParser::RuleTextOrIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8899);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1132, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8897);
        identifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8898);
        textStringLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LValueIdentifierContext ------------------------------------------------------------------

MySQLParser::LValueIdentifierContext::LValueIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext *MySQLParser::LValueIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::LValueKeywordContext *MySQLParser::LValueIdentifierContext::lValueKeyword() {
  return getRuleContext<MySQLParser::LValueKeywordContext>(0);
}

size_t MySQLParser::LValueIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleLValueIdentifier;
}

void MySQLParser::LValueIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLValueIdentifier(this);
}

void MySQLParser::LValueIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLValueIdentifier(this);
}

std::any MySQLParser::LValueIdentifierContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLValueIdentifier(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LValueIdentifierContext *MySQLParser::lValueIdentifier() {
  LValueIdentifierContext *_localctx = _tracker.createInstance<LValueIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1408, MySQLParser::RuleLValueIdentifier);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8903);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1133, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8901);
        pureIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8902);
        lValueKeyword();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierOrTextContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierOrTextContext::RoleIdentifierOrTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierContext *MySQLParser::RoleIdentifierOrTextContext::roleIdentifier() {
  return getRuleContext<MySQLParser::RoleIdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext *MySQLParser::RoleIdentifierOrTextContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::RoleIdentifierOrTextContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifierOrText;
}

void MySQLParser::RoleIdentifierOrTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifierOrText(this);
}

void MySQLParser::RoleIdentifierOrTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifierOrText(this);
}

std::any MySQLParser::RoleIdentifierOrTextContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleIdentifierOrText(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleIdentifierOrTextContext *MySQLParser::roleIdentifierOrText() {
  RoleIdentifierOrTextContext *_localctx = _tracker.createInstance<RoleIdentifierOrTextContext>(_ctx, getState());
  enterRule(_localctx, 1410, MySQLParser::RuleRoleIdentifierOrText);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8907);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1134, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8905);
        roleIdentifier();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8906);
        textStringLiteral();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeNumberContext ------------------------------------------------------------------

MySQLParser::SizeNumberContext::SizeNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulonglong_numberContext *MySQLParser::SizeNumberContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::PureIdentifierContext *MySQLParser::SizeNumberContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

size_t MySQLParser::SizeNumberContext::getRuleIndex() const {
  return MySQLParser::RuleSizeNumber;
}

void MySQLParser::SizeNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeNumber(this);
}

void MySQLParser::SizeNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeNumber(this);
}

std::any MySQLParser::SizeNumberContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSizeNumber(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SizeNumberContext *MySQLParser::sizeNumber() {
  SizeNumberContext *_localctx = _tracker.createInstance<SizeNumberContext>(_ctx, getState());
  enterRule(_localctx, 1412, MySQLParser::RuleSizeNumber);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1135, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8909);
        real_ulonglong_number();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8910);
        pureIdentifier();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesesContext ------------------------------------------------------------------

MySQLParser::ParenthesesContext::ParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::ParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::ParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

size_t MySQLParser::ParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleParentheses;
}

void MySQLParser::ParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParentheses(this);
}

void MySQLParser::ParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParentheses(this);
}

std::any MySQLParser::ParenthesesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitParentheses(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::ParenthesesContext *MySQLParser::parentheses() {
  ParenthesesContext *_localctx = _tracker.createInstance<ParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1414, MySQLParser::RuleParentheses);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8913);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8914);
    match(MySQLParser::CLOSE_PAR_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualContext ------------------------------------------------------------------

MySQLParser::EqualContext::EqualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::EqualContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode *MySQLParser::EqualContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}

size_t MySQLParser::EqualContext::getRuleIndex() const {
  return MySQLParser::RuleEqual;
}

void MySQLParser::EqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqual(this);
}

void MySQLParser::EqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqual(this);
}

std::any MySQLParser::EqualContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitEqual(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::EqualContext *MySQLParser::equal() {
  EqualContext *_localctx = _tracker.createInstance<EqualContext>(_ctx, getState());
  enterRule(_localctx, 1416, MySQLParser::RuleEqual);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8916);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EQUAL_OPERATOR

          || _la == MySQLParser::ASSIGN_OPERATOR)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionTypeContext::OptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::OptionTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OptionTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OptionTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OptionTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::OptionTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

size_t MySQLParser::OptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionType;
}

void MySQLParser::OptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionType(this);
}

void MySQLParser::OptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionType(this);
}

std::any MySQLParser::OptionTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitOptionType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::OptionTypeContext *MySQLParser::optionType() {
  OptionTypeContext *_localctx = _tracker.createInstance<OptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 1418, MySQLParser::RuleOptionType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8918);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL ||
          _la == MySQLParser::PERSIST_SYMBOL

          || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RvalueSystemVariableTypeContext ------------------------------------------------------------------

MySQLParser::RvalueSystemVariableTypeContext::RvalueSystemVariableTypeContext(ParserRuleContext *parent,
                                                                              size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RvalueSystemVariableTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RvalueSystemVariableTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RvalueSystemVariableTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RvalueSystemVariableTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

size_t MySQLParser::RvalueSystemVariableTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRvalueSystemVariableType;
}

void MySQLParser::RvalueSystemVariableTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRvalueSystemVariableType(this);
}

void MySQLParser::RvalueSystemVariableTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRvalueSystemVariableType(this);
}

std::any MySQLParser::RvalueSystemVariableTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRvalueSystemVariableType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RvalueSystemVariableTypeContext *MySQLParser::rvalueSystemVariableType() {
  RvalueSystemVariableTypeContext *_localctx =
    _tracker.createInstance<RvalueSystemVariableTypeContext>(_ctx, getState());
  enterRule(_localctx, 1420, MySQLParser::RuleRvalueSystemVariableType);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8926);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GLOBAL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8920);
        match(MySQLParser::GLOBAL_SYMBOL);
        setState(8921);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::LOCAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8922);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(8923);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::SESSION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8924);
        match(MySQLParser::SESSION_SYMBOL);
        setState(8925);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      default:
        throw NoViableAltException(this);
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetVarIdentTypeContext ------------------------------------------------------------------

MySQLParser::SetVarIdentTypeContext::SetVarIdentTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::SetVarIdentTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

size_t MySQLParser::SetVarIdentTypeContext::getRuleIndex() const {
  return MySQLParser::RuleSetVarIdentType;
}

void MySQLParser::SetVarIdentTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetVarIdentType(this);
}

void MySQLParser::SetVarIdentTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetVarIdentType(this);
}

std::any MySQLParser::SetVarIdentTypeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitSetVarIdentType(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::SetVarIdentTypeContext *MySQLParser::setVarIdentType() {
  SetVarIdentTypeContext *_localctx = _tracker.createInstance<SetVarIdentTypeContext>(_ctx, getState());
  enterRule(_localctx, 1422, MySQLParser::RuleSetVarIdentType);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8928);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL ||
          _la == MySQLParser::PERSIST_SYMBOL

          || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(8929);
    match(MySQLParser::DOT_SYMBOL);

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonAttributeContext ------------------------------------------------------------------

MySQLParser::JsonAttributeContext::JsonAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext *MySQLParser::JsonAttributeContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

size_t MySQLParser::JsonAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleJsonAttribute;
}

void MySQLParser::JsonAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonAttribute(this);
}

void MySQLParser::JsonAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonAttribute(this);
}

std::any MySQLParser::JsonAttributeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitJsonAttribute(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::JsonAttributeContext *MySQLParser::jsonAttribute() {
  JsonAttributeContext *_localctx = _tracker.createInstance<JsonAttributeContext>(_ctx, getState());
  enterRule(_localctx, 1424, MySQLParser::RuleJsonAttribute);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8931);
    textStringLiteral();

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordContext::IdentifierKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelKeywordContext *MySQLParser::IdentifierKeywordContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext *MySQLParser::IdentifierKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext *
MySQLParser::IdentifierKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext *
MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous1RolesAndLabels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext *
MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext *
MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext *
MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}

size_t MySQLParser::IdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeyword;
}

void MySQLParser::IdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeyword(this);
}

void MySQLParser::IdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeyword(this);
}

std::any MySQLParser::IdentifierKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordContext *MySQLParser::identifierKeyword() {
  IdentifierKeywordContext *_localctx = _tracker.createInstance<IdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1426, MySQLParser::RuleIdentifierKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8949);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1139, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8933);

        if (!(serverVersion < 80017))
          throw FailedPredicateException(this, "serverVersion < 80017");
        setState(8940);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1137, _ctx)) {
          case 1: {
            setState(8934);
            labelKeyword();
            break;
          }

          case 2: {
            setState(8935);
            roleOrIdentifierKeyword();
            break;
          }

          case 3: {
            setState(8936);
            match(MySQLParser::EXECUTE_SYMBOL);
            break;
          }

          case 4: {
            setState(8937);
            match(MySQLParser::SHUTDOWN_SYMBOL);
            break;
          }

          case 5: {
            setState(8938);

            if (!(serverVersion >= 80011))
              throw FailedPredicateException(this, "serverVersion >= 80011");
            setState(8939);
            match(MySQLParser::RESTART_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8947);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1138, _ctx)) {
          case 1: {
            setState(8942);
            identifierKeywordsUnambiguous();
            break;
          }

          case 2: {
            setState(8943);
            identifierKeywordsAmbiguous1RolesAndLabels();
            break;
          }

          case 3: {
            setState(8944);
            identifierKeywordsAmbiguous2Labels();
            break;
          }

          case 4: {
            setState(8945);
            identifierKeywordsAmbiguous3Roles();
            break;
          }

          case 5: {
            setState(8946);
            identifierKeywordsAmbiguous4SystemVariables();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous1RolesAndLabelsContext
//------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::IdentifierKeywordsAmbiguous1RolesAndLabelsContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

size_t MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous1RolesAndLabels;
}

void MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous1RolesAndLabels(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous1RolesAndLabels(this);
}

std::any MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeywordsAmbiguous1RolesAndLabels(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext *
MySQLParser::identifierKeywordsAmbiguous1RolesAndLabels() {
  IdentifierKeywordsAmbiguous1RolesAndLabelsContext *_localctx =
    _tracker.createInstance<IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(_ctx, getState());
  enterRule(_localctx, 1428, MySQLParser::RuleIdentifierKeywordsAmbiguous1RolesAndLabels);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8951);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EXECUTE_SYMBOL || _la == MySQLParser::SHUTDOWN_SYMBOL ||
          _la == MySQLParser::RESTART_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous2LabelsContext
//------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::IdentifierKeywordsAmbiguous2LabelsContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

size_t MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous2Labels;
}

void MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous2Labels(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous2Labels(this);
}

std::any MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeywordsAmbiguous2Labels(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext *MySQLParser::identifierKeywordsAmbiguous2Labels() {
  IdentifierKeywordsAmbiguous2LabelsContext *_localctx =
    _tracker.createInstance<IdentifierKeywordsAmbiguous2LabelsContext>(_ctx, getState());
  enterRule(_localctx, 1430, MySQLParser::RuleIdentifierKeywordsAmbiguous2Labels);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8953);
    _la = _input->LA(1);
    if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2594284492135333888) != 0) ||
          ((((_la - 75) & ~0x3fULL) == 0) && ((1ULL << (_la - 75)) & 281474976743429) != 0) ||
          ((((_la - 147) & ~0x3fULL) == 0) && ((1ULL << (_la - 147)) & 1688849860268033) != 0) ||
          ((((_la - 219) & ~0x3fULL) == 0) && ((1ULL << (_la - 219)) & 281475043852297) != 0) ||
          ((((_la - 373) & ~0x3fULL) == 0) && ((1ULL << (_la - 373)) & 21990232555521) != 0) ||
          ((((_la - 455) & ~0x3fULL) == 0) && ((1ULL << (_la - 455)) & 720575957592711169) != 0) ||
          ((((_la - 543) & ~0x3fULL) == 0) && ((1ULL << (_la - 543)) & -9205357638345293311) != 0) ||
          _la == MySQLParser::UNINSTALL_SYMBOL

          || _la == MySQLParser::XA_SYMBOL || _la == MySQLParser::CLONE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelKeywordContext ------------------------------------------------------------------

MySQLParser::LabelKeywordContext::LabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext *MySQLParser::LabelKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::LabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext *MySQLParser::LabelKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext *
MySQLParser::LabelKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext *
MySQLParser::LabelKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}

size_t MySQLParser::LabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleLabelKeyword;
}

void MySQLParser::LabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelKeyword(this);
}

void MySQLParser::LabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelKeyword(this);
}

std::any MySQLParser::LabelKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLabelKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LabelKeywordContext *MySQLParser::labelKeyword() {
  LabelKeywordContext *_localctx = _tracker.createInstance<LabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1432, MySQLParser::RuleLabelKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8973);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1142, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8955);

        if (!(serverVersion < 80017))
          throw FailedPredicateException(this, "serverVersion < 80017");
        setState(8966);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1140, _ctx)) {
          case 1: {
            setState(8956);
            roleOrLabelKeyword();
            break;
          }

          case 2: {
            setState(8957);
            match(MySQLParser::EVENT_SYMBOL);
            break;
          }

          case 3: {
            setState(8958);
            match(MySQLParser::FILE_SYMBOL);
            break;
          }

          case 4: {
            setState(8959);
            match(MySQLParser::NONE_SYMBOL);
            break;
          }

          case 5: {
            setState(8960);
            match(MySQLParser::PROCESS_SYMBOL);
            break;
          }

          case 6: {
            setState(8961);
            match(MySQLParser::PROXY_SYMBOL);
            break;
          }

          case 7: {
            setState(8962);
            match(MySQLParser::RELOAD_SYMBOL);
            break;
          }

          case 8: {
            setState(8963);
            match(MySQLParser::REPLICATION_SYMBOL);
            break;
          }

          case 9: {
            setState(8964);
            match(MySQLParser::RESOURCE_SYMBOL);
            break;
          }

          case 10: {
            setState(8965);
            match(MySQLParser::SUPER_SYMBOL);
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8971);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1141, _ctx)) {
          case 1: {
            setState(8968);
            identifierKeywordsUnambiguous();
            break;
          }

          case 2: {
            setState(8969);
            identifierKeywordsAmbiguous3Roles();
            break;
          }

          case 3: {
            setState(8970);
            identifierKeywordsAmbiguous4SystemVariables();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous3RolesContext
//------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::IdentifierKeywordsAmbiguous3RolesContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

size_t MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous3Roles;
}

void MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous3Roles(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous3Roles(this);
}

std::any MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeywordsAmbiguous3Roles(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext *MySQLParser::identifierKeywordsAmbiguous3Roles() {
  IdentifierKeywordsAmbiguous3RolesContext *_localctx =
    _tracker.createInstance<IdentifierKeywordsAmbiguous3RolesContext>(_ctx, getState());
  enterRule(_localctx, 1434, MySQLParser::RuleIdentifierKeywordsAmbiguous3Roles);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8975);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EVENT_SYMBOL

          || _la == MySQLParser::FILE_SYMBOL ||
          ((((_la - 369) & ~0x3fULL) == 0) && ((1ULL << (_la - 369)) & 306244774661193729) != 0) ||
          _la == MySQLParser::RELOAD_SYMBOL

          || _la == MySQLParser::REPLICATION_SYMBOL || _la == MySQLParser::SUPER_SYMBOL ||
          _la == MySQLParser::RESOURCE_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsUnambiguousContext
//------------------------------------------------------------------

MySQLParser::IdentifierKeywordsUnambiguousContext::IdentifierKeywordsUnambiguousContext(ParserRuleContext *parent,
                                                                                        size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ATTRIBUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AUTHENTICATION_SYMBOL() {
  return getToken(MySQLParser::AUTHENTICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CHALLENGE_RESPONSE_SYMBOL() {
  return getToken(MySQLParser::CHALLENGE_RESPONSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DEFINITION_SYMBOL() {
  return getToken(MySQLParser::DEFINITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENFORCED_SYMBOL() {
  return getToken(MySQLParser::ENFORCED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FACTOR_SYMBOL() {
  return getToken(MySQLParser::FACTOR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FINISH_SYMBOL() {
  return getToken(MySQLParser::FINISH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GET_MASTER_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GET_SOURCE_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_SOURCE_PUBLIC_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::GTID_ONLY_SYMBOL() {
  return getToken(MySQLParser::GTID_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INITIAL_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INITIATE_SYMBOL() {
  return getToken(MySQLParser::INITIATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::JSON_VALUE_SYMBOL() {
  return getToken(MySQLParser::JSON_VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::KEYRING_SYMBOL() {
  return getToken(MySQLParser::KEYRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LOCKS_SYMBOL() {
  return getToken(MySQLParser::LOCKS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_COMPRESSION_ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::MASTER_COMPRESSION_ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NETWORK_NAMESPACE_SYMBOL() {
  return getToken(MySQLParser::NETWORK_NAMESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_TLS_CIPHERSUITES_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_CIPHERSUITES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() {
  return getToken(MySQLParser::MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NDBCLUSTER_SYMBOL() {
  return getToken(MySQLParser::NDBCLUSTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NEW_SYMBOL() {
  return getToken(MySQLParser::NEW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OJ_SYMBOL() {
  return getToken(MySQLParser::OJ_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PRIVILEGE_CHECKS_USER_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGE_CHECKS_USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REGISTRATION_SYMBOL() {
  return getToken(MySQLParser::REGISTRATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL() {
  return getToken(MySQLParser::ASSIGN_GTIDS_TO_ANONYMOUS_TRANSACTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICAS_SYMBOL() {
  return getToken(MySQLParser::REPLICAS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICA_SYMBOL() {
  return getToken(MySQLParser::REPLICA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RESTORE_SYMBOL() {
  return getToken(MySQLParser::RESTORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RETURNING_SYMBOL() {
  return getToken(MySQLParser::RETURNING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_ATTRIBUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::SOURCE_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_BIND_SYMBOL() {
  return getToken(MySQLParser::SOURCE_BIND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_COMPRESSION_ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::SOURCE_COMPRESSION_ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_CONNECTION_AUTO_FAILOVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_DELAY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_DELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::SOURCE_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_HOST_SYMBOL() {
  return getToken(MySQLParser::SOURCE_HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::SOURCE_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_PORT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SSL_VERIFY_SERVER_CERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_TLS_CIPHERSUITES_SYMBOL() {
  return getToken(MySQLParser::SOURCE_TLS_CIPHERSUITES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::SOURCE_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_USER_SYMBOL() {
  return getToken(MySQLParser::SOURCE_USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL() {
  return getToken(MySQLParser::SOURCE_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ST_COLLECT_SYMBOL() {
  return getToken(MySQLParser::ST_COLLECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMPADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMPDIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPDIFF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TLS_SYMBOL() {
  return getToken(MySQLParser::TLS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TYPES_SYMBOL() {
  return getToken(MySQLParser::TYPES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNREGISTER_SYMBOL() {
  return getToken(MySQLParser::UNREGISTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ZONE_SYMBOL() {
  return getToken(MySQLParser::ZONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::ARRAY_SYMBOL() {
  return getToken(MySQLParser::ARRAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::FAILED_LOGIN_ATTEMPTS_SYMBOL() {
  return getToken(MySQLParser::FAILED_LOGIN_ATTEMPTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::MEMBER_SYMBOL() {
  return getToken(MySQLParser::MEMBER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::OFF_SYMBOL() {
  return getToken(MySQLParser::OFF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::PASSWORD_LOCK_TIME_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_LOCK_TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::RANDOM_SYMBOL() {
  return getToken(MySQLParser::RANDOM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REQUIRE_ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsUnambiguousContext::STREAM_SYMBOL() {
  return getToken(MySQLParser::STREAM_SYMBOL, 0);
}

size_t MySQLParser::IdentifierKeywordsUnambiguousContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsUnambiguous;
}

void MySQLParser::IdentifierKeywordsUnambiguousContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsUnambiguous(this);
}

void MySQLParser::IdentifierKeywordsUnambiguousContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsUnambiguous(this);
}

std::any MySQLParser::IdentifierKeywordsUnambiguousContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeywordsUnambiguous(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordsUnambiguousContext *MySQLParser::identifierKeywordsUnambiguous() {
  IdentifierKeywordsUnambiguousContext *_localctx =
    _tracker.createInstance<IdentifierKeywordsUnambiguousContext>(_ctx, getState());
  enterRule(_localctx, 1436, MySQLParser::RuleIdentifierKeywordsUnambiguous);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8980);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1143, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8977);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -8979026322011384852) != 0) ||
              ((((_la - 64) & ~0x3fULL) == 0) && ((1ULL << (_la - 64)) & 293728076221109983) != 0) ||
              ((((_la - 129) & ~0x3fULL) == 0) && ((1ULL << (_la - 129)) & -1036516489208775157) != 0) ||
              ((((_la - 201) & ~0x3fULL) == 0) && ((1ULL << (_la - 201)) & -6430563964047286645) != 0) ||
              ((((_la - 268) & ~0x3fULL) == 0) && ((1ULL << (_la - 268)) & 1868852832190601317) != 0) ||
              ((((_la - 333) & ~0x3fULL) == 0) && ((1ULL << (_la - 333)) & 173760286417661087) != 0) ||
              ((((_la - 398) & ~0x3fULL) == 0) && ((1ULL << (_la - 398)) & -4228991016542077057) != 0) ||
              ((((_la - 462) & ~0x3fULL) == 0) && ((1ULL << (_la - 462)) & 2209089036834331935) != 0) ||
              ((((_la - 528) & ~0x3fULL) == 0) && ((1ULL << (_la - 528)) & 339909363748525207) != 0) ||
              ((((_la - 592) & ~0x3fULL) == 0) && ((1ULL << (_la - 592)) & 3874169395838459587) != 0) ||
              ((((_la - 656) & ~0x3fULL) == 0) && ((1ULL << (_la - 656)) & -315315032541044359) != 0) ||
              ((((_la - 720) & ~0x3fULL) == 0) && ((1ULL << (_la - 720)) & 497599) != 0) ||
              ((((_la - 792) & ~0x3fULL) == 0) && ((1ULL << (_la - 792)) & 4503599627369407) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8978);

        if (!(serverVersion >= 80019))
          throw FailedPredicateException(this, "serverVersion >= 80019");
        setState(8979);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::TIMESTAMP_SYMBOL

              || _la == MySQLParser::TIME_SYMBOL ||
              ((((_la - 731) & ~0x3fULL) == 0) && ((1ULL << (_la - 731)) & 16381) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleKeywordContext ------------------------------------------------------------------

MySQLParser::RoleKeywordContext::RoleKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext *MySQLParser::RoleKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext *MySQLParser::RoleKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext *MySQLParser::RoleKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext *
MySQLParser::RoleKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext *
MySQLParser::RoleKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}

size_t MySQLParser::RoleKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleKeyword;
}

void MySQLParser::RoleKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleKeyword(this);
}

void MySQLParser::RoleKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleKeyword(this);
}

std::any MySQLParser::RoleKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleKeywordContext *MySQLParser::roleKeyword() {
  RoleKeywordContext *_localctx = _tracker.createInstance<RoleKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1438, MySQLParser::RuleRoleKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8992);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1146, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8982);

        if (!(serverVersion < 80017))
          throw FailedPredicateException(this, "serverVersion < 80017");
        setState(8985);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1144, _ctx)) {
          case 1: {
            setState(8983);
            roleOrLabelKeyword();
            break;
          }

          case 2: {
            setState(8984);
            roleOrIdentifierKeyword();
            break;
          }

          default:
            break;
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8990);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1145, _ctx)) {
          case 1: {
            setState(8987);
            identifierKeywordsUnambiguous();
            break;
          }

          case 2: {
            setState(8988);
            identifierKeywordsAmbiguous2Labels();
            break;
          }

          case 3: {
            setState(8989);
            identifierKeywordsAmbiguous4SystemVariables();
            break;
          }

          default:
            break;
        }
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LValueKeywordContext ------------------------------------------------------------------

MySQLParser::LValueKeywordContext::LValueKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierKeywordsUnambiguousContext *MySQLParser::LValueKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext *
MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous1RolesAndLabels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext *
MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext *
MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}

size_t MySQLParser::LValueKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleLValueKeyword;
}

void MySQLParser::LValueKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLValueKeyword(this);
}

void MySQLParser::LValueKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLValueKeyword(this);
}

std::any MySQLParser::LValueKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitLValueKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::LValueKeywordContext *MySQLParser::lValueKeyword() {
  LValueKeywordContext *_localctx = _tracker.createInstance<LValueKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1440, MySQLParser::RuleLValueKeyword);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(8998);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1147, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(8994);
        identifierKeywordsUnambiguous();
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(8995);
        identifierKeywordsAmbiguous1RolesAndLabels();
        break;
      }

      case 3: {
        enterOuterAlt(_localctx, 3);
        setState(8996);
        identifierKeywordsAmbiguous2Labels();
        break;
      }

      case 4: {
        enterOuterAlt(_localctx, 4);
        setState(8997);
        identifierKeywordsAmbiguous3Roles();
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous4SystemVariablesContext
//------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::IdentifierKeywordsAmbiguous4SystemVariablesContext(
  ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

size_t MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous4SystemVariables;
}

void MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous4SystemVariables(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous4SystemVariables(this);
}

std::any MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitIdentifierKeywordsAmbiguous4SystemVariables(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext *
MySQLParser::identifierKeywordsAmbiguous4SystemVariables() {
  IdentifierKeywordsAmbiguous4SystemVariablesContext *_localctx =
    _tracker.createInstance<IdentifierKeywordsAmbiguous4SystemVariablesContext>(_ctx, getState());
  enterRule(_localctx, 1442, MySQLParser::RuleIdentifierKeywordsAmbiguous4SystemVariables);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9000);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL ||
          _la == MySQLParser::PERSIST_SYMBOL

          || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrIdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrIdentifierKeywordContext::RoleOrIdentifierKeywordContext(ParserRuleContext *parent,
                                                                            size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::RESTORE_SYMBOL() {
  return getToken(MySQLParser::RESTORE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrIdentifierKeywordContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

size_t MySQLParser::RoleOrIdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrIdentifierKeyword;
}

void MySQLParser::RoleOrIdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrIdentifierKeyword(this);
}

void MySQLParser::RoleOrIdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrIdentifierKeyword(this);
}

std::any MySQLParser::RoleOrIdentifierKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleOrIdentifierKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrIdentifierKeywordContext *MySQLParser::roleOrIdentifierKeyword() {
  RoleOrIdentifierKeywordContext *_localctx = _tracker.createInstance<RoleOrIdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1444, MySQLParser::RuleRoleOrIdentifierKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(9002);
    _la = _input->LA(1);
    if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & 2594284492269555716) != 0) ||
          ((((_la - 66) & ~0x3fULL) == 0) && ((1ULL << (_la - 66)) & 144115188092635649) != 0) ||
          ((((_la - 147) & ~0x3fULL) == 0) && ((1ULL << (_la - 147)) & -9203668788485025791) != 0) ||
          ((((_la - 219) & ~0x3fULL) == 0) && ((1ULL << (_la - 219)) & 281475043819561) != 0) ||
          ((((_la - 373) & ~0x3fULL) == 0) && ((1ULL << (_la - 373)) & 23094341287937) != 0) ||
          ((((_la - 452) & ~0x3fULL) == 0) && ((1ULL << (_la - 452)) & 5766877052741681161) != 0) ||
          ((((_la - 519) & ~0x3fULL) == 0) && ((1ULL << (_la - 519)) & 8606711811) != 0) ||
          ((((_la - 597) & ~0x3fULL) == 0) && ((1ULL << (_la - 597)) & 4631952216750818817) != 0) ||
          ((((_la - 661) & ~0x3fULL) == 0) && ((1ULL << (_la - 661)) & 8646911284551417859) != 0))) {
      _errHandler->recoverInline(this);
    } else {
      _errHandler->reportMatch(this);
      consume();
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrLabelKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrLabelKeywordContext::RoleOrLabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENGINE_ATTRIBUTE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_ATTRIBUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LOCKS_SYMBOL() {
  return getToken(MySQLParser::LOCKS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NDBCLUSTER_SYMBOL() {
  return getToken(MySQLParser::NDBCLUSTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NEW_SYMBOL() {
  return getToken(MySQLParser::NEW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TIMESTAMPADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPADD_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TIMESTAMPDIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMPDIFF_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TYPES_SYMBOL() {
  return getToken(MySQLParser::TYPES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UDF_RETURNS_SYMBOL() {
  return getToken(MySQLParser::UDF_RETURNS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode *MySQLParser::RoleOrLabelKeywordContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

size_t MySQLParser::RoleOrLabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrLabelKeyword;
}

void MySQLParser::RoleOrLabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrLabelKeyword(this);
}

void MySQLParser::RoleOrLabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrLabelKeyword(this);
}

std::any MySQLParser::RoleOrLabelKeywordContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<MySQLParserVisitor *>(visitor))
    return parserVisitor->visitRoleOrLabelKeyword(this);
  else
    return visitor->visitChildren(this);
}

MySQLParser::RoleOrLabelKeywordContext *MySQLParser::roleOrLabelKeyword() {
  RoleOrLabelKeywordContext *_localctx = _tracker.createInstance<RoleOrLabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1446, MySQLParser::RuleRoleOrLabelKeyword);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(9007);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1148, _ctx)) {
      case 1: {
        enterOuterAlt(_localctx, 1);
        setState(9004);
        _la = _input->LA(1);
        if (!((((_la & ~0x3fULL) == 0) && ((1ULL << _la) & -8979026322145606680) != 0) ||
              ((((_la - 64) & ~0x3fULL) == 0) && ((1ULL << (_la - 64)) & 293728076221109979) != 0) ||
              ((((_la - 129) & ~0x3fULL) == 0) && ((1ULL << (_la - 129)) & -1036806760278508021) != 0) ||
              ((((_la - 202) & ~0x3fULL) == 0) && ((1ULL << (_la - 202)) & 6008090054826942021) != 0) ||
              ((((_la - 268) & ~0x3fULL) == 0) && ((1ULL << (_la - 268)) & 1868852832190666853) != 0) ||
              ((((_la - 333) & ~0x3fULL) == 0) && ((1ULL << (_la - 333)) & 2623500577582239) != 0) ||
              ((((_la - 399) & ~0x3fULL) == 0) && ((1ULL << (_la - 399)) & -2123502707525795909) != 0) ||
              ((((_la - 463) & ~0x3fULL) == 0) && ((1ULL << (_la - 463)) & 888371177957633551) != 0) ||
              ((((_la - 528) & ~0x3fULL) == 0) && ((1ULL << (_la - 528)) & 339909501187478679) != 0) ||
              ((((_la - 592) & ~0x3fULL) == 0) && ((1ULL << (_la - 592)) & 3784097394692726723) != 0) ||
              ((((_la - 656) & ~0x3fULL) == 0) && ((1ULL << (_la - 656)) & -5647576991346663167) != 0) ||
              ((((_la - 724) & ~0x3fULL) == 0) && ((1ULL << (_la - 724)) & 27) != 0) ||
              ((((_la - 792) & ~0x3fULL) == 0) && ((1ULL << (_la - 792)) & 67) != 0))) {
          _errHandler->recoverInline(this);
        } else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case 2: {
        enterOuterAlt(_localctx, 2);
        setState(9005);

        if (!(serverVersion >= 80014))
          throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(9006);
        match(MySQLParser::ADMIN_SYMBOL);
        break;
      }

      default:
        break;
    }

  } catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool MySQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 2:
      return alterStatementSempred(antlrcpp::downCast<AlterStatementContext *>(context), predicateIndex);
    case 14:
      return standaloneAlterCommandsSempred(antlrcpp::downCast<StandaloneAlterCommandsContext *>(context),
                                            predicateIndex);
    case 18:
      return alterListItemSempred(antlrcpp::downCast<AlterListItemContext *>(context), predicateIndex);
    case 28:
      return alterTablespaceSempred(antlrcpp::downCast<AlterTablespaceContext *>(context), predicateIndex);
    case 33:
      return alterTablespaceOptionSempred(antlrcpp::downCast<AlterTablespaceOptionContext *>(context), predicateIndex);
    case 39:
      return alterInstanceStatementSempred(antlrcpp::downCast<AlterInstanceStatementContext *>(context),
                                           predicateIndex);
    case 40:
      return createStatementSempred(antlrcpp::downCast<CreateStatementContext *>(context), predicateIndex);
    case 42:
      return createDatabaseOptionSempred(antlrcpp::downCast<CreateDatabaseOptionContext *>(context), predicateIndex);
    case 48:
      return queryExpressionOrParensSempred(antlrcpp::downCast<QueryExpressionOrParensContext *>(context),
                                            predicateIndex);
    case 68:
      return tsDataFileNameSempred(antlrcpp::downCast<TsDataFileNameContext *>(context), predicateIndex);
    case 71:
      return tablespaceOptionSempred(antlrcpp::downCast<TablespaceOptionContext *>(context), predicateIndex);
    case 94:
      return dropStatementSempred(antlrcpp::downCast<DropStatementContext *>(context), predicateIndex);
    case 115:
      return deleteStatementSempred(antlrcpp::downCast<DeleteStatementContext *>(context), predicateIndex);
    case 121:
      return insertStatementSempred(antlrcpp::downCast<InsertStatementContext *>(context), predicateIndex);
    case 139:
      return selectStatementWithIntoSempred(antlrcpp::downCast<SelectStatementWithIntoContext *>(context),
                                            predicateIndex);
    case 141:
      return queryExpressionBodySempred(antlrcpp::downCast<QueryExpressionBodyContext *>(context), predicateIndex);
    case 143:
      return queryPrimarySempred(antlrcpp::downCast<QueryPrimaryContext *>(context), predicateIndex);
    case 185:
      return tableReferenceSempred(antlrcpp::downCast<TableReferenceContext *>(context), predicateIndex);
    case 191:
      return tableFactorSempred(antlrcpp::downCast<TableFactorContext *>(context), predicateIndex);
    case 194:
      return derivedTableSempred(antlrcpp::downCast<DerivedTableContext *>(context), predicateIndex);
    case 198:
      return jtColumnSempred(antlrcpp::downCast<JtColumnContext *>(context), predicateIndex);
    case 205:
      return tableAliasSempred(antlrcpp::downCast<TableAliasContext *>(context), predicateIndex);
    case 230:
      return changeReplicationSourceSempred(antlrcpp::downCast<ChangeReplicationSourceContext *>(context),
                                            predicateIndex);
    case 233:
      return sourceDefinitionSempred(antlrcpp::downCast<SourceDefinitionContext *>(context), predicateIndex);
    case 293:
      return cloneStatementSempred(antlrcpp::downCast<CloneStatementContext *>(context), predicateIndex);
    case 297:
      return alterUserStatementSempred(antlrcpp::downCast<AlterUserStatementContext *>(context), predicateIndex);
    case 299:
      return alterUserSempred(antlrcpp::downCast<AlterUserContext *>(context), predicateIndex);
    case 303:
      return createUserTailSempred(antlrcpp::downCast<CreateUserTailContext *>(context), predicateIndex);
    case 308:
      return accountLockPasswordExpireOptionsSempred(
        antlrcpp::downCast<AccountLockPasswordExpireOptionsContext *>(context), predicateIndex);
    case 312:
      return grantTargetListSempred(antlrcpp::downCast<GrantTargetListContext *>(context), predicateIndex);
    case 313:
      return grantOptionsSempred(antlrcpp::downCast<GrantOptionsContext *>(context), predicateIndex);
    case 317:
      return versionedRequireClauseSempred(antlrcpp::downCast<VersionedRequireClauseContext *>(context),
                                           predicateIndex);
    case 319:
      return revokeStatementSempred(antlrcpp::downCast<RevokeStatementContext *>(context), predicateIndex);
    case 323:
      return grantIdentifierSempred(antlrcpp::downCast<GrantIdentifierContext *>(context), predicateIndex);
    case 326:
      return grantOptionSempred(antlrcpp::downCast<GrantOptionContext *>(context), predicateIndex);
    case 331:
      return histogramSempred(antlrcpp::downCast<HistogramContext *>(context), predicateIndex);
    case 336:
      return startOptionValueListSempred(antlrcpp::downCast<StartOptionValueListContext *>(context), predicateIndex);
    case 341:
      return optionValueNoOptionTypeSempred(antlrcpp::downCast<OptionValueNoOptionTypeContext *>(context),
                                            predicateIndex);
    case 423:
      return utilityStatementSempred(antlrcpp::downCast<UtilityStatementContext *>(context), predicateIndex);
    case 425:
      return explainStatementSempred(antlrcpp::downCast<ExplainStatementContext *>(context), predicateIndex);
    case 430:
      return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);
    case 431:
      return boolPriSempred(antlrcpp::downCast<BoolPriContext *>(context), predicateIndex);
    case 433:
      return predicateSempred(antlrcpp::downCast<PredicateContext *>(context), predicateIndex);
    case 435:
      return bitExprSempred(antlrcpp::downCast<BitExprContext *>(context), predicateIndex);
    case 436:
      return simpleExprSempred(antlrcpp::downCast<SimpleExprContext *>(context), predicateIndex);
    case 437:
      return arrayCastSempred(antlrcpp::downCast<ArrayCastContext *>(context), predicateIndex);
    case 441:
      return windowFunctionCallSempred(antlrcpp::downCast<WindowFunctionCallContext *>(context), predicateIndex);
    case 443:
      return leadLagInfoSempred(antlrcpp::downCast<LeadLagInfoContext *>(context), predicateIndex);
    case 452:
      return runtimeFunctionCallSempred(antlrcpp::downCast<RuntimeFunctionCallContext *>(context), predicateIndex);
    case 468:
      return lvalueVariableSempred(antlrcpp::downCast<LvalueVariableContext *>(context), predicateIndex);
    case 473:
      return castTypeSempred(antlrcpp::downCast<CastTypeContext *>(context), predicateIndex);
    case 529:
      return checkOrReferencesSempred(antlrcpp::downCast<CheckOrReferencesContext *>(context), predicateIndex);
    case 532:
      return tableConstraintDefSempred(antlrcpp::downCast<TableConstraintDefContext *>(context), predicateIndex);
    case 535:
      return columnAttributeSempred(antlrcpp::downCast<ColumnAttributeContext *>(context), predicateIndex);
    case 546:
      return keyPartOrExpressionSempred(antlrcpp::downCast<KeyPartOrExpressionContext *>(context), predicateIndex);
    case 549:
      return commonIndexOptionSempred(antlrcpp::downCast<CommonIndexOptionContext *>(context), predicateIndex);
    case 566:
      return charsetNameSempred(antlrcpp::downCast<CharsetNameContext *>(context), predicateIndex);
    case 567:
      return collationNameSempred(antlrcpp::downCast<CollationNameContext *>(context), predicateIndex);
    case 572:
      return createTableOptionSempred(antlrcpp::downCast<CreateTableOptionContext *>(context), predicateIndex);
    case 672:
      return pureIdentifierSempred(antlrcpp::downCast<PureIdentifierContext *>(context), predicateIndex);
    case 682:
      return real_ulonglong_numberSempred(antlrcpp::downCast<Real_ulonglong_numberContext *>(context), predicateIndex);
    case 684:
      return signedLiteralOrNullSempred(antlrcpp::downCast<SignedLiteralOrNullContext *>(context), predicateIndex);
    case 686:
      return literalOrNullSempred(antlrcpp::downCast<LiteralOrNullContext *>(context), predicateIndex);
    case 689:
      return textStringLiteralSempred(antlrcpp::downCast<TextStringLiteralContext *>(context), predicateIndex);
    case 691:
      return textStringHashSempred(antlrcpp::downCast<TextStringHashContext *>(context), predicateIndex);
    case 713:
      return identifierKeywordSempred(antlrcpp::downCast<IdentifierKeywordContext *>(context), predicateIndex);
    case 716:
      return labelKeywordSempred(antlrcpp::downCast<LabelKeywordContext *>(context), predicateIndex);
    case 718:
      return identifierKeywordsUnambiguousSempred(antlrcpp::downCast<IdentifierKeywordsUnambiguousContext *>(context),
                                                  predicateIndex);
    case 719:
      return roleKeywordSempred(antlrcpp::downCast<RoleKeywordContext *>(context), predicateIndex);
    case 723:
      return roleOrLabelKeywordSempred(antlrcpp::downCast<RoleOrLabelKeywordContext *>(context), predicateIndex);

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterStatementSempred(AlterStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::standaloneAlterCommandsSempred(StandaloneAlterCommandsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 1:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterListItemSempred(AlterListItemContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 2:
      return serverVersion >= 80017;
    case 3:
      return serverVersion >= 80019;
    case 4:
      return serverVersion >= 80014;
    case 5:
      return serverVersion >= 80024;
    case 6:
      return serverVersion >= 80017;
    case 7:
      return serverVersion >= 80019;
    case 8:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterTablespaceSempred(AlterTablespaceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterTablespaceOptionSempred(AlterTablespaceOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 10:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterInstanceStatementSempred(AlterInstanceStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::createStatementSempred(CreateStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 12:
      return serverVersion >= 80011;
    case 13:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::createDatabaseOptionSempred(CreateDatabaseOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 14:
      return serverVersion >= 80016;

    default:
      break;
  }
  return true;
}

bool MySQLParser::queryExpressionOrParensSempred(QueryExpressionOrParensContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 15:
      return serverVersion >= 80031;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tsDataFileNameSempred(TsDataFileNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 16:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tablespaceOptionSempred(TablespaceOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 17:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::dropStatementSempred(DropStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 18:
      return serverVersion >= 80011;
    case 19:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::deleteStatementSempred(DeleteStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 20:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::insertStatementSempred(InsertStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 21:
      return serverVersion >= 80018;
    case 22:
      return serverVersion >= 80018;

    default:
      break;
  }
  return true;
}

bool MySQLParser::selectStatementWithIntoSempred(SelectStatementWithIntoContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 23:
      return serverVersion >= 80024 && serverVersion < 80031;

    default:
      break;
  }
  return true;
}

bool MySQLParser::queryExpressionBodySempred(QueryExpressionBodyContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 24:
      return serverVersion >= 80031;

    default:
      break;
  }
  return true;
}

bool MySQLParser::queryPrimarySempred(QueryPrimaryContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 25:
      return serverVersion >= 80019;
    case 26:
      return serverVersion >= 80019;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tableReferenceSempred(TableReferenceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 27:
      return serverVersion < 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tableFactorSempred(TableFactorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 28:
      return serverVersion >= 80004;

    default:
      break;
  }
  return true;
}

bool MySQLParser::derivedTableSempred(DerivedTableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 29:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::jtColumnSempred(JtColumnContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 30:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tableAliasSempred(TableAliasContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 31:
      return serverVersion < 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::changeReplicationSourceSempred(ChangeReplicationSourceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 32:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::sourceDefinitionSempred(SourceDefinitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 33:
      return serverVersion >= 80024;
    case 34:
      return serverVersion >= 80024;
    case 35:
      return serverVersion >= 80027;

    default:
      break;
  }
  return true;
}

bool MySQLParser::cloneStatementSempred(CloneStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 36:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterUserStatementSempred(AlterUserStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 37:
      return serverVersion < 80014;
    case 38:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::alterUserSempred(AlterUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 39:
      return serverVersion < 80025;
    case 40:
      return serverVersion >= 80025;

    default:
      break;
  }
  return true;
}

bool MySQLParser::createUserTailSempred(CreateUserTailContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 41:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::accountLockPasswordExpireOptionsSempred(AccountLockPasswordExpireOptionsContext *_localctx,
                                                          size_t predicateIndex) {
  switch (predicateIndex) {
    case 42:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

bool MySQLParser::grantTargetListSempred(GrantTargetListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 43:
      return serverVersion < 80011;
    case 44:
      return serverVersion >= 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::grantOptionsSempred(GrantOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 45:
      return serverVersion < 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::versionedRequireClauseSempred(VersionedRequireClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 46:
      return serverVersion < 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::revokeStatementSempred(RevokeStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 47:
      return serverVersion >= 80031;
    case 48:
      return serverVersion >= 80031;

    default:
      break;
  }
  return true;
}

bool MySQLParser::grantIdentifierSempred(GrantIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 49:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::grantOptionSempred(GrantOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 50:
      return serverVersion < 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::histogramSempred(HistogramContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 51:
      return serverVersion >= 80031;

    default:
      break;
  }
  return true;
}

bool MySQLParser::startOptionValueListSempred(StartOptionValueListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 52:
      return serverVersion < 80014;
    case 53:
      return serverVersion >= 80018;

    default:
      break;
  }
  return true;
}

bool MySQLParser::optionValueNoOptionTypeSempred(OptionValueNoOptionTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 54:
      return serverVersion >= 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::utilityStatementSempred(UtilityStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 55:
      return serverVersion >= 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::explainStatementSempred(ExplainStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 56:
      return serverVersion >= 80018;
    case 57:
      return serverVersion >= 80019;

    default:
      break;
  }
  return true;
}

bool MySQLParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 58:
      return precpred(_ctx, 3);
    case 59:
      return precpred(_ctx, 2);
    case 60:
      return precpred(_ctx, 1);

    default:
      break;
  }
  return true;
}

bool MySQLParser::boolPriSempred(BoolPriContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 61:
      return precpred(_ctx, 3);
    case 62:
      return precpred(_ctx, 2);
    case 63:
      return precpred(_ctx, 1);

    default:
      break;
  }
  return true;
}

bool MySQLParser::predicateSempred(PredicateContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 64:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::bitExprSempred(BitExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 65:
      return precpred(_ctx, 7);
    case 66:
      return precpred(_ctx, 6);
    case 67:
      return precpred(_ctx, 5);
    case 68:
      return precpred(_ctx, 3);
    case 69:
      return precpred(_ctx, 2);
    case 70:
      return precpred(_ctx, 1);
    case 71:
      return precpred(_ctx, 4);

    default:
      break;
  }
  return true;
}

bool MySQLParser::simpleExprSempred(SimpleExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 72:
      return precpred(_ctx, 16);
    case 73:
      return precpred(_ctx, 24);

    default:
      break;
  }
  return true;
}

bool MySQLParser::arrayCastSempred(ArrayCastContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 74:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::windowFunctionCallSempred(WindowFunctionCallContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 75:
      return serverVersion < 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::leadLagInfoSempred(LeadLagInfoContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 76:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::runtimeFunctionCallSempred(RuntimeFunctionCallContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 77:
      return serverVersion < 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::lvalueVariableSempred(LvalueVariableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 78:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::castTypeSempred(CastTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 79:
      return serverVersion >= 80024;
    case 80:
      return serverVersion >= 80017;
    case 81:
      return serverVersion >= 80017;
    case 82:
      return serverVersion >= 80027;

    default:
      break;
  }
  return true;
}

bool MySQLParser::checkOrReferencesSempred(CheckOrReferencesContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 83:
      return serverVersion < 80016;

    default:
      break;
  }
  return true;
}

bool MySQLParser::tableConstraintDefSempred(TableConstraintDefContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 84:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::columnAttributeSempred(ColumnAttributeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 85:
      return serverVersion >= 80014;
    case 86:
      return serverVersion >= 80013;
    case 87:
      return serverVersion >= 80017;
    case 88:
      return serverVersion >= 80017;
    case 89:
      return serverVersion >= 80024;
    case 90:
      return serverVersion >= 80024;
    case 91:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::keyPartOrExpressionSempred(KeyPartOrExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 92:
      return serverVersion >= 80013;

    default:
      break;
  }
  return true;
}

bool MySQLParser::commonIndexOptionSempred(CommonIndexOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 93:
      return serverVersion >= 80024;
    case 94:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::charsetNameSempred(CharsetNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 95:
      return serverVersion < 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::collationNameSempred(CollationNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 96:
      return serverVersion < 80011;
    case 97:
      return serverVersion >= 80018;

    default:
      break;
  }
  return true;
}

bool MySQLParser::createTableOptionSempred(CreateTableOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 98:
      return serverVersion >= 80014;
    case 99:
      return serverVersion >= 80024;
    case 100:
      return serverVersion >= 80024;
    case 101:
      return serverVersion >= 80024;
    case 102:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::pureIdentifierSempred(PureIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 103:
      return isSqlModeActive(AnsiQuotes);

    default:
      break;
  }
  return true;
}

bool MySQLParser::real_ulonglong_numberSempred(Real_ulonglong_numberContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 104:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::signedLiteralOrNullSempred(SignedLiteralOrNullContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 105:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::literalOrNullSempred(LiteralOrNullContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 106:
      return serverVersion >= 80024;

    default:
      break;
  }
  return true;
}

bool MySQLParser::textStringLiteralSempred(TextStringLiteralContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 107:
      return !isSqlModeActive(AnsiQuotes);

    default:
      break;
  }
  return true;
}

bool MySQLParser::textStringHashSempred(TextStringHashContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 108:
      return serverVersion >= 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::identifierKeywordSempred(IdentifierKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 109:
      return serverVersion < 80017;
    case 110:
      return serverVersion >= 80011;

    default:
      break;
  }
  return true;
}

bool MySQLParser::labelKeywordSempred(LabelKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 111:
      return serverVersion < 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::identifierKeywordsUnambiguousSempred(IdentifierKeywordsUnambiguousContext *_localctx,
                                                       size_t predicateIndex) {
  switch (predicateIndex) {
    case 112:
      return serverVersion >= 80019;

    default:
      break;
  }
  return true;
}

bool MySQLParser::roleKeywordSempred(RoleKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 113:
      return serverVersion < 80017;

    default:
      break;
  }
  return true;
}

bool MySQLParser::roleOrLabelKeywordSempred(RoleOrLabelKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 114:
      return serverVersion >= 80014;

    default:
      break;
  }
  return true;
}

void MySQLParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  mysqlparserParserInitialize();
#else
  ::antlr4::internal::call_once(mysqlparserParserOnceFlag, mysqlparserParserInitialize);
#endif
}
